var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Maya addon","text":"<p>Maya integration for AYON.</p>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_maya<ul> <li>addon</li> <li>api<ul> <li>action</li> <li>alembic</li> <li>chasers<ul> <li>export_filter_properties</li> </ul> </li> <li>commands</li> <li>customize</li> <li>fbx</li> <li>gltf</li> <li>lib</li> <li>lib_renderproducts</li> <li>lib_rendersettings</li> <li>lib_rendersetup</li> <li>menu</li> <li>pipeline</li> <li>plugin</li> <li>render_setup_tools</li> <li>setdress</li> <li>workfile_template_builder</li> <li>workio</li> <li>yeti</li> </ul> </li> <li>hooks<ul> <li>pre_auto_load_plugins</li> <li>pre_copy_mel</li> <li>pre_open_workfile_post_initialization</li> </ul> </li> <li>lib</li> <li>plugins<ul> <li>create<ul> <li>convert_legacy</li> <li>create_animation_pointcache</li> <li>create_arnold_scene_source</li> <li>create_assembly</li> <li>create_camera</li> <li>create_layout</li> <li>create_look</li> <li>create_matchmove</li> <li>create_maya_usd</li> <li>create_maya_usd_layer</li> <li>create_mayascene</li> <li>create_model</li> <li>create_multishot_layout</li> <li>create_multiverse_look</li> <li>create_multiverse_usd</li> <li>create_multiverse_usd_comp</li> <li>create_multiverse_usd_over</li> <li>create_ornatrix_cache</li> <li>create_ornatrix_rig</li> <li>create_proxy_abc</li> <li>create_redshift_proxy</li> <li>create_render</li> <li>create_rendersetup</li> <li>create_review</li> <li>create_rig</li> <li>create_setdress</li> <li>create_unreal_skeletalmesh</li> <li>create_unreal_staticmesh</li> <li>create_unreal_yeticache</li> <li>create_vrayproxy</li> <li>create_vrayscene</li> <li>create_workfile</li> <li>create_xgen</li> <li>create_yeti_cache</li> <li>create_yeti_rig</li> </ul> </li> <li>inventory<ul> <li>connect_geometry</li> <li>connect_ornatrix_rig</li> <li>connect_xgen</li> <li>connect_yeti_rig</li> <li>import_modelrender</li> <li>import_reference</li> <li>lock_version</li> <li>rig_recreate_animation_instance</li> <li>select_containers</li> </ul> </li> <li>load<ul> <li>_load_animation</li> <li>actions</li> <li>load_arnold_standin</li> <li>load_as_template</li> <li>load_assembly</li> <li>load_audio</li> <li>load_gpucache</li> <li>load_image</li> <li>load_image_plane</li> <li>load_layout</li> <li>load_look</li> <li>load_matchmove</li> <li>load_maya_usd</li> <li>load_multiverse_usd</li> <li>load_multiverse_usd_over</li> <li>load_ornatrix_alembic</li> <li>load_ornatrix_rig</li> <li>load_redshift_proxy</li> <li>load_reference</li> <li>load_rendersetup</li> <li>load_vdb_to_arnold</li> <li>load_vdb_to_redshift</li> <li>load_vdb_to_vray</li> <li>load_vrayproxy</li> <li>load_vrayscene</li> <li>load_xgen</li> <li>load_yeti_cache</li> <li>load_yeti_rig</li> </ul> </li> <li>publish<ul> <li>collect_animation</li> <li>collect_arnold_scene_source</li> <li>collect_assembly</li> <li>collect_current_file</li> <li>collect_farm_instances</li> <li>collect_fbx_animation</li> <li>collect_fbx_camera</li> <li>collect_fbx_model</li> <li>collect_file_dependencies</li> <li>collect_gltf</li> <li>collect_history</li> <li>collect_inputs</li> <li>collect_instances</li> <li>collect_look</li> <li>collect_maya_scene_time</li> <li>collect_maya_units</li> <li>collect_maya_usd_export_filter_properties</li> <li>collect_maya_workspace</li> <li>collect_model</li> <li>collect_multiverse_look</li> <li>collect_ornatrix_cache</li> <li>collect_ornatrix_rig</li> <li>collect_pointcache</li> <li>collect_pointcache_visible_only</li> <li>collect_remove_marked</li> <li>collect_render</li> <li>collect_render_layer_aovs</li> <li>collect_renderable_camera</li> <li>collect_review</li> <li>collect_rig_sets</li> <li>collect_skeleton_mesh</li> <li>collect_unreal_skeletalmesh</li> <li>collect_unreal_staticmesh</li> <li>collect_user_defined_attributes</li> <li>collect_vrayproxy</li> <li>collect_vrayscene</li> <li>collect_workfile</li> <li>collect_workscene_fps</li> <li>collect_xgen</li> <li>collect_yeti_cache</li> <li>collect_yeti_rig</li> <li>determine_future_version</li> <li>extract_active_view_thumbnail</li> <li>extract_arnold_scene_source</li> <li>extract_assembly</li> <li>extract_camera_alembic</li> <li>extract_camera_mayaScene</li> <li>extract_fbx</li> <li>extract_fbx_animation</li> <li>extract_gltf</li> <li>extract_gpu_cache</li> <li>extract_import_reference</li> <li>extract_layout</li> <li>extract_look</li> <li>extract_maya_scene_raw</li> <li>extract_maya_usd</li> <li>extract_maya_usd_layer</li> <li>extract_model</li> <li>extract_multiverse_look</li> <li>extract_multiverse_usd</li> <li>extract_multiverse_usd_comp</li> <li>extract_multiverse_usd_over</li> <li>extract_obj</li> <li>extract_ornatrix_cache</li> <li>extract_ornatrix_rig</li> <li>extract_playblast</li> <li>extract_pointcache</li> <li>extract_proxy_abc</li> <li>extract_redshift_proxy</li> <li>extract_rendersetup</li> <li>extract_rig</li> <li>extract_skeleton_mesh</li> <li>extract_thumbnail</li> <li>extract_unreal_skeletalmesh_abc</li> <li>extract_unreal_skeletalmesh_fbx</li> <li>extract_unreal_staticmesh</li> <li>extract_unreal_yeticache</li> <li>extract_vrayproxy</li> <li>extract_vrayscene</li> <li>extract_workfile_xgen</li> <li>extract_xgen</li> <li>extract_yeti_cache</li> <li>extract_yeti_rig</li> <li>increment_current_file</li> <li>reset_xgen_attributes</li> <li>save_scene</li> <li>validate_alembic_options_defaults</li> <li>validate_animation_content</li> <li>validate_animation_out_set_related_node_ids</li> <li>validate_animation_product_type_publish</li> <li>validate_animation_rig_content</li> <li>validate_arnold_scene_source</li> <li>validate_arnold_scene_source_cbid</li> <li>validate_ass_relative_paths</li> <li>validate_assembly_name</li> <li>validate_assembly_namespaces</li> <li>validate_assembly_transforms</li> <li>validate_attributes</li> <li>validate_camera_attributes</li> <li>validate_camera_contents</li> <li>validate_clashing_sibling_names</li> <li>validate_color_sets</li> <li>validate_current_renderlayer_renderable</li> <li>validate_cycle_error</li> <li>validate_excluded_parents_visible</li> <li>validate_frame_range</li> <li>validate_glsl_material</li> <li>validate_glsl_plugin</li> <li>validate_instance_has_members</li> <li>validate_instance_in_context</li> <li>validate_instance_subset</li> <li>validate_loaded_plugin</li> <li>validate_look_contents</li> <li>validate_look_default_shaders_connections</li> <li>validate_look_id_reference_edits</li> <li>validate_look_no_default_shaders</li> <li>validate_look_sets</li> <li>validate_look_shading_group</li> <li>validate_look_single_shader</li> <li>validate_maya_units</li> <li>validate_mesh_arnold_attributes</li> <li>validate_mesh_empty</li> <li>validate_mesh_has_uv</li> <li>validate_mesh_lamina_faces</li> <li>validate_mesh_ngons</li> <li>validate_mesh_no_negative_scale</li> <li>validate_mesh_non_manifold</li> <li>validate_mesh_non_zero_edge</li> <li>validate_mesh_normals_unlocked</li> <li>validate_mesh_overlapping_uvs</li> <li>validate_mesh_shader_connections</li> <li>validate_mesh_single_uv_set</li> <li>validate_mesh_uv_set_map1</li> <li>validate_mesh_vertices_have_edges</li> <li>validate_model_content</li> <li>validate_mvlook_contents</li> <li>validate_no_animation</li> <li>validate_no_default_camera</li> <li>validate_no_namespace</li> <li>validate_no_null_transforms</li> <li>validate_no_unknown_nodes</li> <li>validate_no_vraymesh</li> <li>validate_node_ids</li> <li>validate_node_ids_deformed_shapes</li> <li>validate_node_ids_in_database</li> <li>validate_node_ids_related</li> <li>validate_node_ids_unique</li> <li>validate_node_no_ghosting</li> <li>validate_ornatrix_cache_content</li> <li>validate_ornatrix_rig_content</li> <li>validate_plugin_path_attributes</li> <li>validate_render_image_rule</li> <li>validate_render_no_default_cameras</li> <li>validate_render_single_camera</li> <li>validate_renderlayer_aovs</li> <li>validate_rendersettings</li> <li>validate_resolution</li> <li>validate_review</li> <li>validate_rig_contents</li> <li>validate_rig_controllers</li> <li>validate_rig_controllers_arnold_attributes</li> <li>validate_rig_joints_hidden</li> <li>validate_rig_out_set_node_ids</li> <li>validate_rig_output_ids</li> <li>validate_scene_set_workspace</li> <li>validate_setdress_root</li> <li>validate_shader_name</li> <li>validate_shape_default_names</li> <li>validate_shape_render_stats</li> <li>validate_shape_zero</li> <li>validate_single_assembly</li> <li>validate_skeletalmesh_hierarchy</li> <li>validate_skeletalmesh_triangulated</li> <li>validate_skeleton_top_group_hierarchy</li> <li>validate_skinCluster_deformer_set</li> <li>validate_step_size</li> <li>validate_transform_naming_suffix</li> <li>validate_transform_zero</li> <li>validate_unique_names</li> <li>validate_unreal_mesh_triangulated</li> <li>validate_unreal_staticmesh_naming</li> <li>validate_unreal_up_axis</li> <li>validate_visible_only</li> <li>validate_vray</li> <li>validate_vray_distributed_rendering</li> <li>validate_vray_referenced_aovs</li> <li>validate_vray_translator_settings</li> <li>validate_vrayproxy</li> <li>validate_vrayproxy_members</li> <li>validate_xgen</li> <li>validate_yeti_renderscript_callbacks</li> <li>validate_yeti_rig_cache_state</li> <li>validate_yeti_rig_input_in_instance</li> <li>validate_yeti_rig_settings</li> </ul> </li> <li>workfile_build<ul> <li>assign_look_placeholder</li> <li>load_placeholder</li> <li>script_placeholder</li> </ul> </li> </ul> </li> <li>startup<ul> <li>userSetup</li> </ul> </li> <li>tools<ul> <li>mayalookassigner<ul> <li>alembic</li> <li>app</li> <li>arnold_standin</li> <li>commands</li> <li>lib</li> <li>models</li> <li>usd</li> <li>views</li> <li>vray_proxies</li> <li>widgets</li> </ul> </li> </ul> </li> <li>vendor<ul> <li>python<ul> <li>capture</li> </ul> </li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>settings<ul> <li>conversion</li> <li>creators</li> <li>dirmap</li> <li>explicit_plugins_loading</li> <li>imageio</li> <li>include_handles</li> <li>loaders</li> <li>main</li> <li>publish_playblast</li> <li>publishers</li> <li>render_settings</li> <li>scriptsmenu</li> <li>templated_workfile_settings</li> <li>workfile_build_settings</li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_maya/index.html","title":"ayon_maya","text":""},{"location":"autoapi/client/ayon_maya/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_maya/lib.html","title":"lib","text":""},{"location":"autoapi/client/ayon_maya/version.html","title":"version","text":"<p>Package declaring AYON addon 'maya' version.</p>"},{"location":"autoapi/client/ayon_maya/api/index.html","title":"api","text":"<p>Public API</p> <p>Anything that isn't defined here is INTERNAL and unreliable for external use.</p>"},{"location":"autoapi/client/ayon_maya/api/index.html#client.ayon_maya.api.Loader","title":"<code>Loader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>class Loader(LoaderPlugin):\n    hosts = [\"maya\"]\n    settings_category = SETTINGS_CATEGORY\n    load_settings = {}  # defined in settings\n\n    use_ayon_entity_uri = False\n\n    @classmethod\n    def filepath_from_context(cls, context):\n        # TODO: This is a 1:1 copy from ayon-houdini and may be good to\n        #  refactor and de-duplicate across the codebase, e.g. to core\n        if cls.use_ayon_entity_uri:\n            return get_ayon_entity_uri_from_representation_context(context)\n\n        return super().filepath_from_context(context)\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        super(Loader, cls).apply_settings(project_settings)\n        cls.load_settings = project_settings['maya']['load']\n\n    def get_custom_namespace_and_group(self, context, options, loader_key):\n        \"\"\"Queries Settings to get custom template for namespace and group.\n\n        Group template might be empty &gt;&gt; this forces to not wrap imported items\n        into separate group.\n\n        Args:\n            context (dict)\n            options (dict): artist modifiable options from dialog\n            loader_key (str): key to get separate configuration from Settings\n                ('reference_loader'|'import_loader')\n        \"\"\"\n\n        options[\"attach_to_root\"] = True\n        custom_naming = self.load_settings[loader_key]\n\n        if not custom_naming[\"namespace\"]:\n            raise LoadError(\"No namespace specified in \"\n                            \"Maya ReferenceLoader settings\")\n        elif not custom_naming[\"group_name\"]:\n            self.log.debug(\"No custom group_name, no group will be created.\")\n            options[\"attach_to_root\"] = False\n\n        folder_entity = context[\"folder\"]\n        product_entity = context[\"product\"]\n        product_name = product_entity[\"name\"]\n        product_type = product_entity[\"productType\"]\n        formatting_data = {\n            \"asset_name\": folder_entity[\"name\"],\n            \"asset_type\": \"asset\",\n            \"folder\": {\n                \"name\": folder_entity[\"name\"],\n            },\n            \"subset\": product_name,\n            \"product\": {\n                \"name\": product_name,\n                \"type\": product_type,\n            },\n            \"family\": product_type\n        }\n\n        custom_namespace = custom_naming[\"namespace\"].format(\n            **formatting_data\n        )\n\n        custom_group_name = custom_naming[\"group_name\"].format(\n            **formatting_data\n        )\n\n        return custom_group_name, custom_namespace, options\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/index.html#client.ayon_maya.api.Loader.get_custom_namespace_and_group","title":"<code>get_custom_namespace_and_group(context, options, loader_key)</code>","text":"<p>Queries Settings to get custom template for namespace and group.</p> <p>Group template might be empty &gt;&gt; this forces to not wrap imported items into separate group.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>dict</code> <p>artist modifiable options from dialog</p> required <code>loader_key</code> <code>str</code> <p>key to get separate configuration from Settings ('reference_loader'|'import_loader')</p> required Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>def get_custom_namespace_and_group(self, context, options, loader_key):\n    \"\"\"Queries Settings to get custom template for namespace and group.\n\n    Group template might be empty &gt;&gt; this forces to not wrap imported items\n    into separate group.\n\n    Args:\n        context (dict)\n        options (dict): artist modifiable options from dialog\n        loader_key (str): key to get separate configuration from Settings\n            ('reference_loader'|'import_loader')\n    \"\"\"\n\n    options[\"attach_to_root\"] = True\n    custom_naming = self.load_settings[loader_key]\n\n    if not custom_naming[\"namespace\"]:\n        raise LoadError(\"No namespace specified in \"\n                        \"Maya ReferenceLoader settings\")\n    elif not custom_naming[\"group_name\"]:\n        self.log.debug(\"No custom group_name, no group will be created.\")\n        options[\"attach_to_root\"] = False\n\n    folder_entity = context[\"folder\"]\n    product_entity = context[\"product\"]\n    product_name = product_entity[\"name\"]\n    product_type = product_entity[\"productType\"]\n    formatting_data = {\n        \"asset_name\": folder_entity[\"name\"],\n        \"asset_type\": \"asset\",\n        \"folder\": {\n            \"name\": folder_entity[\"name\"],\n        },\n        \"subset\": product_name,\n        \"product\": {\n            \"name\": product_name,\n            \"type\": product_type,\n        },\n        \"family\": product_type\n    }\n\n    custom_namespace = custom_naming[\"namespace\"].format(\n        **formatting_data\n    )\n\n    custom_group_name = custom_naming[\"group_name\"].format(\n        **formatting_data\n    )\n\n    return custom_group_name, custom_namespace, options\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/index.html#client.ayon_maya.api.MayaHost","title":"<code>MayaHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_maya/api/pipeline.py</code> <pre><code>class MayaHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"maya\"\n\n    def __init__(self):\n        super(MayaHost, self).__init__()\n        self._op_events = {}\n\n    def get_app_information(self):\n        from ayon_core.host import ApplicationInformation\n\n        version = cmds.about(version=True)\n\n        return ApplicationInformation(\n            app_name=\"Maya\",\n            app_version=version,\n        )\n\n    def install(self):\n        project_name = get_current_project_name()\n        project_settings = get_project_settings(project_name)\n        # process path mapping\n        dirmap_processor = MayaDirmap(\"maya\", project_name, project_settings)\n        dirmap_processor.process_dirmap()\n\n        pyblish.api.register_plugin_path(PUBLISH_PATH)\n        pyblish.api.register_host(\"mayabatch\")\n        pyblish.api.register_host(\"mayapy\")\n        pyblish.api.register_host(\"maya\")\n\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n        register_inventory_action_path(INVENTORY_PATH)\n        register_workfile_build_plugin_path(WORKFILE_BUILD_PATH)\n\n        self.log.info(\"Installing callbacks ... \")\n        register_event_callback(\"init\", on_init)\n\n        _set_project()\n\n        if lib.IS_HEADLESS:\n            self.log.info((\n                \"Running in headless mode, skipping Maya save/open/new\"\n                \" callback installation..\"\n            ))\n\n            return\n\n        self._register_callbacks()\n\n        menu.install(project_settings)\n\n        register_event_callback(\"save\", on_save)\n        register_event_callback(\"open\", on_open)\n        register_event_callback(\"new\", on_new)\n        register_event_callback(\"before.save\", on_before_save)\n        register_event_callback(\"after.save\", on_after_save)\n        register_event_callback(\"before.close\", on_before_close)\n        register_event_callback(\"before.file.open\", before_file_open)\n        register_event_callback(\"taskChanged\", on_task_changed)\n        register_event_callback(\"workfile.open.before\", before_workfile_open)\n        register_event_callback(\"workfile.save.before\", before_workfile_save)\n        register_event_callback(\n            \"workfile.save.before\", workfile_save_before_xgen\n        )\n        register_event_callback(\"workfile.save.after\", after_workfile_save)\n\n        self._register_maya_usd_chasers()\n\n    def open_workfile(self, filepath):\n        return open_file(filepath)\n\n    def save_workfile(self, filepath=None):\n        return save_file(filepath)\n\n    def work_root(self, session):\n        return work_root(session)\n\n    def get_current_workfile(self):\n        return current_file()\n\n    def workfile_has_unsaved_changes(self):\n        return has_unsaved_changes()\n\n    def get_workfile_extensions(self):\n        return file_extensions()\n\n    def get_containers(self):\n        return ls()\n\n    @contextlib.contextmanager\n    def maintained_selection(self):\n        with lib.maintained_selection():\n            yield\n\n    def get_context_data(self):\n        data = cmds.fileInfo(\"OpenPypeContext\", query=True)\n        if not data:\n            return {}\n\n        data = data[0]  # Maya seems to return a list\n        decoded = base64.b64decode(data).decode(\"utf-8\")\n        return json.loads(decoded)\n\n    def update_context_data(self, data, changes):\n        json_str = json.dumps(data)\n        encoded = base64.b64encode(json_str.encode(\"utf-8\"))\n        return cmds.fileInfo(\"OpenPypeContext\", encoded)\n\n    def _register_callbacks(self):\n        for handler, event in self._op_events.copy().items():\n            if event is None:\n                continue\n\n            try:\n                OpenMaya.MMessage.removeCallback(event)\n                self._op_events[handler] = None\n            except RuntimeError as exc:\n                self.log.info(exc)\n\n        self._op_events[_on_scene_save] = OpenMaya.MSceneMessage.addCallback(\n            OpenMaya.MSceneMessage.kBeforeSave, _on_scene_save\n        )\n\n        self._op_events[_after_scene_save] = (\n            OpenMaya.MSceneMessage.addCallback(\n                OpenMaya.MSceneMessage.kAfterSave,\n                _after_scene_save\n            )\n        )\n\n        self._op_events[_before_scene_save] = (\n            OpenMaya.MSceneMessage.addCheckCallback(\n                OpenMaya.MSceneMessage.kBeforeSaveCheck,\n                _before_scene_save\n            )\n        )\n\n        self._op_events[_on_scene_new] = OpenMaya.MSceneMessage.addCallback(\n            OpenMaya.MSceneMessage.kAfterNew, _on_scene_new\n        )\n\n        self._op_events[_on_maya_initialized] = (\n            OpenMaya.MSceneMessage.addCallback(\n                OpenMaya.MSceneMessage.kMayaInitialized,\n                _on_maya_initialized\n            )\n        )\n\n        self._op_events[_on_scene_open] = (\n            OpenMaya.MSceneMessage.addCallback(\n                OpenMaya.MSceneMessage.kAfterOpen,\n                _on_scene_open\n            )\n        )\n\n        self._op_events[_before_scene_open] = (\n            OpenMaya.MSceneMessage.addCallback(\n                OpenMaya.MSceneMessage.kBeforeOpen,\n                _before_scene_open\n            )\n        )\n\n        self._op_events[_before_close_maya] = (\n            OpenMaya.MSceneMessage.addCallback(\n                OpenMaya.MSceneMessage.kMayaExiting,\n                _before_close_maya\n            )\n        )\n\n        self.log.info(\"Installed event handler _on_scene_save..\")\n        self.log.info(\"Installed event handler _before_scene_save..\")\n        self.log.info(\"Installed event handler _on_after_save..\")\n        self.log.info(\"Installed event handler _on_scene_new..\")\n        self.log.info(\"Installed event handler _on_maya_initialized..\")\n        self.log.info(\"Installed event handler _on_scene_open..\")\n        self.log.info(\"Installed event handler _check_lock_file..\")\n        self.log.info(\"Installed event handler _before_close_maya..\")\n\n    def _register_maya_usd_chasers(self):\n        \"\"\"Register Maya USD chasers if Maya USD libraries are available.\"\"\"\n\n        try:\n            import mayaUsd.lib  # noqa\n        except ImportError:\n            # Do not register if Maya USD is not available\n            return\n\n        self.log.info(\"Installing AYON Maya USD chasers..\")\n\n        from .chasers import export_filter_properties  # noqa\n\n        for export_chaser in [\n            export_filter_properties.FilterPropertiesExportChaser\n        ]:\n            mayaUsd.lib.ExportChaser.Register(export_chaser,\n                                              export_chaser.name)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/index.html#client.ayon_maya.api.apply_shaders","title":"<code>apply_shaders(relationships, shadernodes, nodes)</code>","text":"<p>Link shadingEngine to the right nodes based on relationship data</p> <p>Relationship data is constructed of a collection of <code>sets</code> and <code>attributes</code> <code>sets</code> corresponds with the shaderEngines found in the lookdev. Each set has the keys <code>name</code>, <code>members</code> and <code>uuid</code>, the <code>members</code> hold a collection of node information <code>name</code> and <code>uuid</code>.</p> <p>Parameters:</p> Name Type Description Default <code>relationships</code> <code>dict</code> <p>relationship data</p> required <code>shadernodes</code> <code>list</code> <p>list of nodes of the shading objectSets (includes</p> required <code>nodes</code> <code>list</code> <p>list of nodes to apply shader to</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def apply_shaders(relationships, shadernodes, nodes):\n    \"\"\"Link shadingEngine to the right nodes based on relationship data\n\n    Relationship data is constructed of a collection of `sets` and `attributes`\n    `sets` corresponds with the shaderEngines found in the lookdev.\n    Each set has the keys `name`, `members` and `uuid`, the `members`\n    hold a collection of node information `name` and `uuid`.\n\n    Args:\n        relationships (dict): relationship data\n        shadernodes (list): list of nodes of the shading objectSets (includes\n        VRayObjectProperties and shadingEngines)\n        nodes (list): list of nodes to apply shader to\n\n    Returns:\n        None\n    \"\"\"\n\n    attributes = relationships.get(\"attributes\", [])\n    shader_data = relationships.get(\"relationships\", {})\n\n    shading_engines = cmds.ls(shadernodes, type=\"objectSet\", long=True)\n    assert shading_engines, \"Error in retrieving objectSets from reference\"\n\n    shader_mesh_nodes = cmds.ls(shadernodes, type=\"mesh\", long=True)\n    # region compute lookup\n    nodes_by_id = defaultdict(list)\n    for node in nodes:\n        nodes_by_id[get_id(node)].append(node)\n\n    shading_engines_by_id = defaultdict(list)\n    for shad in shading_engines:\n        shading_engines_by_id[get_id(shad)].append(shad)\n\n    texture_nodes_by_id = defaultdict(list)\n    for mesh_node in shader_mesh_nodes:\n        texture_nodes_by_id[get_id(mesh_node)].append(mesh_node)\n\n    # endregion\n\n    # region assign shading engines and other sets\n    for data in shader_data.values():\n        # collect all unique IDs of the set members\n        shader_uuid = data[\"uuid\"]\n        member_uuids = [member[\"uuid\"] for member in data[\"members\"]]\n\n        filtered_nodes = list()\n        for m_uuid in member_uuids:\n            filtered_nodes.extend(nodes_by_id[m_uuid])\n\n        id_shading_engines = shading_engines_by_id[shader_uuid]\n        if not id_shading_engines:\n            log.error(\"No shader found with cbId \"\n                      \"'{}'\".format(shader_uuid))\n            continue\n        elif len(id_shading_engines) &gt; 1:\n            log.error(\"Skipping shader assignment. \"\n                      \"More than one shader found with cbId \"\n                      \"'{}'. (found: {})\".format(shader_uuid,\n                                                 id_shading_engines))\n            continue\n\n        if not filtered_nodes:\n            log.warning(\"No nodes found for shading engine \"\n                        \"'{0}'\".format(id_shading_engines[0]))\n            continue\n        try:\n            cmds.sets(filtered_nodes, forceElement=id_shading_engines[0])\n        except RuntimeError as rte:\n            log.error(\"Error during shader assignment: {}\".format(rte))\n\n    # check if there is texture references input and connect the texture\n    # reference back to the nodes\n    texture_references_input = relationships.get(\"connections\", [])\n    apply_connections(\n        texture_references_input, nodes_by_id, texture_nodes_by_id\n    )\n\n    # endregion\n\n    apply_attributes(attributes, nodes_by_id)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/index.html#client.ayon_maya.api.containerise","title":"<code>containerise(name, namespace, nodes, context, loader=None, suffix='CON')</code>","text":"<p>Bundle <code>nodes</code> into an assembly and imprint it with metadata</p> <p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>nodes</code> <code>list</code> <p>Long names of nodes to containerise</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>str</code> <p>Name of loader used to produce this container.</p> <code>None</code> <code>suffix</code> <code>str</code> <p>Suffix of container, defaults to <code>_CON</code>.</p> <code>'CON'</code> <p>Returns:</p> Name Type Description <code>container</code> <code>str</code> <p>Name of container assembly</p> Source code in <code>client/ayon_maya/api/pipeline.py</code> <pre><code>@lib.undo_chunk()\ndef containerise(name,\n                 namespace,\n                 nodes,\n                 context,\n                 loader=None,\n                 suffix=\"CON\"):\n    \"\"\"Bundle `nodes` into an assembly and imprint it with metadata\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        nodes (list): Long names of nodes to containerise\n        context (dict): Asset information\n        loader (str, optional): Name of loader used to produce this container.\n        suffix (str, optional): Suffix of container, defaults to `_CON`.\n\n    Returns:\n        container (str): Name of container assembly\n\n    \"\"\"\n    container = cmds.sets(nodes, name=\"%s_%s_%s\" % (namespace, name, suffix))\n\n    data = [\n        (\"schema\", \"openpype:container-2.0\"),\n        (\"id\", AVALON_CONTAINER_ID),\n        (\"name\", name),\n        (\"namespace\", namespace),\n        (\"loader\", loader),\n        (\"representation\", context[\"representation\"][\"id\"]),\n        (\"project_name\", context[\"project\"][\"name\"])\n    ]\n    for key, value in data:\n        cmds.addAttr(container, longName=key, dataType=\"string\")\n        cmds.setAttr(container + \".\" + key, str(value), type=\"string\")\n\n    main_container = cmds.ls(AVALON_CONTAINERS, type=\"objectSet\")\n    if not main_container:\n        main_container = cmds.sets(empty=True, name=AVALON_CONTAINERS)\n\n        # Implement #399: Maya 2019+ hide AVALON_CONTAINERS on creation..\n        if cmds.attributeQuery(\"hiddenInOutliner\",\n                               node=main_container,\n                               exists=True):\n            cmds.setAttr(main_container + \".hiddenInOutliner\", True)\n    else:\n        main_container = main_container[0]\n\n    cmds.sets(container, addElement=main_container)\n\n    # Implement #399: Maya 2019+ hide containers in outliner\n    if cmds.attributeQuery(\"hiddenInOutliner\",\n                           node=container,\n                           exists=True):\n        cmds.setAttr(container + \".hiddenInOutliner\", True)\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/index.html#client.ayon_maya.api.ls","title":"<code>ls()</code>","text":"<p>Yields containers from active Maya scene</p> <p>This is the host-equivalent of api.ls(), but instead of listing assets on disk, it lists assets already loaded in Maya; once loaded they are called 'containers'</p> <p>Yields:</p> Type Description <p>dict[str, Any]: container</p> Source code in <code>client/ayon_maya/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"Yields containers from active Maya scene\n\n    This is the host-equivalent of api.ls(), but instead of listing\n    assets on disk, it lists assets already loaded in Maya; once loaded\n    they are called 'containers'\n\n    Yields:\n        dict[str, Any]: container\n\n    \"\"\"\n    container_names = _ls()\n    for container in sorted(container_names):\n        container_data = parse_container(container)\n        if container_data:\n            yield container_data\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/index.html#client.ayon_maya.api.lsattr","title":"<code>lsattr(attr, value=None)</code>","text":"<p>Return nodes matching <code>key</code> and <code>value</code></p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>Name of Maya attribute</p> required <code>value</code> <code>object</code> <p>Value of attribute. If none is provided, return all nodes with this attribute.</p> <code>None</code> Example <p>lsattr(\"id\", \"myId\") [\"myNode\"] lsattr(\"id\") [\"myNode\", \"myOtherNode\"]</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def lsattr(attr, value=None):\n    \"\"\"Return nodes matching `key` and `value`\n\n    Arguments:\n        attr (str): Name of Maya attribute\n        value (object, optional): Value of attribute. If none\n            is provided, return all nodes with this attribute.\n\n    Example:\n        &gt;&gt; lsattr(\"id\", \"myId\")\n        [\"myNode\"]\n        &gt;&gt; lsattr(\"id\")\n        [\"myNode\", \"myOtherNode\"]\n\n    \"\"\"\n\n    if value is None:\n        return cmds.ls(\"*.%s\" % attr,\n                       recursive=True,\n                       objectsOnly=True,\n                       long=True)\n    return lsattrs({attr: value})\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/index.html#client.ayon_maya.api.lsattrs","title":"<code>lsattrs(attrs)</code>","text":"<p>Return nodes with the given attribute(s).</p> <p>Parameters:</p> Name Type Description Default <code>attrs</code> <code>dict</code> <p>Name and value pairs of expected matches</p> required Example Return <p>list: matching nodes.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def lsattrs(attrs):\n    \"\"\"Return nodes with the given attribute(s).\n\n    Arguments:\n        attrs (dict): Name and value pairs of expected matches\n\n    Example:\n        &gt;&gt;&gt; # Return nodes with an `age` of five.\n        &gt;&gt;&gt; lsattrs({\"age\": \"five\"})\n        &gt;&gt;&gt; # Return nodes with both `age` and `color` of five and blue.\n        &gt;&gt;&gt; lsattrs({\"age\": \"five\", \"color\": \"blue\"})\n\n    Return:\n         list: matching nodes.\n\n    \"\"\"\n\n    dep_fn = OpenMaya.MFnDependencyNode()\n    dag_fn = OpenMaya.MFnDagNode()\n    selection_list = OpenMaya.MSelectionList()\n\n    first_attr = next(iter(attrs))\n\n    try:\n        selection_list.add(\"*.{0}\".format(first_attr),\n                           searchChildNamespaces=True)\n    except RuntimeError as exc:\n        if str(exc).endswith(\"Object does not exist\"):\n            return []\n\n    matches = set()\n    for i in range(selection_list.length()):\n        node = selection_list.getDependNode(i)\n        if node.hasFn(OpenMaya.MFn.kDagNode):\n            fn_node = dag_fn.setObject(node)\n            full_path_names = [path.fullPathName()\n                               for path in fn_node.getAllPaths()]\n        else:\n            fn_node = dep_fn.setObject(node)\n            full_path_names = [fn_node.name()]\n\n        for attr in attrs:\n            try:\n                plug = fn_node.findPlug(attr, True)\n                if plug.asString() != attrs[attr]:\n                    break\n            except RuntimeError:\n                break\n        else:\n            matches.update(full_path_names)\n\n    return list(matches)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/index.html#client.ayon_maya.api.lsattrs--return-nodes-with-an-age-of-five","title":"Return nodes with an <code>age</code> of five.","text":"<p>lsattrs({\"age\": \"five\"})</p>"},{"location":"autoapi/client/ayon_maya/api/index.html#client.ayon_maya.api.lsattrs--return-nodes-with-both-age-and-color-of-five-and-blue","title":"Return nodes with both <code>age</code> and <code>color</code> of five and blue.","text":"<p>lsattrs({\"age\": \"five\", \"color\": \"blue\"})</p>"},{"location":"autoapi/client/ayon_maya/api/index.html#client.ayon_maya.api.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context</p> Example <p>scene = cmds.file(new=True, force=True) node = cmds.createNode(\"transform\", name=\"Test\") cmds.select(\"persp\") with maintained_selection(): ...     cmds.select(\"Test\", replace=True) \"Test\" in cmds.ls(selection=True) False</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection():\n    \"\"\"Maintain selection during context\n\n    Example:\n        &gt;&gt;&gt; scene = cmds.file(new=True, force=True)\n        &gt;&gt;&gt; node = cmds.createNode(\"transform\", name=\"Test\")\n        &gt;&gt;&gt; cmds.select(\"persp\")\n        &gt;&gt;&gt; with maintained_selection():\n        ...     cmds.select(\"Test\", replace=True)\n        &gt;&gt;&gt; \"Test\" in cmds.ls(selection=True)\n        False\n\n    \"\"\"\n\n    previous_selection = cmds.ls(selection=True, long=True)\n    try:\n        yield\n    finally:\n        if previous_selection:\n            cmds.select(previous_selection,\n                        replace=True,\n                        noExpand=True)\n        else:\n            cmds.select(clear=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/index.html#client.ayon_maya.api.read","title":"<code>read(node)</code>","text":"<p>Return user-defined attributes from <code>node</code></p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def read(node):\n    \"\"\"Return user-defined attributes from `node`\"\"\"\n\n    data = dict()\n\n    for attr in cmds.listAttr(node, userDefined=True) or list():\n        try:\n            value = cmds.getAttr(node + \".\" + attr, asString=True)\n\n        except RuntimeError:\n            # For Message type attribute or others that have connections,\n            # take source node name as value.\n            source = cmds.listConnections(node + \".\" + attr,\n                                          source=True,\n                                          destination=False)\n            source = cmds.ls(source, long=True) or [None]\n            value = source[0]\n\n        except ValueError:\n            # Some attributes cannot be read directly,\n            # such as mesh and color attributes. These\n            # are considered non-essential to this\n            # particular publishing pipeline.\n            value = None\n\n        data[attr] = value\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/index.html#client.ayon_maya.api.suspended_refresh","title":"<code>suspended_refresh(suspend=True)</code>","text":"<p>Suspend viewport refreshes</p> <p>cmds.ogs(pause=True) is a toggle so we can't pass False.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef suspended_refresh(suspend=True):\n    \"\"\"Suspend viewport refreshes\n\n    cmds.ogs(pause=True) is a toggle so we can't pass False.\n    \"\"\"\n    if IS_HEADLESS:\n        yield\n        return\n\n    original_state = cmds.ogs(query=True, pause=True)\n    try:\n        if suspend and not original_state:\n            cmds.ogs(pause=True)\n        yield\n    finally:\n        if suspend and not original_state:\n            cmds.ogs(pause=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/index.html#client.ayon_maya.api.unique_namespace","title":"<code>unique_namespace(namespace, format='%02d', prefix='', suffix='')</code>","text":"<p>Return unique namespace</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str</code> <p>Name of namespace to consider</p> required <code>format</code> <code>str</code> <p>Formatting of the given iteration number</p> <code>'%02d'</code> <code>suffix</code> <code>str</code> <p>Only consider namespaces with this suffix.</p> <code>''</code> <p>unique_namespace(\"bar\")</p>"},{"location":"autoapi/client/ayon_maya/api/index.html#client.ayon_maya.api.unique_namespace--bar01","title":"bar01","text":"<p>unique_namespace(\":hello\")</p>"},{"location":"autoapi/client/ayon_maya/api/index.html#client.ayon_maya.api.unique_namespace--hello01","title":":hello01","text":"<p>unique_namespace(\"bar:\", suffix=\"_NS\")</p>"},{"location":"autoapi/client/ayon_maya/api/index.html#client.ayon_maya.api.unique_namespace--bar01_ns","title":"bar01_NS:","text":"Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def unique_namespace(namespace, format=\"%02d\", prefix=\"\", suffix=\"\"):\n    \"\"\"Return unique namespace\n\n    Arguments:\n        namespace (str): Name of namespace to consider\n        format (str, optional): Formatting of the given iteration number\n        suffix (str, optional): Only consider namespaces with this suffix.\n\n    &gt;&gt;&gt; unique_namespace(\"bar\")\n    # bar01\n    &gt;&gt;&gt; unique_namespace(\":hello\")\n    # :hello01\n    &gt;&gt;&gt; unique_namespace(\"bar:\", suffix=\"_NS\")\n    # bar01_NS:\n\n    \"\"\"\n\n    def current_namespace():\n        current = cmds.namespaceInfo(currentNamespace=True,\n                                     absoluteName=True)\n        # When inside a namespace Maya adds no trailing :\n        if not current.endswith(\":\"):\n            current += \":\"\n        return current\n\n    # Always check against the absolute namespace root\n    # There's no clash with :x if we're defining namespace :a:x\n    ROOT = \":\" if namespace.startswith(\":\") else current_namespace()\n\n    # Strip trailing `:` tokens since we might want to add a suffix\n    start = \":\" if namespace.startswith(\":\") else \"\"\n    end = \":\" if namespace.endswith(\":\") else \"\"\n    namespace = namespace.strip(\":\")\n    if \":\" in namespace:\n        # Split off any nesting that we don't uniqify anyway.\n        parents, namespace = namespace.rsplit(\":\", 1)\n        start += parents + \":\"\n        ROOT += start\n\n    def exists(n):\n        # Check for clash with nodes and namespaces\n        fullpath = ROOT + n\n        return cmds.objExists(fullpath) or cmds.namespace(exists=fullpath)\n\n    iteration = 1\n    while True:\n        nr_namespace = namespace + format % iteration\n        unique = prefix + nr_namespace + suffix\n\n        if not exists(unique):\n            return start + unique + end\n\n        iteration += 1\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/action.html","title":"action","text":""},{"location":"autoapi/client/ayon_maya/api/action.html#client.ayon_maya.api.action.GenerateUUIDsOnInvalidAction","title":"<code>GenerateUUIDsOnInvalidAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Generate UUIDs on the invalid nodes in the instance.</p> <p>Invalid nodes are those returned by the plugin's <code>get_invalid</code> method. As such it is the plug-in's responsibility to ensure the nodes that receive new UUIDs are actually invalid.</p> Requires <ul> <li>instance.data[\"folderPath\"]</li> </ul> Source code in <code>client/ayon_maya/api/action.py</code> <pre><code>class GenerateUUIDsOnInvalidAction(pyblish.api.Action):\n    \"\"\"Generate UUIDs on the invalid nodes in the instance.\n\n    Invalid nodes are those returned by the plugin's `get_invalid` method.\n    As such it is the plug-in's responsibility to ensure the nodes that\n    receive new UUIDs are actually invalid.\n\n    Requires:\n        - instance.data[\"folderPath\"]\n\n    \"\"\"\n\n    label = \"Regenerate UUIDs\"\n    on = \"failed\"  # This action is only available on a failed plug-in\n    icon = \"wrench\"  # Icon from Awesome Icon\n\n    def process(self, context, plugin):\n\n        from maya import cmds\n\n        self.log.info(\"Finding bad nodes..\")\n\n        errored_instances = get_errored_instances_from_context(context)\n\n        # Apply pyblish logic to get the instances for the plug-in\n        instances = pyblish.api.instances_by_plugin(errored_instances, plugin)\n\n        # Get the nodes from the all instances that ran through this plug-in\n        all_invalid = []\n        for instance in instances:\n            invalid = plugin.get_invalid(instance)\n\n            # Don't allow referenced nodes to get their ids regenerated to\n            # avoid loaded content getting messed up with reference edits\n            if invalid:\n                referenced = {node for node in invalid if\n                              cmds.referenceQuery(node, isNodeReferenced=True)}\n                if referenced:\n                    self.log.warning(\"Skipping UUID generation on referenced \"\n                                     \"nodes: {}\".format(list(referenced)))\n                    invalid = [node for node in invalid\n                               if node not in referenced]\n\n            if invalid:\n\n                self.log.info(\"Fixing instance {}\".format(instance.name))\n                self._update_id_attribute(instance, invalid)\n\n                all_invalid.extend(invalid)\n\n        if not all_invalid:\n            self.log.info(\"No invalid nodes found.\")\n            return\n\n        all_invalid = list(set(all_invalid))\n        self.log.info(\"Generated ids on nodes: {0}\".format(all_invalid))\n\n    def _update_id_attribute(self, instance, nodes):\n        \"\"\"Delete the id attribute\n\n        Args:\n            instance: The instance we're fixing for\n            nodes (list): all nodes to regenerate ids on\n        \"\"\"\n\n        from . import lib\n\n        # Expecting this is called on validators in which case 'folderEntity'\n        #   should be always available, but kept a way to query it by name.\n        folder_entity = instance.data.get(\"folderEntity\")\n        if not folder_entity:\n            folder_path = instance.data[\"folderPath\"]\n            project_name = instance.context.data[\"projectName\"]\n            self.log.info((\n                \"Folder is not stored on instance.\"\n                \" Querying by path \\\"{}\\\" from project \\\"{}\\\"\"\n            ).format(folder_path, project_name))\n            folder_entity = ayon_api.get_folder_by_path(\n                project_name, folder_path, fields={\"id\"}\n            )\n\n        for node, _id in lib.generate_ids(\n            nodes, folder_id=folder_entity[\"id\"]\n        ):\n            lib.set_id(node, _id, overwrite=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/action.html#client.ayon_maya.api.action.SelectInvalidAction","title":"<code>SelectInvalidAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Select invalid nodes in Maya when plug-in failed.</p> <p>To retrieve the invalid nodes this assumes a static <code>get_invalid()</code> method is available on the plugin.</p> Source code in <code>client/ayon_maya/api/action.py</code> <pre><code>class SelectInvalidAction(pyblish.api.Action):\n    \"\"\"Select invalid nodes in Maya when plug-in failed.\n\n    To retrieve the invalid nodes this assumes a static `get_invalid()`\n    method is available on the plugin.\n\n    \"\"\"\n    label = \"Select invalid\"\n    on = \"failed\"  # This action is only available on a failed plug-in\n    icon = \"search\"  # Icon from Awesome Icon\n\n    def process(self, context, plugin):\n\n        try:\n            from maya import cmds\n        except ImportError:\n            raise ImportError(\"Current host is not Maya\")\n\n        # Get the invalid nodes for the plug-ins\n        self.log.info(\"Finding invalid nodes..\")\n        invalid = list()\n        if issubclass(plugin, pyblish.api.ContextPlugin):\n            errored_plugins = get_errored_plugins_from_context(context)\n            if plugin in errored_plugins:\n                invalid = plugin.get_invalid(context)\n        else:\n            errored_instances = get_errored_instances_from_context(\n                context, plugin=plugin\n            )\n            for instance in errored_instances:\n                invalid_nodes = plugin.get_invalid(instance)\n                if invalid_nodes:\n                    if isinstance(invalid_nodes, (list, tuple)):\n                        invalid.extend(invalid_nodes)\n                    else:\n                        self.log.warning(\"Plug-in returned to be invalid, \"\n                                         \"but has no selectable nodes.\")\n\n        # Ensure unique (process each node only once)\n        invalid = list(set(invalid))\n\n        if invalid:\n            self.log.info(\"Selecting invalid nodes: %s\" % \", \".join(invalid))\n            cmds.select(invalid, replace=True, noExpand=True)\n        else:\n            self.log.info(\"No invalid nodes found.\")\n            cmds.select(deselect=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/alembic.html","title":"alembic","text":""},{"location":"autoapi/client/ayon_maya/api/alembic.html#client.ayon_maya.api.alembic.extract_alembic","title":"<code>extract_alembic(file, attr=None, attrPrefix=None, dataFormat='ogawa', endFrame=None, eulerFilter=True, frameRange='', melPerFrameCallback=None, melPostJobCallback=None, noNormals=False, preRoll=False, preRollStartFrame=None, pythonPerFrameCallback=None, pythonPostJobCallback=None, renderableOnly=False, root=None, selection=True, startFrame=None, step=1.0, stripNamespaces=True, userAttr=None, userAttrPrefix=None, uvsOnly=False, uvWrite=True, verbose=False, wholeFrameGeo=False, worldSpace=False, writeColorSets=False, writeCreases=False, writeFaceSets=False, writeUVSets=False, writeVisibility=False)</code>","text":"<p>Extract a single Alembic Cache.</p> <p>This extracts an Alembic cache using the <code>-selection</code> flag to minimize the extracted content to solely what was Collected into the instance.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>The filepath to write the alembic file to.</p> required <code>attr</code> <code>list of str</code> <p>A specific geometric attribute to write out. Defaults to [].</p> <code>None</code> <code>attrPrefix</code> <code>list of str</code> <p>Prefix filter for determining which geometric attributes to write out. Defaults to [\"ABC_\"].</p> <code>None</code> <code>dataFormat</code> <code>str</code> <p>The data format to use for the cache,               defaults to \"ogawa\"</p> <code>'ogawa'</code> <code>endFrame</code> <code>float</code> <p>End frame of output. Ignored if <code>frameRange</code> provided.</p> <code>None</code> <code>eulerFilter</code> <code>bool</code> <p>When on, X, Y, and Z rotation data is filtered with an Euler filter. Euler filtering helps resolve irregularities in rotations especially if X, Y, and Z rotations exceed 360 degrees. Defaults to True.</p> <code>True</code> <code>frameRange</code> <code>tuple or str</code> <p>Two-tuple with start and end frame or a string formatted as: \"startFrame endFrame\". This argument overrides <code>startFrame</code> and <code>endFrame</code> arguments.</p> <code>''</code> <code>melPerFrameCallback</code> <code>Optional[str]</code> <p>MEL callback run per frame.</p> <code>None</code> <code>melPostJobCallback</code> <code>Optional[str]</code> <p>MEL callback after last frame is written.</p> <code>None</code> <code>noNormals</code> <code>bool</code> <p>When on, normal data from the original polygon objects is not included in the exported Alembic cache file.</p> <code>False</code> <code>preRoll</code> <code>bool</code> <p>This frame range will not be sampled. Defaults to False.</p> <code>False</code> <code>preRollStartFrame</code> <code>Optional[float]</code> <p>The frame to start scene evaluation at.  This is used to set the starting frame for time dependent translations and can be used to evaluate run-up that isn't actually translated. Defaults to None, meaning no pre-roll start frame will be used to roll from.</p> <code>None</code> <code>pythonPerFrameCallback</code> <code>Optional[str]</code> <p>Python callback run per frame.</p> <code>None</code> <code>pythonPostJobCallback</code> <code>Optional[str]</code> <p>Python callback after last frame is written.</p> <code>None</code> <code>renderableOnly</code> <code>bool</code> <p>When on, any non-renderable nodes or hierarchy, such as hidden objects, are not included in the Alembic file. Defaults to False.</p> <code>False</code> <code>root</code> <code>list of str</code> <p>Maya dag path which will be parented to the root of the Alembic file. Defaults to [], which means the entire scene will be written out.</p> <code>None</code> <code>selection</code> <code>bool</code> <p>Write out all all selected nodes from the active selection list that are descendents of the roots specified with -root. Defaults to False.</p> <code>True</code> <code>startFrame</code> <code>float</code> <p>Start frame of output. Ignored if <code>frameRange</code> provided.</p> <code>None</code> <code>step</code> <code>float</code> <p>The time interval (expressed in frames) at which the frame range is sampled. Additional samples around each frame can be specified with -frs. Defaults to 1.0.</p> <code>1.0</code> <code>stripNamespaces</code> <code>bool</code> <p>When on, any namespaces associated with the exported objects are removed from the Alembic file. For example, an object with the namespace taco:foo:bar appears as bar in the Alembic file.</p> <code>True</code> <code>userAttr</code> <code>list of str</code> <p>A specific user defined attribute to write out. Defaults to [].</p> <code>None</code> <code>userAttrPrefix</code> <code>list of str</code> <p>Prefix filter for determining which user defined attributes to write out. Defaults to [].</p> <code>None</code> <code>uvsOnly</code> <code>bool</code> <p>When on, only uv data for PolyMesh and SubD shapes will be written to the Alembic file.</p> <code>False</code> <code>uvWrite</code> <code>bool</code> <p>When on, UV data from polygon meshes and subdivision objects are written to the Alembic file. Only the current UV map is included.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>When on, outputs frame number information to the Script Editor or output window during extraction.</p> <code>False</code> <code>wholeFrameGeo</code> <code>bool</code> <p>Data for geometry will only be written out on whole frames. Defaults to False.</p> <code>False</code> <code>worldSpace</code> <code>bool</code> <p>When on, the top node in the node hierarchy is stored as world space. By default, these nodes are stored as local space. Defaults to False.</p> <code>False</code> <code>writeColorSets</code> <code>bool</code> <p>Write all color sets on MFnMeshes as color 3 or color 4 indexed geometry parameters with face varying scope. Defaults to False.</p> <code>False</code> <code>writeCreases</code> <code>bool</code> <p>If the mesh has crease edges or crease vertices, the mesh (OPolyMesh) would now be written out as an OSubD and crease info will be stored in the Alembic file. Otherwise, creases info won't be preserved in Alembic file unless a custom Boolean attribute SubDivisionMesh has been added to mesh node and its value is true. Defaults to False.</p> <code>False</code> <code>writeFaceSets</code> <code>bool</code> <p>Write all Face sets on MFnMeshes. Defaults to False.</p> <code>False</code> <code>writeUVSets</code> <code>bool</code> <p>Write all uv sets on MFnMeshes as vector 2 indexed geometry parameters with face varying scope. Defaults to False.</p> <code>False</code> <code>writeVisibility</code> <code>bool</code> <p>Visibility state will be stored in the Alembic file.  Otherwise everything written out is treated as visible. Defaults to False.</p> <code>False</code> Source code in <code>client/ayon_maya/api/alembic.py</code> <pre><code>def extract_alembic(\n    file,\n    attr=None,\n    attrPrefix=None,\n    dataFormat=\"ogawa\",\n    endFrame=None,\n    eulerFilter=True,\n    frameRange=\"\",\n    melPerFrameCallback=None,\n    melPostJobCallback=None,\n    noNormals=False,\n    preRoll=False,\n    preRollStartFrame=None,\n    pythonPerFrameCallback=None,\n    pythonPostJobCallback=None,\n    renderableOnly=False,\n    root=None,\n    selection=True,\n    startFrame=None,\n    step=1.0,\n    stripNamespaces=True,\n    userAttr=None,\n    userAttrPrefix=None,\n    uvsOnly=False,\n    uvWrite=True,\n    verbose=False,\n    wholeFrameGeo=False,\n    worldSpace=False,\n    writeColorSets=False,\n    writeCreases=False,\n    writeFaceSets=False,\n    writeUVSets=False,\n    writeVisibility=False\n):\n    \"\"\"Extract a single Alembic Cache.\n\n    This extracts an Alembic cache using the `-selection` flag to minimize\n    the extracted content to solely what was Collected into the instance.\n\n    Arguments:\n        file (str): The filepath to write the alembic file to.\n\n        attr (list of str, optional): A specific geometric attribute to write\n            out. Defaults to [].\n\n        attrPrefix (list of str, optional): Prefix filter for determining which\n            geometric attributes to write out. Defaults to [\"ABC_\"].\n\n        dataFormat (str): The data format to use for the cache,\n                          defaults to \"ogawa\"\n\n        endFrame (float): End frame of output. Ignored if `frameRange`\n            provided.\n\n        eulerFilter (bool): When on, X, Y, and Z rotation data is filtered with\n            an Euler filter. Euler filtering helps resolve irregularities in\n            rotations especially if X, Y, and Z rotations exceed 360 degrees.\n            Defaults to True.\n\n        frameRange (tuple or str): Two-tuple with start and end frame or a\n            string formatted as: \"startFrame endFrame\". This argument\n            overrides `startFrame` and `endFrame` arguments.\n\n        melPerFrameCallback (Optional[str]): MEL callback run per frame.\n\n        melPostJobCallback (Optional[str]): MEL callback after last frame is\n            written.\n\n        noNormals (bool): When on, normal data from the original polygon\n            objects is not included in the exported Alembic cache file.\n\n        preRoll (bool): This frame range will not be sampled.\n            Defaults to False.\n\n        preRollStartFrame (Optional[float]): The frame to start scene\n            evaluation at.  This is used to set the starting frame for time\n            dependent translations and can be used to evaluate run-up that\n            isn't actually translated. Defaults to None, meaning no pre-roll\n            start frame will be used to roll from.\n\n        pythonPerFrameCallback (Optional[str]): Python callback run per frame.\n\n        pythonPostJobCallback (Optional[str]): Python callback after last frame\n            is written.\n\n        renderableOnly (bool): When on, any non-renderable nodes or hierarchy,\n            such as hidden objects, are not included in the Alembic file.\n            Defaults to False.\n\n        root (list of str): Maya dag path which will be parented to\n            the root of the Alembic file. Defaults to [], which means the\n            entire scene will be written out.\n\n        selection (bool): Write out all all selected nodes from the\n            active selection list that are descendents of the roots specified\n            with -root. Defaults to False.\n\n        startFrame (float): Start frame of output. Ignored if `frameRange`\n            provided.\n\n        step (float): The time interval (expressed in frames) at\n            which the frame range is sampled. Additional samples around each\n            frame can be specified with -frs. Defaults to 1.0.\n\n        stripNamespaces (bool): When on, any namespaces associated with the\n            exported objects are removed from the Alembic file. For example, an\n            object with the namespace taco:foo:bar appears as bar in the\n            Alembic file.\n\n        userAttr (list of str, optional): A specific user defined attribute to\n            write out. Defaults to [].\n\n        userAttrPrefix (list of str, optional): Prefix filter for determining\n            which user defined attributes to write out. Defaults to [].\n\n        uvsOnly (bool): When on, only uv data for PolyMesh and SubD shapes\n            will be written to the Alembic file.\n\n        uvWrite (bool): When on, UV data from polygon meshes and subdivision\n            objects are written to the Alembic file. Only the current UV map is\n            included.\n\n        verbose (bool): When on, outputs frame number information to the\n            Script Editor or output window during extraction.\n\n        wholeFrameGeo (bool): Data for geometry will only be written\n            out on whole frames. Defaults to False.\n\n        worldSpace (bool): When on, the top node in the node hierarchy is\n            stored as world space. By default, these nodes are stored as local\n            space. Defaults to False.\n\n        writeColorSets (bool): Write all color sets on MFnMeshes as\n            color 3 or color 4 indexed geometry parameters with face varying\n            scope. Defaults to False.\n\n        writeCreases (bool): If the mesh has crease edges or crease\n            vertices, the mesh (OPolyMesh) would now be written out as an OSubD\n            and crease info will be stored in the Alembic file. Otherwise,\n            creases info won't be preserved in Alembic file unless a custom\n            Boolean attribute SubDivisionMesh has been added to mesh node and\n            its value is true. Defaults to False.\n\n        writeFaceSets (bool): Write all Face sets on MFnMeshes.\n            Defaults to False.\n\n        writeUVSets (bool): Write all uv sets on MFnMeshes as vector\n            2 indexed geometry parameters with face varying scope. Defaults to\n            False.\n\n        writeVisibility (bool): Visibility state will be stored in\n            the Alembic file.  Otherwise everything written out is treated as\n            visible. Defaults to False.\n    \"\"\"\n\n    # Ensure alembic exporter is loaded\n    cmds.loadPlugin('AbcExport', quiet=True)\n\n    # Alembic Exporter requires forward slashes\n    file = file.replace('\\\\', '/')\n\n    # Ensure list arguments are valid.\n    attr = attr or []\n    attrPrefix = attrPrefix or []\n    userAttr = userAttr or []\n    userAttrPrefix = userAttrPrefix or []\n    root = root or []\n\n    # Pass the start and end frame on as `frameRange` so that it\n    # never conflicts with that argument\n    if not frameRange:\n        # Fallback to maya timeline if no start or end frame provided.\n        if startFrame is None:\n            startFrame = cmds.playbackOptions(query=True,\n                                              animationStartTime=True)\n        if endFrame is None:\n            endFrame = cmds.playbackOptions(query=True,\n                                            animationEndTime=True)\n\n        # Ensure valid types are converted to frame range\n        assert isinstance(startFrame, ALEMBIC_ARGS[\"startFrame\"])\n        assert isinstance(endFrame, ALEMBIC_ARGS[\"endFrame\"])\n        frameRange = \"{0} {1}\".format(startFrame, endFrame)\n    else:\n        # Allow conversion from tuple for `frameRange`\n        if isinstance(frameRange, (list, tuple)):\n            assert len(frameRange) == 2\n            frameRange = \"{0} {1}\".format(frameRange[0], frameRange[1])\n\n    # Assemble options\n    options = {\n        \"selection\": selection,\n        \"frameRange\": frameRange,\n        \"eulerFilter\": eulerFilter,\n        \"noNormals\": noNormals,\n        \"preRoll\": preRoll,\n        \"root\": root,\n        \"renderableOnly\": renderableOnly,\n        \"uvWrite\": uvWrite,\n        \"uvsOnly\": uvsOnly,\n        \"writeColorSets\": writeColorSets,\n        \"writeFaceSets\": writeFaceSets,\n        \"wholeFrameGeo\": wholeFrameGeo,\n        \"worldSpace\": worldSpace,\n        \"writeVisibility\": writeVisibility,\n        \"writeUVSets\": writeUVSets,\n        \"writeCreases\": writeCreases,\n        \"dataFormat\": dataFormat,\n        \"step\": step,\n        \"attr\": attr,\n        \"attrPrefix\": attrPrefix,\n        \"userAttr\": userAttr,\n        \"userAttrPrefix\": userAttrPrefix,\n        \"stripNamespaces\": stripNamespaces,\n    }\n\n    # Validate options\n    for key, value in options.copy().items():\n\n        # Discard unknown options\n        if key not in ALEMBIC_ARGS:\n            log.warning(\"extract_alembic() does not support option '%s'. \"\n                        \"Flag will be ignored..\", key)\n            options.pop(key)\n            continue\n\n        # Validate value type\n        valid_types = ALEMBIC_ARGS[key]\n        if not isinstance(value, valid_types):\n            raise TypeError(\"Alembic option unsupported type: \"\n                            \"{0} (expected {1})\".format(value, valid_types))\n\n        # Ignore empty values, like an empty string, since they mess up how\n        # job arguments are built\n        if isinstance(value, (list, tuple)):\n            value = [x for x in value if x.strip()]\n\n            # Ignore option completely if no values remaining\n            if not value:\n                options.pop(key)\n                continue\n\n            options[key] = value\n\n    # The `writeCreases` argument was changed to `autoSubd` in Maya 2018+\n    maya_version = int(cmds.about(version=True))\n    if maya_version &gt;= 2018:\n        options['autoSubd'] = options.pop('writeCreases', False)\n\n    # Only add callbacks if they are set so that we're not passing `None`\n    callbacks = {\n        \"melPerFrameCallback\": melPerFrameCallback,\n        \"melPostJobCallback\": melPostJobCallback,\n        \"pythonPerFrameCallback\": pythonPerFrameCallback,\n        \"pythonPostJobCallback\": pythonPostJobCallback,\n    }\n    for key, callback in callbacks.items():\n        if callback:\n            options[key] = str(callback)\n\n    # Format the job string from options\n    job_args = list()\n    for key, value in options.items():\n        if isinstance(value, (list, tuple)):\n            for entry in value:\n                job_args.append(\"-{} {}\".format(key, entry))\n        elif isinstance(value, bool):\n            # Add only when state is set to True\n            if value:\n                job_args.append(\"-{0}\".format(key))\n        else:\n            job_args.append(\"-{0} {1}\".format(key, value))\n\n    job_str = \" \".join(job_args)\n    job_str += ' -file \"%s\"' % file\n\n    # Ensure output directory exists\n    parent_dir = os.path.dirname(file)\n    if not os.path.exists(parent_dir):\n        os.makedirs(parent_dir)\n\n    if verbose:\n        log.debug(\"Preparing Alembic export with options: %s\",\n                  json.dumps(options, indent=4))\n        log.debug(\"Extracting Alembic with job arguments: %s\", job_str)\n\n    # Perform extraction\n    print(\"Alembic Job Arguments : {}\".format(job_str))\n\n    # Disable the parallel evaluation temporarily to ensure no buggy\n    # exports are made. (PLN-31)\n    # TODO: Make sure this actually fixes the issues\n    with evaluation(\"off\"):\n        cmds.AbcExport(\n            j=job_str,\n            verbose=verbose,\n            preRollStartFrame=preRollStartFrame\n        )\n\n    if verbose:\n        log.debug(\"Extracted Alembic to: %s\", file)\n\n    return file\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/commands.html","title":"commands","text":"<p>AYON script commands to be used directly in Maya.</p>"},{"location":"autoapi/client/ayon_maya/api/commands.html#client.ayon_maya.api.commands.ToolWindows","title":"<code>ToolWindows</code>","text":"Source code in <code>client/ayon_maya/api/commands.py</code> <pre><code>class ToolWindows:\n\n    _windows = {}\n\n    @classmethod\n    def get_window(cls, tool):\n        \"\"\"Get widget for specific tool.\n\n        Args:\n            tool (str): Name of the tool.\n\n        Returns:\n            Stored widget.\n\n        \"\"\"\n        try:\n            return cls._windows[tool]\n        except KeyError:\n            return None\n\n    @classmethod\n    def set_window(cls, tool, window):\n        \"\"\"Set widget for the tool.\n\n        Args:\n            tool (str): Name of the tool.\n            window (QtWidgets.QWidget): Widget\n\n        \"\"\"\n        cls._windows[tool] = window\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/commands.html#client.ayon_maya.api.commands.ToolWindows.get_window","title":"<code>get_window(tool)</code>  <code>classmethod</code>","text":"<p>Get widget for specific tool.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>str</code> <p>Name of the tool.</p> required <p>Returns:</p> Type Description <p>Stored widget.</p> Source code in <code>client/ayon_maya/api/commands.py</code> <pre><code>@classmethod\ndef get_window(cls, tool):\n    \"\"\"Get widget for specific tool.\n\n    Args:\n        tool (str): Name of the tool.\n\n    Returns:\n        Stored widget.\n\n    \"\"\"\n    try:\n        return cls._windows[tool]\n    except KeyError:\n        return None\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/commands.html#client.ayon_maya.api.commands.ToolWindows.set_window","title":"<code>set_window(tool, window)</code>  <code>classmethod</code>","text":"<p>Set widget for the tool.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>str</code> <p>Name of the tool.</p> required <code>window</code> <code>QWidget</code> <p>Widget</p> required Source code in <code>client/ayon_maya/api/commands.py</code> <pre><code>@classmethod\ndef set_window(cls, tool, window):\n    \"\"\"Set widget for the tool.\n\n    Args:\n        tool (str): Name of the tool.\n        window (QtWidgets.QWidget): Widget\n\n    \"\"\"\n    cls._windows[tool] = window\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/customize.html","title":"customize","text":"<p>A set of commands that install overrides to Maya's UI</p>"},{"location":"autoapi/client/ayon_maya/api/customize.html#client.ayon_maya.api.customize.override_component_mask_commands","title":"<code>override_component_mask_commands()</code>","text":"<p>Override component mask ctrl+click behavior.</p> <p>This implements special behavior for Maya's component mask menu items where a ctrl+click will instantly make it an isolated behavior disabling all others.</p> <p>Tested in Maya 2016 and 2018</p> Source code in <code>client/ayon_maya/api/customize.py</code> <pre><code>def override_component_mask_commands():\n    \"\"\"Override component mask ctrl+click behavior.\n\n    This implements special behavior for Maya's component\n    mask menu items where a ctrl+click will instantly make\n    it an isolated behavior disabling all others.\n\n    Tested in Maya 2016 and 2018\n\n    \"\"\"\n    log.info(\"Installing override_component_mask_commands..\")\n\n    # Get all object mask buttons\n    buttons = cmds.formLayout(\"objectMaskIcons\",\n                              query=True,\n                              childArray=True)\n    # Skip the triangle list item\n    buttons = [btn for btn in buttons if btn != \"objPickMenuLayout\"]\n\n    def on_changed_callback(raw_command, state):\n        \"\"\"New callback\"\"\"\n\n        # If \"control\" is held force the toggled one to on and\n        # toggle the others based on whether any of the buttons\n        # was remaining active after the toggle, if not then\n        # enable all\n        if cmds.getModifiers() == 4:  # = CTRL\n            state = True\n            active = [cmds.iconTextCheckBox(btn, query=True, value=True)\n                      for btn in buttons]\n            if any(active):\n                cmds.selectType(allObjects=False)\n            else:\n                cmds.selectType(allObjects=True)\n\n        # Replace #1 with the current button state\n        cmd = raw_command.replace(\" #1\", \" {}\".format(int(state)))\n        mel.eval(cmd)\n\n    for btn in buttons:\n\n        # Store a reference to the original command so that if\n        # we rerun this override command it doesn't recursively\n        # try to implement the fix. (This also allows us to\n        # \"uninstall\" the behavior later)\n        if btn not in COMPONENT_MASK_ORIGINAL:\n            original = cmds.iconTextCheckBox(btn, query=True, cc=True)\n            COMPONENT_MASK_ORIGINAL[btn] = original\n\n        # Assign the special callback\n        original = COMPONENT_MASK_ORIGINAL[btn]\n        new_fn = partial(on_changed_callback, original)\n        cmds.iconTextCheckBox(btn, edit=True, cc=new_fn)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/customize.html#client.ayon_maya.api.customize.override_toolbox_ui","title":"<code>override_toolbox_ui()</code>","text":"<p>Add custom buttons in Toolbox as replacement for Maya web help icon.</p> Source code in <code>client/ayon_maya/api/customize.py</code> <pre><code>def override_toolbox_ui():\n    \"\"\"Add custom buttons in Toolbox as replacement for Maya web help icon.\"\"\"\n    icons = resources.get_resource(\"icons\")\n    parent_widget = get_main_window()\n\n    # Ensure the maya web icon on toolbox exists\n    button_names = [\n        # Maya 2022.1+ with maya.cmds.iconTextStaticLabel\n        \"ToolBox|MainToolboxLayout|mayaHomeToolboxButton\",\n        # Older with maya.cmds.iconTextButton\n        \"ToolBox|MainToolboxLayout|mayaWebButton\"\n    ]\n    for name in button_names:\n        if cmds.control(name, query=True, exists=True):\n            web_button = name\n            break\n    else:\n        # Button does not exist\n        log.warning(\"Can't find Maya Home/Web button to override toolbox ui..\")\n        return\n\n    cmds.control(web_button, edit=True, visible=False)\n\n    # real = 32, but 36 with padding - according to toolbox mel script\n    icon_size = 36\n    parent = web_button.rsplit(\"|\", 1)[0]\n\n    # Ensure the parent is a formLayout\n    if not cmds.objectTypeUI(parent) == \"formLayout\":\n        return\n\n    # Create our controls\n    controls = []\n\n    controls.append(\n        cmds.iconTextButton(\n            \"ayon_toolbox_lookmanager\",\n            annotation=\"Look Manager\",\n            label=\"Look Manager\",\n            image=os.path.join(icons, \"lookmanager.png\"),\n            command=lambda: show_look_assigner(\n                parent=parent_widget\n            ),\n            width=icon_size,\n            height=icon_size,\n            parent=parent\n        )\n    )\n\n    controls.append(\n        cmds.iconTextButton(\n            \"ayon_toolbox_workfiles\",\n            annotation=\"Work Files\",\n            label=\"Work Files\",\n            image=os.path.join(icons, \"workfiles.png\"),\n            command=lambda: host_tools.show_workfiles(\n                parent=parent_widget\n            ),\n            width=icon_size,\n            height=icon_size,\n            parent=parent\n        )\n    )\n\n    controls.append(\n        cmds.iconTextButton(\n            \"ayon_toolbox_loader\",\n            annotation=\"Loader\",\n            label=\"Loader\",\n            image=os.path.join(icons, \"loader.png\"),\n            command=lambda: host_tools.show_loader(\n                parent=parent_widget, use_context=True\n            ),\n            width=icon_size,\n            height=icon_size,\n            parent=parent\n        )\n    )\n\n    controls.append(\n        cmds.iconTextButton(\n            \"ayon_toolbox_manager\",\n            annotation=\"Inventory\",\n            label=\"Inventory\",\n            image=os.path.join(icons, \"inventory.png\"),\n            command=lambda: host_tools.show_scene_inventory(\n                parent=parent_widget\n            ),\n            width=icon_size,\n            height=icon_size,\n            parent=parent\n        )\n    )\n\n    # Add the buttons on the bottom and stack\n    # them above each other with side padding\n    controls.reverse()\n    for i, control in enumerate(controls):\n        previous = controls[i - 1] if i &gt; 0 else web_button\n\n        cmds.formLayout(parent, edit=True,\n                        attachControl=[control, \"bottom\", 0, previous],\n                        attachForm=([control, \"left\", 1],\n                                    [control, \"right\", 1]))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/fbx.html","title":"fbx","text":"<p>Tools to work with FBX.</p>"},{"location":"autoapi/client/ayon_maya/api/fbx.html#client.ayon_maya.api.fbx.FBXExtractor","title":"<code>FBXExtractor</code>","text":"<p>Extract FBX from Maya.</p> <p>This extracts reproducible FBX exports ignoring any of the settings set on the local machine in the FBX export options window.</p> <p>All export settings are applied with the <code>FBXExport*</code> commands prior to the <code>FBXExport</code> call itself. The options can be overridden with their nice names as seen in the \"options\" property on this class.</p> <p>For more information on FBX exports see: - https://knowledge.autodesk.com/support/maya/learn-explore/caas /CloudHelp/cloudhelp/2016/ENU/Maya/files/GUID-6CCE943A-2ED4-4CEE-96D4 -9CB19C28F4E0-htm.html - http://forums.cgsociety.org/archive/index.php?t-1032853.html - https://groups.google.com/forum/#!msg/python_inside_maya/cLkaSo361oE /LKs9hakE28kJ</p> Source code in <code>client/ayon_maya/api/fbx.py</code> <pre><code>class FBXExtractor:\n    \"\"\"Extract FBX from Maya.\n\n        This extracts reproducible FBX exports ignoring any of the settings set\n        on the local machine in the FBX export options window.\n\n        All export settings are applied with the `FBXExport*` commands prior\n        to the `FBXExport` call itself. The options can be overridden with\n        their\n        nice names as seen in the \"options\" property on this class.\n\n        For more information on FBX exports see:\n        - https://knowledge.autodesk.com/support/maya/learn-explore/caas\n        /CloudHelp/cloudhelp/2016/ENU/Maya/files/GUID-6CCE943A-2ED4-4CEE-96D4\n        -9CB19C28F4E0-htm.html\n        - http://forums.cgsociety.org/archive/index.php?t-1032853.html\n        - https://groups.google.com/forum/#!msg/python_inside_maya/cLkaSo361oE\n        /LKs9hakE28kJ\n\n        \"\"\"\n    @property\n    def options(self):\n        \"\"\"Overridable options for FBX Export\n\n        Given in the following format\n            - {NAME: EXPECTED TYPE}\n\n        If the overridden option's type does not match,\n        the option is not included and a warning is logged.\n\n        \"\"\"\n\n        return {\n            \"cameras\": bool,\n            \"smoothingGroups\": bool,\n            \"hardEdges\": bool,\n            \"tangents\": bool,\n            \"smoothMesh\": bool,\n            \"instances\": bool,\n            # \"referencedContainersContent\": bool, # deprecated in Maya 2016+\n            \"bakeComplexAnimation\": bool,\n            \"bakeComplexStart\": int,\n            \"bakeComplexEnd\": int,\n            \"bakeComplexStep\": int,\n            \"bakeResampleAnimation\": bool,\n            \"useSceneName\": bool,\n            \"quaternion\": str,  # \"euler\"\n            \"shapes\": bool,\n            \"skins\": bool,\n            \"constraints\": bool,\n            \"lights\": bool,\n            \"embeddedTextures\": bool,\n            \"includeChildren\": bool,\n            \"inputConnections\": bool,\n            \"upAxis\": str,  # x, y or z,\n            \"triangulate\": bool,\n            \"fileVersion\": str,\n            \"skeletonDefinitions\": bool,\n            \"referencedAssetsContent\": bool\n        }\n\n    @property\n    def default_options(self):\n        \"\"\"The default options for FBX extraction.\n\n        This includes shapes, skins, constraints, lights and incoming\n        connections and exports with the Y-axis as up-axis.\n\n        By default this uses the time sliders start and end time.\n\n        \"\"\"\n\n        start_frame = int(cmds.playbackOptions(query=True,\n                                               animationStartTime=True))\n        end_frame = int(cmds.playbackOptions(query=True,\n                                             animationEndTime=True))\n\n        return {\n            \"cameras\": False,\n            \"smoothingGroups\": True,\n            \"hardEdges\": False,\n            \"tangents\": False,\n            \"smoothMesh\": True,\n            \"instances\": False,\n            \"bakeComplexAnimation\": True,\n            \"bakeComplexStart\": start_frame,\n            \"bakeComplexEnd\": end_frame,\n            \"bakeComplexStep\": 1,\n            \"bakeResampleAnimation\": True,\n            \"useSceneName\": False,\n            \"quaternion\": \"euler\",\n            \"shapes\": True,\n            \"skins\": True,\n            \"constraints\": False,\n            \"lights\": True,\n            \"embeddedTextures\": False,\n            \"includeChildren\": True,\n            \"inputConnections\": True,\n            \"upAxis\": \"y\",\n            \"triangulate\": False,\n            \"fileVersion\": \"FBX202000\",\n            \"skeletonDefinitions\": False,\n            \"referencedAssetsContent\": False\n        }\n\n    def __init__(self, log=None):\n        # Ensure FBX plug-in is loaded\n        self.log = log or logging.getLogger(self.__class__.__name__)\n        cmds.loadPlugin(\"fbxmaya\", quiet=True)\n\n    def parse_overrides(self, instance, options):\n        \"\"\"Inspect data of instance to determine overridden options\n\n        An instance may supply any of the overridable options\n        as data, the option is then added to the extraction.\n\n        \"\"\"\n\n        for key in instance.data:\n            if key not in self.options:\n                continue\n\n            # Ensure the data is of correct type\n            value = instance.data[key]\n            if not isinstance(value, self.options[key]):\n                self.log.warning(\n                    \"Overridden attribute {key} was of \"\n                    \"the wrong type: {invalid_type} \"\n                    \"- should have been {valid_type}\".format(\n                        key=key,\n                        invalid_type=type(value).__name__,\n                        valid_type=self.options[key].__name__))\n                continue\n\n            options[key] = value\n\n        return options\n\n    def set_options_from_instance(self, instance):\n        \"\"\"Sets FBX export options from data in the instance.\n\n        Args:\n            instance (Instance): Instance data.\n\n        \"\"\"\n        # Parse export options\n        options = self.default_options\n        options = self.parse_overrides(instance, options)\n        self.log.debug(\"Export options: {0}\".format(options))\n\n        # Collect the start and end including handles\n        start = instance.data.get(\"frameStartHandle\") or \\\n            instance.context.data.get(\"frameStartHandle\")\n        end = instance.data.get(\"frameEndHandle\") or \\\n            instance.context.data.get(\"frameEndHandle\")\n\n        options['bakeComplexStart'] = start\n        options['bakeComplexEnd'] = end\n\n        # First apply the default export settings to be fully consistent\n        # each time for successive publishes\n        mel.eval(\"FBXResetExport\")\n\n        # Apply the FBX overrides through MEL since the commands\n        # only work correctly in MEL according to online\n        # available discussions on the topic\n        _iteritems = getattr(options, \"iteritems\", options.items)\n        for option, value in _iteritems():\n            key = option[0].upper() + option[1:]  # uppercase first letter\n\n            # Boolean must be passed as lower-case strings\n            # as to MEL standards\n            if isinstance(value, bool):\n                value = str(value).lower()\n\n            template = \"FBXExport{0} {1}\" if key == \"UpAxis\" else \\\n                \"FBXExport{0} -v {1}\"  # noqa\n            cmd = template.format(key, value)\n            self.log.debug(cmd)\n            mel.eval(cmd)\n\n        # Never show the UI or generate a log\n        mel.eval(\"FBXExportShowUI -v false\")\n        mel.eval(\"FBXExportGenerateLog -v false\")\n\n    @staticmethod\n    def export(members, path):\n        # type: (list, str) -&gt; None\n        \"\"\"Export members as FBX with given path.\n\n        Args:\n            members (list): List of members to export.\n            path (str): Path to use for export.\n\n        \"\"\"\n        # The export requires forward slashes because we need\n        # to format it into a string in a mel expression\n        path = path.replace(\"\\\\\", \"/\")\n        with maintained_selection():\n            cmds.select(members, r=True, noExpand=True)\n            mel.eval('FBXExport -f \"{}\" -s'.format(path))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/fbx.html#client.ayon_maya.api.fbx.FBXExtractor.default_options","title":"<code>default_options</code>  <code>property</code>","text":"<p>The default options for FBX extraction.</p> <p>This includes shapes, skins, constraints, lights and incoming connections and exports with the Y-axis as up-axis.</p> <p>By default this uses the time sliders start and end time.</p>"},{"location":"autoapi/client/ayon_maya/api/fbx.html#client.ayon_maya.api.fbx.FBXExtractor.options","title":"<code>options</code>  <code>property</code>","text":"<p>Overridable options for FBX Export</p> <p>Given in the following format     - {NAME: EXPECTED TYPE}</p> <p>If the overridden option's type does not match, the option is not included and a warning is logged.</p>"},{"location":"autoapi/client/ayon_maya/api/fbx.html#client.ayon_maya.api.fbx.FBXExtractor.export","title":"<code>export(members, path)</code>  <code>staticmethod</code>","text":"<p>Export members as FBX with given path.</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>list</code> <p>List of members to export.</p> required <code>path</code> <code>str</code> <p>Path to use for export.</p> required Source code in <code>client/ayon_maya/api/fbx.py</code> <pre><code>@staticmethod\ndef export(members, path):\n    # type: (list, str) -&gt; None\n    \"\"\"Export members as FBX with given path.\n\n    Args:\n        members (list): List of members to export.\n        path (str): Path to use for export.\n\n    \"\"\"\n    # The export requires forward slashes because we need\n    # to format it into a string in a mel expression\n    path = path.replace(\"\\\\\", \"/\")\n    with maintained_selection():\n        cmds.select(members, r=True, noExpand=True)\n        mel.eval('FBXExport -f \"{}\" -s'.format(path))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/fbx.html#client.ayon_maya.api.fbx.FBXExtractor.parse_overrides","title":"<code>parse_overrides(instance, options)</code>","text":"<p>Inspect data of instance to determine overridden options</p> <p>An instance may supply any of the overridable options as data, the option is then added to the extraction.</p> Source code in <code>client/ayon_maya/api/fbx.py</code> <pre><code>def parse_overrides(self, instance, options):\n    \"\"\"Inspect data of instance to determine overridden options\n\n    An instance may supply any of the overridable options\n    as data, the option is then added to the extraction.\n\n    \"\"\"\n\n    for key in instance.data:\n        if key not in self.options:\n            continue\n\n        # Ensure the data is of correct type\n        value = instance.data[key]\n        if not isinstance(value, self.options[key]):\n            self.log.warning(\n                \"Overridden attribute {key} was of \"\n                \"the wrong type: {invalid_type} \"\n                \"- should have been {valid_type}\".format(\n                    key=key,\n                    invalid_type=type(value).__name__,\n                    valid_type=self.options[key].__name__))\n            continue\n\n        options[key] = value\n\n    return options\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/fbx.html#client.ayon_maya.api.fbx.FBXExtractor.set_options_from_instance","title":"<code>set_options_from_instance(instance)</code>","text":"<p>Sets FBX export options from data in the instance.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>Instance data.</p> required Source code in <code>client/ayon_maya/api/fbx.py</code> <pre><code>def set_options_from_instance(self, instance):\n    \"\"\"Sets FBX export options from data in the instance.\n\n    Args:\n        instance (Instance): Instance data.\n\n    \"\"\"\n    # Parse export options\n    options = self.default_options\n    options = self.parse_overrides(instance, options)\n    self.log.debug(\"Export options: {0}\".format(options))\n\n    # Collect the start and end including handles\n    start = instance.data.get(\"frameStartHandle\") or \\\n        instance.context.data.get(\"frameStartHandle\")\n    end = instance.data.get(\"frameEndHandle\") or \\\n        instance.context.data.get(\"frameEndHandle\")\n\n    options['bakeComplexStart'] = start\n    options['bakeComplexEnd'] = end\n\n    # First apply the default export settings to be fully consistent\n    # each time for successive publishes\n    mel.eval(\"FBXResetExport\")\n\n    # Apply the FBX overrides through MEL since the commands\n    # only work correctly in MEL according to online\n    # available discussions on the topic\n    _iteritems = getattr(options, \"iteritems\", options.items)\n    for option, value in _iteritems():\n        key = option[0].upper() + option[1:]  # uppercase first letter\n\n        # Boolean must be passed as lower-case strings\n        # as to MEL standards\n        if isinstance(value, bool):\n            value = str(value).lower()\n\n        template = \"FBXExport{0} {1}\" if key == \"UpAxis\" else \\\n            \"FBXExport{0} -v {1}\"  # noqa\n        cmd = template.format(key, value)\n        self.log.debug(cmd)\n        mel.eval(cmd)\n\n    # Never show the UI or generate a log\n    mel.eval(\"FBXExportShowUI -v false\")\n    mel.eval(\"FBXExportGenerateLog -v false\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/gltf.html","title":"gltf","text":"<p>Tools to work with GLTF.</p>"},{"location":"autoapi/client/ayon_maya/api/gltf.html#client.ayon_maya.api.gltf.extract_gltf","title":"<code>extract_gltf(parent_dir, filename, **kwargs)</code>","text":"<p>Sets GLTF export options from data in the instance.</p> Source code in <code>client/ayon_maya/api/gltf.py</code> <pre><code>def extract_gltf(parent_dir,\n                 filename,\n                 **kwargs):\n\n    \"\"\"Sets GLTF export options from data in the instance.\n\n    \"\"\"\n\n    cmds.loadPlugin('maya2glTF', quiet=True)\n    # load the UI to run mel command\n    mel.eval(\"maya2glTF_UI()\")\n\n    parent_dir = parent_dir.replace('\\\\', '/')\n    options = {\n        \"dsa\": 1,\n        \"glb\": True\n    }\n    options.update(kwargs)\n\n    for key, value in options.copy().items():\n        if key not in _gltf_options:\n            log.warning(\"extract_gltf() does not support option '%s'. \"\n                        \"Flag will be ignored..\", key)\n            options.pop(key)\n            options.pop(value)\n            continue\n\n    job_args = list()\n    default_opt = \"maya2glTF -of \\\"{0}\\\" -sn \\\"{1}\\\"\".format(parent_dir, filename) # noqa\n    job_args.append(default_opt)\n\n    for key, value in options.items():\n        if isinstance(value, str):\n            job_args.append(\"-{0} \\\"{1}\\\"\".format(key, value))\n        elif isinstance(value, bool):\n            if value:\n                job_args.append(\"-{0}\".format(key))\n        else:\n            job_args.append(\"-{0} {1}\".format(key, value))\n\n    job_str = \" \".join(job_args)\n    log.info(\"{}\".format(job_str))\n    mel.eval(job_str)\n\n    # close the gltf export after finish the export\n    gltf_UI = \"maya2glTF_exporter_window\"\n    if cmds.window(gltf_UI, q=True, exists=True):\n        cmds.deleteUI(gltf_UI)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html","title":"lib","text":"<p>Standalone helper functions</p>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.RigSetsNotExistError","title":"<code>RigSetsNotExistError</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Raised when required rig sets for animation instance are missing.</p> <p>This is raised from <code>create_rig_animation_instance</code> when the required <code>out_SET</code> or <code>controls_SET</code> are missing.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>class RigSetsNotExistError(RuntimeError):\n    \"\"\"Raised when required rig sets for animation instance are missing.\n\n    This is raised from `create_rig_animation_instance` when the required\n    `out_SET` or `controls_SET` are missing.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.delete_after","title":"<code>delete_after</code>","text":"<p>               Bases: <code>object</code></p> <p>Context Manager that will delete collected nodes after exit.</p> <p>This allows to ensure the nodes added to the context are deleted afterwards. This is useful if you want to ensure nodes are deleted even if an error is raised.</p> <p>Examples:</p> <p>with delete_after() as delete_bin:     cube = maya.cmds.polyCube()     delete_bin.extend(cube)     # cube exists</p>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.delete_after--cube-deleted","title":"cube deleted","text":"Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>class delete_after(object):\n    \"\"\"Context Manager that will delete collected nodes after exit.\n\n    This allows to ensure the nodes added to the context are deleted\n    afterwards. This is useful if you want to ensure nodes are deleted\n    even if an error is raised.\n\n    Examples:\n        with delete_after() as delete_bin:\n            cube = maya.cmds.polyCube()\n            delete_bin.extend(cube)\n            # cube exists\n        # cube deleted\n\n    \"\"\"\n\n    def __init__(self, nodes=None):\n\n        self._nodes = list()\n\n        if nodes:\n            self.extend(nodes)\n\n    def append(self, node):\n        self._nodes.append(node)\n\n    def extend(self, nodes):\n        self._nodes.extend(nodes)\n\n    def __iter__(self):\n        return iter(self._nodes)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, traceback):\n        if self._nodes:\n            cmds.delete(self._nodes)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.apply_attributes","title":"<code>apply_attributes(attributes, nodes_by_id)</code>","text":"<p>Alter the attributes to match the state when publishing</p> <p>Apply attribute settings from the publish to the node in the scene based on the UUID which is stored in the cbId attribute.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>list</code> <p>list of dictionaries</p> required <code>nodes_by_id</code> <code>dict</code> <p>collection of nodes based on UUID                {uuid: [node, node]}</p> required Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def apply_attributes(attributes, nodes_by_id):\n    \"\"\"Alter the attributes to match the state when publishing\n\n    Apply attribute settings from the publish to the node in the scene based\n    on the UUID which is stored in the cbId attribute.\n\n    Args:\n        attributes (list): list of dictionaries\n        nodes_by_id (dict): collection of nodes based on UUID\n                           {uuid: [node, node]}\n\n    \"\"\"\n\n    for attr_data in attributes:\n        nodes = nodes_by_id[attr_data[\"uuid\"]]\n        attr_value = attr_data[\"attributes\"]\n        for node in nodes:\n            for attr, value in attr_value.items():\n                if value is None:\n                    log.warning(\n                        f\"Skipping setting {node}.{attr} with value 'None'\")\n                    continue\n\n                set_attribute(attr, value, node)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.apply_connections","title":"<code>apply_connections(connections, target_nodes_by_id, source_nodes_by_id)</code>","text":"<p>Connect texture reference object nodes to the target object nodes if there is one.</p> <p>Parameters:</p> Name Type Description Default <code>connections</code> <code>list[dict[str, Any]]</code> <p>list of texture reference</p> required <code>target_nodes_by_id</code> <code>dict[str, list[str]]</code> <p>The dict with target shape node ids</p> required <code>source_nodes_by_id</code> <code>dict[str, list[str]]</code> <p>The dict with texture reference node ids.</p> required Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def apply_connections(connections, target_nodes_by_id, source_nodes_by_id):\n    \"\"\"Connect texture reference object nodes to the target object\n    nodes if there is one.\n\n    Args:\n        connections (list[dict[str, Any]]): list of texture reference\n        objects connection data\n        target_nodes_by_id (dict[str, list[str]]): The dict with target shape node ids\n        source_nodes_by_id (dict[str, list[str]]): The dict with texture reference node ids.\n    \"\"\"\n    # Compare loaded connections to scene.\n    for connection in connections:\n        source_node = next(\n            iter(source_nodes_by_id.get(\n            connection[\"sourceID\"], [])\n            ), None\n        )\n\n        target_nodes = target_nodes_by_id.get(connection[\"destinationID\"], [])\n\n        if not source_node or not target_nodes:\n            self.log.debug(\n                \"Could not find nodes for reference input:\\n\" +\n                json.dumps(connection, indent=4, sort_keys=True)\n            )\n            continue\n\n        source_attr, target_attr = connection[\"connections\"]\n\n        if not cmds.attributeQuery(\n            source_attr, node=source_node, exists=True\n        ):\n            self.log.debug(\n                \"Could not find attribute {} on node {} for \"\n                \"reference input:\\n{}\".format(\n                    source_attr,\n                    source_node,\n                    json.dumps(\n                        connection, indent=4, sort_keys=True\n                    )\n                )\n            )\n            continue\n\n        for target_node in target_nodes:\n            if target_node == source_node:\n                self.log.debug(\n                    f\"Skipping connection to itself for {source_node} \"\n                    f\"connection {source_attr}-&gt;{target_attr}.\"\n                )\n                continue\n\n            if not cmds.attributeQuery(\n                target_attr, node=target_node, exists=True\n            ):\n                self.log.debug(\n                    \"Could not find attribute {} on node {} for \"\n                    \"reference input:\\n{}\".format(\n                        target_attr,\n                        target_node,\n                        json.dumps(\n                            connection, indent=4, sort_keys=True\n                        )\n                    )\n                )\n                continue\n\n            source_plug = f\"{source_node}.{source_attr}\"\n            target_plug = f\"{target_node}.{target_attr}\"\n\n            if cmds.isConnected(\n                source_plug, target_plug, ignoreUnitConversion=True\n            ):\n                self.log.debug(\n                    \"Connection already exists: {} -&gt; {}\".format(\n                        source_plug, target_plug\n                    )\n                )\n                continue\n\n            cmds.connectAttr(source_plug, target_plug, force=True)\n            self.log.debug(\n                \"Connected attributes: {} -&gt; {}\".format(\n                    source_plug, target_plug\n                )\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.apply_shaders","title":"<code>apply_shaders(relationships, shadernodes, nodes)</code>","text":"<p>Link shadingEngine to the right nodes based on relationship data</p> <p>Relationship data is constructed of a collection of <code>sets</code> and <code>attributes</code> <code>sets</code> corresponds with the shaderEngines found in the lookdev. Each set has the keys <code>name</code>, <code>members</code> and <code>uuid</code>, the <code>members</code> hold a collection of node information <code>name</code> and <code>uuid</code>.</p> <p>Parameters:</p> Name Type Description Default <code>relationships</code> <code>dict</code> <p>relationship data</p> required <code>shadernodes</code> <code>list</code> <p>list of nodes of the shading objectSets (includes</p> required <code>nodes</code> <code>list</code> <p>list of nodes to apply shader to</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def apply_shaders(relationships, shadernodes, nodes):\n    \"\"\"Link shadingEngine to the right nodes based on relationship data\n\n    Relationship data is constructed of a collection of `sets` and `attributes`\n    `sets` corresponds with the shaderEngines found in the lookdev.\n    Each set has the keys `name`, `members` and `uuid`, the `members`\n    hold a collection of node information `name` and `uuid`.\n\n    Args:\n        relationships (dict): relationship data\n        shadernodes (list): list of nodes of the shading objectSets (includes\n        VRayObjectProperties and shadingEngines)\n        nodes (list): list of nodes to apply shader to\n\n    Returns:\n        None\n    \"\"\"\n\n    attributes = relationships.get(\"attributes\", [])\n    shader_data = relationships.get(\"relationships\", {})\n\n    shading_engines = cmds.ls(shadernodes, type=\"objectSet\", long=True)\n    assert shading_engines, \"Error in retrieving objectSets from reference\"\n\n    shader_mesh_nodes = cmds.ls(shadernodes, type=\"mesh\", long=True)\n    # region compute lookup\n    nodes_by_id = defaultdict(list)\n    for node in nodes:\n        nodes_by_id[get_id(node)].append(node)\n\n    shading_engines_by_id = defaultdict(list)\n    for shad in shading_engines:\n        shading_engines_by_id[get_id(shad)].append(shad)\n\n    texture_nodes_by_id = defaultdict(list)\n    for mesh_node in shader_mesh_nodes:\n        texture_nodes_by_id[get_id(mesh_node)].append(mesh_node)\n\n    # endregion\n\n    # region assign shading engines and other sets\n    for data in shader_data.values():\n        # collect all unique IDs of the set members\n        shader_uuid = data[\"uuid\"]\n        member_uuids = [member[\"uuid\"] for member in data[\"members\"]]\n\n        filtered_nodes = list()\n        for m_uuid in member_uuids:\n            filtered_nodes.extend(nodes_by_id[m_uuid])\n\n        id_shading_engines = shading_engines_by_id[shader_uuid]\n        if not id_shading_engines:\n            log.error(\"No shader found with cbId \"\n                      \"'{}'\".format(shader_uuid))\n            continue\n        elif len(id_shading_engines) &gt; 1:\n            log.error(\"Skipping shader assignment. \"\n                      \"More than one shader found with cbId \"\n                      \"'{}'. (found: {})\".format(shader_uuid,\n                                                 id_shading_engines))\n            continue\n\n        if not filtered_nodes:\n            log.warning(\"No nodes found for shading engine \"\n                        \"'{0}'\".format(id_shading_engines[0]))\n            continue\n        try:\n            cmds.sets(filtered_nodes, forceElement=id_shading_engines[0])\n        except RuntimeError as rte:\n            log.error(\"Error during shader assignment: {}\".format(rte))\n\n    # check if there is texture references input and connect the texture\n    # reference back to the nodes\n    texture_references_input = relationships.get(\"connections\", [])\n    apply_connections(\n        texture_references_input, nodes_by_id, texture_nodes_by_id\n    )\n\n    # endregion\n\n    apply_attributes(attributes, nodes_by_id)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.assign_look","title":"<code>assign_look(nodes, product_name='lookMain')</code>","text":"<p>Assigns a look to a node.</p> <p>Optimizes the nodes by grouping by folder id and finding related product by name.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list</code> <p>all nodes to assign the look to</p> required <code>product_name</code> <code>str</code> <p>name of the product to find</p> <code>'lookMain'</code> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def assign_look(nodes, product_name=\"lookMain\"):\n    \"\"\"Assigns a look to a node.\n\n    Optimizes the nodes by grouping by folder id and finding\n    related product by name.\n\n    Args:\n        nodes (list): all nodes to assign the look to\n        product_name (str): name of the product to find\n    \"\"\"\n\n    # Group all nodes per folder id\n    grouped = defaultdict(list)\n    for node in nodes:\n        hash_id = get_id(node)\n        if not hash_id:\n            continue\n\n        parts = hash_id.split(\":\", 1)\n        grouped[parts[0]].append(node)\n\n    project_name = get_current_project_name()\n    product_entities = ayon_api.get_products(\n        project_name, product_names=[product_name], folder_ids=grouped.keys()\n    )\n    product_entities_by_folder_id = {\n        product_entity[\"folderId\"]: product_entity\n        for product_entity in product_entities\n    }\n    product_ids = {\n        product_entity[\"id\"]\n        for product_entity in product_entities_by_folder_id.values()\n    }\n    last_version_entities_by_product_id = ayon_api.get_last_versions(\n        project_name,\n        product_ids\n    )\n\n    for folder_id, asset_nodes in grouped.items():\n        product_entity = product_entities_by_folder_id.get(folder_id)\n        if not product_entity:\n            log.warning((\n                \"No product '{}' found for {}\"\n            ).format(product_name, folder_id))\n            continue\n\n        product_id = product_entity[\"id\"]\n        last_version = last_version_entities_by_product_id.get(product_id)\n        if not last_version:\n            log.warning((\n                \"Not found last version for product '{}' on folder with id {}\"\n            ).format(product_name, folder_id))\n            continue\n\n        families = last_version.get(\"attrib\", {}).get(\"families\") or []\n        if \"look\" not in families:\n            log.warning((\n                \"Last version for product '{}' on folder with id {}\"\n                \" does not have look product type\"\n            ).format(product_name, folder_id))\n            continue\n\n        log.debug(\"Assigning look '{}' &lt;v{:03d}&gt;\".format(\n            product_name, last_version[\"version\"]))\n\n        assign_look_by_version(asset_nodes, last_version[\"id\"])\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.assign_look_by_version","title":"<code>assign_look_by_version(nodes, version_id)</code>","text":"<p>Assign nodes a specific published look version by id.</p> <p>This assumes the nodes correspond with the asset.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list</code> <p>nodes to assign look to</p> required <code>version_id</code> <code>ObjectId</code> <p>database id of the version</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def assign_look_by_version(nodes, version_id):\n    \"\"\"Assign nodes a specific published look version by id.\n\n    This assumes the nodes correspond with the asset.\n\n    Args:\n        nodes(list): nodes to assign look to\n        version_id (bson.ObjectId): database id of the version\n\n    Returns:\n        None\n    \"\"\"\n\n    project_name = get_current_project_name()\n\n    # Get representations of shader file and relationships\n    representations = list(ayon_api.get_representations(\n        project_name=project_name,\n        representation_names={\"ma\", \"json\"},\n        version_ids=[version_id]\n    ))\n    look_representation = next(\n        repre for repre in representations if repre[\"name\"] == \"ma\")\n    json_representation = next(\n        repre for repre in representations if repre[\"name\"] == \"json\")\n\n    # See if representation is already loaded, if so reuse it.\n    host = registered_host()\n    representation_id = look_representation[\"id\"]\n    for container in host.ls():\n        if (container['loader'] == \"LookLoader\" and\n                container['representation'] == representation_id):\n            log.info(\"Reusing loaded look ..\")\n            container_node = container['objectName']\n            break\n    else:\n        log.info(\"Using look for the first time ..\")\n\n        # Load file\n        _loaders = discover_loader_plugins()\n        loaders = loaders_from_representation(_loaders, representation_id)\n        Loader = next((i for i in loaders if i.__name__ == \"LookLoader\"), None)\n        if Loader is None:\n            raise RuntimeError(\"Could not find LookLoader, this is a bug\")\n\n        # Reference the look file\n        with maintained_selection():\n            container_node = load_container(Loader, look_representation)\n\n    # Get container members\n    shader_nodes = get_container_members(container_node)\n\n    # Load relationships\n    shader_relation = get_representation_path_by_project(\n        project_name, json_representation\n    )\n    with open(shader_relation, \"r\") as f:\n        relationships = json.load(f)\n\n    # Assign relationships\n    apply_shaders(relationships, shader_nodes, nodes)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.attribute_values","title":"<code>attribute_values(attr_values)</code>","text":"<p>Remaps node attributes to values during context.</p> <p>Parameters:</p> Name Type Description Default <code>attr_values</code> <code>dict</code> <p>Dictionary with (attr, value)</p> required Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef attribute_values(attr_values):\n    \"\"\"Remaps node attributes to values during context.\n\n    Arguments:\n        attr_values (dict): Dictionary with (attr, value)\n\n    \"\"\"\n\n    original = [(attr, cmds.getAttr(attr)) for attr in attr_values]\n    try:\n        for attr, value in attr_values.items():\n            if isinstance(value, str):\n                cmds.setAttr(attr, value, type=\"string\")\n            else:\n                cmds.setAttr(attr, value)\n        yield\n    finally:\n        for attr, value in original:\n            if isinstance(value, str):\n                cmds.setAttr(attr, value, type=\"string\")\n            elif value is None and cmds.getAttr(attr, type=True) == \"string\":\n                # In some cases the maya.cmds.getAttr command returns None\n                # for string attributes but this value cannot assigned.\n                # Note: After setting it once to \"\" it will then return \"\"\n                #       instead of None. So this would only happen once.\n                cmds.setAttr(attr, \"\", type=\"string\")\n            else:\n                cmds.setAttr(attr, value)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.bake","title":"<code>bake(nodes, frame_range=None, step=1.0, simulation=True, preserve_outside_keys=False, disable_implicit_control=True, shape=True)</code>","text":"<p>Bake the given nodes over the time range.</p> <p>This will bake all attributes of the node, including custom attributes.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list</code> <p>Names of transform nodes, eg. camera, light.</p> required <code>frame_range</code> <code>list</code> <p>frame range with start and end frame. or if None then takes timeSliderRange</p> <code>None</code> <code>simulation</code> <code>bool</code> <p>Whether to perform a full simulation of the attributes over time.</p> <code>True</code> <code>preserve_outside_keys</code> <code>bool</code> <p>Keep keys that are outside of the baked range.</p> <code>False</code> <code>disable_implicit_control</code> <code>bool</code> <p>When True will disable any constraints to the object.</p> <code>True</code> <code>shape</code> <code>bool</code> <p>When True also bake attributes on the children shapes.</p> <code>True</code> <code>step</code> <code>float</code> <p>The step size to sample by.</p> <code>1.0</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def bake(nodes,\n         frame_range=None,\n         step=1.0,\n         simulation=True,\n         preserve_outside_keys=False,\n         disable_implicit_control=True,\n         shape=True):\n    \"\"\"Bake the given nodes over the time range.\n\n    This will bake all attributes of the node, including custom attributes.\n\n    Args:\n        nodes (list): Names of transform nodes, eg. camera, light.\n        frame_range (list): frame range with start and end frame.\n            or if None then takes timeSliderRange\n        simulation (bool): Whether to perform a full simulation of the\n            attributes over time.\n        preserve_outside_keys (bool): Keep keys that are outside of the baked\n            range.\n        disable_implicit_control (bool): When True will disable any\n            constraints to the object.\n        shape (bool): When True also bake attributes on the children shapes.\n        step (float): The step size to sample by.\n\n    Returns:\n        None\n\n    \"\"\"\n\n    # Parse inputs\n    if not nodes:\n        return\n\n    assert isinstance(nodes, (list, tuple)), \"Nodes must be a list or tuple\"\n\n    # If frame range is None fall back to time slider playback time range\n    if frame_range is None:\n        frame_range = [cmds.playbackOptions(query=True, minTime=True),\n                       cmds.playbackOptions(query=True, maxTime=True)]\n\n    # If frame range is single frame bake one frame more,\n    # otherwise maya.cmds.bakeResults gets confused\n    if frame_range[1] == frame_range[0]:\n        frame_range[1] += 1\n\n    # Bake it\n    with keytangent_default(in_tangent_type='auto',\n                            out_tangent_type='auto'):\n        cmds.bakeResults(nodes,\n                         simulation=simulation,\n                         preserveOutsideKeys=preserve_outside_keys,\n                         disableImplicitControl=disable_implicit_control,\n                         shape=shape,\n                         sampleBy=step,\n                         time=(frame_range[0], frame_range[1]))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.bake_to_world_space","title":"<code>bake_to_world_space(nodes, frame_range=None, simulation=True, preserve_outside_keys=False, disable_implicit_control=True, shape=True, step=1.0)</code>","text":"<p>Bake the nodes to world space transformation (incl. other attributes)</p> <p>Bakes the transforms to world space (while maintaining all its animated attributes and settings) by duplicating the node. Then parents it to world and constrains to the original.</p> <p>Other attributes are also baked by connecting all attributes directly. Baking is then done using Maya's bakeResults command.</p> <p>See <code>bake</code> for the argument documentation.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>The newly created and baked node names.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def bake_to_world_space(nodes,\n                        frame_range=None,\n                        simulation=True,\n                        preserve_outside_keys=False,\n                        disable_implicit_control=True,\n                        shape=True,\n                        step=1.0):\n    \"\"\"Bake the nodes to world space transformation (incl. other attributes)\n\n    Bakes the transforms to world space (while maintaining all its animated\n    attributes and settings) by duplicating the node. Then parents it to world\n    and constrains to the original.\n\n    Other attributes are also baked by connecting all attributes directly.\n    Baking is then done using Maya's bakeResults command.\n\n    See `bake` for the argument documentation.\n\n    Returns:\n         list: The newly created and baked node names.\n\n    \"\"\"\n    @contextlib.contextmanager\n    def _unlock_attr(attr):\n        \"\"\"Unlock attribute during context if it is locked\"\"\"\n        if not cmds.getAttr(attr, lock=True):\n            # If not locked, do nothing\n            yield\n            return\n        try:\n            cmds.setAttr(attr, lock=False)\n            yield\n        finally:\n            cmds.setAttr(attr, lock=True)\n\n    def _get_attrs(node):\n        \"\"\"Workaround for buggy shape attribute listing with listAttr\n\n        This will only return keyable settable attributes that have an\n        incoming connections (those that have a reason to be baked).\n\n        Technically this *may* fail to return attributes driven by complex\n        expressions for which maya makes no connections, e.g. doing actual\n        `setAttr` calls in expressions.\n\n        Arguments:\n            node (str): The node to list attributes for.\n\n        Returns:\n            list: Keyable attributes with incoming connections.\n                The attribute may be locked.\n\n        \"\"\"\n        attrs = cmds.listAttr(node,\n                              write=True,\n                              scalar=True,\n                              settable=True,\n                              connectable=True,\n                              keyable=True,\n                              shortNames=True) or []\n        valid_attrs = []\n        for attr in attrs:\n            node_attr = '{0}.{1}'.format(node, attr)\n\n            # Sometimes Maya returns 'non-existent' attributes for shapes\n            # so we filter those out\n            if not cmds.attributeQuery(attr, node=node, exists=True):\n                continue\n\n            # We only need those that have a connection, just to be safe\n            # that it's actually keyable/connectable anyway.\n            if cmds.connectionInfo(node_attr,\n                                   isDestination=True):\n                valid_attrs.append(attr)\n\n        return valid_attrs\n\n    transform_attrs = {\"t\", \"r\", \"s\",\n                       \"tx\", \"ty\", \"tz\",\n                       \"rx\", \"ry\", \"rz\",\n                       \"sx\", \"sy\", \"sz\"}\n\n    world_space_nodes = []\n    with contextlib.ExitStack() as stack:\n        delete_bin = stack.enter_context(delete_after())\n        # Create the duplicate nodes that are in world-space connected to\n        # the originals\n        for node in nodes:\n\n            # Duplicate the node\n            short_name = node.rsplit(\"|\", 1)[-1]\n            new_name = \"{0}_baked\".format(short_name)\n            new_node = cmds.duplicate(node,\n                                      name=new_name,\n                                      renameChildren=True)[0]  # noqa\n\n            # Parent new node to world\n            if cmds.listRelatives(new_node, parent=True):\n                new_node = cmds.parent(new_node, world=True)[0]\n\n            # Temporarily unlock and passthrough connect all attributes\n            # so we can bake them over time\n            # Skip transform attributes because we will constrain them later\n            attrs = set(_get_attrs(node)) - transform_attrs\n            for attr in attrs:\n                orig_node_attr = \"{}.{}\".format(node, attr)\n                new_node_attr = \"{}.{}\".format(new_node, attr)\n\n                # unlock during context to avoid connection errors\n                stack.enter_context(_unlock_attr(new_node_attr))\n                cmds.connectAttr(orig_node_attr,\n                                 new_node_attr,\n                                 force=True)\n\n            # If shapes are also baked then also temporarily unlock and\n            # passthrough connect all shape attributes for baking\n            if shape:\n                children_shapes = cmds.listRelatives(new_node,\n                                                     children=True,\n                                                     fullPath=True,\n                                                     shapes=True)\n                if children_shapes:\n                    orig_children_shapes = cmds.listRelatives(node,\n                                                              children=True,\n                                                              fullPath=True,\n                                                              shapes=True)\n                    for orig_shape, new_shape in zip(orig_children_shapes,\n                                                     children_shapes):\n                        attrs = _get_attrs(orig_shape)\n                        for attr in attrs:\n                            orig_node_attr = \"{}.{}\".format(orig_shape, attr)\n                            new_node_attr = \"{}.{}\".format(new_shape, attr)\n\n                            # unlock during context to avoid connection errors\n                            stack.enter_context(_unlock_attr(new_node_attr))\n                            cmds.connectAttr(orig_node_attr,\n                                             new_node_attr,\n                                             force=True)\n\n            # Constraint transforms\n            for attr in transform_attrs:\n                transform_attr = \"{}.{}\".format(new_node, attr)\n                stack.enter_context(_unlock_attr(transform_attr))\n            delete_bin.extend(cmds.parentConstraint(node, new_node, mo=False))\n            delete_bin.extend(cmds.scaleConstraint(node, new_node, mo=False))\n\n            world_space_nodes.append(new_node)\n\n        bake(world_space_nodes,\n             frame_range=frame_range,\n             step=step,\n             simulation=simulation,\n             preserve_outside_keys=preserve_outside_keys,\n             disable_implicit_control=disable_implicit_control,\n             shape=shape)\n\n    return world_space_nodes\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.collect_animation_defs","title":"<code>collect_animation_defs(fps=False, create_context=None)</code>","text":"<p>Get the basic animation attribute definitions for the publisher.</p> <p>Parameters:</p> Name Type Description Default <code>fps</code> <code>bool</code> <p>Whether to include <code>fps</code> attribute definition.</p> <code>False</code> <code>create_context</code> <code>CreateContext | None</code> <p>When provided the context of publisher will be used to define the defaults for the attributes. Depending on project settings this may then use the entity's frame range and FPS instead of the current scene values.</p> <code>None</code> <p>Returns:</p> Type Description <p>List[NumberDef]: List of number attribute definitions.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def collect_animation_defs(fps=False, create_context=None):\n    \"\"\"Get the basic animation attribute definitions for the publisher.\n\n    Arguments:\n        fps (bool): Whether to include `fps` attribute definition.\n        create_context (CreateContext | None): When provided the context of\n            publisher will be used to define the defaults for the attributes.\n            Depending on project settings this may then use the entity's frame\n            range and FPS instead of the current scene values.\n\n    Returns:\n        List[NumberDef]: List of number attribute definitions.\n\n    \"\"\"\n\n    use_entity_frame_range = False\n    if create_context is not None:\n        project_settings = create_context.get_current_project_settings()\n        use_entity_frame_range: bool = project_settings[\"maya\"][\"create\"].get(\n            \"use_entity_attributes_as_defaults\", False)\n\n    if create_context is not None and use_entity_frame_range:\n        task_entity = create_context.get_current_task_entity()\n        frame_start = task_entity[\"attrib\"][\"frameStart\"]\n        frame_end = task_entity[\"attrib\"][\"frameEnd\"]\n        handle_start = task_entity[\"attrib\"][\"handleStart\"]\n        handle_end = task_entity[\"attrib\"][\"handleEnd\"]\n        default_fps = task_entity[\"attrib\"][\"fps\"]\n    else:\n        # get scene values as defaults\n        frame_start = cmds.playbackOptions(query=True, minTime=True)\n        frame_end = cmds.playbackOptions(query=True, maxTime=True)\n        frame_start_handle = cmds.playbackOptions(\n            query=True, animationStartTime=True)\n        frame_end_handle = cmds.playbackOptions(\n            query=True, animationEndTime=True)\n\n        handle_start = frame_start - frame_start_handle\n        handle_end = frame_end_handle - frame_end\n        default_fps = mel.eval('currentTimeUnitToFPS()')\n\n    # build attributes\n    defs = [\n        NumberDef(\"frameStart\",\n                  label=\"Frame Start\",\n                  default=frame_start,\n                  decimals=0),\n        NumberDef(\"frameEnd\",\n                  label=\"Frame End\",\n                  default=frame_end,\n                  decimals=0),\n        NumberDef(\"handleStart\",\n                  label=\"Handle Start\",\n                  default=handle_start,\n                  decimals=0),\n        NumberDef(\"handleEnd\",\n                  label=\"Handle End\",\n                  default=handle_end,\n                  decimals=0),\n        NumberDef(\"step\",\n                  label=\"Step size\",\n                  tooltip=\"A smaller step size means more samples and larger \"\n                          \"output files.\\n\"\n                          \"A 1.0 step size is a single sample every frame.\\n\"\n                          \"A 0.5 step size is two samples per frame.\\n\"\n                          \"A 0.2 step size is five samples per frame.\",\n                  default=1.0,\n                  decimals=3),\n    ]\n\n    if fps:\n        fps_def = NumberDef(\n            \"fps\", label=\"FPS\", default=default_fps, decimals=5\n        )\n        defs.append(fps_def)\n\n    return defs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.convert_to_maya_fps","title":"<code>convert_to_maya_fps(fps)</code>","text":"<p>Convert any fps to supported Maya framerates.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def convert_to_maya_fps(fps):\n    \"\"\"Convert any fps to supported Maya framerates.\"\"\"\n    float_framerates = [\n        23.976023976023978,\n        # WTF is 29.97 df vs fps?\n        29.97002997002997,\n        47.952047952047955,\n        59.94005994005994\n    ]\n    # 44100 fps evaluates as 41000.0. Why? Omitting for now.\n    int_framerates = [\n        2,\n        3,\n        4,\n        5,\n        6,\n        8,\n        10,\n        12,\n        15,\n        16,\n        20,\n        24,\n        25,\n        30,\n        40,\n        48,\n        50,\n        60,\n        75,\n        80,\n        90,\n        100,\n        120,\n        125,\n        150,\n        200,\n        240,\n        250,\n        300,\n        375,\n        400,\n        500,\n        600,\n        750,\n        1200,\n        1500,\n        2000,\n        3000,\n        6000,\n        48000\n    ]\n\n    # If input fps is a whole number we'll return.\n    if float(fps).is_integer():\n        # Validate fps is part of Maya's fps selection.\n        if int(fps) not in int_framerates:\n            raise ValueError(\n                \"Framerate \\\"{}\\\" is not supported in Maya\".format(fps)\n            )\n        return int(fps)\n    else:\n        # Differences to supported float frame rates.\n        differences = []\n        for i in float_framerates:\n            differences.append(abs(i - fps))\n\n        # Validate difference does not stray too far from supported framerates.\n        min_difference = min(differences)\n        min_index = differences.index(min_difference)\n        supported_framerate = float_framerates[min_index]\n        if min_difference &gt; 0.1:\n            raise ValueError(\n                \"Framerate \\\"{}\\\" strays too far from any supported framerate\"\n                \" in Maya. Closest supported framerate is \\\"{}\\\"\".format(\n                    fps, supported_framerate\n                )\n            )\n\n        return supported_framerate\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.create_rig_animation_instance","title":"<code>create_rig_animation_instance(nodes, context, namespace, options=None, log=None)</code>","text":"<p>Create an animation publish instance for loaded rigs.</p> <p>See the RecreateRigAnimationInstance inventory action on how to use this for loaded rig containers.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list</code> <p>Member nodes of the rig instance.</p> required <code>context</code> <code>dict</code> <p>Representation context of the rig container</p> required <code>namespace</code> <code>str</code> <p>Namespace of the rig container</p> required <code>options</code> <code>dict</code> <p>Additional loader data</p> <code>None</code> <code>log</code> <code>Logger</code> <p>Logger to log to if provided</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def create_rig_animation_instance(\n    nodes, context, namespace, options=None, log=None\n):\n    \"\"\"Create an animation publish instance for loaded rigs.\n\n    See the RecreateRigAnimationInstance inventory action on how to use this\n    for loaded rig containers.\n\n    Arguments:\n        nodes (list): Member nodes of the rig instance.\n        context (dict): Representation context of the rig container\n        namespace (str): Namespace of the rig container\n        options (dict, optional): Additional loader data\n        log (logging.Logger, optional): Logger to log to if provided\n\n    Returns:\n        None\n\n    \"\"\"\n    if options is None:\n        options = {}\n    name = context[\"representation\"][\"name\"]\n    output = next((node for node in nodes if\n                   node.endswith(\"out_SET\")), None)\n    controls = next((node for node in nodes if\n                     node.endswith(\"controls_SET\")), None)\n    if name != \"fbx\":\n        if not output:\n            raise RigSetsNotExistError(\n                \"No out_SET in rig. The loaded rig publish is lacking the \"\n                \"out_SET required for animation instances.\")\n        if not controls:\n            raise RigSetsNotExistError(\n                \"No controls_SET in rig. The loaded rig publish is lacking \"\n                \"the controls_SET required for animation instances.\")\n\n    anim_skeleton = next((node for node in nodes if\n                          node.endswith(\"skeletonAnim_SET\")), None)\n    skeleton_mesh = next((node for node in nodes if\n                          node.endswith(\"skeletonMesh_SET\")), None)\n\n    # Find the roots amongst the loaded nodes\n    roots = (\n        cmds.ls(nodes, assemblies=True, long=True) or\n        get_highest_in_hierarchy(nodes)\n    )\n    assert roots, \"No root nodes in rig, this is a bug.\"\n\n    folder_entity = context[\"folder\"]\n    product_entity = context[\"product\"]\n    product_type = product_entity[\"productType\"]\n    product_name = product_entity[\"name\"]\n\n    custom_product_name = options.get(\"animationProductName\")\n    if custom_product_name:\n        formatting_data = {\n            \"folder\": {\n                \"name\": folder_entity[\"name\"]\n            },\n            \"product\": {\n                \"type\": product_type,\n                \"name\": product_name,\n            },\n            \"asset\": folder_entity[\"name\"],\n            \"subset\": product_name,\n            \"family\": product_type\n        }\n        namespace = get_custom_namespace(\n            custom_product_name.format(**formatting_data)\n        )\n\n    if log:\n        log.info(\"Creating product: {}\".format(namespace))\n\n    # Fill creator identifier\n    creator_identifier = \"io.openpype.creators.maya.animation\"\n\n    host = registered_host()\n    create_context = CreateContext(host)\n    # Create the animation instance\n    rig_sets = [output, controls, anim_skeleton, skeleton_mesh]\n    # Remove sets that this particular rig does not have\n    rig_sets = [s for s in rig_sets if s is not None]\n    with maintained_selection():\n        cmds.select(rig_sets + roots, noExpand=True)\n        create_context.create(\n            creator_identifier=creator_identifier,\n            variant=namespace,\n            pre_create_data={\n                \"use_selection\": True,\n                \"lock_instance\": options.get(\"lock_instance\", False)\n            }\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.displaySmoothness","title":"<code>displaySmoothness(nodes, divisionsU=0, divisionsV=0, pointsWire=4, pointsShaded=1, polygonObject=1)</code>","text":"<p>Set the displaySmoothness during the context</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef displaySmoothness(nodes,\n                      divisionsU=0,\n                      divisionsV=0,\n                      pointsWire=4,\n                      pointsShaded=1,\n                      polygonObject=1):\n    \"\"\"Set the displaySmoothness during the context\"\"\"\n\n    # Ensure only non-intermediate shapes\n    nodes = cmds.ls(nodes,\n                    dag=1,\n                    shapes=1,\n                    long=1,\n                    noIntermediate=True)\n\n    def parse(node):\n        \"\"\"Parse the current state of a node\"\"\"\n        state = {}\n        for key in [\"divisionsU\",\n                    \"divisionsV\",\n                    \"pointsWire\",\n                    \"pointsShaded\",\n                    \"polygonObject\"]:\n            value = cmds.displaySmoothness(node, query=1, **{key: True})\n            if value is not None:\n                state[key] = value[0]\n        return state\n\n    originals = dict((node, parse(node)) for node in nodes)\n\n    try:\n        # Apply current state\n        cmds.displaySmoothness(nodes,\n                               divisionsU=divisionsU,\n                               divisionsV=divisionsV,\n                               pointsWire=pointsWire,\n                               pointsShaded=pointsShaded,\n                               polygonObject=polygonObject)\n        yield\n    finally:\n        # Revert state\n        _iteritems = getattr(originals, \"iteritems\", originals.items)\n        for node, state in _iteritems():\n            if state:\n                cmds.displaySmoothness(node, **state)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.empty_sets","title":"<code>empty_sets(sets, force=False)</code>","text":"<p>Remove all members of the sets during the context</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef empty_sets(sets, force=False):\n    \"\"\"Remove all members of the sets during the context\"\"\"\n\n    assert isinstance(sets, (list, tuple))\n\n    original = dict()\n    original_connections = []\n\n    # Store original state\n    for obj_set in sets:\n        members = cmds.sets(obj_set, query=True)\n        original[obj_set] = members\n\n    try:\n        for obj_set in sets:\n            cmds.sets(clear=obj_set)\n            if force:\n                # Break all connections if force is enabled, this way we\n                # prevent Maya from exporting any reference nodes which are\n                # connected with placeHolder[x] attributes\n                plug = \"%s.dagSetMembers\" % obj_set\n                connections = cmds.listConnections(plug,\n                                                   source=True,\n                                                   destination=False,\n                                                   plugs=True,\n                                                   connections=True) or []\n                original_connections.extend(connections)\n                for dest, src in pairwise(connections):\n                    cmds.disconnectAttr(src, dest)\n        yield\n    finally:\n\n        for dest, src in pairwise(original_connections):\n            cmds.connectAttr(src, dest)\n\n        # Restore original members\n        _iteritems = getattr(original, \"iteritems\", original.items)\n        for origin_set, members in _iteritems():\n            cmds.sets(members, forceElement=origin_set)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.evaluation","title":"<code>evaluation(mode='off')</code>","text":"<p>Set the evaluation manager during context.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>The mode to apply during context. \"off\": The standard DG evaluation (stable) \"serial\": A serial DG evaluation \"parallel\": The Maya 2016+ parallel evaluation</p> <code>'off'</code> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef evaluation(mode=\"off\"):\n    \"\"\"Set the evaluation manager during context.\n\n    Arguments:\n        mode (str): The mode to apply during context.\n            \"off\": The standard DG evaluation (stable)\n            \"serial\": A serial DG evaluation\n            \"parallel\": The Maya 2016+ parallel evaluation\n\n    \"\"\"\n\n    original = cmds.evaluationManager(query=True, mode=1)[0]\n    try:\n        cmds.evaluationManager(mode=mode)\n        yield\n    finally:\n        cmds.evaluationManager(mode=original)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.fix_incompatible_containers","title":"<code>fix_incompatible_containers()</code>","text":"<p>Backwards compatibility: old containers to use new ReferenceLoader</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def fix_incompatible_containers():\n    \"\"\"Backwards compatibility: old containers to use new ReferenceLoader\"\"\"\n    old_loaders = {\n        \"MayaAsciiLoader\",\n        \"AbcLoader\",\n        \"ModelLoader\",\n        \"CameraLoader\",\n        \"RigLoader\",\n        \"FBXLoader\"\n    }\n    host = registered_host()\n    for container in host.ls():\n        loader = container['loader']\n        if loader in old_loaders:\n            log.info(\n                \"Converting legacy container loader {} to \"\n                \"ReferenceLoader: {}\".format(loader, container[\"objectName\"])\n            )\n            cmds.setAttr(container[\"objectName\"] + \".loader\",\n                         \"ReferenceLoader\", type=\"string\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.force_shader_assignments_to_faces","title":"<code>force_shader_assignments_to_faces(shapes)</code>","text":"<p>Replaces any non-face shader assignments with shader assignments to the faces during the context.</p> <p>Parameters:</p> Name Type Description Default <code>shapes</code> <code>List[str]</code> <p>The shapes to add into face sets for any component assignments of shading engine</p> required Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef force_shader_assignments_to_faces(shapes):\n    \"\"\"Replaces any non-face shader assignments with shader assignments\n    to the faces during the context.\n\n    Args:\n        shapes (List[str]): The shapes to add into face sets for any component\n            assignments of shading engine\n    \"\"\"\n    shapes = cmds.ls(shapes, shapes=True, type=\"mesh\", long=True)\n    if not shapes:\n        # Do nothing\n        yield\n        return\n\n    all_render_sets = set()\n    for shape in shapes:\n        render_sets = cmds.listSets(object=shape, t=1, extendToShape=False)\n        if render_sets:\n            all_render_sets.update(render_sets)\n\n    shapes_lookup = set(shapes)\n\n    # Maya has the tendency to return component assignment using the transform\n    # name instead of the shape name, like `pCube1.f[1]` instead of\n    # `pCube1Shape.f[1]` so we need to take those into consideration as members\n    def get_parent(_shape: str) -&gt; str:\n        return _shape.rsplit(\"|\", 1)[0]\n\n    components_lookup = {f\"{shape}.\" for shape in shapes}\n    components_lookup.update(f\"{get_parent(shape)}.\" for shape in shapes)\n    components_lookup = tuple(components_lookup)  # support str.startswith\n\n    original_assignments = {}\n    override_assignments = defaultdict(list)\n    for shading_engine in cmds.ls(list(all_render_sets), type=\"shadingEngine\"):\n        members = cmds.sets(shading_engine, query=True)\n        if not members:\n            continue\n\n        members = cmds.ls(members, long=True)\n\n        # Include ALL originals, even those not among our shapes\n        original_assignments[shading_engine] = members\n\n        has_conversions = False\n        for member in members:\n            # Only consider shapes from our inputs\n            if (\n                    member not in shapes_lookup\n                    and not member.startswith(components_lookup)\n            ):\n                continue\n\n            if \".\" not in member:\n                # Convert to face assignments\n                member = f\"{member}.f[*]\"\n                if not cmds.objExists(member):\n                    # It is possible for a mesh to have no faces at all\n                    # for which we cannot convert to face assignments anyway.\n                    # It is a `mesh` node type - it just would error on\n                    # 'No object matches name' when trying to assign to the\n                    # faces. So we skip the conversion\n                    log.debug(\n                        \"Skipping face assignment conversion because \"\n                        f\"no mesh faces were found: {member}\")\n                    continue\n\n                has_conversions = True\n            override_assignments[shading_engine].append(member)\n\n        if not has_conversions:\n            # We can skip this shading engine completely because\n            # we have nothing to override\n            original_assignments.pop(shading_engine, None)\n            override_assignments.pop(shading_engine, None)\n\n    try:\n        # Apply overrides\n        for shading_engine, override_members in override_assignments.items():\n            # We force remove the members because this allows maya to take\n            # out the mesh (also without the components)\n            cmds.sets(clear=shading_engine)\n            cmds.sets(override_members, forceElement=shading_engine)\n\n        yield\n\n    finally:\n        # Revert to original assignments\n        for shading_engine, original_members in original_assignments.items():\n            cmds.sets(clear=shading_engine)\n            cmds.sets(original_members, forceElement=shading_engine)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.generate_capture_preset","title":"<code>generate_capture_preset(instance, camera, path, start=None, end=None, capture_preset=None)</code>","text":"<p>Function for getting all the data of preset options for playblast capturing</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>instance</p> required <code>camera</code> <code>str</code> <p>review camera</p> required <code>path</code> <code>str</code> <p>filepath</p> required <code>start</code> <code>int</code> <p>frameStart</p> <code>None</code> <code>end</code> <code>int</code> <p>frameEnd</p> <code>None</code> <code>capture_preset</code> <code>dict</code> <p>capture preset</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Resulting preset</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def generate_capture_preset(instance, camera, path,\n                            start=None, end=None, capture_preset=None):\n    \"\"\"Function for getting all the data of preset options for\n    playblast capturing\n\n    Args:\n        instance (pyblish.api.Instance): instance\n        camera (str): review camera\n        path (str): filepath\n        start (int): frameStart\n        end (int): frameEnd\n        capture_preset (dict): capture preset\n\n    Returns:\n        dict: Resulting preset\n    \"\"\"\n    preset = load_capture_preset(data=capture_preset)\n\n    preset[\"camera\"] = camera\n    preset[\"start_frame\"] = start\n    preset[\"end_frame\"] = end\n    preset[\"filename\"] = path\n    preset[\"overwrite\"] = True\n    preset[\"panel\"] = instance.data[\"panel\"]\n\n    # Disable viewer since we use the rendering logic for publishing\n    # We don't want to open the generated playblast in a viewer directly.\n    preset[\"viewer\"] = False\n\n    # \"isolate_view\" will already have been applied at creation, so we'll\n    # ignore it here.\n    preset.pop(\"isolate_view\")\n\n    # Set resolution variables from capture presets\n    width_preset = capture_preset[\"Resolution\"][\"width\"]\n    height_preset = capture_preset[\"Resolution\"][\"height\"]\n\n    # Set resolution variables from folder values\n    folder_attributes = instance.data[\"folderEntity\"][\"attrib\"]\n    folder_width = folder_attributes.get(\"resolutionWidth\")\n    folder_height = folder_attributes.get(\"resolutionHeight\")\n    review_instance_width = instance.data.get(\"review_width\")\n    review_instance_height = instance.data.get(\"review_height\")\n\n    # Use resolution from instance if review width/height is set\n    # Otherwise use the resolution from preset if it has non-zero values\n    # Otherwise fall back to folder width x height\n    # Else define no width, then `capture.capture` will use render resolution\n    if review_instance_width and review_instance_height:\n        preset[\"width\"] = review_instance_width\n        preset[\"height\"] = review_instance_height\n    elif width_preset and height_preset:\n        preset[\"width\"] = width_preset\n        preset[\"height\"] = height_preset\n    elif folder_width and folder_height:\n        preset[\"width\"] = folder_width\n        preset[\"height\"] = folder_height\n\n    # Isolate view is requested by having objects in the set besides a\n    # camera. If there is only 1 member it'll be the camera because we\n    # validate to have 1 camera only.\n    if instance.data[\"isolate\"] and len(instance.data[\"setMembers\"]) &gt; 1:\n        preset[\"isolate\"] = instance.data[\"setMembers\"]\n\n    # Override camera options\n    # Enforce persisting camera depth of field\n    camera_options = preset.setdefault(\"camera_options\", {})\n    camera_options[\"depthOfField\"] = cmds.getAttr(\n        \"{0}.depthOfField\".format(camera)\n    )\n\n    # Use Pan/Zoom from instance data instead of from preset\n    preset.pop(\"pan_zoom\", None)\n    camera_options[\"panZoomEnabled\"] = instance.data[\"panZoom\"]\n\n    # Override viewport options by instance data\n    viewport_options = preset.setdefault(\"viewport_options\", {})\n    viewport_options[\"imagePlane\"] = instance.data.get(\"imagePlane\", True)\n\n    # When using 'project settings' we preserve the capture preset that\n    # was picked, then we do not override it with the instance data\n    if instance.data[\"displayLights\"] != \"project_settings\":\n        viewport_options[\"displayLights\"] = instance.data[\"displayLights\"]\n\n    # Override transparency if requested.\n    transparency = instance.data.get(\"transparency\", 0)\n    if transparency != 0:\n        preset[\"viewport2_options\"][\"transparencyAlgorithm\"] = transparency\n\n    # Update preset with current panel setting\n    # if override_viewport_options is turned off\n    if not capture_preset[\"ViewportOptions\"][\"override_viewport_options\"]:\n        panel_preset = capture.parse_view(preset[\"panel\"])\n        panel_preset.pop(\"camera\")\n        preset.update(panel_preset)\n\n    return preset\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.generate_ids","title":"<code>generate_ids(nodes, folder_id=None)</code>","text":"<p>Returns new unique ids for the given nodes.</p> <p>Note: This does not assign the new ids, it only generates the values.</p> <p>To assign new ids using this method:</p> <p>nodes = [\"a\", \"b\", \"c\"] for node, id in generate_ids(nodes):     set_id(node, id)</p> <p>To also override any existing values (and assign regenerated ids):</p> <p>nodes = [\"a\", \"b\", \"c\"] for node, id in generate_ids(nodes):     set_id(node, id, overwrite=True)</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list</code> <p>List of nodes.</p> required <code>folder_id</code> <code>Optional[str]</code> <p>Folder id to generate id for. When None provided current folder is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of (node, id) tuples.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def generate_ids(nodes, folder_id=None):\n    \"\"\"Returns new unique ids for the given nodes.\n\n    Note: This does not assign the new ids, it only generates the values.\n\n    To assign new ids using this method:\n    &gt;&gt;&gt; nodes = [\"a\", \"b\", \"c\"]\n    &gt;&gt;&gt; for node, id in generate_ids(nodes):\n    &gt;&gt;&gt;     set_id(node, id)\n\n    To also override any existing values (and assign regenerated ids):\n    &gt;&gt;&gt; nodes = [\"a\", \"b\", \"c\"]\n    &gt;&gt;&gt; for node, id in generate_ids(nodes):\n    &gt;&gt;&gt;     set_id(node, id, overwrite=True)\n\n    Args:\n        nodes (list): List of nodes.\n        folder_id (Optional[str]): Folder id to generate id for. When None\n            provided current folder is used.\n\n    Returns:\n        list: A list of (node, id) tuples.\n\n    \"\"\"\n\n    if folder_id is None:\n        # Get the folder id based on current context folder\n        project_name = get_current_project_name()\n        folder_path = get_current_folder_path()\n        if not folder_path:\n            raise ValueError(\"Current folder path is not set\")\n        folder_entity = ayon_api.get_folder_by_path(\n            project_name, folder_path, fields=[\"id\"]\n        )\n        if not folder_entity:\n            raise ValueError((\n                \"Current folder '{}' was not found on the server\"\n            ).format(folder_path))\n        folder_id = folder_entity[\"id\"]\n\n    node_ids = []\n    for node in nodes:\n        _, uid = str(uuid.uuid4()).rsplit(\"-\", 1)\n        unique_id = \"{}:{}\".format(folder_id, uid)\n        node_ids.append((node, unique_id))\n\n    return node_ids\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_all_children","title":"<code>get_all_children(nodes, ignore_intermediate_objects=False)</code>","text":"<p>Return all children of <code>nodes</code> including each instanced child. Using maya.cmds.listRelatives(allDescendents=True) includes only the first instance. As such, this function acts as an optimal replacement with a focus on a fast query.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>iterable[str]</code> <p>List of nodes to get children for.</p> required <code>ignore_intermediate_objects</code> <code>bool</code> <p>Ignore any children that are intermediate objects.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>set</code> <p>Children of input nodes.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_all_children(nodes, ignore_intermediate_objects=False):\n    \"\"\"Return all children of `nodes` including each instanced child.\n    Using maya.cmds.listRelatives(allDescendents=True) includes only the first\n    instance. As such, this function acts as an optimal replacement with a\n    focus on a fast query.\n\n    Args:\n        nodes (iterable[str]): List of nodes to get children for.\n        ignore_intermediate_objects (bool): Ignore any children that\n            are intermediate objects.\n\n    Returns:\n        set: Children of input nodes.\n\n    \"\"\"\n    sel = OpenMaya.MSelectionList()\n    traversed = set()\n    iterator = OpenMaya.MItDag(OpenMaya.MItDag.kDepthFirst)\n    fn_dag = OpenMaya.MFnDagNode()\n    for node in nodes:\n\n        if node in traversed:\n            # Ignore if already processed as a child\n            # before\n            continue\n\n        sel.clear()\n        sel.add(node)\n        obj = sel.getDependNode(0)\n        if not obj.hasFn(OpenMaya.MFn.kDagNode):\n            # Not a dag node, skip\n            continue\n\n        dag = sel.getDagPath(0)\n\n        iterator.reset(dag)\n        # ignore self\n        iterator.next()  # noqa: B305\n        while not iterator.isDone():\n\n            if ignore_intermediate_objects:\n                fn_dag.setObject(iterator.currentItem())\n                if fn_dag.isIntermediateObject:\n                    iterator.prune()\n                    iterator.next()  # noqa: B305\n                    continue\n\n            path = iterator.fullPathName()\n\n            if path in traversed:\n                iterator.prune()\n                iterator.next()  # noqa: B305\n                continue\n\n            traversed.add(path)\n            iterator.next()  # noqa: B305\n\n    return traversed\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_attr_in_layer","title":"<code>get_attr_in_layer(attr, layer, as_string=True)</code>","text":"<p>Return attribute value in specified renderlayer.</p> <p>Same as cmds.getAttr but this gets the attribute's value in a given render layer without having to switch to it.</p> Warning for parent attribute overrides <p>Attributes that have render layer overrides to their parent attribute are not captured correctly since they do not have a direct connection. For example, an override to sphere.rotate when querying sphere.rotateX will not return correctly!</p> This is much faster for Maya's renderLayer system, yet the code <p>does no optimized query for render setup.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>attribute name, ex. \"node.attribute\"</p> required <code>layer</code> <code>str</code> <p>layer name</p> required <code>as_string</code> <code>bool</code> <p>whether attribute should convert to a string value</p> <code>True</code> <p>Returns:</p> Type Description <p>The return value from <code>maya.cmds.getAttr</code></p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_attr_in_layer(attr, layer, as_string=True):\n    \"\"\"Return attribute value in specified renderlayer.\n\n    Same as cmds.getAttr but this gets the attribute's value in a\n    given render layer without having to switch to it.\n\n    Warning for parent attribute overrides:\n        Attributes that have render layer overrides to their parent attribute\n        are not captured correctly since they do not have a direct connection.\n        For example, an override to sphere.rotate when querying sphere.rotateX\n        will not return correctly!\n\n    Note: This is much faster for Maya's renderLayer system, yet the code\n        does no optimized query for render setup.\n\n    Args:\n        attr (str): attribute name, ex. \"node.attribute\"\n        layer (str): layer name\n        as_string (bool): whether attribute should convert to a string value\n\n    Returns:\n        The return value from `maya.cmds.getAttr`\n\n    \"\"\"\n\n    try:\n        if cmds.mayaHasRenderSetup():\n            from . import lib_rendersetup\n            return lib_rendersetup.get_attr_in_layer(\n                attr, layer, as_string=as_string)\n    except AttributeError:\n        pass\n\n    # Ignore complex query if we're in the layer anyway\n    current_layer = cmds.editRenderLayerGlobals(query=True,\n                                                currentRenderLayer=True)\n    if layer == current_layer:\n        return cmds.getAttr(attr, asString=as_string)\n\n    connections = cmds.listConnections(attr,\n                                       plugs=True,\n                                       source=False,\n                                       destination=True,\n                                       type=\"renderLayer\") or []\n    connections = filter(lambda x: x.endswith(\".plug\"), connections)\n    if not connections:\n        return cmds.getAttr(attr)\n\n    # Some value types perform a conversion when assigning\n    # TODO: See if there's a maya method to allow this conversion\n    # instead of computing it ourselves.\n    attr_type = cmds.getAttr(attr, type=True)\n    conversion = None\n    if attr_type == \"time\":\n        conversion = mel.eval('currentTimeUnitToFPS()')  # returns float\n    elif attr_type == \"doubleAngle\":\n        # Radians to Degrees: 180 / pi\n        # TODO: This will likely only be correct when Maya units are set\n        #       to degrees\n        conversion = 57.2957795131\n    elif attr_type == \"doubleLinear\":\n        raise NotImplementedError(\"doubleLinear conversion not implemented.\")\n\n    for connection in connections:\n        if connection.startswith(layer + \".\"):\n            attr_split = connection.split(\".\")\n            if attr_split[0] == layer:\n                attr = \".\".join(attr_split[0:-1])\n                value = cmds.getAttr(\"%s.value\" % attr)\n                if conversion:\n                    value *= conversion\n                return value\n\n    else:\n        # When connections are present, but none\n        # to the specific renderlayer than the layer\n        # should have the \"defaultRenderLayer\"'s value\n        layer = \"defaultRenderLayer\"\n        for connection in connections:\n            if connection.startswith(layer):\n                attr_split = connection.split(\".\")\n                if attr_split[0] == \"defaultRenderLayer\":\n                    attr = \".\".join(attr_split[0:-1])\n                    value = cmds.getAttr(\"%s.value\" % attr)\n                    if conversion:\n                        value *= conversion\n                    return value\n\n    return cmds.getAttr(attr, asString=as_string)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_attribute","title":"<code>get_attribute(plug, asString=False, expandEnvironmentVariables=False, **kwargs)</code>","text":"<p>Maya getAttr with some fixes based on <code>pymel.core.general.getAttr()</code>.</p> <p>Like Pymel getAttr this applies some changes to <code>maya.cmds.getAttr</code>   - maya pointlessly returned vector results as a tuple wrapped in a list     (ex.  '[(1,2,3)]'). This command unpacks the vector for you.   - when getting a multi-attr, maya would raise an error, but this will     return a list of values for the multi-attr   - added support for getting message attributes by returning the     connections instead</p> <p>Note that the asString + expandEnvironmentVariables argument naming convention matches the <code>maya.cmds.getAttr</code> arguments so that it can act as a direct replacement for it.</p> <p>Parameters:</p> Name Type Description Default <code>plug</code> <code>str</code> <p>Node's attribute plug as <code>node.attribute</code></p> required <code>asString</code> <code>bool</code> <p>Return string value for enum attributes instead of the index. Note that the return value can be dependent on the UI language Maya is running in.</p> <code>False</code> <code>expandEnvironmentVariables</code> <code>bool</code> <p>Expand any environment variable and (tilde characters on UNIX) found in string attributes which are returned.</p> <code>False</code> Kwargs <p>Supports the keyword arguments of <code>maya.cmds.getAttr</code></p> <p>Returns:</p> Name Type Description <code>object</code> <p>The value of the maya attribute.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_attribute(plug,\n                  asString=False,\n                  expandEnvironmentVariables=False,\n                  **kwargs):\n    \"\"\"Maya getAttr with some fixes based on `pymel.core.general.getAttr()`.\n\n    Like Pymel getAttr this applies some changes to `maya.cmds.getAttr`\n      - maya pointlessly returned vector results as a tuple wrapped in a list\n        (ex.  '[(1,2,3)]'). This command unpacks the vector for you.\n      - when getting a multi-attr, maya would raise an error, but this will\n        return a list of values for the multi-attr\n      - added support for getting message attributes by returning the\n        connections instead\n\n    Note that the asString + expandEnvironmentVariables argument naming\n    convention matches the `maya.cmds.getAttr` arguments so that it can\n    act as a direct replacement for it.\n\n    Args:\n        plug (str): Node's attribute plug as `node.attribute`\n        asString (bool): Return string value for enum attributes instead\n            of the index. Note that the return value can be dependent on the\n            UI language Maya is running in.\n        expandEnvironmentVariables (bool): Expand any environment variable and\n            (tilde characters on UNIX) found in string attributes which are\n            returned.\n\n    Kwargs:\n        Supports the keyword arguments of `maya.cmds.getAttr`\n\n    Returns:\n        object: The value of the maya attribute.\n\n    \"\"\"\n    attr_type = cmds.getAttr(plug, type=True)\n    if asString:\n        kwargs[\"asString\"] = True\n    if expandEnvironmentVariables:\n        kwargs[\"expandEnvironmentVariables\"] = True\n    try:\n        res = cmds.getAttr(plug, **kwargs)\n    except RuntimeError:\n        if attr_type == \"message\":\n            return cmds.listConnections(plug)\n\n        node, attr = plug.split(\".\", 1)\n        children = cmds.attributeQuery(attr, node=node, listChildren=True)\n        if children:\n            return [\n                get_attribute(\"{}.{}\".format(node, child))\n                for child in children\n            ]\n\n        raise\n\n    # Convert vector result wrapped in tuple\n    if isinstance(res, list) and len(res):\n        if isinstance(res[0], tuple) and len(res):\n            if attr_type in {'pointArray', 'vectorArray'}:\n                return res\n            return res[0]\n\n    return res\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_capture_preset","title":"<code>get_capture_preset(task_name, task_type, product_name, project_settings, log)</code>","text":"<p>Get capture preset for playblasting.</p> <p>Logic for transitioning from old style capture preset to new capture preset profiles.</p> <p>Parameters:</p> Name Type Description Default <code>task_name</code> <code>str</code> <p>Task name.</p> required <code>task_type</code> <code>str</code> <p>Task type.</p> required <code>product_name</code> <code>str</code> <p>Product name.</p> required <code>project_settings</code> <code>dict</code> <p>Project settings.</p> required <code>log</code> <code>Logger</code> <p>Logging object.</p> required Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_capture_preset(\n    task_name, task_type, product_name, project_settings, log\n):\n    \"\"\"Get capture preset for playblasting.\n\n    Logic for transitioning from old style capture preset to new capture preset\n    profiles.\n\n    Args:\n        task_name (str): Task name.\n        task_type (str): Task type.\n        product_name (str): Product name.\n        project_settings (dict): Project settings.\n        log (logging.Logger): Logging object.\n    \"\"\"\n    capture_preset = None\n    filtering_criteria = {\n        \"task_names\": task_name,\n        \"task_types\": task_type,\n        \"product_names\": product_name\n    }\n\n    plugin_settings = project_settings[\"maya\"][\"publish\"][\"ExtractPlayblast\"]\n    if plugin_settings[\"profiles\"]:\n        profile = filter_profiles(\n            plugin_settings[\"profiles\"],\n            filtering_criteria,\n            logger=log\n        ) or {}\n        capture_preset = profile.get(\"capture_preset\")\n    else:\n        log.warning(\"No profiles present for Extract Playblast\")\n\n    # Backward compatibility for deprecated Extract Playblast settings\n    # without profiles.\n    if capture_preset is None:\n        log.debug(\n            \"Falling back to deprecated Extract Playblast capture preset \"\n            \"because no new style playblast profiles are defined or no \"\n            \"profile matches for your current context.\"\n        )\n        capture_preset = plugin_settings.get(\"capture_preset\")\n\n    if capture_preset:\n        # Create deepcopy of preset as we'll change the values\n        capture_preset = copy.deepcopy(capture_preset)\n\n        viewport_options = capture_preset[\"ViewportOptions\"]\n        # Change 'list' to 'dict' for 'capture.py'\n        viewport_options[\"pluginObjects\"] = {\n            item[\"name\"]: item[\"value\"]\n            for item in viewport_options[\"pluginObjects\"]\n        }\n    return capture_preset or {}\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_color_management_preferences","title":"<code>get_color_management_preferences()</code>","text":"<p>Get and resolve OCIO preferences.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_color_management_preferences():\n    \"\"\"Get and resolve OCIO preferences.\"\"\"\n    data = {\n        # Is color management enabled.\n        \"enabled\": cmds.colorManagementPrefs(\n            query=True, cmEnabled=True\n        ),\n        \"rendering_space\": cmds.colorManagementPrefs(\n            query=True, renderingSpaceName=True\n        ),\n        \"output_transform\": cmds.colorManagementPrefs(\n            query=True, outputTransformName=True\n        ),\n        \"output_transform_enabled\": cmds.colorManagementPrefs(\n            query=True, outputTransformEnabled=True\n        ),\n        \"view_transform\": cmds.colorManagementPrefs(\n            query=True, viewTransformName=True\n        )\n    }\n\n    # Split view and display from view_transform. view_transform comes in\n    # format of \"{view} ({display})\".\n    regex = re.compile(r\"^(?P&lt;view&gt;.+) \\((?P&lt;display&gt;.+)\\)$\")\n    if int(cmds.about(version=True)) &lt;= 2020:\n        # view_transform comes in format of \"{view} {display}\" in 2020.\n        regex = re.compile(r\"^(?P&lt;view&gt;.+) (?P&lt;display&gt;.+)$\")\n\n    match = regex.match(data[\"view_transform\"])\n    if not match:\n        raise ValueError(\n            \"Unable to parse view and display from Maya view transform: '{}' \"\n            \"using regex '{}'\".format(data[\"view_transform\"], regex.pattern)\n        )\n\n    data.update({\n        \"display\": match.group(\"display\"),\n        \"view\": match.group(\"view\")\n    })\n\n    # Get config absolute path.\n    path = cmds.colorManagementPrefs(\n        query=True, configFilePath=True\n    )\n\n    # The OCIO config supports a custom &lt;MAYA_RESOURCES&gt; token.\n    maya_resources_token = \"&lt;MAYA_RESOURCES&gt;\"\n    maya_resources_path = OpenMaya.MGlobal.getAbsolutePathToResources()\n    path = path.replace(maya_resources_token, maya_resources_path)\n\n    data[\"config\"] = path\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_container_members","title":"<code>get_container_members(container)</code>","text":"<p>Returns the members of a container. This includes the nodes from any loaded references in the container.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_container_members(container):\n    \"\"\"Returns the members of a container.\n    This includes the nodes from any loaded references in the container.\n    \"\"\"\n    if isinstance(container, dict):\n        # Assume it's a container dictionary\n        container = container[\"objectName\"]\n\n    members = cmds.sets(container, query=True) or []\n    members = cmds.ls(members, long=True, objectsOnly=True) or []\n    all_members = set(members)\n\n    # Include any referenced nodes from any reference in the container\n    # This is required since we've removed adding ALL nodes of a reference\n    # into the container set and only add the reference node now.\n    for ref in cmds.ls(members, exactType=\"reference\", objectsOnly=True):\n\n        # Ignore any `:sharedReferenceNode`\n        if ref.rsplit(\":\", 1)[-1].startswith(\"sharedReferenceNode\"):\n            continue\n\n        # Ignore _UNKNOWN_REF_NODE_ (PLN-160)\n        if ref.rsplit(\":\", 1)[-1].startswith(\"_UNKNOWN_REF_NODE_\"):\n            continue\n\n        try:\n            reference_members = cmds.referenceQuery(ref,\n                                                    nodes=True,\n                                                    dagPath=True)\n        except RuntimeError:\n            # Ignore reference nodes that are not associated with a\n            # referenced file on which `referenceQuery` command fails\n            if not is_valid_reference_node(ref):\n                continue\n            raise\n        reference_members = cmds.ls(reference_members,\n                                    long=True,\n                                    objectsOnly=True)\n        all_members.update(reference_members)\n\n    return list(all_members)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_container_transforms","title":"<code>get_container_transforms(container, members=None, root=False)</code>","text":"<p>Retrieve the root node of the container content</p> <p>When a container is created through a Loader the content of the file will be grouped under a transform. The name of the root transform is stored in the container information</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>dict</code> <p>the container</p> required <code>members</code> <code>list</code> <p>optional and convenience argument</p> <code>None</code> <code>root</code> <code>bool</code> <p>return highest node in hierarchy if True</p> <code>False</code> <p>Returns:</p> Name Type Description <code>root</code> <code>list / str</code> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_container_transforms(container, members=None, root=False):\n    \"\"\"Retrieve the root node of the container content\n\n    When a container is created through a Loader the content\n    of the file will be grouped under a transform. The name of the root\n    transform is stored in the container information\n\n    Args:\n        container (dict): the container\n        members (list): optional and convenience argument\n        root (bool): return highest node in hierarchy if True\n\n    Returns:\n        root (list / str):\n    \"\"\"\n\n    if not members:\n        members = get_container_members(container)\n\n    results = cmds.ls(members, type=\"transform\", long=True)\n    if root:\n        root = get_highest_in_hierarchy(results)\n        if root:\n            results = root[0]\n\n    return results\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_creator_identifier","title":"<code>get_creator_identifier(node)</code>","text":"<p>Get the creator identifier of an instance node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>The name of the instance node.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The creator identifier of the instance or None if not found.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_creator_identifier(node: str) -&gt; str | None:\n    \"\"\"Get the creator identifier of an instance node.\n\n    Arguments:\n        node (str): The name of the instance node.\n\n    Returns:\n        str | None: The creator identifier of the instance or None if not found.\n    \"\"\"\n    if get_attribute(f\"{node}.id\") not in {\n        AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n    }:\n        return None\n    return get_attribute(f\"{node}.creator_identifier\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_custom_namespace","title":"<code>get_custom_namespace(custom_namespace)</code>","text":"<p>Return unique namespace.</p> <p>The input namespace can contain a single group of '#' number tokens to indicate where the namespace's unique index should go. The amount of tokens defines the zero padding of the number, e.g ### turns into 001.</p> Note that a namespace will always be <p>prefixed with a _ if it starts with a digit</p> Example <p>get_custom_namespace(\"myspace_##_\")</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_custom_namespace(custom_namespace):\n    \"\"\"Return unique namespace.\n\n    The input namespace can contain a single group\n    of '#' number tokens to indicate where the namespace's\n    unique index should go. The amount of tokens defines\n    the zero padding of the number, e.g ### turns into 001.\n\n    Warning: Note that a namespace will always be\n        prefixed with a _ if it starts with a digit\n\n    Example:\n        &gt;&gt;&gt; get_custom_namespace(\"myspace_##_\")\n        # myspace_01_\n        &gt;&gt;&gt; get_custom_namespace(\"##_myspace\")\n        # _01_myspace\n        &gt;&gt;&gt; get_custom_namespace(\"myspace##\")\n        # myspace01\n\n    \"\"\"\n    split = re.split(\"([#]+)\", custom_namespace, 1)\n\n    if len(split) == 3:\n        base, padding, suffix = split\n        padding = \"%0{}d\".format(len(padding))\n    else:\n        base = split[0]\n        padding = \"%02d\"  # default padding\n        suffix = \"\"\n\n    return unique_namespace(\n        base,\n        format=padding,\n        prefix=\"_\" if not base or base[0].isdigit() else \"\",\n        suffix=suffix\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_custom_namespace--myspace_01_","title":"myspace_01_","text":"<p>get_custom_namespace(\"##_myspace\")</p>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_custom_namespace--_01_myspace","title":"_01_myspace","text":"<p>get_custom_namespace(\"myspace##\")</p>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_custom_namespace--myspace01","title":"myspace01","text":""},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_fps_for_current_context","title":"<code>get_fps_for_current_context(task_entity=None)</code>","text":"<p>Get fps that should be set for current context.</p> <p>Parameters:</p> Name Type Description Default <code>task_entity</code> <code>dict</code> <p>Task entity to use. If not provided, the current task entity is used. This is mostly used for optimization purposes.</p> <code>None</code> <p>Returns:</p> Type Description <p>Union[int, float]: FPS value.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_fps_for_current_context(task_entity=None):\n    \"\"\"Get fps that should be set for current context.\n\n    Arguments:\n        task_entity (dict, optional): Task entity to use.\n            If not provided, the current task entity is used.\n            This is mostly used for optimization purposes.\n\n    Returns:\n        Union[int, float]: FPS value.\n    \"\"\"\n    if task_entity is None:\n        task_entity = get_current_task_entity(fields={\"attrib.fps\"})\n    fps = task_entity.get(\"attrib\", {}).get(\"fps\", 25)\n    return convert_to_maya_fps(fps)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_frame_range","title":"<code>get_frame_range(include_animation_range=False, task_entity=None, project_settings=None)</code>","text":"<p>Get the current task frame range and handles.</p> <p>Note: This does not return the Maya time slider range.</p> <p>Parameters:</p> Name Type Description Default <code>include_animation_range</code> <code>bool</code> <p>Whether to include <code>animationStart</code> and <code>animationEnd</code> keys to define the outer range of the timeline. It is excluded by default.</p> <code>False</code> <code>task_entity</code> <code>dict</code> <p>Task entity to use. If not provided, the current task entity is used. This is mostly used for optimization purposes.</p> <code>None</code> <code>project_settings</code> <code>dict</code> <p>Project settings to use. If not provided, the current project settings are used. This is mostly used for optimization purposes.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Task's expected frame range values.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_frame_range(\n        include_animation_range=False,\n        task_entity=None,\n        project_settings=None\n):\n    \"\"\"Get the current task frame range and handles.\n\n    Note: This does *not* return the Maya time slider range.\n\n    Args:\n        include_animation_range (bool, optional): Whether to include\n            `animationStart` and `animationEnd` keys to define the outer\n            range of the timeline. It is excluded by default.\n        task_entity (dict, optional): Task entity to use.\n            If not provided, the current task entity is used.\n            This is mostly used for optimization purposes.\n        project_settings (dict, optional): Project settings to use.\n            If not provided, the current project settings are used.\n            This is mostly used for optimization purposes.\n\n    Returns:\n        dict: Task's expected frame range values.\n\n    \"\"\"\n    if task_entity is None:\n        task_entity = get_current_task_entity(\n            fields={\n                \"taskType\",\n                \"attrib.frameStart\",\n                \"attrib.frameEnd\",\n                \"attrib.handleStart\",\n                \"attrib.handleEnd\",\n            }\n        )\n    task_attributes = task_entity[\"attrib\"]\n\n    frame_start = task_attributes.get(\"frameStart\")\n    frame_end = task_attributes.get(\"frameEnd\")\n    if frame_start is None or frame_end is None:\n        # This should never happen because attributes always exist on tasks\n        cmds.warning(\n            \"No frame start and frame end information found for current task.\"\n        )\n        return\n\n    handle_start = task_attributes.get(\"handleStart\") or 0\n    handle_end = task_attributes.get(\"handleEnd\") or 0\n\n    frame_range = {\n        \"frameStart\": frame_start,\n        \"frameEnd\": frame_end,\n        \"handleStart\": handle_start,\n        \"handleEnd\": handle_end\n    }\n    if include_animation_range:\n        # The animation range values are only included to define whether\n        # the Maya time slider should include the handles or not.\n        # Some usages of this function use the full dictionary to define\n        # instance attributes for which we want to exclude the animation\n        # keys. That is why these are excluded by default.\n        if not project_settings:\n            project_name = get_current_project_name()\n            project_settings = get_project_settings(project_name)\n\n        task_type = task_entity[\"taskType\"]\n\n        include_handles_settings = project_settings[\"maya\"][\"include_handles\"]\n\n        animation_start = frame_start\n        animation_end = frame_end\n\n        include_handles = include_handles_settings[\"include_handles_default\"]\n        for item in include_handles_settings[\"per_task_type\"]:\n            if task_type in item[\"task_type\"]:\n                include_handles = item[\"include_handles\"]\n                break\n        if include_handles:\n            animation_start -= int(handle_start)\n            animation_end += int(handle_end)\n\n        frame_range[\"animationStart\"] = animation_start\n        frame_range[\"animationEnd\"] = animation_end\n\n    return frame_range\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_highest_in_hierarchy","title":"<code>get_highest_in_hierarchy(nodes)</code>","text":"<p>Return highest nodes in the hierarchy that are in the <code>nodes</code> list.</p> <p>The \"highest in hierarchy\" are the nodes closest to world: top-most level. The result only contains DAG nodes.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list[str]</code> <p>The nodes in which find the highest in hierarchies.</p> required <p>Returns:</p> Type Description <p>list[str]: The highest DAG nodes from the input nodes.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_highest_in_hierarchy(nodes):\n    \"\"\"Return highest nodes in the hierarchy that are in the `nodes` list.\n\n    The \"highest in hierarchy\" are the nodes closest to world: top-most level.\n    The result only contains DAG nodes.\n\n    Args:\n        nodes (list[str]): The nodes in which find the highest in hierarchies.\n\n    Returns:\n        list[str]: The highest DAG nodes from the input nodes.\n\n    \"\"\"\n\n    # Ensure we use long names\n    nodes = cmds.ls(nodes, long=True, type=\"dagNode\")\n    lookup = set(nodes)\n\n    highest = []\n    for node in nodes:\n        # If no parents are within the nodes input list\n        # then this is a highest node\n        if not any(n in lookup for n in iter_parents(node)):\n            highest.append(node)\n\n    return highest\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_id","title":"<code>get_id(node)</code>","text":"<p>Get the <code>cbId</code> attribute of the given node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>the name of the node to retrieve the attribute from</p> required <p>Returns:     str</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_id(node):\n    \"\"\"Get the `cbId` attribute of the given node.\n\n    Args:\n        node (str): the name of the node to retrieve the attribute from\n    Returns:\n        str\n\n    \"\"\"\n    if node is None:\n        return\n\n    sel = OpenMaya.MSelectionList()\n    sel.add(node)\n\n    api_node = sel.getDependNode(0)\n    fn = OpenMaya.MFnDependencyNode(api_node)\n\n    if not fn.hasAttribute(\"cbId\"):\n        return\n\n    try:\n        return fn.findPlug(\"cbId\", False).asString()\n    except RuntimeError:\n        log.warning(\"Failed to retrieve cbId on %s\", node)\n        return\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_id_from_sibling","title":"<code>get_id_from_sibling(node, history_only=True)</code>","text":"<p>Return first node id in the history chain that matches this node.</p> <p>The nodes in history must be of the exact same node type and must be parented under the same parent.</p> <p>Optionally, if no matching node is found from the history, all the siblings of the node that are of the same type are checked. Additionally to having the same parent, the sibling must be marked as 'intermediate object'.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>node to retrieve the history from</p> required <code>history_only</code> <code>bool</code> <p>if True and if nothing found in history, look for an 'intermediate object' in all the node's siblings of same type</p> <code>True</code> <p>Returns:</p> Type Description <p>str or None: The id from the sibling node or None when no id found on any valid nodes in the history or siblings.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_id_from_sibling(node, history_only=True):\n    \"\"\"Return first node id in the history chain that matches this node.\n\n    The nodes in history must be of the exact same node type and must be\n    parented under the same parent.\n\n    Optionally, if no matching node is found from the history, all the\n    siblings of the node that are of the same type are checked.\n    Additionally to having the same parent, the sibling must be marked as\n    'intermediate object'.\n\n    Args:\n        node (str): node to retrieve the history from\n        history_only (bool): if True and if nothing found in history,\n            look for an 'intermediate object' in all the node's siblings\n            of same type\n\n    Returns:\n        str or None: The id from the sibling node or None when no id found\n            on any valid nodes in the history or siblings.\n\n    \"\"\"\n\n    node = cmds.ls(node, long=True)[0]\n\n    # Find all similar nodes in history\n    history = cmds.listHistory(node)\n    node_type = cmds.nodeType(node)\n    similar_nodes = cmds.ls(history, exactType=node_type, long=True)\n\n    # Exclude itself\n    similar_nodes = [x for x in similar_nodes if x != node]\n\n    # The node *must be* under the same parent\n    parent = get_node_parent(node)\n    similar_nodes = [i for i in similar_nodes if get_node_parent(i) == parent]\n\n    # Check all of the remaining similar nodes and take the first one\n    # with an id and assume it's the original.\n    for similar_node in similar_nodes:\n        _id = get_id(similar_node)\n        if _id:\n            return _id\n\n    if not history_only:\n        # Get siblings of same type\n        similar_nodes = cmds.listRelatives(parent,\n                                           type=node_type,\n                                           fullPath=True)\n        similar_nodes = cmds.ls(similar_nodes, exactType=node_type, long=True)\n\n        # Exclude itself\n        similar_nodes = [x for x in similar_nodes if x != node]\n\n        # Get all unique ids from siblings in order since\n        # we consistently take the first one found\n        sibling_ids = OrderedDict()\n        for similar_node in similar_nodes:\n            # Check if \"intermediate object\"\n            if not cmds.getAttr(similar_node + \".intermediateObject\"):\n                continue\n\n            _id = get_id(similar_node)\n            if not _id:\n                continue\n\n            if _id in sibling_ids:\n                sibling_ids[_id].append(similar_node)\n            else:\n                sibling_ids[_id] = [similar_node]\n\n        if sibling_ids:\n            first_id, found_nodes = next(iter(sibling_ids.items()))\n\n            # Log a warning if we've found multiple unique ids\n            if len(sibling_ids) &gt; 1:\n                log.warning((\"Found more than 1 intermediate shape with\"\n                             \" unique id for '{}'. Using id of first\"\n                             \" found: '{}'\".format(node, found_nodes[0])))\n\n            return first_id\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_id_required_nodes","title":"<code>get_id_required_nodes(referenced_nodes=False, nodes=None, existing_ids=True)</code>","text":"<p>Return nodes that should receive a <code>cbId</code> attribute.</p> <p>This includes only mesh and curve nodes, parent transforms of the shape nodes, file texture nodes and object sets (including shading engines).</p> <p>This filters out any node which is locked, referenced, read-only, intermediate object.</p> <p>Parameters:</p> Name Type Description Default <code>referenced_nodes</code> <code>bool</code> <p>set True to include referenced nodes</p> <code>False</code> <code>nodes</code> <code>(list, Optional)</code> <p>nodes to consider</p> <code>None</code> <code>existing_ids</code> <code>bool</code> <p>set True to include nodes with <code>cbId</code> attribute</p> <code>True</code> <p>Returns:</p> Name Type Description <code>nodes</code> <code>set</code> <p>list of filtered nodes</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_id_required_nodes(referenced_nodes=False,\n                          nodes=None,\n                          existing_ids=True):\n    \"\"\"Return nodes that should receive a `cbId` attribute.\n\n    This includes only mesh and curve nodes, parent transforms of the shape\n    nodes, file texture nodes and object sets (including shading engines).\n\n    This filters out any node which is locked, referenced, read-only,\n    intermediate object.\n\n    Args:\n        referenced_nodes (bool): set True to include referenced nodes\n        nodes (list, Optional): nodes to consider\n        existing_ids (bool): set True to include nodes with `cbId` attribute\n\n    Returns:\n        nodes (set): list of filtered nodes\n    \"\"\"\n\n    if nodes is not None and not nodes:\n        # User supplied an empty `nodes` list to check so all we can\n        # do is return the empty result\n        return set()\n\n    def _node_type_exists(node_type):\n        try:\n            cmds.nodeType(node_type, isTypeName=True)\n            return True\n        except RuntimeError:\n            return False\n\n    def iterate(maya_iterator):\n        while not maya_iterator.isDone():\n            yield maya_iterator.thisNode()\n            maya_iterator.next()\n\n    # `readOnly` flag is obsolete as of Maya 2016 therefore we explicitly\n    # remove default nodes and reference nodes\n    default_camera_shapes = {\n        \"frontShape\", \"sideShape\", \"topShape\", \"perspShape\"\n    }\n\n    # The filtered types do not include transforms because we only want the\n    # parent transforms that have a child shape that we filtered to, so we\n    # include the parents here\n    types = [\"mesh\", \"nurbsCurve\", \"nurbsSurface\", \"file\", \"objectSet\"]\n\n    # Check if plugin nodes are available for Maya by checking if the plugin\n    # is loaded\n    if cmds.pluginInfo(\"pgYetiMaya\", query=True, loaded=True):\n        types.append(\"pgYetiMaya\")\n\n    iterator_type = OpenMaya.MIteratorType()\n    # This tries to be closest matching API equivalents of `types` variable\n    iterator_type.filterList = [\n        OpenMaya.MFn.kMesh,  # mesh\n        OpenMaya.MFn.kNurbsSurface,  # nurbsSurface\n        OpenMaya.MFn.kNurbsCurve,  # nurbsCurve\n        OpenMaya.MFn.kFileTexture,  # file\n        OpenMaya.MFn.kSet,  # objectSet\n        OpenMaya.MFn.kPluginShape  # pgYetiMaya\n    ]\n    it = OpenMaya.MItDependencyNodes(iterator_type)\n\n    fn_dep = OpenMaya.MFnDependencyNode()\n    fn_dag = OpenMaya.MFnDagNode()\n    result = set()\n\n    def _should_include_parents(obj):\n        \"\"\"Whether to include parents of obj in output\"\"\"\n        if not obj.hasFn(OpenMaya.MFn.kShape):\n            return False\n\n        fn_dag.setObject(obj)\n        if fn_dag.isIntermediateObject:\n            return False\n\n        # Skip default cameras\n        if (\n            obj.hasFn(OpenMaya.MFn.kCamera) and\n            fn_dag.name() in default_camera_shapes\n        ):\n            return False\n\n        return True\n\n    def _add_to_result_if_valid(obj):\n        \"\"\"Add to `result` if the object should be included\"\"\"\n        fn_dep.setObject(obj)\n        if not existing_ids and fn_dep.hasAttribute(\"cbId\"):\n            # If not including existing ids, skip nodes with `cbId` attribute\n            plug = fn_dep.findPlug(\"cbId\", True)\n            try:\n                value = plug.asString()\n                if value:\n                    return\n            except RuntimeError:\n                # Likely not a string attribute which we will consider as\n                # not having a `cbId` attribute - however we do log a warning\n                if obj.hasFn(OpenMaya.MFn.kDagNode):\n                    fn_dag.setObject(obj)\n                    name = fn_dag.fullPathName()\n                else:\n                    name = fn_dep.name()\n\n                type_name = cmds.getAttr(f\"{name}.cbId\", type=True)\n                if type_name == \"string\":\n                    # Type is correct so the issue must be something else,\n                    # so we re-raise the exception\n                    raise\n                # If the attribute is not a string, we log a warning\n                log.warning(\n                    f\"\\\"{name}.cbId\\\" is not a string attribute. \"\n                    f\"Attribute type: '{type_name}'.\"\n                )\n\n        if not referenced_nodes and fn_dep.isFromReferencedFile:\n            return\n\n        if fn_dep.isDefaultNode:\n            return\n\n        if fn_dep.isLocked:\n            return\n\n        # Skip default cameras\n        if (\n            obj.hasFn(OpenMaya.MFn.kCamera) and\n            fn_dep.name() in default_camera_shapes\n        ):\n            return\n\n        if obj.hasFn(OpenMaya.MFn.kDagNode):\n            # DAG nodes\n            fn_dag.setObject(obj)\n\n            # Skip intermediate objects\n            if fn_dag.isIntermediateObject:\n                return\n\n            # DAG nodes can be instanced and thus may have multiple paths.\n            # We need to identify each path\n            paths = OpenMaya.MDagPath.getAllPathsTo(obj)\n            for dag in paths:\n                path = dag.fullPathName()\n                result.add(path)\n        else:\n            # Dependency node\n            path = fn_dep.name()\n            result.add(path)\n\n    for obj in iterate(it):\n        # For any non-intermediate shape node always include the parent\n        # even if we exclude the shape itself (e.g. when locked, default)\n        if _should_include_parents(obj):\n            fn_dag.setObject(obj)\n            parents = [\n                fn_dag.parent(index) for index in range(fn_dag.parentCount())\n            ]\n            for parent_obj in parents:\n                _add_to_result_if_valid(parent_obj)\n\n        _add_to_result_if_valid(obj)\n\n    if not result:\n        return result\n\n    # Exclude some additional types\n    exclude_types = []\n    if _node_type_exists(\"ilrBakeLayer\"):\n        # Remove Turtle from the result if Turtle is loaded\n        exclude_types.append(\"ilrBakeLayer\")\n\n    if exclude_types:\n        exclude_nodes = set(cmds.ls(nodes, long=True, type=exclude_types))\n        if exclude_nodes:\n            result -= exclude_nodes\n\n    # Filter to explicit input nodes if provided\n    if nodes is not None:\n        # The amount of input nodes to filter to can be large and querying\n        # many nodes can be slow in Maya. As such we want to try and reduce\n        # it as much as possible, so we include the type filter to try and\n        # reduce the result of `maya.cmds.ls` here.\n        nodes = set(cmds.ls(nodes, long=True, type=types + [\"dagNode\"]))\n        if nodes:\n            result &amp;= nodes\n        else:\n            return set()\n\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_isolate_view_sets","title":"<code>get_isolate_view_sets()</code>","text":"<p>Return isolate view sets of all modelPanels.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>all sets related to isolate view</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_isolate_view_sets():\n    \"\"\"Return isolate view sets of all modelPanels.\n\n    Returns:\n        list: all sets related to isolate view\n\n    \"\"\"\n\n    view_sets = set()\n    for panel in cmds.getPanel(type=\"modelPanel\") or []:\n        view_set = cmds.modelEditor(panel, query=True, viewObjects=True)\n        if view_set:\n            view_sets.add(view_set)\n\n    return view_sets\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_main_window","title":"<code>get_main_window()</code>","text":"<p>Acquire Maya's main window</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_main_window():\n    \"\"\"Acquire Maya's main window\"\"\"\n    from qtpy import QtWidgets\n\n    if self._parent is None:\n        self._parent = {\n            widget.objectName(): widget\n            for widget in QtWidgets.QApplication.topLevelWidgets()\n        }[\"MayaWindow\"]\n    return self._parent\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_namespace","title":"<code>get_namespace(node)</code>","text":"<p>Return namespace of given node</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_namespace(node):\n    \"\"\"Return namespace of given node\"\"\"\n    node_name = node.rsplit(\"|\", 1)[-1]\n    if \":\" in node_name:\n        return node_name.rsplit(\":\", 1)[0]\n    else:\n        return \"\"\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_node_index_under_parent","title":"<code>get_node_index_under_parent(node)</code>","text":"<p>Return the index of a DAG node under its parent.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>A DAG Node path.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The DAG node's index under its parents or world</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_node_index_under_parent(node: str) -&gt; int:\n    \"\"\"Return the index of a DAG node under its parent.\n\n    Arguments:\n        node (str): A DAG Node path.\n\n    Returns:\n        int: The DAG node's index under its parents or world\n\n    \"\"\"\n    node = cmds.ls(node, long=True)[0]  # enforce long names\n    parent = node.rsplit(\"|\", 1)[0]\n    if not parent:\n        return cmds.ls(assemblies=True, long=True).index(node)\n    else:\n        return cmds.listRelatives(parent,\n                                  children=True,\n                                  fullPath=True).index(node)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_node_name","title":"<code>get_node_name(path)</code>","text":"<p>Return maya node name without namespace or parents</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_node_name(\"|grp|node\")\n\"node\"\n&gt;&gt;&gt; get_node_name(\"|foobar:grp|foobar:child\")\n\"child\"\n&gt;&gt;&gt; get_node_name(\"|foobar:grp|lala:bar|foobar:test:hello_world\")\n\"hello_world\"\n</code></pre> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_node_name(path: str) -&gt; str:\n    \"\"\"Return maya node name without namespace or parents\n\n    Examples:\n        &gt;&gt;&gt; get_node_name(\"|grp|node\")\n        \"node\"\n        &gt;&gt;&gt; get_node_name(\"|foobar:grp|foobar:child\")\n        \"child\"\n        &gt;&gt;&gt; get_node_name(\"|foobar:grp|lala:bar|foobar:test:hello_world\")\n        \"hello_world\"\n    \"\"\"\n    return path.rsplit(\"|\", 1)[-1].rsplit(\":\", 1)[-1]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_node_parent","title":"<code>get_node_parent(node)</code>","text":"<p>Return full path name for parent of node</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_node_parent(node):\n    \"\"\"Return full path name for parent of node\"\"\"\n    parents = cmds.listRelatives(node, parent=True, fullPath=True)\n    return parents[0] if parents else None\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_reference_node","title":"<code>get_reference_node(members, log=None)</code>","text":"<p>Get the reference node from the container members Args:     members: list of node names</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Reference node name.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_reference_node(members, log=None):\n    \"\"\"Get the reference node from the container members\n    Args:\n        members: list of node names\n\n    Returns:\n        str: Reference node name.\n\n    \"\"\"\n\n    # Collect the references without .placeHolderList[] attributes as\n    # unique entries (objects only) and skipping the sharedReferenceNode.\n    references = set()\n    for ref in cmds.ls(members, exactType=\"reference\", objectsOnly=True):\n\n        # Ignore any `:sharedReferenceNode`\n        if ref.rsplit(\":\", 1)[-1].startswith(\"sharedReferenceNode\"):\n            continue\n\n        # Ignore _UNKNOWN_REF_NODE_ (PLN-160)\n        if ref.rsplit(\":\", 1)[-1].startswith(\"_UNKNOWN_REF_NODE_\"):\n            continue\n\n        if not is_valid_reference_node(ref):\n            continue\n\n        references.add(ref)\n\n    if not references:\n        return\n\n    # Get highest reference node (least parents)\n    highest = min(references,\n                  key=lambda x: len(get_reference_node_parents(x)))\n\n    # Warn the user when we're taking the highest reference node\n    if len(references) &gt; 1:\n        if not log:\n            log = logging.getLogger(__name__)\n\n        log.warning(\"More than one reference node found in \"\n                    \"container, using highest reference node: \"\n                    \"%s (in: %s)\", highest, list(references))\n\n    return highest\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_reference_node_parents","title":"<code>get_reference_node_parents(ref)</code>","text":"<p>Return all parent reference nodes of reference node</p> <p>Parameters:</p> Name Type Description Default <code>ref</code> <code>str</code> <p>reference node.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>The upstream parent reference nodes.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_reference_node_parents(ref):\n    \"\"\"Return all parent reference nodes of reference node\n\n    Args:\n        ref (str): reference node.\n\n    Returns:\n        list: The upstream parent reference nodes.\n\n    \"\"\"\n    def _get_parent(reference_node):\n        \"\"\"Return parent reference node, but ignore invalid reference nodes\"\"\"\n        if not is_valid_reference_node(reference_node):\n            return\n        return cmds.referenceQuery(reference_node,\n                                   referenceNode=True,\n                                   parent=True)\n\n    parent = _get_parent(ref)\n    parents = []\n    while parent:\n        parents.append(parent)\n        parent = _get_parent(parent)\n    return parents\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_related_sets","title":"<code>get_related_sets(node)</code>","text":"<p>Return objectSets that are relationships for a look for <code>node</code>.</p> <p>Filters out based on: - id attribute is NOT <code>AVALON_CONTAINER_ID</code> - shapes and deformer shapes (alembic creates meshShapeDeformed) - set name ends with any from a predefined list - set in not in viewport set (isolate selected for example)</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>name of the current node to check</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>The related sets</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_related_sets(node):\n    \"\"\"Return objectSets that are relationships for a look for `node`.\n\n    Filters out based on:\n    - id attribute is NOT `AVALON_CONTAINER_ID`\n    - shapes and deformer shapes (alembic creates meshShapeDeformed)\n    - set name ends with any from a predefined list\n    - set in not in viewport set (isolate selected for example)\n\n    Args:\n        node (str): name of the current node to check\n\n    Returns:\n        list: The related sets\n\n    \"\"\"\n\n    sets = cmds.listSets(object=node, extendToShape=False)\n    if not sets:\n        return []\n\n    # Fix 'no object matches name' errors on nodes returned by listSets.\n    # In rare cases it can happen that a node is added to an internal maya\n    # set inaccessible by maya commands, for example check some nodes\n    # returned by `cmds.listSets(allSets=True)`\n    sets = cmds.ls(sets)\n\n    # Ids to ignore\n    ignored = {\n        AVALON_INSTANCE_ID,\n        AVALON_CONTAINER_ID,\n        AYON_INSTANCE_ID,\n        AYON_CONTAINER_ID,\n    }\n\n    # Ignore `avalon.container`\n    sets = [\n        s for s in sets\n        if (\n           not cmds.attributeQuery(\"id\", node=s, exists=True)\n           or cmds.getAttr(f\"{s}.id\") not in ignored\n        )\n    ]\n    if not sets:\n        return sets\n\n    # Exclude deformer sets (`type=2` for `maya.cmds.listSets`)\n    exclude_sets = cmds.listSets(object=node,\n                                 extendToShape=False,\n                                 type=2) or []\n    exclude_sets = set(exclude_sets)  # optimize lookup\n\n    # Default nodes to ignore\n    exclude_sets.update({\"defaultLightSet\", \"defaultObjectSet\"})\n\n    # Filter out the sets to exclude\n    sets = [s for s in sets if s not in exclude_sets]\n\n    # Ignore when the set has a specific suffix\n    ignore_suffices = (\"out_SET\", \"controls_SET\", \"_INST\", \"_CON\")\n    sets = [s for s in sets if not s.endswith(ignore_suffices)]\n    if not sets:\n        return sets\n\n    # Ignore viewport filter view sets (from isolate select and\n    # viewports)\n    view_sets = get_isolate_view_sets()\n    sets = [s for s in sets if s not in view_sets]\n\n    return sets\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_representation_path_by_project","title":"<code>get_representation_path_by_project(project_name, repre_entity)</code>","text":"<p>Get the representation path for a given representation entity. This function would be used temporarily until the version from the core addon is available. Args:     project_name (str): The project name.     repre_entity (dict): The representation entity.     project_name (str, optional): The project name. Defaults to None. Returns:     str: The representation path.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_representation_path_by_project(project_name, repre_entity):\n    \"\"\"Get the representation path for a given representation entity.\n    This function would be used temporarily until the version from\n    the core addon is available.\n    Args:\n        project_name (str): The project name.\n        repre_entity (dict): The representation entity.\n        project_name (str, optional): The project name. Defaults to None.\n    Returns:\n        str: The representation path.\n    \"\"\"\n    if project_name is None:\n        project_name = get_current_project_name()\n    anatomy = Anatomy(project_name)\n    return get_representation_path_with_anatomy(repre_entity, anatomy)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_scene_units_settings","title":"<code>get_scene_units_settings(project_settings=None)</code>","text":"<p>Function to return preferred linear unit and angular scale from settings</p> <p>Parameters:</p> Name Type Description Default <code>project_settings</code> <code>dict</code> <p>Project Name. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>tuple[str, str]: linear scene unit, angular scene unit</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_scene_units_settings(project_settings=None)-&gt; tuple[str, str]:\n    \"\"\"Function to return preferred linear unit and angular scale from settings\n\n    Args:\n        project_settings (dict, optional): Project Name. Defaults to None.\n\n    Returns:\n        tuple[str, str]: linear scene unit, angular scene unit\n    \"\"\"\n    if project_settings is None:\n        project_name = get_current_project_name()\n        project_settings = get_project_settings(project_name)\n\n    scene_units = project_settings[\"maya\"][\"scene_units\"]\n    linear_unit = scene_units.get(\"linear_units\", \"cm\")\n    angular_unit = scene_units.get(\"angular_units\", \"deg\")\n    return linear_unit, angular_unit\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_sequence","title":"<code>get_sequence(filepath, pattern='%04d')</code>","text":"<p>Get sequence from filename.</p> <p>This will only return files if they exist on disk as it tries to collect the sequence using the filename pattern and searching for them on disk.</p> <p>Supports negative frame ranges like -001, 0000, 0001 and -0001, 0000, 0001.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The full path to filename containing the given</p> required <code>pattern</code> <code>str</code> <p>The pattern to swap with the variable frame number.</p> <code>'%04d'</code> <p>Returns:</p> Type Description <p>Optional[list[str]]: file sequence.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_sequence(filepath, pattern=\"%04d\"):\n    \"\"\"Get sequence from filename.\n\n    This will only return files if they exist on disk as it tries\n    to collect the sequence using the filename pattern and searching\n    for them on disk.\n\n    Supports negative frame ranges like -001, 0000, 0001 and -0001,\n    0000, 0001.\n\n    Arguments:\n        filepath (str): The full path to filename containing the given\n        pattern.\n        pattern (str): The pattern to swap with the variable frame number.\n\n    Returns:\n        Optional[list[str]]: file sequence.\n\n    \"\"\"\n    filename = os.path.basename(filepath)\n    re_pattern = re.escape(filename)\n    re_pattern = re_pattern.replace(re.escape(pattern), \"-?[0-9]+\")\n    source_dir = os.path.dirname(filepath)\n    files = [f for f in os.listdir(source_dir) if re.match(re_pattern, f)]\n    if not files:\n        # Files do not exist, this may not be a problem if e.g. the\n        # textures were relative paths and we're searching across\n        # multiple image search paths.\n        return\n\n    # clique.PATTERNS[\"frames\"] supports only `.1001.exr` not `_1001.exr` so\n    # we use a customized pattern.\n    pattern = \"[_.](?P&lt;index&gt;(?P&lt;padding&gt;0*)\\\\d+)\\\\.\\\\D+\\\\d?$\"\n    patterns = [pattern]\n    collections, _remainder = clique.assemble(\n        files,\n        patterns=patterns,\n        minimum_items=1)\n\n    if len(collections) &gt; 1:\n        raise ValueError(\n            f\"Multiple collections found for {collections}. \"\n            \"This is a bug.\")\n\n    return [\n        os.path.join(source_dir, filename)\n        for filename in collections[0]\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.get_shader_assignments_from_shapes","title":"<code>get_shader_assignments_from_shapes(shapes, components=True)</code>","text":"<p>Return the shape assignment per related shading engines.</p> <p>Returns a dictionary where the keys are shadingGroups and the values are lists of assigned shapes or shape-components.</p> <p>Since <code>maya.cmds.sets</code> returns shader members on the shapes as components on the transform we correct that in this method too.</p> <p>For the 'shapes' this will return a dictionary like:     {         \"shadingEngineX\": [\"nodeX\", \"nodeY\"],         \"shadingEngineY\": [\"nodeA\", \"nodeB\"]     }</p> <p>Parameters:</p> Name Type Description Default <code>shapes</code> <code>list</code> <p>The shapes to collect the assignments for.</p> required <code>components</code> <code>bool</code> <p>Whether to include the component assignments.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The {shadingEngine: shapes} relationships</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def get_shader_assignments_from_shapes(shapes, components=True):\n    \"\"\"Return the shape assignment per related shading engines.\n\n    Returns a dictionary where the keys are shadingGroups and the values are\n    lists of assigned shapes or shape-components.\n\n    Since `maya.cmds.sets` returns shader members on the shapes as components\n    on the transform we correct that in this method too.\n\n    For the 'shapes' this will return a dictionary like:\n        {\n            \"shadingEngineX\": [\"nodeX\", \"nodeY\"],\n            \"shadingEngineY\": [\"nodeA\", \"nodeB\"]\n        }\n\n    Args:\n        shapes (list): The shapes to collect the assignments for.\n        components (bool): Whether to include the component assignments.\n\n    Returns:\n        dict: The {shadingEngine: shapes} relationships\n\n    \"\"\"\n\n    shapes = cmds.ls(shapes,\n                     long=True,\n                     shapes=True,\n                     objectsOnly=True)\n    if not shapes:\n        return {}\n\n    # Collect shading engines and their shapes\n    assignments = defaultdict(list)\n    for shape in shapes:\n\n        # Get unique shading groups for the shape\n        shading_groups = cmds.listConnections(shape,\n                                              source=False,\n                                              destination=True,\n                                              plugs=False,\n                                              connections=False,\n                                              type=\"shadingEngine\") or []\n        shading_groups = list(set(shading_groups))\n        for shading_group in shading_groups:\n            assignments[shading_group].append(shape)\n\n    if components:\n        # Note: Components returned from maya.cmds.sets are \"listed\" as if\n        # being assigned to the transform like: pCube1.f[0] as opposed\n        # to pCubeShape1.f[0] so we correct that here too.\n\n        # Build a mapping from parent to shapes to include in lookup.\n        transforms = {shape.rsplit(\"|\", 1)[0]: shape for shape in shapes}\n        lookup = set(shapes) | set(transforms.keys())\n\n        component_assignments = defaultdict(list)\n        for shading_group in assignments.keys():\n            members = cmds.ls(cmds.sets(shading_group, query=True), long=True)\n            for member in members:\n\n                node = member.split(\".\", 1)[0]\n                if node not in lookup:\n                    continue\n\n                # Component\n                if \".\" in member:\n\n                    # Fix transform to shape as shaders are assigned to shapes\n                    if node in transforms:\n                        shape = transforms[node]\n                        component = member.split(\".\", 1)[1]\n                        member = \"{0}.{1}\".format(shape, component)\n\n                component_assignments[shading_group].append(member)\n        assignments = component_assignments\n\n    return dict(assignments)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.guess_colorspace","title":"<code>guess_colorspace(img_info)</code>","text":"<p>Guess the colorspace of the input image filename. Note:     Reference from makeTx.py Args:     img_info (dict): Image info generated by :func:<code>image_info</code> Returns:     str: color space name use in the <code>--colorconvert</code>          option of maketx.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def guess_colorspace(img_info):\n    # type: (dict) -&gt; str\n    \"\"\"Guess the colorspace of the input image filename.\n    Note:\n        Reference from makeTx.py\n    Args:\n        img_info (dict): Image info generated by :func:`image_info`\n    Returns:\n        str: color space name use in the `--colorconvert`\n             option of maketx.\n    \"\"\"\n    from arnold import (\n        AiTextureInvalidate,\n        # types\n        AI_TYPE_BYTE,\n        AI_TYPE_INT,\n        AI_TYPE_UINT\n    )\n    try:\n        if img_info['bit_depth'] &lt;= 16:\n            if img_info['format'] in (AI_TYPE_BYTE, AI_TYPE_INT, AI_TYPE_UINT): # noqa\n                return 'sRGB'\n            else:\n                return 'linear'\n        # now discard the image file as AiTextureGetFormat has loaded it\n        AiTextureInvalidate(img_info['filename'])       # noqa\n    except ValueError:\n        print((\"[maketx] Error: Could not guess\"\n               \"colorspace for {}\").format(img_info[\"filename\"]))\n        return \"linear\"\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.image_info","title":"<code>image_info(file_path)</code>","text":"<p>Based on the texture path, get its bit depth and format information. Take reference from makeTx.py in Arnold:     ImageInfo(filename): Get Image Information for colorspace     AiTextureGetFormat(filename): Get Texture Format     AiTextureGetBitDepth(filename): Get Texture bit depth Args:     file_path (str): Path to the texture file. Returns:     dict: Dictionary with the information about the texture file.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def image_info(file_path):\n    # type: (str) -&gt; dict\n    \"\"\"Based on the texture path, get its bit depth and format information.\n    Take reference from makeTx.py in Arnold:\n        ImageInfo(filename): Get Image Information for colorspace\n        AiTextureGetFormat(filename): Get Texture Format\n        AiTextureGetBitDepth(filename): Get Texture bit depth\n    Args:\n        file_path (str): Path to the texture file.\n    Returns:\n        dict: Dictionary with the information about the texture file.\n    \"\"\"\n    from arnold import (\n        AiTextureGetBitDepth,\n        AiTextureGetFormat\n    )\n    # Get Texture Information\n    img_info = {'filename': file_path}\n    if os.path.isfile(file_path):\n        img_info['bit_depth'] = AiTextureGetBitDepth(file_path)  # noqa\n        img_info['format'] = AiTextureGetFormat(file_path)  # noqa\n    else:\n        img_info['bit_depth'] = 8\n        img_info['format'] = \"unknown\"\n    return img_info\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.imprint","title":"<code>imprint(node, data)</code>","text":"<p>Write <code>data</code> to <code>node</code> as userDefined attributes</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>Long name of node</p> required <code>data</code> <code>dict</code> <p>Dictionary of key/value pairs</p> required Example <p>from maya import cmds def compute(): ...   return 6 ... cube, generator = cmds.polyCube() imprint(cube, { ...   \"regularString\": \"myFamily\", ...   \"computedValue\": lambda: compute() ... }) ... cmds.getAttr(cube + \".computedValue\") 6</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def imprint(node, data):\n    \"\"\"Write `data` to `node` as userDefined attributes\n\n    Arguments:\n        node (str): Long name of node\n        data (dict): Dictionary of key/value pairs\n\n    Example:\n        &gt;&gt;&gt; from maya import cmds\n        &gt;&gt;&gt; def compute():\n        ...   return 6\n        ...\n        &gt;&gt;&gt; cube, generator = cmds.polyCube()\n        &gt;&gt;&gt; imprint(cube, {\n        ...   \"regularString\": \"myFamily\",\n        ...   \"computedValue\": lambda: compute()\n        ... })\n        ...\n        &gt;&gt;&gt; cmds.getAttr(cube + \".computedValue\")\n        6\n\n    \"\"\"\n\n    for key, value in data.items():\n\n        if callable(value):\n            # Support values evaluated at imprint\n            value = value()\n\n        if isinstance(value, bool):\n            add_type = {\"attributeType\": \"bool\"}\n            set_type = {\"keyable\": False, \"channelBox\": True}\n        elif isinstance(value, str):\n            add_type = {\"dataType\": \"string\"}\n            set_type = {\"type\": \"string\"}\n        elif isinstance(value, int):\n            add_type = {\"attributeType\": \"long\"}\n            set_type = {\"keyable\": False, \"channelBox\": True}\n        elif isinstance(value, float):\n            add_type = {\"attributeType\": \"double\"}\n            set_type = {\"keyable\": False, \"channelBox\": True}\n        elif isinstance(value, (list, tuple)):\n            add_type = {\"attributeType\": \"enum\", \"enumName\": \":\".join(value)}\n            set_type = {\"keyable\": False, \"channelBox\": True}\n            value = 0  # enum default\n        else:\n            raise TypeError(\"Unsupported type: %r\" % type(value))\n\n        cmds.addAttr(node, longName=key, **add_type)\n        cmds.setAttr(node + \".\" + key, value, **set_type)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.is_valid_reference_node","title":"<code>is_valid_reference_node(reference_node)</code>","text":"<p>Return whether Maya considers the reference node a valid reference.</p> <p>Maya might report an error when using <code>maya.cmds.referenceQuery</code>: Reference node 'reference_node' is not associated with a reference file.</p> <p>Note that this does not check whether the reference node points to an existing file. Instead, it only returns whether maya considers it valid and thus is not an unassociated reference node</p> <p>Parameters:</p> Name Type Description Default <code>reference_node</code> <code>str</code> <p>Reference node name</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether reference node is a valid reference</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def is_valid_reference_node(reference_node):\n    \"\"\"Return whether Maya considers the reference node a valid reference.\n\n    Maya might report an error when using `maya.cmds.referenceQuery`:\n    Reference node 'reference_node' is not associated with a reference file.\n\n    Note that this does *not* check whether the reference node points to an\n    existing file. Instead, it only returns whether maya considers it valid\n    and thus is not an unassociated reference node\n\n    Arguments:\n         reference_node (str): Reference node name\n\n    Returns:\n        bool: Whether reference node is a valid reference\n\n    \"\"\"\n    # maya 2022 is missing `isValidReference` so the check needs to be\n    # done in different way.\n    if int(cmds.about(version=True)) &lt; 2023:\n        try:\n            cmds.referenceQuery(reference_node, filename=True)\n            return True\n        except RuntimeError:\n            return False\n    sel = OpenMaya.MSelectionList()\n    sel.add(reference_node)\n    depend_node = sel.getDependNode(0)\n\n    return OpenMaya.MFnReference(depend_node).isValidReference()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.is_visible","title":"<code>is_visible(node, displayLayer=True, intermediateObject=True, parentHidden=True, visibility=True)</code>","text":"<p>Is <code>node</code> visible?</p> <p>Returns whether a node is hidden by one of the following methods: - The node exists (always checked) - The node must be a dagNode (always checked) - The node's visibility is off. - The node is set as intermediate Object. - The node is in a disabled displayLayer. - Whether any of its parent nodes is hidden.</p> <p>Roughly based on: http://ewertb.soundlinker.com/mel/mel.098.php</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether the node is visible in the scene</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def is_visible(node,\n               displayLayer=True,\n               intermediateObject=True,\n               parentHidden=True,\n               visibility=True):\n    \"\"\"Is `node` visible?\n\n    Returns whether a node is hidden by one of the following methods:\n    - The node exists (always checked)\n    - The node must be a dagNode (always checked)\n    - The node's visibility is off.\n    - The node is set as intermediate Object.\n    - The node is in a disabled displayLayer.\n    - Whether any of its parent nodes is hidden.\n\n    Roughly based on: http://ewertb.soundlinker.com/mel/mel.098.php\n\n    Returns:\n        bool: Whether the node is visible in the scene\n\n    \"\"\"\n\n    # Only existing objects can be visible\n    if not cmds.objExists(node):\n        return False\n\n    # Only dagNodes can be visible\n    if not cmds.objectType(node, isAType='dagNode'):\n        return False\n\n    if visibility:\n        if not cmds.getAttr('{0}.visibility'.format(node)):\n            return False\n\n    if intermediateObject and cmds.objectType(node, isAType='shape'):\n        if cmds.getAttr('{0}.intermediateObject'.format(node)):\n            return False\n\n    if displayLayer:\n        # Display layers set overrideEnabled and overrideVisibility on members\n        if cmds.attributeQuery('overrideEnabled', node=node, exists=True):\n            override_enabled = cmds.getAttr('{}.overrideEnabled'.format(node))\n            override_visibility = cmds.getAttr('{}.overrideVisibility'.format(\n                node))\n            if override_enabled and not override_visibility:\n                return False\n\n    if parentHidden:\n        parents = cmds.listRelatives(node, parent=True, fullPath=True)\n        if parents:\n            parent = parents[0]\n            if not is_visible(parent,\n                              displayLayer=displayLayer,\n                              intermediateObject=False,\n                              parentHidden=parentHidden,\n                              visibility=visibility):\n                return False\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.iter_parents","title":"<code>iter_parents(node)</code>","text":"<p>Iter parents of node from its long name.</p> <p>Note: The <code>node</code> must be the long node name.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>Node long name.</p> required <p>Yields:</p> Name Type Description <code>str</code> <p>All parent node names (long names)</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def iter_parents(node):\n    \"\"\"Iter parents of node from its long name.\n\n    Note: The `node` *must* be the long node name.\n\n    Args:\n        node (str): Node long name.\n\n    Yields:\n        str: All parent node names (long names)\n\n    \"\"\"\n    while True:\n        split = node.rsplit(\"|\", 1)\n        if len(split) == 1 or not split[0]:\n            return\n\n        node = split[0]\n        yield node\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.iter_shader_edits","title":"<code>iter_shader_edits(relationships, shader_nodes, nodes_by_id, label=None)</code>","text":"<p>Yield edits as a set of actions.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def iter_shader_edits(relationships, shader_nodes, nodes_by_id, label=None):\n    \"\"\"Yield edits as a set of actions.\"\"\"\n\n    attributes = relationships.get(\"attributes\", [])\n    shader_data = relationships.get(\"relationships\", {})\n\n    shading_engines = cmds.ls(shader_nodes, type=\"objectSet\", long=True)\n    assert shading_engines, \"Error in retrieving objectSets from reference\"\n\n    # region compute lookup\n    shading_engines_by_id = defaultdict(list)\n    for shad in shading_engines:\n        shading_engines_by_id[get_id(shad)].append(shad)\n    # endregion\n\n    # region assign shading engines and other sets\n    for data in shader_data.values():\n        # collect all unique IDs of the set members\n        shader_uuid = data[\"uuid\"]\n        member_uuids = [\n            (member[\"uuid\"], member.get(\"components\"))\n            for member in data[\"members\"]]\n\n        filtered_nodes = list()\n        for _uuid, components in member_uuids:\n            nodes = nodes_by_id.get(_uuid, None)\n            if nodes is None:\n                continue\n\n            if components:\n                # Assign to the components\n                nodes = [\".\".join([node, components]) for node in nodes]\n\n            filtered_nodes.extend(nodes)\n\n        id_shading_engines = shading_engines_by_id[shader_uuid]\n        if not id_shading_engines:\n            log.error(\"{} - No shader found with cbId \"\n                      \"'{}'\".format(label, shader_uuid))\n            continue\n        elif len(id_shading_engines) &gt; 1:\n            log.error(\"{} - Skipping shader assignment. \"\n                      \"More than one shader found with cbId \"\n                      \"'{}'. (found: {})\".format(label, shader_uuid,\n                                                 id_shading_engines))\n            continue\n\n        if not filtered_nodes:\n            log.warning(\"{} - No nodes found for shading engine \"\n                        \"'{}'\".format(label, id_shading_engines[0]))\n            continue\n\n        yield {\"action\": \"assign\",\n               \"uuid\": data[\"uuid\"],\n               \"nodes\": filtered_nodes,\n               \"shader\": id_shading_engines[0]}\n\n    for data in attributes:\n        nodes = nodes_by_id.get(data[\"uuid\"], [])\n        attr_value = data[\"attributes\"]\n        yield {\"action\": \"setattr\",\n               \"uuid\": data[\"uuid\"],\n               \"nodes\": nodes,\n               \"attributes\": attr_value}\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.iter_visible_nodes_in_range","title":"<code>iter_visible_nodes_in_range(nodes, start, end)</code>","text":"<p>Yield nodes that are visible in start-end frame range.</p> <ul> <li>Ignores intermediateObjects completely.</li> <li>Considers animated visibility attributes + upstream visibilities.</li> </ul> <p>This is optimized for large scenes where some nodes in the parent hierarchy might have some input connections to the visibilities, e.g. key, driven keys, connections to other attributes, etc.</p> <p>This only does a single time step to <code>start</code> if current frame is not inside frame range since the assumption is made that changing a frame isn't so slow that it beats querying all visibility plugs through MDGContext on another frame.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list</code> <p>List of node names to consider.</p> required <code>start</code> <code>(int, float)</code> <p>Start frame.</p> required <code>end</code> <code>(int, float)</code> <p>End frame.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of node names. These will be long full path names so might have a longer name than the input nodes.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def iter_visible_nodes_in_range(nodes, start, end):\n    \"\"\"Yield nodes that are visible in start-end frame range.\n\n    - Ignores intermediateObjects completely.\n    - Considers animated visibility attributes + upstream visibilities.\n\n    This is optimized for large scenes where some nodes in the parent\n    hierarchy might have some input connections to the visibilities,\n    e.g. key, driven keys, connections to other attributes, etc.\n\n    This only does a single time step to `start` if current frame is\n    not inside frame range since the assumption is made that changing\n    a frame isn't so slow that it beats querying all visibility\n    plugs through MDGContext on another frame.\n\n    Args:\n        nodes (list): List of node names to consider.\n        start (int, float): Start frame.\n        end (int, float): End frame.\n\n    Returns:\n        list: List of node names. These will be long full path names so\n            might have a longer name than the input nodes.\n\n    \"\"\"\n    # States we consider per node\n    VISIBLE = 1  # always visible\n    INVISIBLE = 0  # always invisible\n    ANIMATED = -1  # animated visibility\n\n    # Ensure integers\n    start = int(start)\n    end = int(end)\n\n    # Consider only non-intermediate dag nodes and use the \"long\" names.\n    nodes = cmds.ls(nodes, long=True, noIntermediate=True, type=\"dagNode\")\n    if not nodes:\n        return\n\n    with maintained_time():\n        # Go to first frame of the range if the current time is outside\n        # the queried range so can directly query all visible nodes on\n        # that frame.\n        current_time = cmds.currentTime(query=True)\n        if not (start &lt;= current_time &lt;= end):\n            cmds.currentTime(start)\n\n        visible = cmds.ls(nodes, long=True, visible=True)\n        for node in visible:\n            yield node\n        if len(visible) == len(nodes) or start == end:\n            # All are visible on frame one, so they are at least visible once\n            # inside the frame range.\n            return\n\n    # For the invisible ones check whether its visibility and/or\n    # any of its parents visibility attributes are animated. If so, it might\n    # get visible on other frames in the range.\n    def memodict(f):\n        \"\"\"Memoization decorator for a function taking a single argument.\n\n        See: http://code.activestate.com/recipes/\n             578231-probably-the-fastest-memoization-decorator-in-the-/\n        \"\"\"\n\n        class memodict(dict):\n            def __missing__(self, key):\n                ret = self[key] = f(key)\n                return ret\n\n        return memodict().__getitem__\n\n    @memodict\n    def get_state(node):\n        plug = node + \".visibility\"\n        connections = cmds.listConnections(plug,\n                                           source=True,\n                                           destination=False)\n        if connections:\n            return ANIMATED\n        else:\n            return VISIBLE if cmds.getAttr(plug) else INVISIBLE\n\n    visible = set(visible)\n    invisible = [node for node in nodes if node not in visible]\n    always_invisible = set()\n    # Iterate over the nodes by short to long names to iterate the highest\n    # in hierarchy nodes first. So the collected data can be used from the\n    # cache for parent queries in next iterations.\n    node_dependencies = dict()\n    for node in sorted(invisible, key=len):\n\n        state = get_state(node)\n        if state == INVISIBLE:\n            always_invisible.add(node)\n            continue\n\n        # If not always invisible by itself we should go through and check\n        # the parents to see if any of them are always invisible. For those\n        # that are \"ANIMATED\" we consider that this node is dependent on\n        # that attribute, we store them as dependency.\n        dependencies = set()\n        if state == ANIMATED:\n            dependencies.add(node)\n\n        traversed_parents = list()\n        for parent in iter_parents(node):\n\n            if parent in always_invisible or get_state(parent) == INVISIBLE:\n                # When parent is always invisible then consider this parent,\n                # this node we started from and any of the parents we\n                # have traversed in-between to be *always invisible*\n                always_invisible.add(parent)\n                always_invisible.add(node)\n                always_invisible.update(traversed_parents)\n                break\n\n            # If we have traversed the parent before and its visibility\n            # was dependent on animated visibilities then we can just extend\n            # its dependencies for to those for this node and break further\n            # iteration upwards.\n            parent_dependencies = node_dependencies.get(parent, None)\n            if parent_dependencies is not None:\n                dependencies.update(parent_dependencies)\n                break\n\n            state = get_state(parent)\n            if state == ANIMATED:\n                dependencies.add(parent)\n\n            traversed_parents.append(parent)\n\n        if node not in always_invisible and dependencies:\n            node_dependencies[node] = dependencies\n\n    if not node_dependencies:\n        return\n\n    # Now we only have to check the visibilities for nodes that have animated\n    # visibility dependencies upstream. The fastest way to check these\n    # visibility attributes across different frames is with Python api 2.0\n    # so we do that.\n    @memodict\n    def get_visibility_mplug(node):\n        \"\"\"Return api 2.0 MPlug with cached memoize decorator\"\"\"\n        sel = OpenMaya.MSelectionList()\n        sel.add(node)\n        dag = sel.getDagPath(0)\n        return OpenMaya.MFnDagNode(dag).findPlug(\"visibility\", True)\n\n    @contextlib.contextmanager\n    def dgcontext(mtime):\n        \"\"\"MDGContext context manager\"\"\"\n        context = OpenMaya.MDGContext(mtime)\n        try:\n            previous = context.makeCurrent()\n            yield context\n        finally:\n            previous.makeCurrent()\n\n    # We skip the first frame as we already used that frame to check for\n    # overall visibilities. And end+1 to include the end frame.\n    scene_units = OpenMaya.MTime.uiUnit()\n    for frame in range(start + 1, end + 1):\n        mtime = OpenMaya.MTime(frame, unit=scene_units)\n\n        # Build little cache so we don't query the same MPlug's value\n        # again if it was checked on this frame and also is a dependency\n        # for another node\n        frame_visibilities = {}\n        with dgcontext(mtime):\n            for node, dependencies in list(node_dependencies.items()):\n                for dependency in dependencies:\n                    dependency_visible = frame_visibilities.get(dependency,\n                                                                None)\n                    if dependency_visible is None:\n                        mplug = get_visibility_mplug(dependency)\n                        dependency_visible = mplug.asBool()\n                        frame_visibilities[dependency] = dependency_visible\n\n                    if not dependency_visible:\n                        # One dependency is not visible, thus the\n                        # node is not visible.\n                        break\n\n                else:\n                    # All dependencies are visible.\n                    yield node\n                    # Remove node with dependencies for next frame iterations\n                    # because it was visible at least once.\n                    node_dependencies.pop(node)\n\n        # If no more nodes to process break the frame iterations..\n        if not node_dependencies:\n            break\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.keytangent_default","title":"<code>keytangent_default(in_tangent_type='auto', out_tangent_type='auto')</code>","text":"<p>Set the default keyTangent for new keys during this context</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef keytangent_default(in_tangent_type='auto',\n                       out_tangent_type='auto'):\n    \"\"\"Set the default keyTangent for new keys during this context\"\"\"\n\n    original_itt = cmds.keyTangent(query=True, g=True, itt=True)[0]\n    original_ott = cmds.keyTangent(query=True, g=True, ott=True)[0]\n    cmds.keyTangent(g=True, itt=in_tangent_type)\n    cmds.keyTangent(g=True, ott=out_tangent_type)\n    try:\n        yield\n    finally:\n        cmds.keyTangent(g=True, itt=original_itt)\n        cmds.keyTangent(g=True, ott=original_ott)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.len_flattened","title":"<code>len_flattened(components)</code>","text":"<p>Return the length of the list as if it was flattened.</p> <p>Maya will return consecutive components as a single entry when requesting with <code>maya.cmds.ls</code> without the <code>flatten</code> flag. Though enabling <code>flatten</code> on a large list (e.g. millions) will result in a slow result. This command will return the amount of entries in a non-flattened list by parsing the result with regex.</p> <p>Parameters:</p> Name Type Description Default <code>components</code> <code>list</code> <p>The non-flattened components.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>The amount of entries.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def len_flattened(components):\n    \"\"\"Return the length of the list as if it was flattened.\n\n    Maya will return consecutive components as a single entry\n    when requesting with `maya.cmds.ls` without the `flatten`\n    flag. Though enabling `flatten` on a large list (e.g. millions)\n    will result in a slow result. This command will return the amount\n    of entries in a non-flattened list by parsing the result with\n    regex.\n\n    Args:\n        components (list): The non-flattened components.\n\n    Returns:\n        int: The amount of entries.\n\n    \"\"\"\n    assert isinstance(components, (list, tuple))\n    n = 0\n\n    pattern = re.compile(r\"\\[(\\d+):(\\d+)\\]\")\n    for c in components:\n        match = pattern.search(c)\n        if match:\n            start, end = match.groups()\n            n += int(end) - int(start) + 1\n        else:\n            n += 1\n    return n\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.list_looks","title":"<code>list_looks(project_name, folder_id)</code>","text":"<p>Return all look products for the given folder.</p> <p>This assumes all look products start with \"look*\" in their names.</p> <p>Returns:</p> Type Description <p>list[dict[str, Any]]: List of look products.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def list_looks(project_name, folder_id):\n    \"\"\"Return all look products for the given folder.\n\n    This assumes all look products start with \"look*\" in their names.\n\n    Returns:\n        list[dict[str, Any]]: List of look products.\n\n    \"\"\"\n    return list(ayon_api.get_products(\n        project_name, folder_ids=[folder_id], product_types={\"look\"}\n    ))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.load_capture_preset","title":"<code>load_capture_preset(data)</code>","text":"<p>Convert AYON Extract Playblast settings to <code>capture</code> arguments</p> Input data is the settings from <p><code>project_settings/maya/publish/ExtractPlayblast/capture_preset</code></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Capture preset settings from AYON settings</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p><code>capture.capture</code> compatible keyword arguments</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def load_capture_preset(data):\n    \"\"\"Convert AYON Extract Playblast settings to `capture` arguments\n\n    Input data is the settings from:\n        `project_settings/maya/publish/ExtractPlayblast/capture_preset`\n\n    Args:\n        data (dict): Capture preset settings from AYON settings\n\n    Returns:\n        dict: `capture.capture` compatible keyword arguments\n\n    \"\"\"\n\n    options = dict()\n    viewport_options = dict()\n    viewport2_options = dict()\n    camera_options = dict()\n\n    # Straight key-value match from settings to capture arguments\n    options.update(data[\"Codec\"])\n    options.update(data[\"Generic\"])\n    options.update(data[\"Resolution\"])\n\n    camera_options.update(data[\"CameraOptions\"])\n    viewport_options.update(data[\"Renderer\"])\n\n    # DISPLAY OPTIONS\n    disp_options = {}\n    for key, value in data[\"DisplayOptions\"].items():\n        if key.startswith(\"background\"):\n            # Convert background, backgroundTop, backgroundBottom colors\n\n            if len(value) == 4:\n                # Ignore alpha + convert RGB to float\n                value = [\n                    float(value[0]) / 255,\n                    float(value[1]) / 255,\n                    float(value[2]) / 255\n                ]\n            disp_options[key] = value\n        elif key == \"displayGradient\":\n            disp_options[key] = value\n\n    options[\"display_options\"] = disp_options\n\n    # Viewport Options has a mixture of Viewport2 Options and Viewport Options\n    # to pass along to capture. So we'll need to differentiate between the two\n    VIEWPORT2_OPTIONS = {\n        \"textureMaxResolution\",\n        \"renderDepthOfField\",\n        \"ssaoEnable\",\n        \"ssaoSamples\",\n        \"ssaoAmount\",\n        \"ssaoRadius\",\n        \"ssaoFilterRadius\",\n        \"hwFogStart\",\n        \"hwFogEnd\",\n        \"hwFogAlpha\",\n        \"hwFogFalloff\",\n        \"hwFogColorR\",\n        \"hwFogColorG\",\n        \"hwFogColorB\",\n        \"hwFogDensity\",\n        \"motionBlurEnable\",\n        \"motionBlurSampleCount\",\n        \"motionBlurShutterOpenFraction\",\n        \"lineAAEnable\"\n    }\n    for key, value in data[\"ViewportOptions\"].items():\n\n        # There are some keys we want to ignore\n        if key in {\"override_viewport_options\", \"high_quality\"}:\n            continue\n\n        # First handle special cases where we do value conversion to\n        # separate option values\n        if key == 'textureMaxResolution':\n            viewport2_options['textureMaxResolution'] = value\n            if value &gt; 0:\n                viewport2_options['enableTextureMaxRes'] = True\n                viewport2_options['textureMaxResMode'] = 1\n            else:\n                viewport2_options['enableTextureMaxRes'] = False\n                viewport2_options['textureMaxResMode'] = 0\n\n        elif key == 'multiSample':\n            viewport2_options['multiSampleEnable'] = value &gt; 0\n            viewport2_options['multiSampleCount'] = value\n\n        elif key == 'alphaCut':\n            viewport2_options['transparencyAlgorithm'] = 5\n            viewport2_options['transparencyQuality'] = 1\n\n        elif key == 'hwFogFalloff':\n            # Settings enum value string to integer\n            viewport2_options['hwFogFalloff'] = int(value)\n\n        # Then handle Viewport 2.0 Options\n        elif key in VIEWPORT2_OPTIONS:\n            viewport2_options[key] = value\n\n        # Then assume remainder is Viewport Options\n        else:\n            viewport_options[key] = value\n\n    options['viewport_options'] = viewport_options\n    options['viewport2_options'] = viewport2_options\n    options['camera_options'] = camera_options\n\n    # use active sound track\n    scene = capture.parse_active_scene()\n    options['sound'] = scene['sound']\n\n    return options\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.lsattr","title":"<code>lsattr(attr, value=None)</code>","text":"<p>Return nodes matching <code>key</code> and <code>value</code></p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>Name of Maya attribute</p> required <code>value</code> <code>object</code> <p>Value of attribute. If none is provided, return all nodes with this attribute.</p> <code>None</code> Example <p>lsattr(\"id\", \"myId\") [\"myNode\"] lsattr(\"id\") [\"myNode\", \"myOtherNode\"]</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def lsattr(attr, value=None):\n    \"\"\"Return nodes matching `key` and `value`\n\n    Arguments:\n        attr (str): Name of Maya attribute\n        value (object, optional): Value of attribute. If none\n            is provided, return all nodes with this attribute.\n\n    Example:\n        &gt;&gt; lsattr(\"id\", \"myId\")\n        [\"myNode\"]\n        &gt;&gt; lsattr(\"id\")\n        [\"myNode\", \"myOtherNode\"]\n\n    \"\"\"\n\n    if value is None:\n        return cmds.ls(\"*.%s\" % attr,\n                       recursive=True,\n                       objectsOnly=True,\n                       long=True)\n    return lsattrs({attr: value})\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.lsattrs","title":"<code>lsattrs(attrs)</code>","text":"<p>Return nodes with the given attribute(s).</p> <p>Parameters:</p> Name Type Description Default <code>attrs</code> <code>dict</code> <p>Name and value pairs of expected matches</p> required Example Return <p>list: matching nodes.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def lsattrs(attrs):\n    \"\"\"Return nodes with the given attribute(s).\n\n    Arguments:\n        attrs (dict): Name and value pairs of expected matches\n\n    Example:\n        &gt;&gt;&gt; # Return nodes with an `age` of five.\n        &gt;&gt;&gt; lsattrs({\"age\": \"five\"})\n        &gt;&gt;&gt; # Return nodes with both `age` and `color` of five and blue.\n        &gt;&gt;&gt; lsattrs({\"age\": \"five\", \"color\": \"blue\"})\n\n    Return:\n         list: matching nodes.\n\n    \"\"\"\n\n    dep_fn = OpenMaya.MFnDependencyNode()\n    dag_fn = OpenMaya.MFnDagNode()\n    selection_list = OpenMaya.MSelectionList()\n\n    first_attr = next(iter(attrs))\n\n    try:\n        selection_list.add(\"*.{0}\".format(first_attr),\n                           searchChildNamespaces=True)\n    except RuntimeError as exc:\n        if str(exc).endswith(\"Object does not exist\"):\n            return []\n\n    matches = set()\n    for i in range(selection_list.length()):\n        node = selection_list.getDependNode(i)\n        if node.hasFn(OpenMaya.MFn.kDagNode):\n            fn_node = dag_fn.setObject(node)\n            full_path_names = [path.fullPathName()\n                               for path in fn_node.getAllPaths()]\n        else:\n            fn_node = dep_fn.setObject(node)\n            full_path_names = [fn_node.name()]\n\n        for attr in attrs:\n            try:\n                plug = fn_node.findPlug(attr, True)\n                if plug.asString() != attrs[attr]:\n                    break\n            except RuntimeError:\n                break\n        else:\n            matches.update(full_path_names)\n\n    return list(matches)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.lsattrs--return-nodes-with-an-age-of-five","title":"Return nodes with an <code>age</code> of five.","text":"<p>lsattrs({\"age\": \"five\"})</p>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.lsattrs--return-nodes-with-both-age-and-color-of-five-and-blue","title":"Return nodes with both <code>age</code> and <code>color</code> of five and blue.","text":"<p>lsattrs({\"age\": \"five\", \"color\": \"blue\"})</p>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context</p> Example <p>scene = cmds.file(new=True, force=True) node = cmds.createNode(\"transform\", name=\"Test\") cmds.select(\"persp\") with maintained_selection(): ...     cmds.select(\"Test\", replace=True) \"Test\" in cmds.ls(selection=True) False</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection():\n    \"\"\"Maintain selection during context\n\n    Example:\n        &gt;&gt;&gt; scene = cmds.file(new=True, force=True)\n        &gt;&gt;&gt; node = cmds.createNode(\"transform\", name=\"Test\")\n        &gt;&gt;&gt; cmds.select(\"persp\")\n        &gt;&gt;&gt; with maintained_selection():\n        ...     cmds.select(\"Test\", replace=True)\n        &gt;&gt;&gt; \"Test\" in cmds.ls(selection=True)\n        False\n\n    \"\"\"\n\n    previous_selection = cmds.ls(selection=True, long=True)\n    try:\n        yield\n    finally:\n        if previous_selection:\n            cmds.select(previous_selection,\n                        replace=True,\n                        noExpand=True)\n        else:\n            cmds.select(clear=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.maintained_selection_api","title":"<code>maintained_selection_api()</code>","text":"<p>Maintain selection using the Maya Python API.</p> <p>Warning: This is not added to the undo stack.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection_api():\n    \"\"\"Maintain selection using the Maya Python API.\n\n    Warning: This is *not* added to the undo stack.\n\n    \"\"\"\n    original = OpenMaya.MGlobal.getActiveSelectionList()\n    try:\n        yield\n    finally:\n        OpenMaya.MGlobal.setActiveSelectionList(original)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.material_loading_mode","title":"<code>material_loading_mode(mode='immediate')</code>","text":"<p>Set material loading mode during context</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef material_loading_mode(mode=\"immediate\"):\n    \"\"\"Set material loading mode during context\"\"\"\n    original = cmds.displayPref(query=True, materialLoadingMode=True)\n    cmds.displayPref(materialLoadingMode=mode)\n    try:\n        yield\n    finally:\n        cmds.displayPref(materialLoadingMode=original)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.matrix_equals","title":"<code>matrix_equals(a, b, tolerance=1e-10)</code>","text":"<p>Compares two matrices with an imperfection tolerance</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>(list, tuple)</code> <p>the matrix to check</p> required <code>b</code> <code>(list, tuple)</code> <p>the matrix to check against</p> required <code>tolerance</code> <code>float</code> <p>the precision of the differences</p> <code>1e-10</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>True or False</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def matrix_equals(a, b, tolerance=1e-10):\n    \"\"\"\n    Compares two matrices with an imperfection tolerance\n\n    Args:\n        a (list, tuple): the matrix to check\n        b (list, tuple): the matrix to check against\n        tolerance (float): the precision of the differences\n\n    Returns:\n        bool : True or False\n\n    \"\"\"\n    if not all(abs(x - y) &lt; tolerance for x, y in zip(a, b)):\n        return False\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.namespaced","title":"<code>namespaced(namespace, new=True, relative_names=None)</code>","text":"<p>Work inside namespace during context</p> <p>Parameters:</p> Name Type Description Default <code>new</code> <code>bool</code> <p>When enabled this will rename the namespace to a unique namespace if the input namespace already exists.</p> <code>True</code> <p>Yields:</p> Name Type Description <code>str</code> <p>The namespace that is used during the context</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef namespaced(namespace, new=True, relative_names=None):\n    \"\"\"Work inside namespace during context\n\n    Args:\n        new (bool): When enabled this will rename the namespace to a unique\n            namespace if the input namespace already exists.\n\n    Yields:\n        str: The namespace that is used during the context\n\n    \"\"\"\n    original = cmds.namespaceInfo(cur=True, absoluteName=True)\n    original_relative_names = cmds.namespace(query=True, relativeNames=True)\n    if new:\n        namespace = unique_namespace(namespace)\n        cmds.namespace(add=namespace)\n    if relative_names is not None:\n        cmds.namespace(relativeNames=relative_names)\n    try:\n        cmds.namespace(set=namespace)\n        yield namespace\n    finally:\n        cmds.namespace(set=original)\n        if relative_names is not None:\n            cmds.namespace(relativeNames=original_relative_names)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.no_display_layers","title":"<code>no_display_layers(nodes)</code>","text":"<p>Ensure nodes are not in a displayLayer during context.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list</code> <p>The nodes to remove from any display layer.</p> required Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef no_display_layers(nodes):\n    \"\"\"Ensure nodes are not in a displayLayer during context.\n\n    Arguments:\n        nodes (list): The nodes to remove from any display layer.\n\n    \"\"\"\n\n    # Ensure long names\n    nodes = cmds.ls(nodes, long=True)\n\n    # Get the original state\n    lookup = set(nodes)\n    original = {}\n    for layer in cmds.ls(type='displayLayer'):\n\n        # Skip default layer\n        if layer == \"defaultLayer\":\n            continue\n\n        members = cmds.editDisplayLayerMembers(layer,\n                                               query=True,\n                                               fullNames=True)\n        if not members:\n            continue\n        members = set(members)\n\n        included = lookup.intersection(members)\n        if included:\n            original[layer] = list(included)\n\n    try:\n        # Add all nodes to default layer\n        cmds.editDisplayLayerMembers(\"defaultLayer\", nodes, noRecurse=True)\n        yield\n    finally:\n        # Restore original members\n        _iteritems = getattr(original, \"iteritems\", original.items)\n        for layer, members in _iteritems():\n            cmds.editDisplayLayerMembers(layer, members, noRecurse=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.no_undo","title":"<code>no_undo(flush=False)</code>","text":"<p>Disable the undo queue during the context</p> <p>Parameters:</p> Name Type Description Default <code>flush</code> <code>bool</code> <p>When True the undo queue will be emptied when returning from the context losing all undo history. Defaults to False.</p> <code>False</code> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef no_undo(flush=False):\n    \"\"\"Disable the undo queue during the context\n\n    Arguments:\n        flush (bool): When True the undo queue will be emptied when returning\n            from the context losing all undo history. Defaults to False.\n\n    \"\"\"\n    original = cmds.undoInfo(query=True, state=True)\n    keyword = 'state' if flush else 'stateWithoutFlush'\n\n    try:\n        cmds.undoInfo(**{keyword: False})\n        yield\n    finally:\n        cmds.undoInfo(**{keyword: original})\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.nodetype_exists","title":"<code>nodetype_exists(nodetype)</code>","text":"<p>Return whether node type exists in the current Maya session.</p> <p>This returns whether it's registered as a node type to maya, it does not check whether it exists in the current scene.</p> <p>Parameters:</p> Name Type Description Default <code>nodetype</code> <code>str</code> <p>The node type name to check for existence.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the node type exists, False otherwise.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def nodetype_exists(nodetype: str) -&gt; bool:\n    \"\"\"Return whether node type exists in the current Maya session.\n\n    This returns whether it's registered as a node type to maya, it does not\n    check whether it exists in the current scene.\n\n    Args:\n        nodetype (str): The node type name to check for existence.\n\n    Returns:\n        bool: True if the node type exists, False otherwise.\n    \"\"\"\n    # If the node type does not exist, Maya will raise a RuntimeError.\n    try:\n        cmds.nodeType(nodetype, isTypeName=True)\n        return True\n    except RuntimeError:\n        return False\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.pairwise","title":"<code>pairwise(iterable)</code>","text":"<p>s -&gt; (s0,s1), (s2,s3), (s4, s5), ...</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def pairwise(iterable):\n    \"\"\"s -&gt; (s0,s1), (s2,s3), (s4, s5), ...\"\"\"\n    a = iter(iterable)\n    return zip(a, a)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.panel_camera","title":"<code>panel_camera(panel, camera)</code>","text":"<p>Set modelPanel's camera during the context.</p> <p>Parameters:</p> Name Type Description Default <code>panel</code> <code>str</code> <p>modelPanel name.</p> required <code>camera</code> <code>str</code> <p>camera name.</p> required Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef panel_camera(panel, camera):\n    \"\"\"Set modelPanel's camera during the context.\n\n    Arguments:\n        panel (str): modelPanel name.\n        camera (str): camera name.\n\n    \"\"\"\n    original_camera = cmds.modelPanel(panel, query=True, camera=True)\n    try:\n        cmds.modelPanel(panel, edit=True, camera=camera)\n        yield\n    finally:\n        cmds.modelPanel(panel, edit=True, camera=original_camera)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.parent_nodes","title":"<code>parent_nodes(nodes, parent=None)</code>","text":"<p>Context manager to un-parent provided nodes and return them back.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef parent_nodes(nodes, parent=None):\n    # type: (list, str) -&gt; list\n    \"\"\"Context manager to un-parent provided nodes and return them back.\"\"\"\n\n    def _as_mdagpath(node):\n        \"\"\"Return MDagPath for node path.\"\"\"\n        if not node:\n            return\n        sel = OpenMaya.MSelectionList()\n        sel.add(node)\n        return sel.getDagPath(0)\n\n    # We can only parent dag nodes so we ensure input contains only dag nodes\n    nodes = cmds.ls(nodes, type=\"dagNode\", long=True)\n    if not nodes:\n        # opt-out early\n        yield\n        return\n\n    parent_node_path = None\n    delete_parent = False\n    if parent:\n        if not cmds.objExists(parent):\n            parent_node = cmds.createNode(\"transform\",\n                                          name=parent,\n                                          skipSelect=False)\n            delete_parent = True\n        else:\n            parent_node = parent\n        parent_node_path = cmds.ls(parent_node, long=True)[0]\n\n    # Store original parents\n    node_parents = []\n    for node in nodes:\n        node_parent = get_node_parent(node)\n        node_parents.append((_as_mdagpath(node), _as_mdagpath(node_parent)))\n\n    try:\n        for node, node_parent in node_parents:\n            node_parent_path = node_parent.fullPathName() if node_parent else None  # noqa\n            if node_parent_path == parent_node_path:\n                # Already a child\n                continue\n\n            if parent_node_path:\n                cmds.parent(node.fullPathName(), parent_node_path)\n            else:\n                cmds.parent(node.fullPathName(), world=True)\n\n        yield\n    finally:\n        # Reparent to original parents\n        for node, original_parent in node_parents:\n            node_path = node.fullPathName()\n            if not node_path:\n                # Node must have been deleted\n                continue\n\n            node_parent_path = get_node_parent(node_path)\n\n            original_parent_path = None\n            if original_parent:\n                original_parent_path = original_parent.fullPathName()\n                if not original_parent_path:\n                    # Original parent node must have been deleted\n                    continue\n\n            if node_parent_path != original_parent_path:\n                if not original_parent_path:\n                    cmds.parent(node_path, world=True)\n                else:\n                    cmds.parent(node_path, original_parent_path)\n\n        if delete_parent:\n            cmds.delete(parent_node_path)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.polyConstraint","title":"<code>polyConstraint(components, *args, **kwargs)</code>","text":"<p>Return the list of components with the constraints applied.</p> <p>A wrapper around Maya's <code>polySelectConstraint</code> to retrieve its results as a list without altering selections. For a list of possible constraints see <code>maya.cmds.polySelectConstraint</code> documentation.</p> <p>Parameters:</p> Name Type Description Default <code>components</code> <code>list</code> <p>List of components of polygon meshes</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>The list of components filtered by the given constraints.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def polyConstraint(components, *args, **kwargs):\n    \"\"\"Return the list of *components* with the constraints applied.\n\n    A wrapper around Maya's `polySelectConstraint` to retrieve its results as\n    a list without altering selections. For a list of possible constraints\n    see `maya.cmds.polySelectConstraint` documentation.\n\n    Arguments:\n        components (list): List of components of polygon meshes\n\n    Returns:\n        list: The list of components filtered by the given constraints.\n\n    \"\"\"\n\n    kwargs.pop('mode', None)\n\n    with no_undo(flush=False):\n        # Reverting selection to the original selection using\n        # `maya.cmds.select` can be slow in rare cases where previously\n        # `maya.cmds.polySelectConstraint` had set constrain to \"All and Next\"\n        # and the \"Random\" setting was activated. To work around this we\n        # revert to the original selection using the Maya API. This is safe\n        # since we're not generating any undo change anyway.\n        with tool(\"selectSuperContext\"):\n            # Selection can be very slow when in a manipulator mode.\n            # So we force the selection context which is fast.\n            with maintained_selection_api():\n                # Apply constraint using mode=2 (current and next) so\n                # it applies to the selection made before it; because just\n                # a `maya.cmds.select()` call will not trigger the constraint.\n                with reset_polySelectConstraint():\n                    cmds.select(components, r=1, noExpand=True)\n                    cmds.polySelectConstraint(*args, mode=2, **kwargs)\n                    result = cmds.ls(selection=True)\n                    cmds.select(clear=True)\n                    return result\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.prompt_reset_context","title":"<code>prompt_reset_context()</code>","text":"<p>Prompt the user what context settings to reset. This prompt is used on saving to a different task to allow the scene to get matched to the new context.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def prompt_reset_context():\n    \"\"\"Prompt the user what context settings to reset.\n    This prompt is used on saving to a different task to allow the scene to\n    get matched to the new context.\n    \"\"\"\n    # TODO: Cleanup this prototyped mess of imports and odd dialog\n    from ayon_core.tools.attribute_defs.dialog import (\n        AttributeDefinitionsDialog\n    )\n    from ayon_core.style import load_stylesheet\n    from ayon_core.lib import BoolDef, UILabelDef\n\n    definitions = [\n        UILabelDef(\n            label=(\n                \"You are saving your workfile into a different folder or task.\"\n                \"\\n\\n\"\n                \"Would you like to update some settings to the new context?\\n\"\n            )\n        ),\n        BoolDef(\n            \"fps\",\n            label=\"FPS\",\n            tooltip=\"Reset workfile FPS\",\n            default=True\n        ),\n        BoolDef(\n            \"frame_range\",\n            label=\"Frame Range\",\n            tooltip=\"Reset workfile start and end frame ranges\",\n            default=True\n        ),\n        BoolDef(\n            \"resolution\",\n            label=\"Resolution\",\n            tooltip=\"Reset workfile resolution\",\n            default=True\n        ),\n        BoolDef(\n            \"colorspace\",\n            label=\"Colorspace\",\n            tooltip=\"Reset workfile resolution\",\n            default=True\n        ),\n        BoolDef(\n            \"scene_units\",\n            label=\"Scene Units\",\n            tooltip=\"Reset Workfile Linear and Angular Scale Unit\",\n            default=True\n        ),\n        BoolDef(\n            \"instances\",\n            label=\"Publish instances\",\n            tooltip=\"Update all publish instance's folder and task to match \"\n                    \"the new folder and task\",\n            default=True\n        ),\n    ]\n\n    dialog = AttributeDefinitionsDialog(definitions)\n    dialog.setWindowTitle(\"Saving to different context.\")\n    dialog.setStyleSheet(load_stylesheet())\n    if not dialog.exec_():\n        return None\n\n    options = dialog.get_values()\n    with suspended_refresh():\n        set_context_settings(\n            fps=options[\"fps\"],\n            resolution=options[\"resolution\"],\n            frame_range=options[\"frame_range\"],\n            colorspace=options[\"colorspace\"],\n            scene_units=options[\"scene_units\"]\n        )\n        if options[\"instances\"]:\n            update_content_on_context_change()\n\n    dialog.deleteLater()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.read","title":"<code>read(node)</code>","text":"<p>Return user-defined attributes from <code>node</code></p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def read(node):\n    \"\"\"Return user-defined attributes from `node`\"\"\"\n\n    data = dict()\n\n    for attr in cmds.listAttr(node, userDefined=True) or list():\n        try:\n            value = cmds.getAttr(node + \".\" + attr, asString=True)\n\n        except RuntimeError:\n            # For Message type attribute or others that have connections,\n            # take source node name as value.\n            source = cmds.listConnections(node + \".\" + attr,\n                                          source=True,\n                                          destination=False)\n            source = cmds.ls(source, long=True) or [None]\n            value = source[0]\n\n        except ValueError:\n            # Some attributes cannot be read directly,\n            # such as mesh and color attributes. These\n            # are considered non-essential to this\n            # particular publishing pipeline.\n            value = None\n\n        data[attr] = value\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.reload_all_udim_tile_previews","title":"<code>reload_all_udim_tile_previews()</code>","text":"<p>Regenerate all UDIM tile preview in texture file</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def reload_all_udim_tile_previews():\n    \"\"\"Regenerate all UDIM tile preview in texture file\"\"\"\n    for texture_file in cmds.ls(type=\"file\"):\n        if cmds.getAttr(\"{}.uvTilingMode\".format(texture_file)) &gt; 0:\n            cmds.ogs(regenerateUVTilePreview=texture_file)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.remove_other_uv_sets","title":"<code>remove_other_uv_sets(mesh)</code>","text":"<p>Remove all other UV sets than the current UV set.</p> <p>Keep only current UV set and ensure it's the renamed to default 'map1'.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def remove_other_uv_sets(mesh):\n    \"\"\"Remove all other UV sets than the current UV set.\n\n    Keep only current UV set and ensure it's the renamed to default 'map1'.\n\n    \"\"\"\n\n    uvSets = cmds.polyUVSet(mesh, query=True, allUVSets=True)\n    current = cmds.polyUVSet(mesh, query=True, currentUVSet=True)[0]\n\n    # Copy over to map1\n    if current != 'map1':\n        cmds.polyUVSet(mesh, uvSet=current, newUVSet='map1', copy=True)\n        cmds.polyUVSet(mesh, currentUVSet=True, uvSet='map1')\n        current = 'map1'\n\n    # Delete all non-current UV sets\n    deleteUVSets = [uvSet for uvSet in uvSets if uvSet != current]\n    uvSet = None\n\n    # Maya Bug (tested in 2015/2016):\n    # In some cases the API's MFnMesh will report less UV sets than\n    # maya.cmds.polyUVSet. This seems to happen when the deletion of UV sets\n    # has not triggered a cleanup of the UVSet array attribute on the mesh\n    # node. It will still have extra entries in the attribute, though it will\n    # not show up in API or UI. Nevertheless it does show up in\n    # maya.cmds.polyUVSet. To ensure we clean up the array we'll force delete\n    # the extra remaining 'indices' that we don't want.\n\n    # TODO: Implement a better fix\n    # The best way to fix would be to get the UVSet indices from api with\n    # MFnMesh (to ensure we keep correct ones) and then only force delete the\n    # other entries in the array attribute on the node. But for now we're\n    # deleting all entries except first one. Note that the first entry could\n    # never be removed (the default 'map1' always exists and is supposed to\n    # be undeletable.)\n    try:\n        for uvSet in deleteUVSets:\n            cmds.polyUVSet(mesh, delete=True, uvSet=uvSet)\n    except RuntimeError as exc:\n        log.warning('Error uvSet: %s - %s', uvSet, exc)\n        indices = cmds.getAttr('{0}.uvSet'.format(mesh),\n                               multiIndices=True)\n        if not indices:\n            log.warning(\"No uv set found indices for: %s\", mesh)\n            return\n\n        # Delete from end to avoid shifting indices\n        # and remove the indices in the attribute\n        indices = reversed(indices[1:])\n        for i in indices:\n            attr = '{0}.uvSet[{1}]'.format(mesh, i)\n            cmds.removeMultiInstance(attr, b=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.render_capture_preset","title":"<code>render_capture_preset(preset)</code>","text":"<p>Capture playblast with a preset.</p> <p>To generate the preset use <code>generate_capture_preset</code>.</p> <p>Parameters:</p> Name Type Description Default <code>preset</code> <code>dict</code> <p>preset options</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Output path of <code>capture.capture</code></p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def render_capture_preset(preset):\n    \"\"\"Capture playblast with a preset.\n\n    To generate the preset use `generate_capture_preset`.\n\n    Args:\n        preset (dict): preset options\n\n    Returns:\n        str: Output path of `capture.capture`\n    \"\"\"\n\n    # Force a refresh at the start of the timeline\n    # TODO (Question): Why do we need to do this? What bug does it solve?\n    #   Is this for simulations?\n    cmds.refresh(force=True)\n    refresh_frame_int = int(cmds.playbackOptions(query=True, minTime=True))\n    cmds.currentTime(refresh_frame_int - 1, edit=True)\n    cmds.currentTime(refresh_frame_int, edit=True)\n    log.debug(\n        \"Using preset: {}\".format(\n            json.dumps(preset, indent=4, sort_keys=True)\n        )\n    )\n    preset = copy.deepcopy(preset)\n    # not supported by `capture` so we pop it off of the preset\n    reload_textures = preset[\"viewport_options\"].pop(\"loadTextures\", False)\n    panel = preset.pop(\"panel\")\n    with contextlib.ExitStack() as stack:\n        stack.enter_context(maintained_time())\n        stack.enter_context(panel_camera(panel, preset[\"camera\"]))\n        stack.enter_context(viewport_default_options(panel, preset))\n        if reload_textures:\n            # Force immediate texture loading when to ensure\n            # all textures have loaded before the playblast starts\n            stack.enter_context(material_loading_mode(mode=\"immediate\"))\n            # Regenerate all UDIM tiles previews\n            reload_all_udim_tile_previews()\n        path = capture.capture(log=self.log, **preset)\n\n    return path\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.renderlayer","title":"<code>renderlayer(layer)</code>","text":"<p>Set the renderlayer during the context</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>str</code> <p>Name of layer to switch to.</p> required Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef renderlayer(layer):\n    \"\"\"Set the renderlayer during the context\n\n    Arguments:\n        layer (str): Name of layer to switch to.\n\n    \"\"\"\n\n    original = cmds.editRenderLayerGlobals(query=True,\n                                           currentRenderLayer=True)\n\n    try:\n        cmds.editRenderLayerGlobals(currentRenderLayer=layer)\n        yield\n    finally:\n        cmds.editRenderLayerGlobals(currentRenderLayer=original)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.reset_frame_range","title":"<code>reset_frame_range(playback=True, render=True, fps=True, task_entity=None, project_settings=None)</code>","text":"<p>Set frame range to current folder.</p> <p>Parameters:</p> Name Type Description Default <code>playback</code> <code>(bool, Optional)</code> <p>Whether to set the maya timeline playback frame range. Defaults to True.</p> <code>True</code> <code>render</code> <code>(bool, Optional)</code> <p>Whether to set the maya render frame range. Defaults to True.</p> <code>True</code> <code>fps</code> <code>(bool, Optional)</code> <p>Whether to set scene FPS. Defaults to True.</p> <code>True</code> <code>task_entity</code> <code>dict</code> <p>Task entity to use. If not provided, the current task entity is used. This is mostly used for optimization purposes.</p> <code>None</code> <code>project_settings</code> <code>dict</code> <p>Project settings to use. If not provided, the current project settings are used. This is mostly used for optimization purposes.</p> <code>None</code> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def reset_frame_range(\n    playback=True,\n    render=True,\n    fps=True,\n    task_entity=None,\n    project_settings=None\n):\n    \"\"\"Set frame range to current folder.\n\n    Args:\n        playback (bool, Optional): Whether to set the maya timeline playback\n            frame range. Defaults to True.\n        render (bool, Optional): Whether to set the maya render frame range.\n            Defaults to True.\n        fps (bool, Optional): Whether to set scene FPS. Defaults to True.\n        task_entity (dict, optional): Task entity to use.\n            If not provided, the current task entity is used.\n            This is mostly used for optimization purposes.\n        project_settings (dict, optional): Project settings to use.\n            If not provided, the current project settings are used.\n            This is mostly used for optimization purposes.\n    \"\"\"\n    if fps:\n        set_scene_fps(get_fps_for_current_context(task_entity))\n\n    if not playback and not render:\n        return\n\n    frame_range = get_frame_range(\n        include_animation_range=True,\n        project_settings=project_settings,\n        task_entity=task_entity\n    )\n    if not frame_range:\n        # No frame range data found for folder\n        return\n\n    frame_start = frame_range[\"frameStart\"]\n    frame_end = frame_range[\"frameEnd\"]\n    animation_start = frame_range[\"animationStart\"]\n    animation_end = frame_range[\"animationEnd\"]\n\n    if playback:\n        cmds.playbackOptions(\n            minTime=frame_start,\n            maxTime=frame_end,\n            animationStartTime=animation_start,\n            animationEndTime=animation_end\n        )\n        cmds.currentTime(frame_start)\n\n    if render:\n        cmds.setAttr(\"defaultRenderGlobals.startFrame\", animation_start)\n        cmds.setAttr(\"defaultRenderGlobals.endFrame\", animation_end)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.reset_polySelectConstraint","title":"<code>reset_polySelectConstraint(reset=True)</code>","text":"<p>Context during which the given polyConstraint settings are disabled.</p> <p>The original settings are restored after the context.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef reset_polySelectConstraint(reset=True):\n    \"\"\"Context during which the given polyConstraint settings are disabled.\n\n    The original settings are restored after the context.\n\n    \"\"\"\n\n    original = cmds.polySelectConstraint(query=True, stateString=True)\n\n    try:\n        if reset:\n            # Ensure command is available in mel\n            # This can happen when running standalone\n            if not mel.eval(\"exists resetPolySelectConstraint\"):\n                mel.eval(\"source polygonConstraint\")\n\n            # Reset all parameters\n            mel.eval(\"resetPolySelectConstraint;\")\n        cmds.polySelectConstraint(disable=True)\n        yield\n    finally:\n        mel.eval(original)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.reset_scene_resolution","title":"<code>reset_scene_resolution(task_entity=None)</code>","text":"<p>Apply the scene resolution  from the project definition</p> <p>The scene resolution will be retrieved from the task entity.</p> <p>Parameters:</p> Name Type Description Default <code>task_entity</code> <code>dict</code> <p>Task entity to use. If not provided, the current task entity is used. This is mostly used for optimization purposes.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def reset_scene_resolution(task_entity=None):\n    \"\"\"Apply the scene resolution  from the project definition\n\n    The scene resolution will be retrieved from the task entity.\n\n    Arguments:\n        task_entity (dict, optional): Task entity to use.\n            If not provided, the current task entity is used.\n            This is mostly used for optimization purposes.\n\n    Returns:\n        None\n    \"\"\"\n    if task_entity is None:\n        task_entity = get_current_task_entity(\n            fields={\n                \"attrib.resolutionWidth\",\n                \"attrib.resolutionHeight\",\n                \"attrib.pixelAspect\",\n            }\n        )\n\n    task_attributes = task_entity[\"attrib\"]\n\n    # Set resolution\n    width = task_attributes.get(\"resolutionWidth\", 1920)\n    height = task_attributes.get(\"resolutionHeight\", 1080)\n    pixel_aspect = task_attributes.get(\"pixelAspect\", 1)\n\n    set_scene_resolution(width, height, pixel_aspect)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.search_textures","title":"<code>search_textures(filepath)</code>","text":"<p>Search all texture files on disk.</p> <p>This also parses to full sequences for those with dynamic patterns like  and %04d in the filename. <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The full path to the file, including any dynamic patterns like  or %04d required <p>Returns:</p> Name Type Description <code>list</code> <p>The files found on disk</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def search_textures(filepath):\n    \"\"\"Search all texture files on disk.\n\n    This also parses to full sequences for those with dynamic patterns\n    like &lt;UDIM&gt; and %04d in the filename.\n\n    Args:\n        filepath (str): The full path to the file, including any\n            dynamic patterns like &lt;UDIM&gt; or %04d\n\n    Returns:\n        list: The files found on disk\n\n    \"\"\"\n    filename = os.path.basename(filepath)\n\n    # Collect full sequence if it matches a sequence pattern\n    # For UDIM based textures (tiles)\n    if \"&lt;UDIM&gt;\" in filename:\n        sequences = get_sequence(filepath,\n                                 pattern=\"&lt;UDIM&gt;\")\n        if sequences:\n            return sequences\n\n    # Frame/time - Based textures (animated masks f.e)\n    elif \"%04d\" in filename:\n        sequences = get_sequence(filepath,\n                                 pattern=\"%04d\")\n        if sequences:\n            return sequences\n\n    # Assuming it is a fixed name (single file)\n    if os.path.exists(filepath):\n        return [filepath]\n\n    return []\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.set_attribute","title":"<code>set_attribute(attribute, value, node)</code>","text":"<p>Adjust attributes based on the value from the attribute data</p> <p>If an attribute does not exists on the target it will be added with the dataType being controlled by the value type.</p> <p>Parameters:</p> Name Type Description Default <code>attribute</code> <code>str</code> <p>name of the attribute to change</p> required <code>value</code> <p>the value to change to attribute to</p> required <code>node</code> <code>str</code> <p>name of the node</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def set_attribute(attribute, value, node):\n    \"\"\"Adjust attributes based on the value from the attribute data\n\n    If an attribute does not exists on the target it will be added with\n    the dataType being controlled by the value type.\n\n    Args:\n        attribute (str): name of the attribute to change\n        value: the value to change to attribute to\n        node (str): name of the node\n\n    Returns:\n        None\n    \"\"\"\n\n    value_type = type(value).__name__\n    kwargs = ATTRIBUTE_DICT[value_type]\n    if not cmds.attributeQuery(attribute, node=node, exists=True):\n        log.debug(\"Creating attribute '{}' on \"\n                  \"'{}'\".format(attribute, node))\n        cmds.addAttr(node, longName=attribute, **kwargs)\n\n    node_attr = \"{}.{}\".format(node, attribute)\n    enum_type = cmds.attributeQuery(attribute, node=node, enum=True)\n    if enum_type and value_type == \"str\":\n        enum_string_values = cmds.attributeQuery(\n            attribute, node=node, listEnum=True\n        )[0].split(\":\")\n        cmds.setAttr(\n            \"{}.{}\".format(node, attribute), enum_string_values.index(value)\n        )\n    elif \"dataType\" in kwargs:\n        attr_type = kwargs[\"dataType\"]\n        cmds.setAttr(node_attr, value, type=attr_type)\n    else:\n        cmds.setAttr(node_attr, value)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.set_colorspace","title":"<code>set_colorspace(project_settings=None)</code>","text":"<p>Set Colorspace from project settings.</p> <p>Parameters:</p> Name Type Description Default <code>project_settings</code> <code>dict</code> <p>Project settings to use. If not provided, the current project settings are used. This is mostly used for optimization purposes.</p> <code>None</code> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def set_colorspace(project_settings=None):\n    \"\"\"Set Colorspace from project settings.\n\n    Arguments:\n        project_settings (dict, optional): Project settings to use.\n            If not provided, the current project settings are used.\n            This is mostly used for optimization purposes.\n    \"\"\"\n    if project_settings is None:\n        project_name = get_current_project_name()\n        project_settings = get_project_settings(project_name)\n    imageio: dict = project_settings[\"maya\"][\"imageio\"]\n\n    if not imageio[\"workfile\"][\"enabled\"]:\n        log.info(\n            \"AYON Maya Color Management settings for workfile are disabled.\"\n        )\n        return\n\n    # set color spaces for rendering space and view transforms\n    def _colormanage(**kwargs):\n        \"\"\"Wrapper around `cmds.colorManagementPrefs`.\n\n        This logs errors instead of raising an error so color management\n        settings get applied as much as possible.\n\n        \"\"\"\n        assert len(kwargs) == 1, \"Must receive one keyword argument\"\n        try:\n            cmds.colorManagementPrefs(edit=True, **kwargs)\n            log.debug(\"Setting Color Management Preference: {}\".format(kwargs))\n        except RuntimeError as exc:\n            log.error(exc)\n\n    log.info(\"Setting Maya colorspace..\")\n\n    # enable color management\n    cmds.colorManagementPrefs(edit=True, cmEnabled=True)\n    cmds.colorManagementPrefs(edit=True, ocioRulesEnabled=True)\n\n    is_ocio_set = bool(os.environ.get(\"OCIO\"))\n    if not is_ocio_set:\n        # Set the Maya 2022+ default OCIO v2 config file path\n        log.info(\"Setting default Maya OCIO v2 config\")\n        # Note: Setting \"\" as value also sets this default however\n        # introduces a bug where launching a file on startup will prompt\n        # to save the empty scene before it, so we set using the path.\n        # This value has been the same for 2022, 2023 and 2024.\n        path = \"&lt;MAYA_RESOURCES&gt;/OCIO-configs/Maya2022-default/config.ocio\"\n        cmds.colorManagementPrefs(edit=True, configFilePath=path)\n\n    # set rendering space and view transform\n    _colormanage(renderingSpaceName=imageio[\"workfile\"][\"renderSpace\"])\n    _colormanage(viewName=imageio[\"workfile\"][\"viewName\"])\n    _colormanage(displayName=imageio[\"workfile\"][\"displayName\"])\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.set_context_settings","title":"<code>set_context_settings(fps=True, resolution=True, frame_range=True, colorspace=True, scene_units=True)</code>","text":"<p>Apply the project settings from the project definition</p> <p>Settings can be overwritten by an asset if the asset.data contains any information regarding those settings.</p> <p>Parameters:</p> Name Type Description Default <code>fps</code> <code>bool</code> <p>Whether to set the scene FPS.</p> <code>True</code> <code>resolution</code> <code>bool</code> <p>Whether to set the render resolution.</p> <code>True</code> <code>frame_range</code> <code>bool</code> <p>Whether to reset the time slide frame ranges.</p> <code>True</code> <code>colorspace</code> <code>bool</code> <p>Whether to reset the colorspace.</p> <code>True</code> <code>scene_units</code> <code>bool</code> <p>Whether to reset the scene units.</p> <code>True</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def set_context_settings(\n        fps=True,\n        resolution=True,\n        frame_range=True,\n        colorspace=True,\n        scene_units=True\n):\n    \"\"\"Apply the project settings from the project definition\n\n    Settings can be overwritten by an asset if the asset.data contains\n    any information regarding those settings.\n\n    Args:\n        fps (bool): Whether to set the scene FPS.\n        resolution (bool): Whether to set the render resolution.\n        frame_range (bool): Whether to reset the time slide frame ranges.\n        colorspace (bool): Whether to reset the colorspace.\n        scene_units (bool): Whether to reset the scene units.\n\n    Returns:\n        None\n\n    \"\"\"\n    project_name = get_current_project_name()\n    project_settings = get_project_settings(project_name)\n    task_entity = get_current_task_entity()\n    reset_frame_range(\n        fps=fps,\n        playback=frame_range,\n        render=frame_range,\n        project_settings=project_settings,\n        task_entity=task_entity\n    )\n    if resolution:\n        reset_scene_resolution(task_entity=task_entity)\n    if colorspace:\n        set_colorspace(project_settings=project_settings)\n    if scene_units:\n        set_scene_units(project_settings=project_settings)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.set_id","title":"<code>set_id(node, unique_id, overwrite=False)</code>","text":"<p>Add cbId to <code>node</code> unless one already exists.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>the node to add the \"cbId\" on</p> required <code>unique_id</code> <code>str</code> <p>The unique node id to assign. This should be generated by <code>generate_ids</code>.</p> required <code>overwrite</code> <code>bool</code> <p>When True overrides the current value even if <code>node</code> already has an id. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def set_id(node, unique_id, overwrite=False):\n    \"\"\"Add cbId to `node` unless one already exists.\n\n    Args:\n        node (str): the node to add the \"cbId\" on\n        unique_id (str): The unique node id to assign.\n            This should be generated by `generate_ids`.\n        overwrite (bool, optional): When True overrides the current value even\n            if `node` already has an id. Defaults to False.\n\n    Returns:\n        None\n\n    \"\"\"\n\n    exists = cmds.attributeQuery(\"cbId\", node=node, exists=True)\n\n    # Add the attribute if it does not exist yet\n    if not exists:\n        cmds.addAttr(node, longName=\"cbId\", dataType=\"string\")\n\n    # Set the value\n    if not exists or overwrite:\n        attr = \"{0}.cbId\".format(node)\n        cmds.setAttr(attr, unique_id, type=\"string\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.set_scene_fps","title":"<code>set_scene_fps(fps, update=True)</code>","text":"<p>Set FPS from project configuration</p> <p>Parameters:</p> Name Type Description Default <code>fps</code> <code>(int, float)</code> <p>desired FPS</p> required <code>update</code> <code>bool</code> <p>toggle update animation, default is True</p> <code>True</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def set_scene_fps(fps, update=True):\n    \"\"\"Set FPS from project configuration\n\n    Args:\n        fps (int, float): desired FPS\n        update(bool): toggle update animation, default is True\n\n    Returns:\n        None\n\n    \"\"\"\n\n    fps_mapping = {\n        '2': '2fps',\n        '3': '3fps',\n        '4': '4fps',\n        '5': '5fps',\n        '6': '6fps',\n        '8': '8fps',\n        '10': '10fps',\n        '12': '12fps',\n        '15': 'game',\n        '16': '16fps',\n        '24': 'film',\n        '25': 'pal',\n        '30': 'ntsc',\n        '48': 'show',\n        '50': 'palf',\n        '60': 'ntscf',\n        '23.976023976023978': '23.976fps',\n        '29.97002997002997': '29.97fps',\n        '47.952047952047955': '47.952fps',\n        '59.94005994005994': '59.94fps',\n        '44100': '44100fps',\n        '48000': '48000fps'\n    }\n\n    unit = fps_mapping.get(str(convert_to_maya_fps(fps)), None)\n    if unit is None:\n        raise ValueError(\"Unsupported FPS value: `%s`\" % fps)\n\n    # Get time slider current state\n    start_frame = cmds.playbackOptions(query=True, minTime=True)\n    end_frame = cmds.playbackOptions(query=True, maxTime=True)\n\n    # Get animation data\n    animation_start = cmds.playbackOptions(query=True, animationStartTime=True)\n    animation_end = cmds.playbackOptions(query=True, animationEndTime=True)\n\n    current_frame = cmds.currentTime(query=True)\n\n    log.info(\"Setting scene FPS to: '{}'\".format(unit))\n    cmds.currentUnit(time=unit, updateAnimation=update)\n\n    # Set time slider data back to previous state\n    cmds.playbackOptions(minTime=start_frame,\n                         maxTime=end_frame,\n                         animationStartTime=animation_start,\n                         animationEndTime=animation_end)\n\n    cmds.currentTime(current_frame, edit=True, update=True)\n\n    # Force file stated to 'modified'\n    cmds.file(modified=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.set_scene_resolution","title":"<code>set_scene_resolution(width, height, pixel_aspect)</code>","text":"<p>Set the render resolution</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>resolution width</p> required <code>height</code> <code>int</code> <p>resolution height</p> required <code>pixel_aspect</code> <code>float</code> <p>pixel aspect ratio</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def set_scene_resolution(width: int, height: int, pixel_aspect: float):\n    \"\"\"Set the render resolution\n\n    Args:\n        width (int): resolution width\n        height (int): resolution height\n        pixel_aspect (float): pixel aspect ratio\n\n    Returns:\n        None\n\n    \"\"\"\n\n    control_node = \"defaultResolution\"\n    current_renderer = cmds.getAttr(\"defaultRenderGlobals.currentRenderer\")\n    aspect_ratio_attr = \"deviceAspectRatio\"\n\n    # Give VRay a helping hand as it is slightly different from the rest\n    if current_renderer == \"vray\":\n        aspect_ratio_attr = \"aspectRatio\"\n        vray_node = \"vraySettings\"\n        if cmds.objExists(vray_node):\n            control_node = vray_node\n        else:\n            log.error(\"Can't set VRay resolution because there is no node \"\n                      \"named: `%s`\" % vray_node)\n\n    log.info(\"Setting scene resolution to: %s x %s\" % (width, height))\n    cmds.setAttr(f\"{control_node}.width\", width)\n    cmds.setAttr(f\"{control_node}.height\", height)\n\n    device_aspect_ratio: float = (\n            (float(width) / float(height)) * float(pixel_aspect)\n    )\n    cmds.setAttr(f\"{control_node}.{aspect_ratio_attr}\", device_aspect_ratio)\n    cmds.setAttr(f\"{control_node}.pixelAspect\", pixel_aspect)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.set_scene_units","title":"<code>set_scene_units(project_settings=None)</code>","text":"<p>Set the Maya scene units</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def set_scene_units(project_settings=None):\n    \"\"\"Set the Maya scene units\"\"\"\n    linear_unit, angular_unit = get_scene_units_settings(\n        project_settings=project_settings\n    )\n    cmds.currentUnit(linear=linear_unit, angle=angular_unit)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.shader","title":"<code>shader(nodes, shadingEngine='initialShadingGroup')</code>","text":"<p>Assign a shader to nodes during the context</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef shader(nodes, shadingEngine=\"initialShadingGroup\"):\n    \"\"\"Assign a shader to nodes during the context\"\"\"\n\n    shapes = cmds.ls(nodes, dag=1, objectsOnly=1, shapes=1, long=1)\n    original = get_shader_assignments_from_shapes(shapes)\n\n    try:\n        # Assign override shader\n        if shapes:\n            cmds.sets(shapes, edit=True, forceElement=shadingEngine)\n        yield\n    finally:\n\n        # Assign original shaders\n        for sg, members in original.items():\n            if members:\n                cmds.sets(members, edit=True, forceElement=sg)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.strip_namespace","title":"<code>strip_namespace(node, namespace)</code>","text":"<p>Strip given namespace from node path.</p> <p>The namespace will only be stripped from names if it starts with that namespace. If the namespace occurs within another namespace it's not removed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; strip_namespace(\"namespace:node\", namespace=\"namespace:\")\n\"node\"\n&gt;&gt;&gt; strip_namespace(\"hello:world:node\", namespace=\"hello:world\")\n\"node\"\n&gt;&gt;&gt; strip_namespace(\"hello:world:node\", namespace=\"hello\")\n\"world:node\"\n&gt;&gt;&gt; strip_namespace(\"hello:world:node\", namespace=\"world\")\n\"hello:world:node\"\n&gt;&gt;&gt; strip_namespace(\"ns:group|ns:node\", namespace=\"ns\")\n\"group|node\"\n</code></pre> <p>Returns:</p> Name Type Description <code>str</code> <p>Node name without given starting namespace.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def strip_namespace(node, namespace):\n    \"\"\"Strip given namespace from node path.\n\n    The namespace will only be stripped from names\n    if it starts with that namespace. If the namespace\n    occurs within another namespace it's not removed.\n\n    Examples:\n        &gt;&gt;&gt; strip_namespace(\"namespace:node\", namespace=\"namespace:\")\n        \"node\"\n        &gt;&gt;&gt; strip_namespace(\"hello:world:node\", namespace=\"hello:world\")\n        \"node\"\n        &gt;&gt;&gt; strip_namespace(\"hello:world:node\", namespace=\"hello\")\n        \"world:node\"\n        &gt;&gt;&gt; strip_namespace(\"hello:world:node\", namespace=\"world\")\n        \"hello:world:node\"\n        &gt;&gt;&gt; strip_namespace(\"ns:group|ns:node\", namespace=\"ns\")\n        \"group|node\"\n\n    Returns:\n        str: Node name without given starting namespace.\n\n    \"\"\"\n\n    # Ensure namespace ends with `:`\n    if not namespace.endswith(\":\"):\n        namespace = \"{}:\".format(namespace)\n\n    # The long path for a node can also have the namespace\n    # in its parents so we need to remove it from each\n    return \"|\".join(\n        name[len(namespace):] if name.startswith(namespace) else name\n        for name in node.split(\"|\")\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.suspended_refresh","title":"<code>suspended_refresh(suspend=True)</code>","text":"<p>Suspend viewport refreshes</p> <p>cmds.ogs(pause=True) is a toggle so we can't pass False.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef suspended_refresh(suspend=True):\n    \"\"\"Suspend viewport refreshes\n\n    cmds.ogs(pause=True) is a toggle so we can't pass False.\n    \"\"\"\n    if IS_HEADLESS:\n        yield\n        return\n\n    original_state = cmds.ogs(query=True, pause=True)\n    try:\n        if suspend and not original_state:\n            cmds.ogs(pause=True)\n        yield\n    finally:\n        if suspend and not original_state:\n            cmds.ogs(pause=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.tool","title":"<code>tool(context)</code>","text":"<p>Set a tool context during the context manager.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef tool(context):\n    \"\"\"Set a tool context during the context manager.\n\n    \"\"\"\n    original = cmds.currentCtx()\n    try:\n        cmds.setToolTo(context)\n        yield\n    finally:\n        cmds.setToolTo(original)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.undo_chunk","title":"<code>undo_chunk()</code>","text":"<p>Open a undo chunk during context.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef undo_chunk():\n    \"\"\"Open a undo chunk during context.\"\"\"\n\n    try:\n        cmds.undoInfo(openChunk=True)\n        yield\n    finally:\n        cmds.undoInfo(closeChunk=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.unique_namespace","title":"<code>unique_namespace(namespace, format='%02d', prefix='', suffix='')</code>","text":"<p>Return unique namespace</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str</code> <p>Name of namespace to consider</p> required <code>format</code> <code>str</code> <p>Formatting of the given iteration number</p> <code>'%02d'</code> <code>suffix</code> <code>str</code> <p>Only consider namespaces with this suffix.</p> <code>''</code> <p>unique_namespace(\"bar\")</p>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.unique_namespace--bar01","title":"bar01","text":"<p>unique_namespace(\":hello\")</p>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.unique_namespace--hello01","title":":hello01","text":"<p>unique_namespace(\"bar:\", suffix=\"_NS\")</p>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.unique_namespace--bar01_ns","title":"bar01_NS:","text":"Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def unique_namespace(namespace, format=\"%02d\", prefix=\"\", suffix=\"\"):\n    \"\"\"Return unique namespace\n\n    Arguments:\n        namespace (str): Name of namespace to consider\n        format (str, optional): Formatting of the given iteration number\n        suffix (str, optional): Only consider namespaces with this suffix.\n\n    &gt;&gt;&gt; unique_namespace(\"bar\")\n    # bar01\n    &gt;&gt;&gt; unique_namespace(\":hello\")\n    # :hello01\n    &gt;&gt;&gt; unique_namespace(\"bar:\", suffix=\"_NS\")\n    # bar01_NS:\n\n    \"\"\"\n\n    def current_namespace():\n        current = cmds.namespaceInfo(currentNamespace=True,\n                                     absoluteName=True)\n        # When inside a namespace Maya adds no trailing :\n        if not current.endswith(\":\"):\n            current += \":\"\n        return current\n\n    # Always check against the absolute namespace root\n    # There's no clash with :x if we're defining namespace :a:x\n    ROOT = \":\" if namespace.startswith(\":\") else current_namespace()\n\n    # Strip trailing `:` tokens since we might want to add a suffix\n    start = \":\" if namespace.startswith(\":\") else \"\"\n    end = \":\" if namespace.endswith(\":\") else \"\"\n    namespace = namespace.strip(\":\")\n    if \":\" in namespace:\n        # Split off any nesting that we don't uniqify anyway.\n        parents, namespace = namespace.rsplit(\":\", 1)\n        start += parents + \":\"\n        ROOT += start\n\n    def exists(n):\n        # Check for clash with nodes and namespaces\n        fullpath = ROOT + n\n        return cmds.objExists(fullpath) or cmds.namespace(exists=fullpath)\n\n    iteration = 1\n    while True:\n        nr_namespace = namespace + format % iteration\n        unique = prefix + nr_namespace + suffix\n\n        if not exists(unique):\n            return start + unique + end\n\n        iteration += 1\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.unlocked","title":"<code>unlocked(node)</code>","text":"<p>Unlock a node for the duration of the context.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>The name of the node to unlock.</p> required Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef unlocked(node):\n    \"\"\"Unlock a node for the duration of the context.\n\n    Args:\n        node (str): The name of the node to unlock.\n    \"\"\"\n    has_locked = cmds.lockNode(node, query=True, lock=True)[0]\n    cmds.lockNode(node, lock=False)\n\n    try:\n        yield\n\n    finally:\n        cmds.lockNode(node, lock=has_locked)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.update_content_on_context_change","title":"<code>update_content_on_context_change()</code>","text":"<p>This will update scene content to match new folder on context change</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def update_content_on_context_change():\n    \"\"\"\n    This will update scene content to match new folder on context change\n    \"\"\"\n\n    host = registered_host()\n    create_context = CreateContext(host, discover_publish_plugins=False)\n    task_entity = create_context.get_current_task_entity()\n\n    instance_values = {\n        \"folderPath\": create_context.get_current_folder_path(),\n        \"task\": task_entity[\"name\"],\n    }\n    creator_attribute_values = {\n        \"frameStart\": float(task_entity[\"attrib\"][\"frameStart\"]),\n        \"frameEnd\": float(task_entity[\"attrib\"][\"frameEnd\"]),\n        \"handleStart\": float(task_entity[\"attrib\"][\"handleStart\"]),\n        \"handleEnd\": float(task_entity[\"attrib\"][\"handleEnd\"]),\n    }\n\n    has_changes = False\n    for instance in create_context.instances:\n        for key, value in instance_values.items():\n            if key not in instance or instance[key] == value:\n                continue\n\n            # Update instance value\n            print(f\"Updating {instance.product_name} {key} to: {value}\")\n            instance[key] = value\n            has_changes = True\n\n        creator_attributes = instance.creator_attributes\n        for key, value in creator_attribute_values.items():\n            if (\n                    key not in creator_attributes\n                    or creator_attributes[key] == value\n            ):\n                continue\n\n            # Update instance creator attribute value\n            print(f\"Updating {instance.product_name} {key} to: {value}\")\n            creator_attributes[key] = value\n            has_changes = True\n\n    if has_changes:\n        create_context.save_changes()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.validate_fps","title":"<code>validate_fps()</code>","text":"<p>Validate current scene FPS and show pop-up when it is incorrect</p> <p>Returns:</p> Type Description <p>bool</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def validate_fps():\n    \"\"\"Validate current scene FPS and show pop-up when it is incorrect\n\n    Returns:\n        bool\n\n    \"\"\"\n\n    expected_fps = get_fps_for_current_context()\n    current_fps = mel.eval(\"currentTimeUnitToFPS()\")\n\n    fps_match = current_fps == expected_fps\n    if not fps_match and not IS_HEADLESS:\n        from ayon_core.tools.utils import PopupUpdateKeys\n\n        parent = get_main_window()\n\n        dialog = PopupUpdateKeys(parent=parent)\n        dialog.setModal(True)\n        dialog.setWindowTitle(\"Maya scene does not match project FPS\")\n        dialog.set_message(\n            \"Scene {} FPS does not match project {} FPS\".format(\n                current_fps, expected_fps\n            )\n        )\n        dialog.set_button_text(\"Fix\")\n\n        # Set new text for button (add optional argument for the popup?)\n        def on_click(update):\n            set_scene_fps(expected_fps, update)\n\n        dialog.on_clicked_state.connect(on_click)\n        dialog.show()\n\n        return False\n\n    return fps_match\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.validate_scene_units","title":"<code>validate_scene_units()</code>","text":"<p>Validate whether scene units match AYON settings</p> <p>If not headless and it does not match, a pop-up dialog is shown to the user with a choice to fix it automatically.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether Maya scene units matches preferences from AYON settings</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def validate_scene_units() -&gt; bool:\n    \"\"\"Validate whether scene units match AYON settings\n\n    If not headless and it does not match, a pop-up dialog is\n    shown to the user with a choice to fix it automatically.\n\n    Returns:\n        bool: Whether Maya scene units matches preferences from AYON settings\n    \"\"\"\n    linear_unit, angular_unit = get_scene_units_settings()\n    current_linear_unit = cmds.currentUnit(query=True, linear=True)\n    current_angular_unit = cmds.currentUnit(query=True, angle=True)\n    unit_match = (\n        current_linear_unit == linear_unit and\n        current_angular_unit == angular_unit\n    )\n    if not unit_match and not IS_HEADLESS:\n        from ayon_core.tools.utils import PopupUpdateKeys\n\n        parent = get_main_window()\n\n        dialog = PopupUpdateKeys(parent=parent)\n        dialog.setModal(True)\n        dialog.setWindowTitle(\"Maya scene does not match project scene units\")\n        message = (\n            f\"Scene units ({current_linear_unit},\"\n            f\"{current_angular_unit}) does not match \"\n            f\"project scene units ({linear_unit}, {angular_unit})\"\n        )\n        dialog.set_message(message)\n        dialog.set_button_text(\"Fix\")\n\n        # Set new text for button (add optional argument for the popup?)\n        def on_click():\n            set_scene_units()\n\n        dialog.on_clicked_state.connect(on_click)\n        dialog.show()\n\n        return False\n    return unit_match\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.viewport_default_options","title":"<code>viewport_default_options(panel, preset)</code>","text":"<p>Context manager used by <code>render_capture_preset</code>.</p> <p>We need to explicitly enable some viewport changes so the viewport is refreshed ahead of playblasting.</p> Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef viewport_default_options(panel, preset):\n    \"\"\"Context manager used by `render_capture_preset`.\n\n    We need to explicitly enable some viewport changes so the viewport is\n    refreshed ahead of playblasting.\n\n    \"\"\"\n    # TODO: Clarify in the docstring WHY we need to set it ahead of\n    #  playblasting. What issues does it solve?\n    viewport_defaults = {}\n    try:\n        keys = [\n            \"useDefaultMaterial\",\n            \"wireframeOnShaded\",\n            \"xray\",\n            \"jointXray\",\n            \"backfaceCulling\",\n            \"textures\"\n        ]\n        for key in keys:\n            viewport_defaults[key] = cmds.modelEditor(\n                panel, query=True, **{key: True}\n            )\n            if preset[\"viewport_options\"].get(key):\n                cmds.modelEditor(\n                    panel, edit=True, **{key: True}\n                )\n        yield\n    finally:\n        # Restoring viewport options.\n        if viewport_defaults:\n            cmds.modelEditor(\n                panel, edit=True, **viewport_defaults\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib.html#client.ayon_maya.api.lib.write_xgen_file","title":"<code>write_xgen_file(data, filepath)</code>","text":"<p>Overwrites data in .xgen files.</p> <p>Quite naive approach to mainly overwrite \"xgDataPath\" and \"xgProjectPath\".</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary of key, value. Key matches with xgen file.</p> required <code>For example</code> <p>{\"xgDataPath\": \"some/path\"}</p> required <code>filepath</code> <code>string</code> <p>Absolute path of .xgen file.</p> required Source code in <code>client/ayon_maya/api/lib.py</code> <pre><code>def write_xgen_file(data, filepath):\n    \"\"\"Overwrites data in .xgen files.\n\n    Quite naive approach to mainly overwrite \"xgDataPath\" and \"xgProjectPath\".\n\n    Args:\n        data (dict): Dictionary of key, value. Key matches with xgen file.\n        For example:\n            {\"xgDataPath\": \"some/path\"}\n        filepath (string): Absolute path of .xgen file.\n    \"\"\"\n    # Generate regex lookup for line to key basically\n    # match any of the keys in `\\t{key}\\t\\t`\n    keys = \"|\".join(re.escape(key) for key in data.keys())\n    re_keys = re.compile(\"^\\t({})\\t\\t\".format(keys))\n\n    lines = []\n    with open(filepath, \"r\") as f:\n        for line in f:\n            match = re_keys.match(line)\n            if match:\n                key = match.group(1)\n                value = data[key]\n                line = \"\\t{}\\t\\t{}\\n\".format(key, value)\n\n            lines.append(line)\n\n    with open(filepath, \"w\") as f:\n        f.writelines(lines)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html","title":"lib_renderproducts","text":"<p>Module handling expected render output from Maya.</p> <p>This module is used in :mod:<code>collect_render</code> and :mod:<code>collect_vray_scene</code>.</p> Note <p>To implement new renderer, just create new class inheriting from :class:<code>ARenderProducts</code> and add it to :func:<code>RenderProducts.get()</code>.</p> <p>Attributes:</p> Name Type Description <code>R_SINGLE_FRAME</code> <p>class:<code>re.Pattern</code>): Find single frame number.</p> <code>R_FRAME_RANGE</code> <p>class:<code>re.Pattern</code>): Find frame range.</p> <code>R_FRAME_NUMBER</code> <p>class:<code>re.Pattern</code>): Find frame number in string.</p> <code>R_LAYER_TOKEN</code> <p>class:<code>re.Pattern</code>): Find layer token in image prefixes.</p> <code>R_AOV_TOKEN</code> <p>class:<code>re.Pattern</code>): Find AOV token in image prefixes.</p> <code>R_SUBSTITUTE_AOV_TOKEN</code> <p>class:<code>re.Pattern</code>): Find and substitute AOV token in image prefixes.</p> <code>R_REMOVE_AOV_TOKEN</code> <p>class:<code>re.Pattern</code>): Find and remove AOV token in image prefixes.</p> <code>R_CLEAN_FRAME_TOKEN</code> <p>class:<code>re.Pattern</code>): Find and remove unfilled Renderman frame token in image prefix.</p> <code>R_CLEAN_EXT_TOKEN</code> <p>class:<code>re.Pattern</code>): Find and remove unfilled Renderman extension token in image prefix.</p> <code>R_SUBSTITUTE_LAYER_TOKEN</code> <p>class:<code>re.Pattern</code>): Find and substitute render layer token in image prefixes.</p> <code>R_SUBSTITUTE_SCENE_TOKEN</code> <p>class:<code>re.Pattern</code>): Find and substitute scene token in image prefixes.</p> <code>R_SUBSTITUTE_CAMERA_TOKEN</code> <p>class:<code>re.Pattern</code>): Find and substitute camera token in image prefixes.</p> <code>IMAGE_PREFIXES</code> <code>dict</code> <p>Mapping between renderers and their respective image prefix attribute names.</p> Thanks <p>Roy Nieterau (BigRoy) / Colorbleed for overhaul of original expected_files.</p>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.AOVError","title":"<code>AOVError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception for determining AOVs.</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>class AOVError(Exception):\n    \"\"\"Custom exception for determining AOVs.\"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.ARenderProducts","title":"<code>ARenderProducts</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class with common code for all renderers.</p> <p>Attributes:</p> Name Type Description <code>renderer</code> <code>str</code> <p>name of renderer.</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>class ARenderProducts(ABC):\n    \"\"\"Abstract class with common code for all renderers.\n\n    Attributes:\n        renderer (str): name of renderer.\n\n    \"\"\"\n\n    renderer = None\n\n    def __init__(self, layer, render_instance):\n        \"\"\"Constructor.\"\"\"\n        self.layer = layer\n        self.render_instance = render_instance\n        self.multipart = self.get_multipart()\n\n        # Initialize\n        self.layer_data = self._get_layer_data()\n        self.layer_data.products = self.get_render_products()\n\n    def get_multipart(self):\n        raise NotImplementedError(\n            \"The render product implementation does not have a \"\n            \"\\\"get_multipart\\\" method.\"\n        )\n\n    def has_camera_token(self):\n        # type: () -&gt; bool\n        \"\"\"Check if camera token is in image prefix.\n\n        Returns:\n            bool: True/False if camera token is present.\n\n        \"\"\"\n        return \"&lt;camera&gt;\" in self.layer_data.filePrefix.lower()\n\n    @abstractmethod\n    def get_render_products(self):\n        \"\"\"To be implemented by renderer class.\n\n        This should return a list of RenderProducts.\n\n        Returns:\n            list[RenderProduct]: List of render products.\n\n        \"\"\"\n\n    @staticmethod\n    def sanitize_camera_name(camera):\n        # type: (str) -&gt; str\n        \"\"\"Sanitize camera name.\n\n        Remove Maya illegal characters from camera name.\n\n        Args:\n            camera (str): Maya camera name.\n\n        Returns:\n            str: sanitized camera name\n\n        Example:\n            &gt;&gt;&gt; ARenderProducts.sanizite_camera_name('test:camera_01')\n            test_camera_01\n\n        \"\"\"\n        return re.sub('[^0-9a-zA-Z_]+', '_', camera)\n\n    def get_renderer_prefix(self):\n        # type: () -&gt; str\n        \"\"\"Return prefix for specific renderer.\n\n        This is for most renderers the same and can be overridden if needed.\n\n        Returns:\n            str: String with image prefix containing tokens\n\n        Raises:\n            :exc:`UnsupportedRendererException`: If we requested image\n                prefix for renderer we know nothing about.\n                See :data:`IMAGE_PREFIXES` for mapping of renderers and\n                image prefixes.\n\n        \"\"\"\n        try:\n            prefix_attr = IMAGE_PREFIXES[self.renderer]\n        except KeyError:\n            raise UnsupportedRendererException(\n                \"Unsupported renderer {}\".format(self.renderer)\n            )\n\n        # Note: When this attribute is never set (e.g. on maya launch) then\n        # this can return None even though it is a string attribute\n        prefix = self._get_attr(prefix_attr)\n\n        if not prefix:\n            # Fall back to scene name by default\n            log.warning(\"Image prefix not set, using &lt;Scene&gt;\")\n            prefix = \"&lt;Scene&gt;\"\n\n        return prefix\n\n    def get_render_attribute(self, attribute):\n        \"\"\"Get attribute from render options.\n\n        Args:\n            attribute (str): name of attribute to be looked up.\n\n        Returns:\n            Any: Attribute value\n\n        \"\"\"\n        return self._get_attr(\"defaultRenderGlobals\", attribute)\n\n    def _get_attr(self, node_attr, attribute=None, as_string=True):\n        \"\"\"Return the value of the attribute in the renderlayer\n\n        For readability this allows passing in the attribute in two ways.\n\n            As a single argument:\n                _get_attr(\"node.attr\")\n            Or as two arguments:\n                _get_attr(\"node\", \"attr\")\n\n        Returns:\n            Value of the attribute inside the layer this instance is set to.\n\n        \"\"\"\n\n        if attribute is None:\n            plug = node_attr\n        else:\n            plug = \"{}.{}\".format(node_attr, attribute)\n\n        return lib.get_attr_in_layer(plug, layer=self.layer, as_string=as_string)\n\n    @staticmethod\n    def extract_separator(file_prefix):\n        \"\"\"Extract AOV separator character from the prefix.\n\n        Default behavior extracts the part between\n        last occurrences of &lt;RenderLayer&gt; and &lt;RenderPass&gt;\n\n        Todo:\n            This code also triggers for V-Ray which overrides it explicitly\n            so this code will invalidly debug log it couldn't extract the\n            AOV separator even though it does set it in RenderProductsVray.\n\n        Args:\n            file_prefix (str): File prefix with tokens.\n\n        Returns:\n            str or None: prefix character if it can be extracted.\n        \"\"\"\n        layer_tokens = [\"&lt;renderlayer&gt;\", \"&lt;layer&gt;\"]\n        aov_tokens = [\"&lt;aov&gt;\", \"&lt;renderpass&gt;\"]\n\n        def match_last(tokens, text):\n            \"\"\"regex match the last occurrence from a list of tokens\"\"\"\n            pattern = \"(?:.*)({})\".format(\"|\".join(tokens))\n            return re.search(pattern, text, re.IGNORECASE)\n\n        layer_match = match_last(layer_tokens, file_prefix)\n        aov_match = match_last(aov_tokens, file_prefix)\n        separator = None\n        if layer_match and aov_match:\n            matches = sorted((layer_match, aov_match),\n                             key=lambda match: match.end(1))\n            separator = file_prefix[matches[0].end(1):matches[1].start(1)]\n        return separator\n\n    def _get_layer_data(self):\n        # type: () -&gt; LayerMetadata\n        #                      ______________________________________________\n        # ____________________/ ____________________________________________/\n        # 1 -  get scene name  /__________________/\n        # ____________________/\n        _, scene_basename = os.path.split(cmds.file(q=True, loc=True))\n        scene_name, _ = os.path.splitext(scene_basename)\n        kwargs = {}\n        file_prefix = self.get_renderer_prefix()\n\n        # If the Render Layer belongs to a Render Setup layer then the\n        # output name is based on the Render Setup Layer name without\n        # the `rs_` prefix.\n        layer_name = self.layer\n        rs_layer = lib_rendersetup.get_rendersetup_layer(layer_name)\n        if rs_layer:\n            layer_name = rs_layer\n\n        if self.layer == \"defaultRenderLayer\":\n            # defaultRenderLayer renders as masterLayer\n            layer_name = \"masterLayer\"\n\n        separator = self.extract_separator(file_prefix)\n        if separator:\n            kwargs[\"aov_separator\"] = separator\n        else:\n            log.debug(\"Couldn't extract aov separator from \"\n                      \"file prefix: {}\".format(file_prefix))\n\n        # todo: Support Custom Frames sequences 0,5-10,100-120\n        #       Deadline allows submitting renders with a custom frame list\n        #       to support those cases we might want to allow 'custom frames'\n        #       to be overridden to `ExpectFiles` class?\n        return LayerMetadata(\n            frameStart=int(self.get_render_attribute(\"startFrame\")),\n            frameEnd=int(self.get_render_attribute(\"endFrame\")),\n            frameStep=int(self.get_render_attribute(\"byFrameStep\")),\n            padding=int(self.get_render_attribute(\"extensionPadding\")),\n            # if we have &lt;camera&gt; token in prefix path we'll expect output for\n            # every renderable camera in layer.\n            cameras=self.get_renderable_cameras(),\n            sceneName=scene_name,\n            layerName=layer_name,\n            renderer=self.renderer,\n            defaultExt=self._get_attr(\"defaultRenderGlobals.imfPluginKey\"),\n            filePrefix=file_prefix,\n            **kwargs\n        )\n\n    def _generate_file_sequence(\n            self, layer_data,\n            force_aov_name=None,\n            force_ext=None,\n            force_cameras=None):\n        # type: (LayerMetadata, str, str, list) -&gt; list\n        expected_files = []\n        cameras = force_cameras or layer_data.cameras\n        ext = force_ext or layer_data.defaultExt\n        for cam in cameras:\n            file_prefix = layer_data.filePrefix\n            mappings = (\n                (R_SUBSTITUTE_SCENE_TOKEN, layer_data.sceneName),\n                (R_SUBSTITUTE_LAYER_TOKEN, layer_data.layerName),\n                (R_SUBSTITUTE_CAMERA_TOKEN, self.sanitize_camera_name(cam)),\n                # this is required to remove unfilled aov token, for example\n                # in Redshift\n                (R_REMOVE_AOV_TOKEN, \"\") if not force_aov_name \\\n                else (R_SUBSTITUTE_AOV_TOKEN, force_aov_name),\n\n                (R_CLEAN_FRAME_TOKEN, \"\"),\n                (R_CLEAN_EXT_TOKEN, \"\"),\n            )\n\n            for regex, value in mappings:\n                file_prefix = re.sub(regex, value, file_prefix)\n\n            for frame in range(\n                    int(layer_data.frameStart),\n                    int(layer_data.frameEnd) + 1,\n                    int(layer_data.frameStep),\n            ):\n                frame_str = str(frame).rjust(layer_data.padding, \"0\")\n                expected_files.append(\n                    \"{}.{}.{}\".format(file_prefix, frame_str, ext)\n                )\n        return expected_files\n\n    def get_files(self, product):\n        # type: (RenderProduct) -&gt; list[str]\n        \"\"\"Return list of expected files.\n\n        It will translate render token strings  ('&lt;RenderPass&gt;', etc.) to\n        their values. This task is tricky as every renderer deals with this\n        differently. That's why we expose `get_files` as a method on the\n        Renderer class so it can be overridden for complex cases.\n\n        Args:\n            product (RenderProduct): Render product to be used for file\n                generation.\n\n        Returns:\n            list[str]: List of files\n\n        \"\"\"\n        return self._generate_file_sequence(\n            self.layer_data,\n            force_aov_name=product.productName,\n            force_ext=product.ext,\n            force_cameras=[product.camera]\n        )\n\n    def get_renderable_cameras(self):\n        # type: () -&gt; list\n        \"\"\"Get all renderable camera transforms.\n\n        Returns:\n            list: list of renderable cameras.\n\n        \"\"\"\n\n        renderable_cameras = [\n            cam for cam in cmds.ls(cameras=True)\n            if self._get_attr(cam, \"renderable\")\n        ]\n\n        # The output produces a sanitized name for &lt;Camera&gt; using its\n        # shortest unique path of the transform so we'll return\n        # at least that unique path. This could include a parent\n        # name too when two cameras have the same name but are\n        # in a different hierarchy, e.g. \"group1|cam\" and \"group2|cam\"\n        def get_name(camera):\n            return cmds.ls(cmds.listRelatives(camera,\n                                              parent=True,\n                                              fullPath=True))[0]\n\n        return [get_name(cam) for cam in renderable_cameras]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.ARenderProducts.__init__","title":"<code>__init__(layer, render_instance)</code>","text":"<p>Constructor.</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>def __init__(self, layer, render_instance):\n    \"\"\"Constructor.\"\"\"\n    self.layer = layer\n    self.render_instance = render_instance\n    self.multipart = self.get_multipart()\n\n    # Initialize\n    self.layer_data = self._get_layer_data()\n    self.layer_data.products = self.get_render_products()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.ARenderProducts.extract_separator","title":"<code>extract_separator(file_prefix)</code>  <code>staticmethod</code>","text":"<p>Extract AOV separator character from the prefix.</p> <p>Default behavior extracts the part between last occurrences of  and  Todo <p>This code also triggers for V-Ray which overrides it explicitly so this code will invalidly debug log it couldn't extract the AOV separator even though it does set it in RenderProductsVray.</p> <p>Parameters:</p> Name Type Description Default <code>file_prefix</code> <code>str</code> <p>File prefix with tokens.</p> required <p>Returns:</p> Type Description <p>str or None: prefix character if it can be extracted.</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>@staticmethod\ndef extract_separator(file_prefix):\n    \"\"\"Extract AOV separator character from the prefix.\n\n    Default behavior extracts the part between\n    last occurrences of &lt;RenderLayer&gt; and &lt;RenderPass&gt;\n\n    Todo:\n        This code also triggers for V-Ray which overrides it explicitly\n        so this code will invalidly debug log it couldn't extract the\n        AOV separator even though it does set it in RenderProductsVray.\n\n    Args:\n        file_prefix (str): File prefix with tokens.\n\n    Returns:\n        str or None: prefix character if it can be extracted.\n    \"\"\"\n    layer_tokens = [\"&lt;renderlayer&gt;\", \"&lt;layer&gt;\"]\n    aov_tokens = [\"&lt;aov&gt;\", \"&lt;renderpass&gt;\"]\n\n    def match_last(tokens, text):\n        \"\"\"regex match the last occurrence from a list of tokens\"\"\"\n        pattern = \"(?:.*)({})\".format(\"|\".join(tokens))\n        return re.search(pattern, text, re.IGNORECASE)\n\n    layer_match = match_last(layer_tokens, file_prefix)\n    aov_match = match_last(aov_tokens, file_prefix)\n    separator = None\n    if layer_match and aov_match:\n        matches = sorted((layer_match, aov_match),\n                         key=lambda match: match.end(1))\n        separator = file_prefix[matches[0].end(1):matches[1].start(1)]\n    return separator\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.ARenderProducts.get_files","title":"<code>get_files(product)</code>","text":"<p>Return list of expected files.</p> <p>It will translate render token strings  ('', etc.) to their values. This task is tricky as every renderer deals with this differently. That's why we expose <code>get_files</code> as a method on the Renderer class so it can be overridden for complex cases. <p>Parameters:</p> Name Type Description Default <code>product</code> <code>RenderProduct</code> <p>Render product to be used for file generation.</p> required <p>Returns:</p> Type Description <p>list[str]: List of files</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>def get_files(self, product):\n    # type: (RenderProduct) -&gt; list[str]\n    \"\"\"Return list of expected files.\n\n    It will translate render token strings  ('&lt;RenderPass&gt;', etc.) to\n    their values. This task is tricky as every renderer deals with this\n    differently. That's why we expose `get_files` as a method on the\n    Renderer class so it can be overridden for complex cases.\n\n    Args:\n        product (RenderProduct): Render product to be used for file\n            generation.\n\n    Returns:\n        list[str]: List of files\n\n    \"\"\"\n    return self._generate_file_sequence(\n        self.layer_data,\n        force_aov_name=product.productName,\n        force_ext=product.ext,\n        force_cameras=[product.camera]\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.ARenderProducts.get_render_attribute","title":"<code>get_render_attribute(attribute)</code>","text":"<p>Get attribute from render options.</p> <p>Parameters:</p> Name Type Description Default <code>attribute</code> <code>str</code> <p>name of attribute to be looked up.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>Attribute value</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>def get_render_attribute(self, attribute):\n    \"\"\"Get attribute from render options.\n\n    Args:\n        attribute (str): name of attribute to be looked up.\n\n    Returns:\n        Any: Attribute value\n\n    \"\"\"\n    return self._get_attr(\"defaultRenderGlobals\", attribute)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.ARenderProducts.get_render_products","title":"<code>get_render_products()</code>  <code>abstractmethod</code>","text":"<p>To be implemented by renderer class.</p> <p>This should return a list of RenderProducts.</p> <p>Returns:</p> Type Description <p>list[RenderProduct]: List of render products.</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>@abstractmethod\ndef get_render_products(self):\n    \"\"\"To be implemented by renderer class.\n\n    This should return a list of RenderProducts.\n\n    Returns:\n        list[RenderProduct]: List of render products.\n\n    \"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.ARenderProducts.get_renderable_cameras","title":"<code>get_renderable_cameras()</code>","text":"<p>Get all renderable camera transforms.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>list of renderable cameras.</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>def get_renderable_cameras(self):\n    # type: () -&gt; list\n    \"\"\"Get all renderable camera transforms.\n\n    Returns:\n        list: list of renderable cameras.\n\n    \"\"\"\n\n    renderable_cameras = [\n        cam for cam in cmds.ls(cameras=True)\n        if self._get_attr(cam, \"renderable\")\n    ]\n\n    # The output produces a sanitized name for &lt;Camera&gt; using its\n    # shortest unique path of the transform so we'll return\n    # at least that unique path. This could include a parent\n    # name too when two cameras have the same name but are\n    # in a different hierarchy, e.g. \"group1|cam\" and \"group2|cam\"\n    def get_name(camera):\n        return cmds.ls(cmds.listRelatives(camera,\n                                          parent=True,\n                                          fullPath=True))[0]\n\n    return [get_name(cam) for cam in renderable_cameras]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.ARenderProducts.get_renderer_prefix","title":"<code>get_renderer_prefix()</code>","text":"<p>Return prefix for specific renderer.</p> <p>This is for most renderers the same and can be overridden if needed.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>String with image prefix containing tokens</p> <p>Raises:</p> Type Description <p>exc:<code>UnsupportedRendererException</code>: If we requested image prefix for renderer we know nothing about. See :data:<code>IMAGE_PREFIXES</code> for mapping of renderers and image prefixes.</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>def get_renderer_prefix(self):\n    # type: () -&gt; str\n    \"\"\"Return prefix for specific renderer.\n\n    This is for most renderers the same and can be overridden if needed.\n\n    Returns:\n        str: String with image prefix containing tokens\n\n    Raises:\n        :exc:`UnsupportedRendererException`: If we requested image\n            prefix for renderer we know nothing about.\n            See :data:`IMAGE_PREFIXES` for mapping of renderers and\n            image prefixes.\n\n    \"\"\"\n    try:\n        prefix_attr = IMAGE_PREFIXES[self.renderer]\n    except KeyError:\n        raise UnsupportedRendererException(\n            \"Unsupported renderer {}\".format(self.renderer)\n        )\n\n    # Note: When this attribute is never set (e.g. on maya launch) then\n    # this can return None even though it is a string attribute\n    prefix = self._get_attr(prefix_attr)\n\n    if not prefix:\n        # Fall back to scene name by default\n        log.warning(\"Image prefix not set, using &lt;Scene&gt;\")\n        prefix = \"&lt;Scene&gt;\"\n\n    return prefix\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.ARenderProducts.has_camera_token","title":"<code>has_camera_token()</code>","text":"<p>Check if camera token is in image prefix.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True/False if camera token is present.</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>def has_camera_token(self):\n    # type: () -&gt; bool\n    \"\"\"Check if camera token is in image prefix.\n\n    Returns:\n        bool: True/False if camera token is present.\n\n    \"\"\"\n    return \"&lt;camera&gt;\" in self.layer_data.filePrefix.lower()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.ARenderProducts.sanitize_camera_name","title":"<code>sanitize_camera_name(camera)</code>  <code>staticmethod</code>","text":"<p>Sanitize camera name.</p> <p>Remove Maya illegal characters from camera name.</p> <p>Parameters:</p> Name Type Description Default <code>camera</code> <code>str</code> <p>Maya camera name.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>sanitized camera name</p> Example <p>ARenderProducts.sanizite_camera_name('test:camera_01') test_camera_01</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>@staticmethod\ndef sanitize_camera_name(camera):\n    # type: (str) -&gt; str\n    \"\"\"Sanitize camera name.\n\n    Remove Maya illegal characters from camera name.\n\n    Args:\n        camera (str): Maya camera name.\n\n    Returns:\n        str: sanitized camera name\n\n    Example:\n        &gt;&gt;&gt; ARenderProducts.sanizite_camera_name('test:camera_01')\n        test_camera_01\n\n    \"\"\"\n    return re.sub('[^0-9a-zA-Z_]+', '_', camera)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.LayerMetadata","title":"<code>LayerMetadata</code>","text":"<p>               Bases: <code>object</code></p> <p>Data class for Render Layer metadata.</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>@attr.s\nclass LayerMetadata(object):\n    \"\"\"Data class for Render Layer metadata.\"\"\"\n    frameStart = attr.ib()\n    frameEnd = attr.ib()\n    cameras = attr.ib()\n    sceneName = attr.ib()\n    layerName = attr.ib()\n    renderer = attr.ib()\n    defaultExt = attr.ib()\n    filePrefix = attr.ib()\n    frameStep = attr.ib(default=1)\n    padding = attr.ib(default=4)\n\n    # Render Products\n    products = attr.ib(init=False, default=attr.Factory(list))\n\n    # The AOV separator token. Note that not all renderers define an explicit\n    # render separator but allow to put the AOV/RenderPass token anywhere in\n    # the file path prefix. For those renderers we'll fall back to whatever\n    # is between the last occurrences of &lt;RenderLayer&gt; and &lt;RenderPass&gt; tokens.\n    aov_separator = attr.ib(default=\"_\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.RenderProduct","title":"<code>RenderProduct</code>","text":"<p>               Bases: <code>object</code></p> <p>Describes an image or other file-like artifact produced by a render.</p> Warning <p>This currently does NOT return as a product PER render camera. A single Render Product will generate files per camera. E.g. with two cameras each render product generates two sequences on disk assuming the file path prefix correctly uses the  tokens. Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>@attr.s\nclass RenderProduct(object):\n    \"\"\"Describes an image or other file-like artifact produced by a render.\n\n    Warning:\n        This currently does NOT return as a product PER render camera.\n        A single Render Product will generate files per camera. E.g. with two\n        cameras each render product generates two sequences on disk assuming\n        the file path prefix correctly uses the &lt;Camera&gt; tokens.\n\n    \"\"\"\n    productName = attr.ib()\n    ext = attr.ib()                             # extension\n    colorspace = attr.ib()                      # colorspace\n    aov = attr.ib(default=None)                 # source aov\n    driver = attr.ib(default=None)              # source driver\n    multipart = attr.ib(default=False)          # multichannel file\n    camera = attr.ib(default=None)              # used only when rendering\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.RenderProductsArnold","title":"<code>RenderProductsArnold</code>","text":"<p>               Bases: <code>ARenderProducts</code></p> <p>Render products for Arnold renderer.</p> References <p>mtoa.utils.getFileName() mtoa.utils.ui.common.updateArnoldTargetFilePreview()</p> Notes <ul> <li>Output Denoising AOVs are not currently included.</li> <li>Only Frame/Animation ext: name.#.ext is supported.</li> <li>Use Custom extension is not supported.</li> <li> and  tokens not tested <li>With Merge AOVs but  in File Name Prefix Arnold   will still NOT merge the aovs. This class correctly resolves   it - but user should be aware. <li>File Path Prefix overrides per AOV driver are not implemented</li> <p>Attributes:</p> Name Type Description <code>aiDriverExtension</code> <code>dict</code> <p>Arnold AOV driver extension mapping. Is there a better way?</p> <code>renderer</code> <code>str</code> <p>name of renderer.</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>class RenderProductsArnold(ARenderProducts):\n    \"\"\"Render products for Arnold renderer.\n\n    References:\n        mtoa.utils.getFileName()\n        mtoa.utils.ui.common.updateArnoldTargetFilePreview()\n\n    Notes:\n        - Output Denoising AOVs are not currently included.\n        - Only Frame/Animation ext: name.#.ext is supported.\n        - Use Custom extension is not supported.\n        - &lt;RenderPassType&gt; and &lt;RenderPassFileGroup&gt; tokens not tested\n        - With Merge AOVs but &lt;RenderPass&gt; in File Name Prefix Arnold\n          will still NOT merge the aovs. This class correctly resolves\n          it - but user should be aware.\n        - File Path Prefix overrides per AOV driver are not implemented\n\n    Attributes:\n        aiDriverExtension (dict): Arnold AOV driver extension mapping.\n            Is there a better way?\n        renderer (str): name of renderer.\n\n    \"\"\"\n    renderer = \"arnold\"\n    aiDriverExtension = {\n        \"jpeg\": \"jpg\",\n        \"exr\": \"exr\",\n        \"deepexr\": \"exr\",\n        \"png\": \"png\",\n        \"tiff\": \"tif\",\n        \"mtoa_shaders\": \"ass\",  # TODO: research what those last two should be\n        \"maya\": \"\",\n    }\n\n    def get_renderer_prefix(self):\n\n        prefix = super().get_renderer_prefix()\n        merge_aovs = self._get_attr(\"defaultArnoldDriver.mergeAOVs\")\n        if not merge_aovs and \"&lt;renderpass&gt;\" not in prefix.lower():\n            # When Merge AOVs is disabled and &lt;renderpass&gt; token not present\n            # then Arnold prepends &lt;RenderPass&gt;/ to the output path.\n            # todo: It's untested what happens if AOV driver has an\n            #       an explicit override path prefix.\n            prefix = \"&lt;RenderPass&gt;/\" + prefix\n\n        return prefix\n\n    def get_multipart(self):\n        multipart = False\n        multilayer = bool(self._get_attr(\"defaultArnoldDriver.multipart\"))\n        merge_AOVs = bool(self._get_attr(\"defaultArnoldDriver.mergeAOVs\"))\n        if multilayer or merge_AOVs:\n            multipart = True\n\n        return multipart\n\n    def _get_aov_multipart(self, aov_driver=None):\n        \"\"\"Return whether AOVs are rendered as multipart files.\"\"\"\n        # Arnold AOVs are always rendered as multipart files\n        # when the `multipart` option is enabled.\n        if aov_driver is None:\n            return self.multipart\n\n        multilayer = bool(self._get_attr(f\"{aov_driver}.multipart\"))\n        merge_aovs = bool(self._get_attr(f\"{aov_driver}.mergeAOVs\"))\n        return multilayer or merge_aovs\n\n    def _get_aov_render_products(self, aov, cameras=None):\n        \"\"\"Return all render products for the AOV\"\"\"\n\n        products = []\n        aov_name = self._get_attr(aov, \"name\")\n        ai_drivers = cmds.listConnections(\"{}.outputs\".format(aov),\n                                          source=True,\n                                          destination=False,\n                                          type=\"aiAOVDriver\") or []\n        if not cameras:\n            cameras = [\n                self.sanitize_camera_name(\n                    self.get_renderable_cameras()[0]\n                )\n            ]\n\n        for ai_driver in ai_drivers:\n            colorspace = self._get_colorspace(\n                ai_driver + \".colorManagement\"\n            )\n            # todo: check aiAOVDriver.prefix as it could have\n            #       a custom path prefix set for this driver\n\n            # Skip Drivers set only for GUI\n            # 0: GUI, 1: Batch, 2: GUI and Batch\n            output_mode = self._get_attr(ai_driver, \"outputMode\")\n            if output_mode == 0:  # GUI only\n                log.warning(\"%s has Output Mode set to GUI, \"\n                            \"skipping...\", ai_driver)\n                continue\n\n            ai_translator = self._get_attr(ai_driver, \"aiTranslator\")\n            try:\n                ext = self.aiDriverExtension[ai_translator]\n            except KeyError:\n                raise AOVError(\n                    \"Unrecognized arnold driver format \"\n                    \"for AOV - {}\".format(aov_name)\n                )\n\n            # If aov RGBA is selected, arnold will translate it to `beauty`\n            name = aov_name\n            if name == \"RGBA\":\n                name = \"beauty\"\n\n            # Support Arnold light groups for AOVs\n            # Global AOV: When disabled the main layer is\n            #             not written: `{pass}`\n            # All Light Groups: When enabled, a `{pass}_lgroups` file is\n            #                   written and is always merged into a\n            #                   single file\n            # Light Groups List: When set, a product per light\n            #                    group is written\n            #                    e.g. {pass}_front, {pass}_rim\n            global_aov = self._get_attr(aov, \"globalAov\")\n            if global_aov:\n                for camera in cameras:\n                    product = RenderProduct(\n                        productName=name,\n                        ext=ext,\n                        aov=aov_name,\n                        driver=ai_driver,\n                        multipart=self._get_aov_multipart(ai_driver),\n                        camera=camera,\n                        colorspace=colorspace\n                    )\n                    products.append(product)\n\n            all_light_groups = self._get_attr(aov, \"lightGroups\")\n            if all_light_groups:\n                # All light groups is enabled. A single multipart\n                # Render Product\n                for camera in cameras:\n                    product = RenderProduct(\n                        productName=name + \"_lgroups\",\n                        ext=ext,\n                        aov=aov_name,\n                        driver=ai_driver,\n                        # Always multichannel output\n                        multipart=True,\n                        camera=camera,\n                        colorspace=colorspace\n                    )\n                    products.append(product)\n            else:\n                value = self._get_attr(aov, \"lightGroupsList\")\n                if not value:\n                    continue\n                selected_light_groups = value.strip().split()\n                for light_group in selected_light_groups:\n                    # Render Product per selected light group\n                    aov_light_group_name = \"{}_{}\".format(name, light_group)\n                    for camera in cameras:\n                        product = RenderProduct(\n                            productName=aov_light_group_name,\n                            aov=aov_name,\n                            driver=ai_driver,\n                            ext=ext,\n                            camera=camera,\n                            colorspace=colorspace\n                        )\n                        products.append(product)\n\n        return products\n\n    def _get_colorspace(self, attribute):\n        \"\"\"Resolve colorspace from Arnold settings.\"\"\"\n\n        def _view_transform():\n            preferences = lib.get_color_management_preferences()\n            views_data = get_ocio_config_views(preferences[\"config\"])\n            view_data = views_data[\n                \"{}/{}\".format(preferences[\"display\"], preferences[\"view\"])\n            ]\n            return view_data[\"colorspace\"]\n\n        def _raw():\n            preferences = lib.get_color_management_preferences()\n            return preferences[\"rendering_space\"]\n\n        resolved_values = {\n            \"Raw\": _raw,\n            \"Use View Transform\": _view_transform,\n            # Default. Same as Maya Preferences.\n            \"Use Output Transform\": lib.get_color_management_output_transform\n        }\n        return resolved_values[self._get_attr(attribute)]()\n\n    def get_render_products(self):\n        \"\"\"Get all AOVs.\n\n        See Also:\n            :func:`ARenderProducts.get_render_products()`\n\n        Raises:\n            :class:`AOVError`: If AOV cannot be determined.\n\n        \"\"\"\n\n        if not cmds.ls(\"defaultArnoldRenderOptions\", type=\"aiOptions\"):\n            # this occurs when Render Setting windows was not opened yet. In\n            # such case there are no Arnold options created so query for AOVs\n            # will fail. We terminate here as there are no AOVs specified then.\n            # This state will most probably fail later on some Validator\n            # anyway.\n            return []\n\n        # check if camera token is in prefix. If so, and we have list of\n        # renderable cameras, generate render product for each and every\n        # of them.\n        cameras = [\n            self.sanitize_camera_name(c)\n            for c in self.get_renderable_cameras()\n        ]\n\n        default_ext = self._get_attr(\"defaultRenderGlobals.imfPluginKey\")\n        colorspace = self._get_colorspace(\n            \"defaultArnoldDriver.colorManagement\"\n        )\n        beauty_products = [\n            RenderProduct(\n                productName=\"beauty\",\n                ext=default_ext,\n                driver=\"defaultArnoldDriver\",\n                camera=camera,\n                colorspace=colorspace\n            ) for camera in cameras\n        ]\n\n        # AOVs &gt; Legacy &gt; Maya Render View &gt; Mode\n        aovs_enabled = bool(\n            self._get_attr(\n                \"defaultArnoldRenderOptions.aovMode\", as_string=False)\n        )\n        if not aovs_enabled:\n            return beauty_products\n\n        # Common &gt; File Output &gt; Merge AOVs or &lt;RenderPass&gt;\n        # We don't need to check for Merge AOVs due to overridden\n        # `get_renderer_prefix()` behavior which forces &lt;renderpass&gt;\n        has_renderpass_token = (\n            \"&lt;renderpass&gt;\" in self.layer_data.filePrefix.lower()\n        )\n        if not has_renderpass_token:\n            for product in beauty_products:\n                product.multipart = True\n            return beauty_products\n\n        # AOVs are set to be rendered separately. We should expect\n        # &lt;RenderPass&gt; token in path.\n        # handle aovs from references\n        use_ref_aovs = self.render_instance.data.get(\n            \"useReferencedAovs\", False) or False\n\n        aovs = cmds.ls(type=\"aiAOV\")\n        if not use_ref_aovs:\n            ref_aovs = cmds.ls(type=\"aiAOV\", referencedNodes=True)\n            aovs = list(set(aovs) - set(ref_aovs))\n\n        products = []\n\n        # Append the AOV products\n        for aov in aovs:\n            enabled = self._get_attr(aov, \"enabled\")\n            if not enabled:\n                continue\n\n            # For now stick to the legacy output format.\n            aov_products = self._get_aov_render_products(aov, cameras)\n            products.extend(aov_products)\n\n        if all(product.aov != \"RGBA\" for product in products):\n            # Append default 'beauty' as this is arnolds default.\n            # However, it is excluded whenever a RGBA pass is enabled.\n            # For legibility add the beauty layer as first entry\n            products += beauty_products\n\n        # TODO: Output Denoising AOVs?\n\n        return products\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.RenderProductsArnold.get_render_products","title":"<code>get_render_products()</code>","text":"<p>Get all AOVs.</p> See Also <p>:func:<code>ARenderProducts.get_render_products()</code></p> <p>Raises:</p> Type Description <p>class:<code>AOVError</code>: If AOV cannot be determined.</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>def get_render_products(self):\n    \"\"\"Get all AOVs.\n\n    See Also:\n        :func:`ARenderProducts.get_render_products()`\n\n    Raises:\n        :class:`AOVError`: If AOV cannot be determined.\n\n    \"\"\"\n\n    if not cmds.ls(\"defaultArnoldRenderOptions\", type=\"aiOptions\"):\n        # this occurs when Render Setting windows was not opened yet. In\n        # such case there are no Arnold options created so query for AOVs\n        # will fail. We terminate here as there are no AOVs specified then.\n        # This state will most probably fail later on some Validator\n        # anyway.\n        return []\n\n    # check if camera token is in prefix. If so, and we have list of\n    # renderable cameras, generate render product for each and every\n    # of them.\n    cameras = [\n        self.sanitize_camera_name(c)\n        for c in self.get_renderable_cameras()\n    ]\n\n    default_ext = self._get_attr(\"defaultRenderGlobals.imfPluginKey\")\n    colorspace = self._get_colorspace(\n        \"defaultArnoldDriver.colorManagement\"\n    )\n    beauty_products = [\n        RenderProduct(\n            productName=\"beauty\",\n            ext=default_ext,\n            driver=\"defaultArnoldDriver\",\n            camera=camera,\n            colorspace=colorspace\n        ) for camera in cameras\n    ]\n\n    # AOVs &gt; Legacy &gt; Maya Render View &gt; Mode\n    aovs_enabled = bool(\n        self._get_attr(\n            \"defaultArnoldRenderOptions.aovMode\", as_string=False)\n    )\n    if not aovs_enabled:\n        return beauty_products\n\n    # Common &gt; File Output &gt; Merge AOVs or &lt;RenderPass&gt;\n    # We don't need to check for Merge AOVs due to overridden\n    # `get_renderer_prefix()` behavior which forces &lt;renderpass&gt;\n    has_renderpass_token = (\n        \"&lt;renderpass&gt;\" in self.layer_data.filePrefix.lower()\n    )\n    if not has_renderpass_token:\n        for product in beauty_products:\n            product.multipart = True\n        return beauty_products\n\n    # AOVs are set to be rendered separately. We should expect\n    # &lt;RenderPass&gt; token in path.\n    # handle aovs from references\n    use_ref_aovs = self.render_instance.data.get(\n        \"useReferencedAovs\", False) or False\n\n    aovs = cmds.ls(type=\"aiAOV\")\n    if not use_ref_aovs:\n        ref_aovs = cmds.ls(type=\"aiAOV\", referencedNodes=True)\n        aovs = list(set(aovs) - set(ref_aovs))\n\n    products = []\n\n    # Append the AOV products\n    for aov in aovs:\n        enabled = self._get_attr(aov, \"enabled\")\n        if not enabled:\n            continue\n\n        # For now stick to the legacy output format.\n        aov_products = self._get_aov_render_products(aov, cameras)\n        products.extend(aov_products)\n\n    if all(product.aov != \"RGBA\" for product in products):\n        # Append default 'beauty' as this is arnolds default.\n        # However, it is excluded whenever a RGBA pass is enabled.\n        # For legibility add the beauty layer as first entry\n        products += beauty_products\n\n    # TODO: Output Denoising AOVs?\n\n    return products\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.RenderProductsMayaHardware","title":"<code>RenderProductsMayaHardware</code>","text":"<p>               Bases: <code>ARenderProducts</code></p> <p>Expected files for MayaHardware renderer.</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>class RenderProductsMayaHardware(ARenderProducts):\n    \"\"\"Expected files for MayaHardware renderer.\"\"\"\n\n    renderer = \"mayahardware2\"\n\n    extensions = [\n        {\"label\": \"JPEG\", \"index\": 8, \"extension\": \"jpg\"},\n        {\"label\": \"PNG\", \"index\": 32, \"extension\": \"png\"},\n        {\"label\": \"EXR(exr)\", \"index\": 40, \"extension\": \"exr\"}\n    ]\n\n    def get_multipart(self):\n        # MayaHardware does not support multipart EXRs.\n        return False\n\n    def _get_extension(self, value):\n        result = None\n        if isinstance(value, int):\n            extensions = {\n                extension[\"index\"]: extension[\"extension\"]\n                for extension in self.extensions\n            }\n            try:\n                result = extensions[value]\n            except KeyError:\n                raise NotImplementedError(\n                    \"Could not find extension for {}\".format(value)\n                )\n\n        if isinstance(value, str):\n            extensions = {\n                extension[\"label\"]: extension[\"extension\"]\n                for extension in self.extensions\n            }\n            try:\n                result = extensions[value]\n            except KeyError:\n                raise NotImplementedError(\n                    \"Could not find extension for {}\".format(value)\n                )\n\n        if not result:\n            raise NotImplementedError(\n                \"Could not find extension for {}\".format(value)\n            )\n\n        return result\n\n    def get_render_products(self):\n        \"\"\"Get all AOVs.\n        See Also:\n            :func:`ARenderProducts.get_render_products()`\n        \"\"\"\n        ext = self._get_extension(\n            self._get_attr(\"defaultRenderGlobals.imageFormat\")\n        )\n\n        products = []\n        for cam in self.get_renderable_cameras():\n            product = RenderProduct(\n                productName=\"beauty\",\n                ext=ext,\n                camera=cam,\n                colorspace=lib.get_color_management_output_transform()\n            )\n            products.append(product)\n\n        return products\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.RenderProductsMayaHardware.get_render_products","title":"<code>get_render_products()</code>","text":"<p>Get all AOVs. See Also:     :func:<code>ARenderProducts.get_render_products()</code></p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>def get_render_products(self):\n    \"\"\"Get all AOVs.\n    See Also:\n        :func:`ARenderProducts.get_render_products()`\n    \"\"\"\n    ext = self._get_extension(\n        self._get_attr(\"defaultRenderGlobals.imageFormat\")\n    )\n\n    products = []\n    for cam in self.get_renderable_cameras():\n        product = RenderProduct(\n            productName=\"beauty\",\n            ext=ext,\n            camera=cam,\n            colorspace=lib.get_color_management_output_transform()\n        )\n        products.append(product)\n\n    return products\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.RenderProductsRedshift","title":"<code>RenderProductsRedshift</code>","text":"<p>               Bases: <code>ARenderProducts</code></p> <p>Expected files for Redshift renderer.</p> Notes <ul> <li><code>get_files()</code> only supports rendering with frames, like \"animation\"</li> </ul> <p>Attributes:</p> <pre><code>unmerged_aovs (list): Name of aovs that are not merged into resulting\n    exr and we need them specified in Render Products output.\n</code></pre> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>class RenderProductsRedshift(ARenderProducts):\n    \"\"\"Expected files for Redshift renderer.\n\n    Notes:\n        - `get_files()` only supports rendering with frames, like \"animation\"\n\n    Attributes:\n\n        unmerged_aovs (list): Name of aovs that are not merged into resulting\n            exr and we need them specified in Render Products output.\n\n    \"\"\"\n\n    renderer = \"redshift\"\n    unmerged_aovs = {\"Cryptomatte\"}\n\n    def get_files(self, product):\n        # When outputting AOVs we need to replace Redshift specific AOV tokens\n        # with Maya render tokens for generating file sequences. We validate to\n        # a specific AOV fileprefix so we only need to account for one\n        # replacement.\n        if not product.multipart and product.driver:\n            file_prefix = self._get_attr(product.driver + \".filePrefix\")\n            self.layer_data.filePrefix = file_prefix.replace(\n                \"&lt;BeautyPath&gt;/&lt;BeautyFile&gt;\",\n                \"&lt;Scene&gt;/&lt;RenderLayer&gt;/&lt;RenderLayer&gt;\"\n            )\n\n        return super().get_files(product)\n\n    def get_multipart(self) -&gt; bool:\n        # For Redshift we don't directly return upon forcing multilayer\n        # due to some AOVs still being written into separate files,\n        # like Cryptomatte.\n        # AOVs are merged in multi-channel file\n        multipart = False\n        force_layer = bool(\n            self._get_attr(\"redshiftOptions.exrForceMultilayer\")\n        )\n        if force_layer:\n            multipart = True\n\n        return multipart\n\n    def get_renderer_prefix(self) -&gt; str:\n        \"\"\"Get image prefix for Redshift.\n\n        This overrides :func:`ARenderProducts.get_renderer_prefix()` as\n        we must add `&lt;aov&gt;` token manually. This is done only for\n        non-multipart outputs, where `&lt;aov&gt;` token doesn't make sense.\n\n        See also:\n            :func:`ARenderProducts.get_renderer_prefix()`\n\n        \"\"\"\n        prefix = super().get_renderer_prefix()\n        if self.multipart:\n            return prefix\n        separator = self.extract_separator(prefix)\n        prefix = \"{}{}&lt;aov&gt;\".format(prefix, separator or \"_\")\n        return prefix\n\n    def get_render_products(self) -&gt; \"list[RenderProduct]\":\n        \"\"\"Get all render products.\n\n        See Also:\n            :func:`ARenderProducts.get_render_products()`\n\n        \"\"\"\n        if not cmds.ls(\"redshiftOptions\", type=\"RedshiftOptions\"):\n            # this occurs when Render Setting windows was not opened yet. In\n            # such case there are no Redshift options created so query for AOVs\n            # will fail. We terminate here as there are no AOVs specified then.\n            # This state will most probably fail later on some validation\n            # anyway.\n            return []\n\n        cameras = [\n            self.sanitize_camera_name(c)\n            for c in self.get_renderable_cameras()\n        ]\n\n        # Get Redshift Extension from image format\n        image_format: int = self._get_attr(\"redshiftOptions.imageFormat\")\n        ext: str = mel.eval(\"redshiftGetImageExtension(%i)\" % image_format)\n\n        use_ref_aovs: bool = self.render_instance.data.get(\n            \"useReferencedAovs\", False) or False\n\n        products: \"list[RenderProduct]\" = []\n        colorspace = lib.get_color_management_output_transform()\n\n        # Main layer is always included\n        for camera in cameras:\n            products.append(\n                RenderProduct(productName=\"\",\n                              ext=ext,\n                              multipart=self.multipart,\n                              camera=camera,\n                              colorspace=colorspace))\n\n        # AOVs can be globally disabled\n        global_aov_enabled = bool(self._get_attr(\n            \"redshiftOptions.aovGlobalEnableMode\", as_string=False))\n        if not global_aov_enabled:\n            return products\n\n        # Process all Redshift AOVs\n        aovs = cmds.ls(type=\"RedshiftAOV\")\n        if not use_ref_aovs:\n            ref_aovs = cmds.ls(type=\"RedshiftAOV\", referencedNodes=True)\n            aovs = list(set(aovs) - set(ref_aovs))\n\n        for aov in aovs:\n            aov_products = self._get_aov_render_products(\n                aov, cameras, ext, colorspace)\n            products.extend(aov_products)\n\n        return products\n\n    def _get_aov_render_products(\n            self, aov, cameras, ext, colorspace) -&gt; \"list[RenderProduct]\":\n        \"\"\"Process a single Redshift AOV.\n\n        Return all output render products for an AOV, considering light groups.\n\n        For example, assuming:\n            - renderlayer name = \"mylayer\"\n            - AOV = BeautyAux\n            - lightgroups = key, rim, fill\n\n        Output for lightgroups disabled:\n            - mylayer.exr\n            - mylayer.BeautyAux.exr\n\n        Output for lightgroups enabled, option \"all\"\n            - mylayer.exr\n            - mylayer.BeautyAux_key.exr\n            - mylayer.BeautxAux_rim.exr\n            - mylayer.BeautyAux_fill.exr\n\n        Output for lightgroups enabled, option \"remainder\"\n        (all other lights that are not in a lightgroup)\n            - mylayer.exr\n            - mylayer.BeautyAux_key.exr\n            - mylayer.BeautyAux_rim.exr\n            - mylayer.BeautyAux_fill.exr\n            - mylayer.BeautyAux_other.exr\n\n        For all other AOVs that support light groups, you will get also the\n        whole AOV itself, i.e.\n            - mylayer.exr\n            - mylayer.DiffuseLighting.exr\n            - mylayer.DiffuseLighting_key.exr\n            - mylayer.DiffuseLighting_rim.exr\n            - mylayer.DiffuseLighting_fill.exr\n\n        See Also:\n            https://redshift.maxon.net/topic/51939\n\n        \"\"\"\n        # TODO: Many Redshift AOV types are not allowed to be included more\n        #  than once. Redshift will then ignore ever AOV of the same type\n        #  after the first one. We should ignore those too. However, some types\n        #  do get rendered if present multiple times, like `ID`, `Beauty` and\n        #  `Cryptomatte`.\n        enabled = self._get_attr(aov, \"enabled\")\n        if not enabled:\n            return []\n\n        aov_type = self._get_attr(aov, \"aovType\")\n        if self.multipart and aov_type not in self.unmerged_aovs:\n            return []\n\n        # Any AOVs that still get processed, like Cryptomatte\n        # by themselves are not multipart files.\n        aov_name = self._get_attr(aov, \"name\")\n\n        # Support light groups for AOVs\n        products = []\n        if self._get_attr(aov, \"supportsLightGroups\"):\n            global_aov_off = 0        # Do not render main AOV\n            # global_aov_all = 1      # Render main AOV\n            global_aov_remainder = 2  # Render main AOV + `_other` light group\n\n            global_aov = self._get_attr(aov, \"globalAov\", as_string=False)\n            light_groups: \"list[str]\" = []\n            all_light_groups = self._get_attr(aov, \"allLightGroups\")\n            if all_light_groups:\n                # All light groups is enabled\n                light_groups = self._get_redshift_light_groups()\n            else:\n                value: str = self._get_attr(aov, \"lightGroupList\")\n                # note: string value can return None when never set\n                if value:\n                    selected_light_groups = value.strip().split()\n                    light_groups = selected_light_groups\n\n            if light_groups and global_aov == global_aov_remainder:\n                # Add the `_other` light group\n                light_groups.append(\"other\")\n\n            for light_group in light_groups:\n                aov_light_group_name = \"{}_{}\".format(aov_name,\n                                                      light_group)\n                for camera in cameras:\n                    product = RenderProduct(\n                        productName=aov_light_group_name,\n                        aov=aov_name,\n                        ext=ext,\n                        multipart=False,\n                        camera=camera,\n                        driver=aov,\n                        colorspace=colorspace)\n                    products.append(product)\n\n            if light_groups:\n                # No global AOV product for this AOV if it had light groups\n\n                if global_aov == global_aov_off or aov_type == \"Beauty\":\n                    return products\n\n        # Include the global product for AOV (non-light group)\n        for camera in cameras:\n            product = RenderProduct(productName=aov_name,\n                                    aov=aov_name,\n                                    ext=ext,\n                                    multipart=False,\n                                    camera=camera,\n                                    driver=aov,\n                                    colorspace=colorspace)\n            products.append(product)\n\n        return products\n\n    @staticmethod\n    def _get_redshift_light_groups() -&gt; \"list[str]\":\n        return sorted(mel.eval(\"redshiftAllAovLightGroups\"))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.RenderProductsRedshift.get_render_products","title":"<code>get_render_products()</code>","text":"<p>Get all render products.</p> See Also <p>:func:<code>ARenderProducts.get_render_products()</code></p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>def get_render_products(self) -&gt; \"list[RenderProduct]\":\n    \"\"\"Get all render products.\n\n    See Also:\n        :func:`ARenderProducts.get_render_products()`\n\n    \"\"\"\n    if not cmds.ls(\"redshiftOptions\", type=\"RedshiftOptions\"):\n        # this occurs when Render Setting windows was not opened yet. In\n        # such case there are no Redshift options created so query for AOVs\n        # will fail. We terminate here as there are no AOVs specified then.\n        # This state will most probably fail later on some validation\n        # anyway.\n        return []\n\n    cameras = [\n        self.sanitize_camera_name(c)\n        for c in self.get_renderable_cameras()\n    ]\n\n    # Get Redshift Extension from image format\n    image_format: int = self._get_attr(\"redshiftOptions.imageFormat\")\n    ext: str = mel.eval(\"redshiftGetImageExtension(%i)\" % image_format)\n\n    use_ref_aovs: bool = self.render_instance.data.get(\n        \"useReferencedAovs\", False) or False\n\n    products: \"list[RenderProduct]\" = []\n    colorspace = lib.get_color_management_output_transform()\n\n    # Main layer is always included\n    for camera in cameras:\n        products.append(\n            RenderProduct(productName=\"\",\n                          ext=ext,\n                          multipart=self.multipart,\n                          camera=camera,\n                          colorspace=colorspace))\n\n    # AOVs can be globally disabled\n    global_aov_enabled = bool(self._get_attr(\n        \"redshiftOptions.aovGlobalEnableMode\", as_string=False))\n    if not global_aov_enabled:\n        return products\n\n    # Process all Redshift AOVs\n    aovs = cmds.ls(type=\"RedshiftAOV\")\n    if not use_ref_aovs:\n        ref_aovs = cmds.ls(type=\"RedshiftAOV\", referencedNodes=True)\n        aovs = list(set(aovs) - set(ref_aovs))\n\n    for aov in aovs:\n        aov_products = self._get_aov_render_products(\n            aov, cameras, ext, colorspace)\n        products.extend(aov_products)\n\n    return products\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.RenderProductsRedshift.get_renderer_prefix","title":"<code>get_renderer_prefix()</code>","text":"<p>Get image prefix for Redshift.</p> <p>This overrides :func:<code>ARenderProducts.get_renderer_prefix()</code> as we must add <code>&lt;aov&gt;</code> token manually. This is done only for non-multipart outputs, where <code>&lt;aov&gt;</code> token doesn't make sense.</p> See also <p>:func:<code>ARenderProducts.get_renderer_prefix()</code></p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>def get_renderer_prefix(self) -&gt; str:\n    \"\"\"Get image prefix for Redshift.\n\n    This overrides :func:`ARenderProducts.get_renderer_prefix()` as\n    we must add `&lt;aov&gt;` token manually. This is done only for\n    non-multipart outputs, where `&lt;aov&gt;` token doesn't make sense.\n\n    See also:\n        :func:`ARenderProducts.get_renderer_prefix()`\n\n    \"\"\"\n    prefix = super().get_renderer_prefix()\n    if self.multipart:\n        return prefix\n    separator = self.extract_separator(prefix)\n    prefix = \"{}{}&lt;aov&gt;\".format(prefix, separator or \"_\")\n    return prefix\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.RenderProductsRenderman","title":"<code>RenderProductsRenderman</code>","text":"<p>               Bases: <code>ARenderProducts</code></p> <p>Expected files for Renderman renderer.</p> Warning <p>This is very rudimentary and needs more love and testing.</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>class RenderProductsRenderman(ARenderProducts):\n    \"\"\"Expected files for Renderman renderer.\n\n    Warning:\n        This is very rudimentary and needs more love and testing.\n    \"\"\"\n\n    renderer = \"renderman\"\n    unmerged_aovs = {\"PxrCryptomatte\"}\n\n    def get_multipart(self):\n        # Implemented as display specific in \"get_render_products\".\n        return False\n\n    def get_render_products(self):\n        \"\"\"Get all AOVs.\n\n        See Also:\n            :func:`ARenderProducts.get_render_products()`\n\n        \"\"\"\n        from rfm2.api.displays import get_displays  # noqa\n\n        colorspace = lib.get_color_management_output_transform()\n\n        cameras = [\n            self.sanitize_camera_name(c)\n            for c in self.get_renderable_cameras()\n        ]\n\n        if not cameras:\n            cameras = [\n                self.sanitize_camera_name(\n                    self.get_renderable_cameras()[0])\n            ]\n        products = []\n\n        # NOTE: This is guessing extensions from renderman display types.\n        #       Some of them are just framebuffers, d_texture format can be\n        #       set in display setting. We set those now to None, but it\n        #       should be handled more gracefully.\n        display_types = {\n            \"d_deepexr\": \"exr\",\n            \"d_it\": None,\n            \"d_null\": None,\n            \"d_openexr\": \"exr\",\n            \"d_png\": \"png\",\n            \"d_pointcloud\": \"ptc\",\n            \"d_targa\": \"tga\",\n            \"d_texture\": None,\n            \"d_tiff\": \"tif\"\n        }\n\n        displays = get_displays(override_dst=\"render\")[\"displays\"]\n        for name, display in displays.items():\n            enabled = display[\"params\"][\"enable\"][\"value\"]\n            if not enabled:\n                continue\n\n            # Skip display types not producing any file output.\n            # Is there a better way to do it?\n            if not display_types.get(display[\"driverNode\"][\"type\"]):\n                continue\n\n            has_cryptomatte = cmds.ls(type=self.unmerged_aovs)\n            matte_enabled = False\n            if has_cryptomatte:\n                for cryptomatte in has_cryptomatte:\n                    cryptomatte_aov = cryptomatte\n                    matte_name = \"cryptomatte\"\n                    rman_globals = cmds.listConnections(cryptomatte +\n                                                        \".message\")\n                    if rman_globals:\n                        matte_enabled = True\n\n            aov_name = name\n            if aov_name == \"rmanDefaultDisplay\":\n                aov_name = \"beauty\"\n\n            extensions = display_types.get(\n                display[\"driverNode\"][\"type\"], \"exr\")\n\n            for camera in cameras:\n                # Create render product and set it as multipart only on\n                # display types supporting it. In all other cases, Renderman\n                # will create separate output per channel.\n                if display[\"driverNode\"][\"type\"] in [\"d_openexr\", \"d_deepexr\", \"d_tiff\"]:  # noqa\n                    product = RenderProduct(\n                        productName=aov_name,\n                        ext=extensions,\n                        camera=camera,\n                        multipart=True,\n                        colorspace=colorspace\n                    )\n\n                    if has_cryptomatte and matte_enabled:\n                        cryptomatte = RenderProduct(\n                            productName=matte_name,\n                            aov=cryptomatte_aov,\n                            ext=extensions,\n                            camera=camera,\n                            multipart=True,\n                            colorspace=colorspace\n                        )\n                else:\n                    # this code should handle the case where no multipart\n                    # capable format is selected. But since it involves\n                    # shady logic to determine what channel become what\n                    # lets not do that as all productions will use exr anyway.\n                    \"\"\"\n                    for channel in display['params']['displayChannels']['value']:  # noqa\n                        product = RenderProduct(\n                            productName=\"{}_{}\".format(aov_name, channel),\n                            ext=extensions,\n                            camera=camera,\n                            multipart=False\n                        )\n                    \"\"\"\n                    raise UnsupportedImageFormatException(\n                        \"Only exr, deep exr and tiff formats are supported.\")\n\n                products.append(product)\n\n                if has_cryptomatte and matte_enabled:\n                    products.append(cryptomatte)\n\n        return products\n\n    def get_files(self, product):\n        \"\"\"Get expected files.\n\n        \"\"\"\n        files = super().get_files(product)\n\n        layer_data = self.layer_data\n        new_files = []\n\n        resolved_image_dir = re.sub(\"&lt;scene&gt;\", layer_data.sceneName, RENDERMAN_IMAGE_DIR, flags=re.IGNORECASE)  # noqa: E501\n        resolved_image_dir = re.sub(\"&lt;layer&gt;\", layer_data.layerName, resolved_image_dir, flags=re.IGNORECASE)  # noqa: E501\n        for file in files:\n            new_file = \"{}/{}\".format(resolved_image_dir, file)\n            new_files.append(new_file)\n\n        return new_files\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.RenderProductsRenderman.get_files","title":"<code>get_files(product)</code>","text":"<p>Get expected files.</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>def get_files(self, product):\n    \"\"\"Get expected files.\n\n    \"\"\"\n    files = super().get_files(product)\n\n    layer_data = self.layer_data\n    new_files = []\n\n    resolved_image_dir = re.sub(\"&lt;scene&gt;\", layer_data.sceneName, RENDERMAN_IMAGE_DIR, flags=re.IGNORECASE)  # noqa: E501\n    resolved_image_dir = re.sub(\"&lt;layer&gt;\", layer_data.layerName, resolved_image_dir, flags=re.IGNORECASE)  # noqa: E501\n    for file in files:\n        new_file = \"{}/{}\".format(resolved_image_dir, file)\n        new_files.append(new_file)\n\n    return new_files\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.RenderProductsRenderman.get_render_products","title":"<code>get_render_products()</code>","text":"<p>Get all AOVs.</p> See Also <p>:func:<code>ARenderProducts.get_render_products()</code></p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>def get_render_products(self):\n    \"\"\"Get all AOVs.\n\n    See Also:\n        :func:`ARenderProducts.get_render_products()`\n\n    \"\"\"\n    from rfm2.api.displays import get_displays  # noqa\n\n    colorspace = lib.get_color_management_output_transform()\n\n    cameras = [\n        self.sanitize_camera_name(c)\n        for c in self.get_renderable_cameras()\n    ]\n\n    if not cameras:\n        cameras = [\n            self.sanitize_camera_name(\n                self.get_renderable_cameras()[0])\n        ]\n    products = []\n\n    # NOTE: This is guessing extensions from renderman display types.\n    #       Some of them are just framebuffers, d_texture format can be\n    #       set in display setting. We set those now to None, but it\n    #       should be handled more gracefully.\n    display_types = {\n        \"d_deepexr\": \"exr\",\n        \"d_it\": None,\n        \"d_null\": None,\n        \"d_openexr\": \"exr\",\n        \"d_png\": \"png\",\n        \"d_pointcloud\": \"ptc\",\n        \"d_targa\": \"tga\",\n        \"d_texture\": None,\n        \"d_tiff\": \"tif\"\n    }\n\n    displays = get_displays(override_dst=\"render\")[\"displays\"]\n    for name, display in displays.items():\n        enabled = display[\"params\"][\"enable\"][\"value\"]\n        if not enabled:\n            continue\n\n        # Skip display types not producing any file output.\n        # Is there a better way to do it?\n        if not display_types.get(display[\"driverNode\"][\"type\"]):\n            continue\n\n        has_cryptomatte = cmds.ls(type=self.unmerged_aovs)\n        matte_enabled = False\n        if has_cryptomatte:\n            for cryptomatte in has_cryptomatte:\n                cryptomatte_aov = cryptomatte\n                matte_name = \"cryptomatte\"\n                rman_globals = cmds.listConnections(cryptomatte +\n                                                    \".message\")\n                if rman_globals:\n                    matte_enabled = True\n\n        aov_name = name\n        if aov_name == \"rmanDefaultDisplay\":\n            aov_name = \"beauty\"\n\n        extensions = display_types.get(\n            display[\"driverNode\"][\"type\"], \"exr\")\n\n        for camera in cameras:\n            # Create render product and set it as multipart only on\n            # display types supporting it. In all other cases, Renderman\n            # will create separate output per channel.\n            if display[\"driverNode\"][\"type\"] in [\"d_openexr\", \"d_deepexr\", \"d_tiff\"]:  # noqa\n                product = RenderProduct(\n                    productName=aov_name,\n                    ext=extensions,\n                    camera=camera,\n                    multipart=True,\n                    colorspace=colorspace\n                )\n\n                if has_cryptomatte and matte_enabled:\n                    cryptomatte = RenderProduct(\n                        productName=matte_name,\n                        aov=cryptomatte_aov,\n                        ext=extensions,\n                        camera=camera,\n                        multipart=True,\n                        colorspace=colorspace\n                    )\n            else:\n                # this code should handle the case where no multipart\n                # capable format is selected. But since it involves\n                # shady logic to determine what channel become what\n                # lets not do that as all productions will use exr anyway.\n                \"\"\"\n                for channel in display['params']['displayChannels']['value']:  # noqa\n                    product = RenderProduct(\n                        productName=\"{}_{}\".format(aov_name, channel),\n                        ext=extensions,\n                        camera=camera,\n                        multipart=False\n                    )\n                \"\"\"\n                raise UnsupportedImageFormatException(\n                    \"Only exr, deep exr and tiff formats are supported.\")\n\n            products.append(product)\n\n            if has_cryptomatte and matte_enabled:\n                products.append(cryptomatte)\n\n    return products\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.RenderProductsVray","title":"<code>RenderProductsVray</code>","text":"<p>               Bases: <code>ARenderProducts</code></p> <p>Expected files for V-Ray renderer.</p> Notes <ul> <li>\"Disabled\" animation incorrectly returns frames in filename</li> <li>\"Renumber Frames\" is not supported</li> </ul> Reference <p>vrayAddRenderElementImpl() in vrayCreateRenderElementsTab.mel</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>class RenderProductsVray(ARenderProducts):\n    \"\"\"Expected files for V-Ray renderer.\n\n    Notes:\n        - \"Disabled\" animation incorrectly returns frames in filename\n        - \"Renumber Frames\" is not supported\n\n    Reference:\n        vrayAddRenderElementImpl() in vrayCreateRenderElementsTab.mel\n\n    \"\"\"\n    # todo: detect whether rendering with V-Ray GPU + whether AOV is supported\n\n    renderer = \"vray\"\n\n    def get_multipart(self):\n        multipart = False\n        image_format = self._get_attr(\"vraySettings.imageFormatStr\")\n        if image_format == \"exr (multichannel)\":\n            multipart = True\n\n        return multipart\n\n    def get_renderer_prefix(self):\n        # type: () -&gt; str\n        \"\"\"Get image prefix for V-Ray.\n\n        This overrides :func:`ARenderProducts.get_renderer_prefix()` as\n        we must add `&lt;aov&gt;` token manually. This is done only for\n        non-multipart outputs, where `&lt;aov&gt;` token doesn't make sense.\n\n        See also:\n            :func:`ARenderProducts.get_renderer_prefix()`\n\n        \"\"\"\n        prefix = super().get_renderer_prefix()\n        if self.multipart:\n            return prefix\n        aov_separator = self._get_aov_separator()\n        prefix = \"{}{}&lt;aov&gt;\".format(prefix, aov_separator)\n        return prefix\n\n    def _get_aov_separator(self):\n        # type: () -&gt; str\n        \"\"\"Return the V-Ray AOV/Render Elements separator\"\"\"\n        return self._get_attr(\n            \"vraySettings.fileNameRenderElementSeparator\"\n        )\n\n    def _get_layer_data(self):\n        # type: () -&gt; LayerMetadata\n        \"\"\"Override to get vray specific extension.\"\"\"\n        layer_data = super()._get_layer_data()\n\n        default_ext = self._get_attr(\"vraySettings.imageFormatStr\")\n        if default_ext in [\"exr (multichannel)\", \"exr (deep)\"]:\n            default_ext = \"exr\"\n        layer_data.defaultExt = default_ext\n        layer_data.padding = self._get_attr(\"vraySettings.fileNamePadding\")\n\n        layer_data.aov_separator = self._get_aov_separator()\n\n        return layer_data\n\n    def get_render_products(self):\n        \"\"\"Get all AOVs.\n\n        See Also:\n            :func:`ARenderProducts.get_render_products()`\n\n        \"\"\"\n        if not cmds.ls(\"vraySettings\", type=\"VRaySettingsNode\"):\n            # this occurs when Render Setting windows was not opened yet. In\n            # such case there are no VRay options created so query for AOVs\n            # will fail. We terminate here as there are no AOVs specified then.\n            # This state will most probably fail later on some Validator\n            # anyway.\n            return []\n\n        cameras = [\n            self.sanitize_camera_name(c)\n            for c in self.get_renderable_cameras()\n        ]\n\n        image_format_str = self._get_attr(\"vraySettings.imageFormatStr\")\n        default_ext = image_format_str\n        if default_ext in {\"exr (multichannel)\", \"exr (deep)\"}:\n            default_ext = \"exr\"\n\n        colorspace = lib.get_color_management_output_transform()\n        products = []\n\n        # add beauty as default when not disabled\n        dont_save_rgb = self._get_attr(\"vraySettings.dontSaveRgbChannel\")\n        if not dont_save_rgb:\n            for camera in cameras:\n                products.append(\n                    RenderProduct(\n                        productName=\"\",\n                        ext=default_ext,\n                        camera=camera,\n                        colorspace=colorspace,\n                        multipart=self.multipart\n                    )\n                )\n\n        # separate alpha file\n        separate_alpha = self._get_attr(\"vraySettings.separateAlpha\")\n        if separate_alpha:\n            for camera in cameras:\n                products.append(\n                    RenderProduct(\n                        productName=\"Alpha\",\n                        ext=default_ext,\n                        camera=camera,\n                        colorspace=colorspace,\n                        multipart=self.multipart\n                    )\n                )\n        if self.multipart:\n            # AOVs are merged in m-channel file, only main layer is rendered\n            return products\n\n        # handle aovs from references\n        use_ref_aovs = self.render_instance.data.get(\n            \"useReferencedAovs\", False) or False\n\n        # this will have list of all aovs no matter if they are coming from\n        # reference or not.\n        aov_types = [\"VRayRenderElement\", \"VRayRenderElementSet\"]\n        aovs = cmds.ls(type=aov_types)\n        if not use_ref_aovs:\n            ref_aovs = cmds.ls(type=aov_types, referencedNodes=True) or []\n            aovs = list(set(aovs) - set(ref_aovs))\n\n        for aov in aovs:\n            enabled = self._get_attr(aov, \"enabled\")\n            if not enabled:\n                continue\n\n            class_type = self._get_attr(aov + \".vrayClassType\")\n            if class_type == \"LightMixElement\":\n                # Special case which doesn't define a name by itself but\n                # instead seems to output multiple Render Products,\n                # specifically \"Self_Illumination\" and \"Environment\"\n                product_names = [\"Self_Illumination\", \"Environment\"]\n                for camera in cameras:\n                    for name in product_names:\n                        product = RenderProduct(productName=name,\n                                                ext=default_ext,\n                                                aov=aov,\n                                                camera=camera,\n                                                colorspace=colorspace)\n                        products.append(product)\n                # Continue as we've processed this special case AOV\n                continue\n\n            aov_name = self._get_vray_aov_name(aov)\n            for camera in cameras:\n                product = RenderProduct(\n                    productName=aov_name,\n                    ext=default_ext,\n                    aov=aov,\n                    camera=camera,\n                    colorspace=colorspace\n                )\n                products.append(product)\n\n        return products\n\n    def _get_vray_aov_attr(self, node, prefix):\n        \"\"\"Get value for attribute that starts with key in name\n\n        V-Ray AOVs have attribute names that include the type\n        of AOV in the attribute name, for example:\n            - vray_filename_rawdiffuse\n            - vray_filename_velocity\n            - vray_name_gi\n            - vray_explicit_name_extratex\n\n        To simplify querying the \"vray_filename\" or \"vray_name\"\n        attributes we just find the first attribute that has\n        that particular \"{prefix}_\" in the attribute name.\n\n        Args:\n            node (str): AOV node name\n            prefix (str): Prefix of the attribute name.\n\n        Returns:\n            Value of the attribute if it exists, else None\n\n        \"\"\"\n        attrs = cmds.listAttr(node, string=\"{}_*\".format(prefix))\n        if not attrs:\n            return None\n\n        assert len(attrs) == 1, \"Found more than one attribute: %s\" % attrs\n        attr = attrs[0]\n\n        return self._get_attr(node, attr)\n\n    def _get_vray_aov_name(self, node):\n        \"\"\"Get AOVs name from Vray.\n\n        Args:\n            node (str): aov node name.\n\n        Returns:\n            str: aov name.\n\n        \"\"\"\n\n        vray_explicit_name = self._get_vray_aov_attr(node,\n                                                     \"vray_explicit_name\")\n        vray_filename = self._get_vray_aov_attr(node, \"vray_filename\")\n        vray_name = self._get_vray_aov_attr(node, \"vray_name\")\n        final_name = vray_explicit_name or vray_filename or vray_name or None\n\n        class_type = self._get_attr(node, \"vrayClassType\")\n        if not vray_explicit_name:\n            # Explicit name takes precedence and overrides completely\n            # otherwise add the connected node names to the special cases\n            # Any namespace colon ':' gets replaced to underscore '_'\n            # so we sanitize using `sanitize_camera_name`\n            def _get_source_name(node, attr):\n                \"\"\"Return sanitized name of input connection to attribute\"\"\"\n                plug = \"{}.{}\".format(node, attr)\n                connections = cmds.listConnections(plug,\n                                                   source=True,\n                                                   destination=False)\n                if connections:\n                    return self.sanitize_camera_name(connections[0])\n\n            if class_type == \"MaterialSelectElement\":\n                # Name suffix is based on the connected material or set\n                attrs = [\n                    \"vray_mtllist_mtlselect\",\n                    \"vray_mtl_mtlselect\"\n                ]\n                for attribute in attrs:\n                    name = _get_source_name(node, attribute)\n                    if name:\n                        final_name += '_{}'.format(name)\n                        break\n                else:\n                    log.warning(\"Material Select Element has no \"\n                                \"selected materials: %s\", node)\n\n            elif class_type == \"ExtraTexElement\":\n                # Name suffix is based on the connected textures\n                extratex_type = self._get_attr(node, \"vray_type_extratex\")\n                attr = {\n                    0: \"vray_texture_extratex\",\n                    1: \"vray_float_texture_extratex\",\n                    2: \"vray_int_texture_extratex\",\n                }.get(extratex_type)\n                name = _get_source_name(node, attr)\n                if name:\n                    final_name += '_{}'.format(name)\n                else:\n                    log.warning(\"Extratex Element has no incoming texture\")\n\n        assert final_name, \"Output filename not defined for AOV: %s\" % node\n\n        return final_name\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.RenderProductsVray.get_render_products","title":"<code>get_render_products()</code>","text":"<p>Get all AOVs.</p> See Also <p>:func:<code>ARenderProducts.get_render_products()</code></p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>def get_render_products(self):\n    \"\"\"Get all AOVs.\n\n    See Also:\n        :func:`ARenderProducts.get_render_products()`\n\n    \"\"\"\n    if not cmds.ls(\"vraySettings\", type=\"VRaySettingsNode\"):\n        # this occurs when Render Setting windows was not opened yet. In\n        # such case there are no VRay options created so query for AOVs\n        # will fail. We terminate here as there are no AOVs specified then.\n        # This state will most probably fail later on some Validator\n        # anyway.\n        return []\n\n    cameras = [\n        self.sanitize_camera_name(c)\n        for c in self.get_renderable_cameras()\n    ]\n\n    image_format_str = self._get_attr(\"vraySettings.imageFormatStr\")\n    default_ext = image_format_str\n    if default_ext in {\"exr (multichannel)\", \"exr (deep)\"}:\n        default_ext = \"exr\"\n\n    colorspace = lib.get_color_management_output_transform()\n    products = []\n\n    # add beauty as default when not disabled\n    dont_save_rgb = self._get_attr(\"vraySettings.dontSaveRgbChannel\")\n    if not dont_save_rgb:\n        for camera in cameras:\n            products.append(\n                RenderProduct(\n                    productName=\"\",\n                    ext=default_ext,\n                    camera=camera,\n                    colorspace=colorspace,\n                    multipart=self.multipart\n                )\n            )\n\n    # separate alpha file\n    separate_alpha = self._get_attr(\"vraySettings.separateAlpha\")\n    if separate_alpha:\n        for camera in cameras:\n            products.append(\n                RenderProduct(\n                    productName=\"Alpha\",\n                    ext=default_ext,\n                    camera=camera,\n                    colorspace=colorspace,\n                    multipart=self.multipart\n                )\n            )\n    if self.multipart:\n        # AOVs are merged in m-channel file, only main layer is rendered\n        return products\n\n    # handle aovs from references\n    use_ref_aovs = self.render_instance.data.get(\n        \"useReferencedAovs\", False) or False\n\n    # this will have list of all aovs no matter if they are coming from\n    # reference or not.\n    aov_types = [\"VRayRenderElement\", \"VRayRenderElementSet\"]\n    aovs = cmds.ls(type=aov_types)\n    if not use_ref_aovs:\n        ref_aovs = cmds.ls(type=aov_types, referencedNodes=True) or []\n        aovs = list(set(aovs) - set(ref_aovs))\n\n    for aov in aovs:\n        enabled = self._get_attr(aov, \"enabled\")\n        if not enabled:\n            continue\n\n        class_type = self._get_attr(aov + \".vrayClassType\")\n        if class_type == \"LightMixElement\":\n            # Special case which doesn't define a name by itself but\n            # instead seems to output multiple Render Products,\n            # specifically \"Self_Illumination\" and \"Environment\"\n            product_names = [\"Self_Illumination\", \"Environment\"]\n            for camera in cameras:\n                for name in product_names:\n                    product = RenderProduct(productName=name,\n                                            ext=default_ext,\n                                            aov=aov,\n                                            camera=camera,\n                                            colorspace=colorspace)\n                    products.append(product)\n            # Continue as we've processed this special case AOV\n            continue\n\n        aov_name = self._get_vray_aov_name(aov)\n        for camera in cameras:\n            product = RenderProduct(\n                productName=aov_name,\n                ext=default_ext,\n                aov=aov,\n                camera=camera,\n                colorspace=colorspace\n            )\n            products.append(product)\n\n    return products\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.RenderProductsVray.get_renderer_prefix","title":"<code>get_renderer_prefix()</code>","text":"<p>Get image prefix for V-Ray.</p> <p>This overrides :func:<code>ARenderProducts.get_renderer_prefix()</code> as we must add <code>&lt;aov&gt;</code> token manually. This is done only for non-multipart outputs, where <code>&lt;aov&gt;</code> token doesn't make sense.</p> See also <p>:func:<code>ARenderProducts.get_renderer_prefix()</code></p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>def get_renderer_prefix(self):\n    # type: () -&gt; str\n    \"\"\"Get image prefix for V-Ray.\n\n    This overrides :func:`ARenderProducts.get_renderer_prefix()` as\n    we must add `&lt;aov&gt;` token manually. This is done only for\n    non-multipart outputs, where `&lt;aov&gt;` token doesn't make sense.\n\n    See also:\n        :func:`ARenderProducts.get_renderer_prefix()`\n\n    \"\"\"\n    prefix = super().get_renderer_prefix()\n    if self.multipart:\n        return prefix\n    aov_separator = self._get_aov_separator()\n    prefix = \"{}{}&lt;aov&gt;\".format(prefix, aov_separator)\n    return prefix\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.UnsupportedImageFormatException","title":"<code>UnsupportedImageFormatException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception to report unsupported output image format.</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>class UnsupportedImageFormatException(Exception):\n    \"\"\"Custom exception to report unsupported output image format.\"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.UnsupportedRendererException","title":"<code>UnsupportedRendererException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception.</p> <p>Raised when requesting data from unsupported renderer.</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>class UnsupportedRendererException(Exception):\n    \"\"\"Custom exception.\n\n    Raised when requesting data from unsupported renderer.\n    \"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.get","title":"<code>get(layer, render_instance=None)</code>","text":"<p>Get render details and products for given renderer and render layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>str</code> <p>Name of render layer</p> required <code>render_instance</code> <code>Instance</code> <p>Publish instance. If not provided an empty mock instance is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ARenderProducts</code> <p>The correct RenderProducts instance for that renderlayer.</p> <p>Raises:</p> Type Description <p>exc:<code>UnsupportedRendererException</code>: If requested renderer is not supported. It needs to be implemented by extending :class:<code>ARenderProducts</code> and added to this methods <code>if</code> statement.</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>def get(layer, render_instance=None):\n    # type: (str, object) -&gt; ARenderProducts\n    \"\"\"Get render details and products for given renderer and render layer.\n\n    Args:\n        layer (str): Name of render layer\n        render_instance (pyblish.api.Instance): Publish instance.\n            If not provided an empty mock instance is used.\n\n    Returns:\n        ARenderProducts: The correct RenderProducts instance for that\n            renderlayer.\n\n    Raises:\n        :exc:`UnsupportedRendererException`: If requested renderer\n            is not supported. It needs to be implemented by extending\n            :class:`ARenderProducts` and added to this methods ``if``\n            statement.\n\n    \"\"\"\n\n    if render_instance is None:\n        # For now produce a mock instance\n        class Instance(object):\n            data = {}\n        render_instance = Instance()\n\n    renderer_name = lib.get_attr_in_layer(\n        \"defaultRenderGlobals.currentRenderer\",\n        layer=layer\n    )\n\n    renderer = {\n        \"arnold\": RenderProductsArnold,\n        \"vray\": RenderProductsVray,\n        \"redshift\": RenderProductsRedshift,\n        \"renderman\": RenderProductsRenderman,\n        \"mayahardware2\": RenderProductsMayaHardware\n    }.get(renderer_name.lower(), None)\n    if renderer is None:\n        raise UnsupportedRendererException(\n            \"Unsupported renderer: {}\".format(renderer_name)\n        )\n\n    return renderer(layer, render_instance)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_renderproducts.html#client.ayon_maya.api.lib_renderproducts.has_tokens","title":"<code>has_tokens(string, tokens)</code>","text":"<p>Return whether any of tokens is in input string (case-insensitive)</p> Source code in <code>client/ayon_maya/api/lib_renderproducts.py</code> <pre><code>def has_tokens(string, tokens):\n    \"\"\"Return whether any of tokens is in input string (case-insensitive)\"\"\"\n    pattern = \"({})\".format(\"|\".join(re.escape(token) for token in tokens))\n    match = re.search(pattern, string, re.IGNORECASE)\n    return bool(match)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_rendersettings.html","title":"lib_rendersettings","text":"<p>Class for handling Render Settings.</p>"},{"location":"autoapi/client/ayon_maya/api/lib_rendersettings.html#client.ayon_maya.api.lib_rendersettings.RenderSettings","title":"<code>RenderSettings</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>client/ayon_maya/api/lib_rendersettings.py</code> <pre><code>class RenderSettings(object):\n\n    _image_prefix_nodes = {\n        'vray': 'vraySettings.fileNamePrefix',\n        'arnold': 'defaultRenderGlobals.imageFilePrefix',\n        'renderman': 'rmanGlobals.imageFileFormat',\n        'redshift': 'defaultRenderGlobals.imageFilePrefix',\n        'mayahardware2': 'defaultRenderGlobals.imageFilePrefix'\n    }\n\n    _aov_chars = {\n        \"dot\": \".\",\n        \"dash\": \"-\",\n        \"underscore\": \"_\"\n    }\n\n    log = Logger.get_logger(\"RenderSettings\")\n\n    @classmethod\n    def get_image_prefix_attr(cls, renderer):\n        return cls._image_prefix_nodes[renderer]\n\n    @staticmethod\n    def get_padding_attr(renderer):\n        \"\"\"Return attribute for renderer that defines frame padding amount\"\"\"\n        if renderer == \"vray\":\n            return \"vraySettings.fileNamePadding\"\n        else:\n            return \"defaultRenderGlobals.extensionPadding\"\n\n    def __init__(self, project_settings=None):\n        if not project_settings:\n            project_settings = get_project_settings(\n                get_current_project_name()\n            )\n        render_settings = project_settings[\"maya\"][\"render_settings\"]\n        image_prefixes = {\n            \"vray\": render_settings[\"vray_renderer\"][\"image_prefix\"],\n            \"arnold\": render_settings[\"arnold_renderer\"][\"image_prefix\"],\n            \"renderman\": render_settings[\"renderman_renderer\"][\"image_prefix\"],\n            \"redshift\": render_settings[\"redshift_renderer\"][\"image_prefix\"],\n            \"mayahardware2\": render_settings[\"mayahardware2_renderer\"][\"image_prefix\"],\n        }\n\n        # TODO probably should be stored to more explicit attribute\n        # Renderman only\n        renderman_settings = render_settings[\"renderman_renderer\"]\n        _image_dir = {\n            \"renderman\": renderman_settings[\"image_dir\"],\n            \"cryptomatte\": renderman_settings[\"cryptomatte_dir\"],\n            \"imageDisplay\": renderman_settings[\"imageDisplay_dir\"],\n            \"watermark\": renderman_settings[\"watermark_dir\"]\n        }\n        self._image_prefixes = image_prefixes\n        self._image_dir = _image_dir\n        self._project_settings = project_settings\n\n    def set_default_renderer_settings(self, renderer=None):\n        \"\"\"Set basic settings based on renderer.\"\"\"\n        # Not all hosts can import this module.\n        from maya import cmds  # noqa: F401\n        import maya.mel as mel  # noqa: F401\n\n        if not renderer:\n            renderer = cmds.getAttr(\n                'defaultRenderGlobals.currentRenderer').lower()\n\n        # project_settings/maya/create/CreateRender/aov_separator\n        try:\n            aov_separator = self._aov_chars[(\n                self._project_settings[\"maya\"]\n                                      [\"render_settings\"]\n                                      [\"aov_separator\"]\n            )]\n        except KeyError:\n            aov_separator = \"_\"\n        reset_frame = self._project_settings[\"maya\"][\"render_settings\"][\"reset_current_frame\"] # noqa\n\n        if reset_frame:\n            start_frame = cmds.getAttr(\"defaultRenderGlobals.startFrame\")\n            cmds.currentTime(start_frame, edit=True)\n\n        if renderer in self._image_prefix_nodes:\n            prefix = self._image_prefixes[renderer]\n            prefix = prefix.replace(\"{aov_separator}\", aov_separator)\n            cmds.setAttr(self._image_prefix_nodes[renderer],\n                        prefix, type=\"string\")  # noqa\n        else:\n            print(\"{0} isn't a supported renderer to autoset settings.\".format(renderer)) # noqa\n\n        task_entity = get_current_task_entity(fields={\"attrib\"})\n        task_attributes = task_entity[\"attrib\"]\n        width: int = task_attributes[\"resolutionWidth\"]\n        height: int = task_attributes[\"resolutionHeight\"]\n        pixel_aspect: float = task_attributes[\"pixelAspect\"]\n        if renderer == \"arnold\":\n            # set renderer settings for Arnold from project settings\n            self._set_arnold_settings()\n\n        if renderer == \"vray\":\n            self._set_vray_settings(width, height, pixel_aspect, aov_separator)\n\n        if renderer == \"redshift\":\n            self._set_redshift_settings()\n            mel.eval(\"redshiftUpdateActiveAovList\")\n\n        if renderer == \"renderman\":\n            image_dir = self._image_dir[\"renderman\"]\n            cmds.setAttr(\"rmanGlobals.imageOutputDir\",\n                         image_dir, type=\"string\")\n            self._set_renderman_settings(aov_separator)\n        self._set_default_render_resolution(width, height, pixel_aspect)\n\n    def _set_arnold_settings(self):\n        \"\"\"Sets settings for Arnold.\"\"\"\n        from mtoa.core import createOptions  # noqa\n        from mtoa.aovs import AOVInterface  # noqa\n        # Not all hosts can import this module.\n        from maya import cmds  # noqa: F401\n        import maya.mel as mel  # noqa: F401\n\n        createOptions()\n        render_settings = self._project_settings[\"maya\"][\"render_settings\"]\n        arnold_render_presets = render_settings[\"arnold_renderer\"] # noqa\n        # Force resetting settings and AOV list to avoid having to deal with\n        # AOV checking logic, for now.\n        # This is a work around because the standard\n        # function to revert render settings does not reset AOVs list in MtoA\n        # Fetch current aovs in case there's any.\n        current_aovs = AOVInterface().getAOVs()\n        remove_aovs = render_settings[\"remove_aovs\"]\n        if remove_aovs:\n        # Remove fetched AOVs\n            AOVInterface().removeAOVs(current_aovs)\n        mel.eval(\"unifiedRenderGlobalsRevertToDefault\")\n        img_ext = arnold_render_presets[\"image_format\"]\n        img_prefix = arnold_render_presets[\"image_prefix\"]\n        aovs = arnold_render_presets[\"aov_list\"]\n        img_tiled = arnold_render_presets[\"tiled\"]\n        multi_exr = arnold_render_presets[\"multilayer_exr\"]\n        additional_options = arnold_render_presets[\"additional_options\"]\n        for aov in aovs:\n            if aov in current_aovs and not remove_aovs:\n                continue\n            AOVInterface('defaultArnoldRenderOptions').addAOV(aov)\n\n        self._set_global_output_settings()\n\n        cmds.setAttr(\n            \"defaultRenderGlobals.imageFilePrefix\", img_prefix, type=\"string\")\n\n        cmds.setAttr(\n            \"defaultArnoldDriver.ai_translator\", img_ext, type=\"string\")\n\n        cmds.setAttr(\n            \"defaultArnoldDriver.exrTiled\", img_tiled)\n\n        cmds.setAttr(\n            \"defaultArnoldDriver.mergeAOVs\", multi_exr)\n        self._additional_attribs_setter(additional_options)\n        reset_frame_range(playback=False, fps=False, render=True)\n\n    def _set_redshift_settings(self):\n        \"\"\"Sets settings for Redshift.\"\"\"\n        # Not all hosts can import this module.\n        from maya import cmds  # noqa: F401\n        import maya.mel as mel  # noqa: F401\n\n        render_settings = self._project_settings[\"maya\"][\"render_settings\"]\n        redshift_render_presets = render_settings[\"redshift_renderer\"]\n\n        remove_aovs = render_settings[\"remove_aovs\"]\n        all_rs_aovs = cmds.ls(type='RedshiftAOV')\n        if remove_aovs:\n            for aov in all_rs_aovs:\n                enabled = cmds.getAttr(\"{}.enabled\".format(aov))\n                if enabled:\n                    cmds.delete(aov)\n\n        redshift_aovs = redshift_render_presets[\"aov_list\"]\n        # list all the aovs\n        all_rs_aovs = cmds.ls(type='RedshiftAOV')\n        for rs_aov in redshift_aovs:\n            rs_layername = \"rsAov_{}\".format(rs_aov.replace(\" \", \"\"))\n            if rs_layername in all_rs_aovs:\n                continue\n            cmds.rsCreateAov(type=rs_aov)\n        # update the AOV list\n        mel.eval(\"redshiftUpdateActiveAovList\")\n\n        gi_enabled: bool = redshift_render_presets[\"gi_enabled\"]\n        rs_p_engine = int(redshift_render_presets[\"primary_gi_engine\"])\n        rs_s_engine = int(redshift_render_presets[\"secondary_gi_engine\"])\n        cmds.setAttr(\"redshiftOptions.GIEnabled\", gi_enabled)\n        if rs_p_engine != 0:\n            cmds.setAttr(\"redshiftOptions.primaryGIEngine\", rs_p_engine)\n        if rs_s_engine != 0:\n            cmds.setAttr(\"redshiftOptions.secondaryGIEngine\", rs_s_engine)\n\n        additional_options = redshift_render_presets[\"additional_options\"]\n        ext = redshift_render_presets[\"image_format\"]\n        img_exts = [\"iff\", \"exr\", \"tif\", \"png\", \"tga\", \"jpg\"]\n        img_ext = img_exts.index(ext)\n\n        self._set_global_output_settings()\n        cmds.setAttr(\"redshiftOptions.imageFormat\", img_ext)\n        cmds.setAttr(\"redshiftOptions.exrMultipart\",\n                     redshift_render_presets.get(\"multipart_exr\", True))\n        cmds.setAttr(\"redshiftOptions.exrForceMultilayer\",\n                     redshift_render_presets[\"force_combine\"])\n        self._additional_attribs_setter(additional_options)\n\n    def _set_renderman_settings(self, aov_separator: str):\n        \"\"\"Sets settings for Renderman\"\"\"\n        # Not all hosts can import this module.\n        from maya import cmds  # noqa: F401\n        import maya.mel as mel  # noqa: F401\n\n        rman_render_presets = (\n            self._project_settings\n            [\"maya\"]\n            [\"render_settings\"]\n            [\"renderman_renderer\"]\n        )\n        display_filters = rman_render_presets[\"display_filters\"]\n        d_filters_number = len(display_filters)\n        for i in range(d_filters_number):\n            d_node = cmds.ls(typ=display_filters[i])\n            if len(d_node) &gt; 0:\n                filter_nodes = d_node[0]\n            else:\n                filter_nodes = cmds.createNode(display_filters[i])\n\n            cmds.connectAttr(filter_nodes + \".message\",\n                             \"rmanGlobals.displayFilters[%i]\" % i,\n                             force=True)\n            if filter_nodes.startswith(\"PxrImageDisplayFilter\"):\n                imageDisplay_dir = self._image_dir[\"imageDisplay\"]\n                imageDisplay_dir = imageDisplay_dir.replace(\"{aov_separator}\",\n                                                            aov_separator)\n                cmds.setAttr(filter_nodes + \".filename\",\n                             imageDisplay_dir, type=\"string\")\n\n        sample_filters = rman_render_presets[\"sample_filters\"]\n        s_filters_number = len(sample_filters)\n        for n in range(s_filters_number):\n            s_node = cmds.ls(typ=sample_filters[n])\n            if len(s_node) &gt; 0:\n                filter_nodes = s_node[0]\n            else:\n                filter_nodes = cmds.createNode(sample_filters[n])\n\n            cmds.connectAttr(filter_nodes + \".message\",\n                             \"rmanGlobals.sampleFilters[%i]\" % n,\n                             force=True)\n\n            if filter_nodes.startswith(\"PxrCryptomatte\"):\n                matte_dir = self._image_dir[\"cryptomatte\"]\n                matte_dir = matte_dir.replace(\"{aov_separator}\",\n                                              aov_separator)\n                cmds.setAttr(filter_nodes + \".filename\",\n                             matte_dir, type=\"string\")\n            elif filter_nodes.startswith(\"PxrWatermarkFilter\"):\n                watermark_dir = self._image_dir[\"watermark\"]\n                watermark_dir = watermark_dir.replace(\"{aov_separator}\",\n                                                      aov_separator)\n                cmds.setAttr(filter_nodes + \".filename\",\n                             watermark_dir, type=\"string\")\n\n        additional_options = rman_render_presets[\"additional_options\"]\n\n        self._set_global_output_settings()\n        self._additional_attribs_setter(additional_options)\n\n    def _set_vray_settings(\n        self,\n        width: int,\n        height: int,\n        pixel_aspect: float,\n        aov_separator\n    ):\n        # type: (str, int, int) -&gt; None\n        \"\"\"Sets important settings for Vray.\"\"\"\n        # Not all hosts can import this module.\n        from maya import cmds  # noqa: F401\n        import maya.mel as mel  # noqa: F401\n\n\n        settings = cmds.ls(type=\"VRaySettingsNode\")\n        node = settings[0] if settings else cmds.createNode(\"VRaySettingsNode\")\n        render_settings = self._project_settings[\"maya\"][\"render_settings\"]\n        vray_render_presets = render_settings[\"vray_renderer\"]\n        # vrayRenderElement\n        remove_aovs = render_settings[\"remove_aovs\"]\n        all_vray_aovs = cmds.ls(type='VRayRenderElement')\n        lightSelect_aovs = cmds.ls(type='VRayRenderElementSet')\n        if remove_aovs:\n            for aov in all_vray_aovs:\n                # remove all aovs except LightSelect\n                enabled = cmds.getAttr(\"{}.enabled\".format(aov))\n                if enabled:\n                    cmds.delete(aov)\n            # remove LightSelect\n            for light_aovs in lightSelect_aovs:\n                light_enabled = cmds.getAttr(\"{}.enabled\".format(light_aovs))\n                if light_enabled:\n                    cmds.delete(lightSelect_aovs)\n\n        vray_aovs = vray_render_presets[\"aov_list\"]\n        for renderlayer in vray_aovs:\n            renderElement = \"vrayAddRenderElement {}\".format(renderlayer)\n            RE_name = mel.eval(renderElement)\n            # if there is more than one same render element\n            if RE_name.endswith(\"1\"):\n                cmds.delete(RE_name)\n        # Set aov separator\n        # First we need to explicitly set the UI items in Render Settings\n        # because that is also what V-Ray updates to when that Render Settings\n        # UI did initialize before and refreshes again.\n        MENU = \"vrayRenderElementSeparator\"\n        if cmds.optionMenuGrp(MENU, query=True, exists=True):\n            items = cmds.optionMenuGrp(MENU, query=True, ill=True)\n            separators = [cmds.menuItem(i, query=True, label=True) for i in items]  # noqa: E501\n            try:\n                sep_idx = separators.index(aov_separator)\n            except ValueError as exc:\n                raise CreatorError(\n                    f\"AOV character {aov_separator} not in {separators}\"\n                ) from exc\n\n            cmds.optionMenuGrp(MENU, edit=True, select=sep_idx + 1)\n\n        # Set the render element attribute as string. This is also what V-Ray\n        # sets whenever the `vrayRenderElementSeparator` menu items switch\n        cmds.setAttr(\n            \"{}.fileNameRenderElementSeparator\".format(node),\n            aov_separator,\n            type=\"string\"\n        )\n\n        # Set render file format to exr\n        ext = vray_render_presets[\"image_format\"]\n        cmds.setAttr(\"{}.imageFormatStr\".format(node), ext, type=\"string\")\n\n        # animType\n        cmds.setAttr(\"{}.animType\".format(node), 1)\n\n        # resolution\n        cmds.setAttr(\"{}.width\".format(node), width)\n        cmds.setAttr(\"{}.height\".format(node), height)\n        cmds.setAttr(\"{}.pixelAspect\".format(node), pixel_aspect)\n\n        additional_options = vray_render_presets[\"additional_options\"]\n        self._additional_attribs_setter(additional_options)\n\n    def _set_default_render_resolution(self,\n                                       width: int,\n                                       height: int,\n                                       pixel_aspect: float):\n        from maya import cmds  # noqa: F401\n        device_aspect = pixel_aspect * (width / height)\n        cmds.setAttr(\"defaultResolution.width\", width)\n        cmds.setAttr(\"defaultResolution.height\", height)\n        cmds.setAttr(\"defaultResolution.pixelAspect\", pixel_aspect)\n        cmds.setAttr(\"defaultResolution.deviceAspectRatio\", device_aspect)\n\n    @staticmethod\n    def _set_global_output_settings():\n        # Not all hosts can import this module.\n        from maya import cmds  # noqa: F401\n        import maya.mel as mel  # noqa: F401\n\n        # enable animation\n        cmds.setAttr(\"defaultRenderGlobals.outFormatControl\", 0)\n        cmds.setAttr(\"defaultRenderGlobals.animation\", 1)\n        cmds.setAttr(\"defaultRenderGlobals.putFrameBeforeExt\", 1)\n        cmds.setAttr(\"defaultRenderGlobals.extensionPadding\", 4)\n\n    def _additional_attribs_setter(self, additional_attribs):\n        # Not all hosts can import this module.\n        from maya import cmds  # noqa: F401\n        import maya.mel as mel  # noqa: F401\n\n        for item in additional_attribs:\n            attribute = item[\"attribute\"]\n            value = item[\"value\"]\n            attribute = str(attribute)  # ensure str conversion from settings\n            attribute_type = cmds.getAttr(attribute, type=True)\n            if attribute_type in {\"long\", \"bool\"}:\n                cmds.setAttr(attribute, int(value))\n            elif attribute_type == \"string\":\n                cmds.setAttr(attribute, str(value), type=\"string\")\n            elif attribute_type in {\"double\", \"doubleAngle\", \"doubleLinear\"}:\n                cmds.setAttr(attribute, float(value))\n            else:\n                self.log.error(\n                    \"Attribute {attribute} can not be set due to unsupported \"\n                    \"type: {attribute_type}\".format(\n                        attribute=attribute,\n                        attribute_type=attribute_type)\n                )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_rendersettings.html#client.ayon_maya.api.lib_rendersettings.RenderSettings.get_padding_attr","title":"<code>get_padding_attr(renderer)</code>  <code>staticmethod</code>","text":"<p>Return attribute for renderer that defines frame padding amount</p> Source code in <code>client/ayon_maya/api/lib_rendersettings.py</code> <pre><code>@staticmethod\ndef get_padding_attr(renderer):\n    \"\"\"Return attribute for renderer that defines frame padding amount\"\"\"\n    if renderer == \"vray\":\n        return \"vraySettings.fileNamePadding\"\n    else:\n        return \"defaultRenderGlobals.extensionPadding\"\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_rendersettings.html#client.ayon_maya.api.lib_rendersettings.RenderSettings.set_default_renderer_settings","title":"<code>set_default_renderer_settings(renderer=None)</code>","text":"<p>Set basic settings based on renderer.</p> Source code in <code>client/ayon_maya/api/lib_rendersettings.py</code> <pre><code>def set_default_renderer_settings(self, renderer=None):\n    \"\"\"Set basic settings based on renderer.\"\"\"\n    # Not all hosts can import this module.\n    from maya import cmds  # noqa: F401\n    import maya.mel as mel  # noqa: F401\n\n    if not renderer:\n        renderer = cmds.getAttr(\n            'defaultRenderGlobals.currentRenderer').lower()\n\n    # project_settings/maya/create/CreateRender/aov_separator\n    try:\n        aov_separator = self._aov_chars[(\n            self._project_settings[\"maya\"]\n                                  [\"render_settings\"]\n                                  [\"aov_separator\"]\n        )]\n    except KeyError:\n        aov_separator = \"_\"\n    reset_frame = self._project_settings[\"maya\"][\"render_settings\"][\"reset_current_frame\"] # noqa\n\n    if reset_frame:\n        start_frame = cmds.getAttr(\"defaultRenderGlobals.startFrame\")\n        cmds.currentTime(start_frame, edit=True)\n\n    if renderer in self._image_prefix_nodes:\n        prefix = self._image_prefixes[renderer]\n        prefix = prefix.replace(\"{aov_separator}\", aov_separator)\n        cmds.setAttr(self._image_prefix_nodes[renderer],\n                    prefix, type=\"string\")  # noqa\n    else:\n        print(\"{0} isn't a supported renderer to autoset settings.\".format(renderer)) # noqa\n\n    task_entity = get_current_task_entity(fields={\"attrib\"})\n    task_attributes = task_entity[\"attrib\"]\n    width: int = task_attributes[\"resolutionWidth\"]\n    height: int = task_attributes[\"resolutionHeight\"]\n    pixel_aspect: float = task_attributes[\"pixelAspect\"]\n    if renderer == \"arnold\":\n        # set renderer settings for Arnold from project settings\n        self._set_arnold_settings()\n\n    if renderer == \"vray\":\n        self._set_vray_settings(width, height, pixel_aspect, aov_separator)\n\n    if renderer == \"redshift\":\n        self._set_redshift_settings()\n        mel.eval(\"redshiftUpdateActiveAovList\")\n\n    if renderer == \"renderman\":\n        image_dir = self._image_dir[\"renderman\"]\n        cmds.setAttr(\"rmanGlobals.imageOutputDir\",\n                     image_dir, type=\"string\")\n        self._set_renderman_settings(aov_separator)\n    self._set_default_render_resolution(width, height, pixel_aspect)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_rendersetup.html","title":"lib_rendersetup","text":"<p>Code to get attributes from render layer without switching to it.</p> <p>https://github.com/Colorbleed/colorbleed-config/blob/acre/colorbleed/maya/lib_rendersetup.py Credits: Roy Nieterau (BigRoy) / Colorbleed Modified for use in AYON</p>"},{"location":"autoapi/client/ayon_maya/api/lib_rendersetup.html#client.ayon_maya.api.lib_rendersetup.get_attr_in_layer","title":"<code>get_attr_in_layer(node_attr, layer, as_string=True)</code>","text":"<p>Return attribute value in Render Setup layer.</p> <p>This will only work for attributes which can be retrieved with <code>maya.cmds.getAttr</code> and for which Relative and Absolute overrides are applicable.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_attr_in_layer(\"defaultResolution.width\", layer=\"layer1\")\n&gt;&gt;&gt; get_attr_in_layer(\"defaultRenderGlobals.startFrame\", layer=\"layer\")\n&gt;&gt;&gt; get_attr_in_layer(\"transform.translate\", layer=\"layer3\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>attribute name as 'node.attribute'</p> required <code>layer</code> <code>str</code> <p>layer name</p> required <p>Returns:</p> Name Type Description <code>object</code> <p>attribute value in layer</p> Source code in <code>client/ayon_maya/api/lib_rendersetup.py</code> <pre><code>def get_attr_in_layer(node_attr, layer, as_string=True):\n    \"\"\"Return attribute value in Render Setup layer.\n\n    This will only work for attributes which can be\n    retrieved with `maya.cmds.getAttr` and for which\n    Relative and Absolute overrides are applicable.\n\n    Examples:\n        &gt;&gt;&gt; get_attr_in_layer(\"defaultResolution.width\", layer=\"layer1\")\n        &gt;&gt;&gt; get_attr_in_layer(\"defaultRenderGlobals.startFrame\", layer=\"layer\")\n        &gt;&gt;&gt; get_attr_in_layer(\"transform.translate\", layer=\"layer3\")\n\n    Args:\n        attr (str): attribute name as 'node.attribute'\n        layer (str): layer name\n\n    Returns:\n        object: attribute value in layer\n\n    \"\"\"\n\n    def _layer_needs_update(layer):\n        \"\"\"Return whether layer needs updating.\"\"\"\n        # Use `getattr` as e.g. DEFAULT_RENDER_LAYER does not have\n        # the attribute\n        return getattr(layer, \"needsMembershipUpdate\", False) or \\\n            getattr(layer, \"needsApplyUpdate\", False)\n\n    def get_default_layer_value(node_attr_):\n        \"\"\"Return attribute value in `DEFAULT_RENDER_LAYER`.\"\"\"\n        inputs = cmds.listConnections(node_attr_,\n                                      source=True,\n                                      destination=False,\n                                      # We want to skip conversion nodes since\n                                      # an override to `endFrame` could have\n                                      # a `unitToTimeConversion` node\n                                      # in-between\n                                      skipConversionNodes=True,\n                                      type=\"applyOverride\") or []\n        if inputs:\n            override = inputs[0]\n            history_overrides = cmds.ls(cmds.listHistory(override,\n                                                         pruneDagObjects=True),\n                                        type=\"applyOverride\")\n            node = history_overrides[-1] if history_overrides else override\n            node_attr_ = node + \".original\"\n\n        return get_attribute(node_attr_, asString=as_string)\n\n    layer = get_rendersetup_layer(layer)\n    rs = renderSetup.instance()\n    current_layer = rs.getVisibleRenderLayer()\n    if current_layer.name() == layer:\n\n        # Ensure layer is up-to-date\n        if _layer_needs_update(current_layer):\n            try:\n                rs.switchToLayer(current_layer)\n            except RuntimeError:\n                # Some cases can cause errors on switching\n                # the first time with Render Setup layers\n                # e.g. different overrides to compounds\n                # and its children plugs. So we just force\n                # it another time. If it then still fails\n                # we will let it error out.\n                rs.switchToLayer(current_layer)\n\n        return get_attribute(node_attr, asString=as_string)\n\n    overrides = get_attr_overrides(node_attr, layer)\n    default_layer_value = get_default_layer_value(node_attr)\n    if not overrides:\n        return default_layer_value\n\n    value = default_layer_value\n    for match, layer_override, index in overrides:\n        if isinstance(layer_override, AbsOverride):\n            # Absolute override\n            value = get_attribute(layer_override.name() + \".attrValue\")\n            if match == EXACT_MATCH:\n                # value = value\n                pass\n            elif match == PARENT_MATCH:\n                value = value[index]\n            elif match == CLIENT_MATCH:\n                value[index] = value\n\n        elif isinstance(layer_override, RelOverride):\n            # Relative override\n            # Value = Original * Multiply + Offset\n            multiply = get_attribute(layer_override.name() + \".multiply\")\n            offset = get_attribute(layer_override.name() + \".offset\")\n\n            if match == EXACT_MATCH:\n                value = value * multiply + offset\n            elif match == PARENT_MATCH:\n                value = value * multiply[index] + offset[index]\n            elif match == CLIENT_MATCH:\n                value[index] = value[index] * multiply + offset\n\n        else:\n            raise TypeError(\"Unsupported override: %s\" % layer_override)\n\n    return value\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_rendersetup.html#client.ayon_maya.api.lib_rendersetup.get_attr_overrides","title":"<code>get_attr_overrides(node_attr, layer, skip_disabled=True, skip_local_render=True, stop_at_absolute_override=True)</code>","text":"<p>Return all Overrides applicable to the attribute.</p> Overrides are returned as a 3-tuple <p>(Match, Override, Index)</p> Match <p>This is any of EXACT_MATCH, PARENT_MATCH, CLIENT_MATCH and defines whether the override is exactly on the plug, on the parent or on a child plug.</p> Override <p>This is the RenderSetup Override instance.</p> Index <p>This is the Plug index under the parent or for the child that matches. The EXACT_MATCH index will always be None. For PARENT_MATCH the index is which index the plug is under the parent plug. For CLIENT_MATCH the index is which child index matches the plug.</p> <p>Parameters:</p> Name Type Description Default <code>node_attr</code> <code>str</code> <p>attribute name as 'node.attribute'</p> required <code>layer</code> <code>str</code> <p>layer name</p> required <code>skip_disabled</code> <code>bool</code> <p>exclude disabled overrides</p> <code>True</code> <code>skip_local_render</code> <code>bool</code> <p>exclude overrides marked as local render.</p> <code>True</code> <code>stop_at_absolute_override</code> <p>exclude overrides prior to the last absolute override as they have no influence on the resulting value.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>list</code> <p>Ordered Overrides in order of strength</p> Source code in <code>client/ayon_maya/api/lib_rendersetup.py</code> <pre><code>def get_attr_overrides(node_attr, layer,\n                       skip_disabled=True,\n                       skip_local_render=True,\n                       stop_at_absolute_override=True):\n    \"\"\"Return all Overrides applicable to the attribute.\n\n    Overrides are returned as a 3-tuple:\n        (Match, Override, Index)\n\n    Match:\n        This is any of EXACT_MATCH, PARENT_MATCH, CLIENT_MATCH\n        and defines whether the override is exactly on the\n        plug, on the parent or on a child plug.\n\n    Override:\n        This is the RenderSetup Override instance.\n\n    Index:\n        This is the Plug index under the parent or for\n        the child that matches. The EXACT_MATCH index will\n        always be None. For PARENT_MATCH the index is which\n        index the plug is under the parent plug. For CLIENT_MATCH\n        the index is which child index matches the plug.\n\n    Args:\n        node_attr (str): attribute name as 'node.attribute'\n        layer (str): layer name\n        skip_disabled (bool): exclude disabled overrides\n        skip_local_render (bool): exclude overrides marked\n            as local render.\n        stop_at_absolute_override: exclude overrides prior\n            to the last absolute override as they have\n            no influence on the resulting value.\n\n    Returns:\n        list: Ordered Overrides in order of strength\n\n    \"\"\"\n\n    def get_mplug_children(plug):\n        \"\"\"Return children MPlugs of compound `MPlug`.\"\"\"\n        children = []\n        if plug.isCompound:\n            for i in range(plug.numChildren()):\n                children.append(plug.child(i))\n        return children\n\n    def get_mplug_names(mplug):\n        \"\"\"Return long and short name of `MPlug`.\"\"\"\n        long_name = mplug.partialName(useLongNames=True)\n        short_name = mplug.partialName(useLongNames=False)\n        return {long_name, short_name}\n\n    def iter_override_targets(override):\n        try:\n            for target in override._targets():\n                yield target\n        except AssertionError:\n            # Workaround: There is a bug where the private `_targets()` method\n            #             fails on some attribute plugs. For example overrides\n            #             to the defaultRenderGlobals.endFrame\n            #             (Tested in Maya 2020.2)\n            log.debug(\"Workaround for %s\" % override)\n            from maya.app.renderSetup.common.utils import findPlug\n\n            attr = override.attributeName()\n            if isinstance(override, UniqueOverride):\n                node = override.targetNodeName()\n                yield findPlug(node, attr)\n            else:\n                nodes = override.parent().selector().nodes()\n                for node in nodes:\n                    if cmds.attributeQuery(attr, node=node, exists=True):\n                        yield findPlug(node, attr)\n\n    # Get the MPlug for the node.attr\n    sel = om.MSelectionList()\n    sel.add(node_attr)\n    plug = sel.getPlug(0)\n\n    layer = get_rendersetup_layer(layer)\n    if layer == DEFAULT_RENDER_LAYER:\n        # DEFAULT_RENDER_LAYER will never have overrides\n        # since it's the default layer\n        return []\n\n    rs_layer = renderSetup.instance().getRenderLayer(layer)\n    if rs_layer is None:\n        # Renderlayer does not exist\n        return\n\n    # Get any parent or children plugs as we also\n    # want to include them in the attribute match\n    # for overrides\n    parent = plug.parent() if plug.isChild else None\n    parent_index = None\n    if parent:\n        parent_index = get_mplug_children(parent).index(plug)\n\n    children = get_mplug_children(plug)\n\n    # Create lookup for the attribute by both long\n    # and short names\n    attr_names = get_mplug_names(plug)\n    for child in children:\n        attr_names.update(get_mplug_names(child))\n    if parent:\n        attr_names.update(get_mplug_names(parent))\n\n        # Get all overrides of the layer\n    # And find those that are relevant to the attribute\n    plug_overrides = []\n\n    # Iterate over the overrides in reverse so we get the last\n    # overrides first and can \"break\" whenever an absolute\n    # override is reached\n    layer_overrides = list(utils.getOverridesRecursive(rs_layer))\n    for layer_override in reversed(layer_overrides):\n\n        if skip_disabled and not layer_override.isEnabled():\n            # Ignore disabled overrides\n            continue\n\n        if skip_local_render and layer_override.isLocalRender():\n            continue\n\n        # The targets list can be very large so we'll do\n        # a quick filter by attribute name to detect whether\n        # it matches the attribute name, or its parent or child\n        if layer_override.attributeName() not in attr_names:\n            continue\n\n        override_match = None\n        for override_plug in iter_override_targets(layer_override):\n\n            override_match = None\n            if plug == override_plug:\n                override_match = (EXACT_MATCH, layer_override, None)\n\n            elif parent and override_plug == parent:\n                override_match = (PARENT_MATCH, layer_override, parent_index)\n\n            elif children and override_plug in children:\n                child_index = children.index(override_plug)\n                override_match = (CLIENT_MATCH, layer_override, child_index)\n\n            if override_match:\n                plug_overrides.append(override_match)\n                break\n\n        if (\n                override_match and\n                stop_at_absolute_override and\n                isinstance(layer_override, AbsOverride) and\n                # When the override is only on a child plug then it doesn't\n                # override the entire value so we not stop at this override\n                not override_match[0] == CLIENT_MATCH\n        ):\n            # If override is absolute override, then BREAK out\n            # of parent loop we don't need to look any further as\n            # this is the absolute override\n            break\n\n    return reversed(plug_overrides)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_rendersetup.html#client.ayon_maya.api.lib_rendersetup.get_rendersetup_layer","title":"<code>get_rendersetup_layer(layer)</code>","text":"<p>Return render setup layer name.</p> <p>This also converts names from legacy renderLayer node name to render setup name.</p> <code>defaultRenderLayer</code> is not a renderSetupLayer node but it is however <p>the valid layer name for Render Setup - so we return that as is.</p> Example <p>for legacy_layer in cmds.ls(type=\"renderLayer\"):    layer = get_rendersetup_layer(legacy_layer)</p> <p>Returns:</p> Type Description <p>str or None: Returns renderSetupLayer node name if <code>layer</code> is a valid layer name in legacy renderlayers or render setup layers. Returns None if the layer can't be found or Render Setup is currently disabled.</p> Source code in <code>client/ayon_maya/api/lib_rendersetup.py</code> <pre><code>def get_rendersetup_layer(layer):\n    \"\"\"Return render setup layer name.\n\n    This also converts names from legacy renderLayer node name to render setup\n    name.\n\n    Note: `defaultRenderLayer` is not a renderSetupLayer node but it is however\n          the valid layer name for Render Setup - so we return that as is.\n\n    Example:\n        &gt;&gt;&gt; for legacy_layer in cmds.ls(type=\"renderLayer\"):\n        &gt;&gt;&gt;    layer = get_rendersetup_layer(legacy_layer)\n\n    Returns:\n        str or None: Returns renderSetupLayer node name if `layer` is a valid\n            layer name in legacy renderlayers or render setup layers.\n            Returns None if the layer can't be found or Render Setup is\n            currently disabled.\n\n\n    \"\"\"\n    if layer == DEFAULT_RENDER_LAYER:\n        # defaultRenderLayer doesn't have a `renderSetupLayer`\n        return layer\n\n    if not cmds.mayaHasRenderSetup():\n        return None\n\n    if not cmds.objExists(layer):\n        return None\n\n    if cmds.nodeType(layer) == \"renderSetupLayer\":\n        return layer\n\n    # By default Render Setup renames the legacy renderlayer\n    # to `rs_&lt;layername&gt;` but lets not rely on that as the\n    # layer node can be renamed manually\n    connections = cmds.listConnections(layer + \".message\",\n                                       type=\"renderSetupLayer\",\n                                       exactType=True,\n                                       source=False,\n                                       destination=True,\n                                       plugs=True) or []\n    return next((conn.split(\".\", 1)[0] for conn in connections\n                 if conn.endswith(\".legacyRenderLayer\")), None)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/lib_rendersetup.html#client.ayon_maya.api.lib_rendersetup.get_shader_in_layer","title":"<code>get_shader_in_layer(node, layer)</code>","text":"<p>Return the assigned shader in a renderlayer without switching layers.</p> <p>This has been developed and tested for Legacy Renderlayers and not for Render Setup.</p> This will also return the shader for any face assignments, however <p>it will not return the components they are assigned to. This could be implemented, but since Maya's renderlayers are famous for breaking with face assignments there has been no need for this function to support that.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>The list of assigned shaders in the given layer.</p> Source code in <code>client/ayon_maya/api/lib_rendersetup.py</code> <pre><code>def get_shader_in_layer(node, layer):\n    \"\"\"Return the assigned shader in a renderlayer without switching layers.\n\n    This has been developed and tested for Legacy Renderlayers and *not* for\n    Render Setup.\n\n    Note: This will also return the shader for any face assignments, however\n        it will *not* return the components they are assigned to. This could\n        be implemented, but since Maya's renderlayers are famous for breaking\n        with face assignments there has been no need for this function to\n        support that.\n\n    Returns:\n        list: The list of assigned shaders in the given layer.\n\n    \"\"\"\n\n    def _get_connected_shader(plug):\n        \"\"\"Return current shader\"\"\"\n        return cmds.listConnections(plug,\n                                    source=False,\n                                    destination=True,\n                                    plugs=False,\n                                    connections=False,\n                                    type=\"shadingEngine\") or []\n\n    # We check the instObjGroups (shader connection) for layer overrides.\n    plug = node + \".instObjGroups\"\n\n    # Ignore complex query if we're in the layer anyway (optimization)\n    current_layer = cmds.editRenderLayerGlobals(query=True,\n                                                currentRenderLayer=True)\n    if layer == current_layer:\n        return _get_connected_shader(plug)\n\n    connections = cmds.listConnections(plug,\n                                       plugs=True,\n                                       source=False,\n                                       destination=True,\n                                       type=\"renderLayer\") or []\n    connections = filter(lambda x: x.endswith(\".outPlug\"), connections)\n    if not connections:\n        # If no overrides anywhere on the shader, just get the current shader\n        return _get_connected_shader(plug)\n\n    def _get_override(connections, layer):\n        \"\"\"Return the overridden connection for that layer in connections\"\"\"\n        # If there's an override on that layer, return that.\n        for connection in connections:\n            if (connection.startswith(layer + \".outAdjustments\") and\n                    connection.endswith(\".outPlug\")):\n\n                # This is a shader override on that layer so get the shader\n                # connected to .outValue of the .outAdjustment[i]\n                out_adjustment = connection.rsplit(\".\", 1)[0]\n                connection_attr = out_adjustment + \".outValue\"\n                override = cmds.listConnections(connection_attr) or []\n\n                return override\n\n    override_shader = _get_override(connections, layer)\n    if override_shader is not None:\n        return override_shader\n    else:\n        # Get the override for \"defaultRenderLayer\" (=masterLayer)\n        return _get_override(connections, layer=\"defaultRenderLayer\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/menu.html","title":"menu","text":""},{"location":"autoapi/client/ayon_maya/api/menu.html#client.ayon_maya.api.menu.popup","title":"<code>popup()</code>","text":"<p>Pop-up the existing menu near the mouse cursor.</p> Source code in <code>client/ayon_maya/api/menu.py</code> <pre><code>def popup():\n    \"\"\"Pop-up the existing menu near the mouse cursor.\"\"\"\n    menu = _get_menu()\n    cursor = QtGui.QCursor()\n    point = cursor.pos()\n    menu.exec_(point)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/menu.html#client.ayon_maya.api.menu.update_menu_task_label","title":"<code>update_menu_task_label()</code>","text":"<p>Update the task label in AYON menu to current session</p> Source code in <code>client/ayon_maya/api/menu.py</code> <pre><code>def update_menu_task_label():\n    \"\"\"Update the task label in AYON menu to current session\"\"\"\n\n    if IS_HEADLESS:\n        return\n\n    object_name = \"{}|currentContext\".format(MENU_NAME)\n    if not cmds.menuItem(object_name, query=True, exists=True):\n        log.warning(\"Can't find menuItem: {}\".format(object_name))\n        return\n\n    label = get_context_label()\n    cmds.menuItem(object_name, edit=True, label=label)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/pipeline.html","title":"pipeline","text":""},{"location":"autoapi/client/ayon_maya/api/pipeline.html#client.ayon_maya.api.pipeline.MayaHost","title":"<code>MayaHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_maya/api/pipeline.py</code> <pre><code>class MayaHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"maya\"\n\n    def __init__(self):\n        super(MayaHost, self).__init__()\n        self._op_events = {}\n\n    def get_app_information(self):\n        from ayon_core.host import ApplicationInformation\n\n        version = cmds.about(version=True)\n\n        return ApplicationInformation(\n            app_name=\"Maya\",\n            app_version=version,\n        )\n\n    def install(self):\n        project_name = get_current_project_name()\n        project_settings = get_project_settings(project_name)\n        # process path mapping\n        dirmap_processor = MayaDirmap(\"maya\", project_name, project_settings)\n        dirmap_processor.process_dirmap()\n\n        pyblish.api.register_plugin_path(PUBLISH_PATH)\n        pyblish.api.register_host(\"mayabatch\")\n        pyblish.api.register_host(\"mayapy\")\n        pyblish.api.register_host(\"maya\")\n\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n        register_inventory_action_path(INVENTORY_PATH)\n        register_workfile_build_plugin_path(WORKFILE_BUILD_PATH)\n\n        self.log.info(\"Installing callbacks ... \")\n        register_event_callback(\"init\", on_init)\n\n        _set_project()\n\n        if lib.IS_HEADLESS:\n            self.log.info((\n                \"Running in headless mode, skipping Maya save/open/new\"\n                \" callback installation..\"\n            ))\n\n            return\n\n        self._register_callbacks()\n\n        menu.install(project_settings)\n\n        register_event_callback(\"save\", on_save)\n        register_event_callback(\"open\", on_open)\n        register_event_callback(\"new\", on_new)\n        register_event_callback(\"before.save\", on_before_save)\n        register_event_callback(\"after.save\", on_after_save)\n        register_event_callback(\"before.close\", on_before_close)\n        register_event_callback(\"before.file.open\", before_file_open)\n        register_event_callback(\"taskChanged\", on_task_changed)\n        register_event_callback(\"workfile.open.before\", before_workfile_open)\n        register_event_callback(\"workfile.save.before\", before_workfile_save)\n        register_event_callback(\n            \"workfile.save.before\", workfile_save_before_xgen\n        )\n        register_event_callback(\"workfile.save.after\", after_workfile_save)\n\n        self._register_maya_usd_chasers()\n\n    def open_workfile(self, filepath):\n        return open_file(filepath)\n\n    def save_workfile(self, filepath=None):\n        return save_file(filepath)\n\n    def work_root(self, session):\n        return work_root(session)\n\n    def get_current_workfile(self):\n        return current_file()\n\n    def workfile_has_unsaved_changes(self):\n        return has_unsaved_changes()\n\n    def get_workfile_extensions(self):\n        return file_extensions()\n\n    def get_containers(self):\n        return ls()\n\n    @contextlib.contextmanager\n    def maintained_selection(self):\n        with lib.maintained_selection():\n            yield\n\n    def get_context_data(self):\n        data = cmds.fileInfo(\"OpenPypeContext\", query=True)\n        if not data:\n            return {}\n\n        data = data[0]  # Maya seems to return a list\n        decoded = base64.b64decode(data).decode(\"utf-8\")\n        return json.loads(decoded)\n\n    def update_context_data(self, data, changes):\n        json_str = json.dumps(data)\n        encoded = base64.b64encode(json_str.encode(\"utf-8\"))\n        return cmds.fileInfo(\"OpenPypeContext\", encoded)\n\n    def _register_callbacks(self):\n        for handler, event in self._op_events.copy().items():\n            if event is None:\n                continue\n\n            try:\n                OpenMaya.MMessage.removeCallback(event)\n                self._op_events[handler] = None\n            except RuntimeError as exc:\n                self.log.info(exc)\n\n        self._op_events[_on_scene_save] = OpenMaya.MSceneMessage.addCallback(\n            OpenMaya.MSceneMessage.kBeforeSave, _on_scene_save\n        )\n\n        self._op_events[_after_scene_save] = (\n            OpenMaya.MSceneMessage.addCallback(\n                OpenMaya.MSceneMessage.kAfterSave,\n                _after_scene_save\n            )\n        )\n\n        self._op_events[_before_scene_save] = (\n            OpenMaya.MSceneMessage.addCheckCallback(\n                OpenMaya.MSceneMessage.kBeforeSaveCheck,\n                _before_scene_save\n            )\n        )\n\n        self._op_events[_on_scene_new] = OpenMaya.MSceneMessage.addCallback(\n            OpenMaya.MSceneMessage.kAfterNew, _on_scene_new\n        )\n\n        self._op_events[_on_maya_initialized] = (\n            OpenMaya.MSceneMessage.addCallback(\n                OpenMaya.MSceneMessage.kMayaInitialized,\n                _on_maya_initialized\n            )\n        )\n\n        self._op_events[_on_scene_open] = (\n            OpenMaya.MSceneMessage.addCallback(\n                OpenMaya.MSceneMessage.kAfterOpen,\n                _on_scene_open\n            )\n        )\n\n        self._op_events[_before_scene_open] = (\n            OpenMaya.MSceneMessage.addCallback(\n                OpenMaya.MSceneMessage.kBeforeOpen,\n                _before_scene_open\n            )\n        )\n\n        self._op_events[_before_close_maya] = (\n            OpenMaya.MSceneMessage.addCallback(\n                OpenMaya.MSceneMessage.kMayaExiting,\n                _before_close_maya\n            )\n        )\n\n        self.log.info(\"Installed event handler _on_scene_save..\")\n        self.log.info(\"Installed event handler _before_scene_save..\")\n        self.log.info(\"Installed event handler _on_after_save..\")\n        self.log.info(\"Installed event handler _on_scene_new..\")\n        self.log.info(\"Installed event handler _on_maya_initialized..\")\n        self.log.info(\"Installed event handler _on_scene_open..\")\n        self.log.info(\"Installed event handler _check_lock_file..\")\n        self.log.info(\"Installed event handler _before_close_maya..\")\n\n    def _register_maya_usd_chasers(self):\n        \"\"\"Register Maya USD chasers if Maya USD libraries are available.\"\"\"\n\n        try:\n            import mayaUsd.lib  # noqa\n        except ImportError:\n            # Do not register if Maya USD is not available\n            return\n\n        self.log.info(\"Installing AYON Maya USD chasers..\")\n\n        from .chasers import export_filter_properties  # noqa\n\n        for export_chaser in [\n            export_filter_properties.FilterPropertiesExportChaser\n        ]:\n            mayaUsd.lib.ExportChaser.Register(export_chaser,\n                                              export_chaser.name)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/pipeline.html#client.ayon_maya.api.pipeline.before_file_open","title":"<code>before_file_open()</code>","text":"<p>check lock file when the file changed</p> Source code in <code>client/ayon_maya/api/pipeline.py</code> <pre><code>def before_file_open():\n    \"\"\"check lock file when the file changed\"\"\"\n    # delete the lock file\n    _remove_workfile_lock()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/pipeline.html#client.ayon_maya.api.pipeline.check_lock_on_current_file","title":"<code>check_lock_on_current_file()</code>","text":"<p>Check if there is a user opening the file</p> Source code in <code>client/ayon_maya/api/pipeline.py</code> <pre><code>def check_lock_on_current_file():\n\n    \"\"\"Check if there is a user opening the file\"\"\"\n    if not handle_workfile_locks():\n        return\n    log.info(\"Running callback on checking the lock file...\")\n\n    # add the lock file when opening the file\n    filepath = current_file()\n    # Skip if current file is 'untitled'\n    if not filepath:\n        return\n\n    if is_workfile_locked(filepath):\n        # add lockfile dialog\n        workfile_dialog = WorkfileLockDialog(filepath)\n        if not workfile_dialog.exec_():\n            cmds.file(new=True)\n            return\n\n    create_workfile_lock(filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/pipeline.html#client.ayon_maya.api.pipeline.containerise","title":"<code>containerise(name, namespace, nodes, context, loader=None, suffix='CON')</code>","text":"<p>Bundle <code>nodes</code> into an assembly and imprint it with metadata</p> <p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>nodes</code> <code>list</code> <p>Long names of nodes to containerise</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>str</code> <p>Name of loader used to produce this container.</p> <code>None</code> <code>suffix</code> <code>str</code> <p>Suffix of container, defaults to <code>_CON</code>.</p> <code>'CON'</code> <p>Returns:</p> Name Type Description <code>container</code> <code>str</code> <p>Name of container assembly</p> Source code in <code>client/ayon_maya/api/pipeline.py</code> <pre><code>@lib.undo_chunk()\ndef containerise(name,\n                 namespace,\n                 nodes,\n                 context,\n                 loader=None,\n                 suffix=\"CON\"):\n    \"\"\"Bundle `nodes` into an assembly and imprint it with metadata\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        nodes (list): Long names of nodes to containerise\n        context (dict): Asset information\n        loader (str, optional): Name of loader used to produce this container.\n        suffix (str, optional): Suffix of container, defaults to `_CON`.\n\n    Returns:\n        container (str): Name of container assembly\n\n    \"\"\"\n    container = cmds.sets(nodes, name=\"%s_%s_%s\" % (namespace, name, suffix))\n\n    data = [\n        (\"schema\", \"openpype:container-2.0\"),\n        (\"id\", AVALON_CONTAINER_ID),\n        (\"name\", name),\n        (\"namespace\", namespace),\n        (\"loader\", loader),\n        (\"representation\", context[\"representation\"][\"id\"]),\n        (\"project_name\", context[\"project\"][\"name\"])\n    ]\n    for key, value in data:\n        cmds.addAttr(container, longName=key, dataType=\"string\")\n        cmds.setAttr(container + \".\" + key, str(value), type=\"string\")\n\n    main_container = cmds.ls(AVALON_CONTAINERS, type=\"objectSet\")\n    if not main_container:\n        main_container = cmds.sets(empty=True, name=AVALON_CONTAINERS)\n\n        # Implement #399: Maya 2019+ hide AVALON_CONTAINERS on creation..\n        if cmds.attributeQuery(\"hiddenInOutliner\",\n                               node=main_container,\n                               exists=True):\n            cmds.setAttr(main_container + \".hiddenInOutliner\", True)\n    else:\n        main_container = main_container[0]\n\n    cmds.sets(container, addElement=main_container)\n\n    # Implement #399: Maya 2019+ hide containers in outliner\n    if cmds.attributeQuery(\"hiddenInOutliner\",\n                           node=container,\n                           exists=True):\n        cmds.setAttr(container + \".hiddenInOutliner\", True)\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/pipeline.html#client.ayon_maya.api.pipeline.ls","title":"<code>ls()</code>","text":"<p>Yields containers from active Maya scene</p> <p>This is the host-equivalent of api.ls(), but instead of listing assets on disk, it lists assets already loaded in Maya; once loaded they are called 'containers'</p> <p>Yields:</p> Type Description <p>dict[str, Any]: container</p> Source code in <code>client/ayon_maya/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"Yields containers from active Maya scene\n\n    This is the host-equivalent of api.ls(), but instead of listing\n    assets on disk, it lists assets already loaded in Maya; once loaded\n    they are called 'containers'\n\n    Yields:\n        dict[str, Any]: container\n\n    \"\"\"\n    container_names = _ls()\n    for container in sorted(container_names):\n        container_data = parse_container(container)\n        if container_data:\n            yield container_data\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/pipeline.html#client.ayon_maya.api.pipeline.on_after_save","title":"<code>on_after_save()</code>","text":"<p>Check if there is a lockfile after save</p> Source code in <code>client/ayon_maya/api/pipeline.py</code> <pre><code>def on_after_save():\n    \"\"\"Check if there is a lockfile after save\"\"\"\n    check_lock_on_current_file()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/pipeline.html#client.ayon_maya.api.pipeline.on_before_close","title":"<code>on_before_close()</code>","text":"<p>Delete the lock file after user quitting the Maya Scene</p> Source code in <code>client/ayon_maya/api/pipeline.py</code> <pre><code>def on_before_close():\n    \"\"\"Delete the lock file after user quitting the Maya Scene\"\"\"\n    log.info(\"Closing Maya...\")\n    # delete the lock file\n    filepath = current_file()\n    if handle_workfile_locks():\n        remove_workfile_lock(filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/pipeline.html#client.ayon_maya.api.pipeline.on_before_save","title":"<code>on_before_save()</code>","text":"<p>Run validation for scene's FPS prior to saving</p> Source code in <code>client/ayon_maya/api/pipeline.py</code> <pre><code>def on_before_save():\n    \"\"\"Run validation for scene's FPS prior to saving\"\"\"\n    return lib.validate_fps() and lib.validate_scene_units()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/pipeline.html#client.ayon_maya.api.pipeline.on_new","title":"<code>on_new()</code>","text":"<p>Set project resolution and fps when create a new file</p> Source code in <code>client/ayon_maya/api/pipeline.py</code> <pre><code>def on_new():\n    \"\"\"Set project resolution and fps when create a new file\"\"\"\n    log.info(\"Running callback on new..\")\n    with lib.suspended_refresh():\n        lib.set_context_settings()\n\n    _remove_workfile_lock()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/pipeline.html#client.ayon_maya.api.pipeline.on_open","title":"<code>on_open()</code>","text":"<p>On scene open let's assume the containers have changed.</p> Source code in <code>client/ayon_maya/api/pipeline.py</code> <pre><code>def on_open():\n    \"\"\"On scene open let's assume the containers have changed.\"\"\"\n\n    from ayon_core.tools.utils import SimplePopup\n\n    # Validate FPS after update_task_from_path to\n    # ensure it is using correct FPS for the folder\n    lib.validate_fps()\n    lib.validate_scene_units()\n    lib.fix_incompatible_containers()\n\n    if any_outdated_containers():\n        log.warning(\"Scene has outdated content.\")\n\n        # Find maya main window\n        parent = lib.get_main_window()\n        if parent is None:\n            log.info(\"Skipping outdated content pop-up \"\n                     \"because Maya window can't be found.\")\n        else:\n\n            # Show outdated pop-up\n            def _on_show_inventory():\n                host_tools.show_scene_inventory(parent=parent)\n\n            dialog = SimplePopup(parent=parent)\n            dialog.setWindowTitle(\"Maya scene has outdated content\")\n            dialog.set_message(\"There are outdated containers in \"\n                              \"your Maya scene.\")\n            dialog.on_clicked.connect(_on_show_inventory)\n            dialog.show()\n\n    # create lock file for the maya scene\n    check_lock_on_current_file()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/pipeline.html#client.ayon_maya.api.pipeline.on_save","title":"<code>on_save()</code>","text":"<p>Automatically add IDs to new nodes</p> <p>Any transform of a mesh, without an existing ID, is given one automatically on file save.</p> Source code in <code>client/ayon_maya/api/pipeline.py</code> <pre><code>def on_save():\n    \"\"\"Automatically add IDs to new nodes\n\n    Any transform of a mesh, without an existing ID, is given one\n    automatically on file save.\n    \"\"\"\n    log.info(\"Running callback on save..\")\n    # remove lockfile if users jumps over from one scene to another\n    _remove_workfile_lock()\n\n    # Generate ids of the current context on nodes in the scene\n    nodes = lib.get_id_required_nodes(referenced_nodes=False,\n                                      existing_ids=False)\n    for node, new_id in lib.generate_ids(nodes):\n        lib.set_id(node, new_id, overwrite=False)\n\n    # We are now starting the actual save directly\n    global _about_to_save\n    _about_to_save = False\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/pipeline.html#client.ayon_maya.api.pipeline.on_task_changed","title":"<code>on_task_changed()</code>","text":"<p>Wrapped function of app initialize and maya's on task changed</p> Source code in <code>client/ayon_maya/api/pipeline.py</code> <pre><code>def on_task_changed():\n    \"\"\"Wrapped function of app initialize and maya's on task changed\"\"\"\n    # Run\n    menu.update_menu_task_label()\n\n    workdir = os.getenv(\"AYON_WORKDIR\")\n    if os.path.exists(workdir):\n        log.info(\"Updating Maya workspace for task change to %s\", workdir)\n        _set_project()\n\n        # Set Maya fileDialog's start-dir to /scenes\n        frule_scene = cmds.workspace(fileRuleEntry=\"scene\")\n        cmds.optionVar(stringValue=(\"browserLocationmayaBinaryscene\",\n                                    workdir + \"/\" + frule_scene))\n\n    else:\n        log.warning((\n            \"Can't set project for new context because path does not exist: {}\"\n        ).format(workdir))\n\n    global _about_to_save\n    if not lib.IS_HEADLESS and _about_to_save:\n        # Let's prompt the user to update the context settings or not\n        lib.prompt_reset_context()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/pipeline.html#client.ayon_maya.api.pipeline.parse_container","title":"<code>parse_container(container)</code>","text":"<p>Return the container node's full container data.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>str</code> <p>A container node name.</p> required <p>Returns:</p> Type Description <p>Optional[dict[str, Any]]: The container schema data for this container if it meets all the required metadata.</p> Source code in <code>client/ayon_maya/api/pipeline.py</code> <pre><code>def parse_container(container):\n    \"\"\"Return the container node's full container data.\n\n    Args:\n        container (str): A container node name.\n\n    Returns:\n        Optional[dict[str, Any]]: The container schema data for this container\n         if it meets all the required metadata.\n\n    \"\"\"\n    data = lib.read(container)\n\n    required = [\"id\", \"name\", \"namespace\", \"loader\", \"representation\"]\n    missing = [key for key in required if key not in data]\n    if missing:\n        log.warning(\"Container '%s' is missing required keys: %s\",\n                    container, missing)\n        return\n\n    # Backwards compatibility pre-schemas for containers\n    data[\"schema\"] = data.get(\"schema\", \"openpype:container-1.0\")\n\n    # Append transient data\n    data[\"objectName\"] = container\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/pipeline.html#client.ayon_maya.api.pipeline.workfile_save_before_xgen","title":"<code>workfile_save_before_xgen(event)</code>","text":"<p>Manage Xgen external files when switching context.</p> <p>Xgen has various external files that needs to be unique and relative to the workfile, so we need to copy and potentially overwrite these files when switching context.</p> Source code in <code>client/ayon_maya/api/pipeline.py</code> <pre><code>def workfile_save_before_xgen(event):\n    \"\"\"Manage Xgen external files when switching context.\n\n    Xgen has various external files that needs to be unique and relative to the\n    workfile, so we need to copy and potentially overwrite these files when\n    switching context.\n\n    Args:\n        event (Event) - ayon_core/lib/events.py\n    \"\"\"\n    if not cmds.pluginInfo(\"xgenToolkit\", query=True, loaded=True):\n        return\n\n    import xgenm\n\n    current_work_dir = os.getenv(\"AYON_WORKDIR\").replace(\"\\\\\", \"/\")\n    expected_work_dir = event.data[\"workdir_path\"].replace(\"\\\\\", \"/\")\n    if current_work_dir == expected_work_dir:\n        return\n\n    palettes = cmds.ls(type=\"xgmPalette\", long=True)\n    if not palettes:\n        return\n\n    transfers = []\n    overwrites = []\n    attribute_changes = {}\n    attrs = [\"xgFileName\", \"xgBaseFile\"]\n    for palette in palettes:\n        sanitized_palette = palette.replace(\"|\", \"\")\n        project_path = xgenm.getAttr(\"xgProjectPath\", sanitized_palette)\n        _, maya_extension = os.path.splitext(event.data[\"filename\"])\n\n        for attr in attrs:\n            node_attr = \"{}.{}\".format(palette, attr)\n            attr_value = cmds.getAttr(node_attr)\n\n            if not attr_value:\n                continue\n\n            source = os.path.join(project_path, attr_value)\n\n            attr_value = event.data[\"filename\"].replace(\n                maya_extension,\n                \"__{}{}\".format(\n                    sanitized_palette.replace(\":\", \"__\"),\n                    os.path.splitext(attr_value)[1]\n                )\n            )\n            target = os.path.join(expected_work_dir, attr_value)\n\n            transfers.append((source, target))\n            attribute_changes[node_attr] = attr_value\n\n        relative_path = xgenm.getAttr(\n            \"xgDataPath\", sanitized_palette\n        ).split(os.pathsep)[0]\n        absolute_path = relative_path.replace(\"${PROJECT}\", project_path)\n        for root, _, files in os.walk(absolute_path):\n            for f in files:\n                source = os.path.join(root, f).replace(\"\\\\\", \"/\")\n                target = source.replace(project_path, expected_work_dir + \"/\")\n                transfers.append((source, target))\n                if os.path.exists(target):\n                    overwrites.append(target)\n\n    # Ask user about overwriting files.\n    if overwrites:\n        log.warning(\n            \"WARNING! Potential loss of data.\\n\\n\"\n            \"Found duplicate Xgen files in new context.\\n{}\".format(\n                \"\\n\".join(overwrites)\n            )\n        )\n        return\n\n    for source, destination in transfers:\n        if not os.path.exists(os.path.dirname(destination)):\n            os.makedirs(os.path.dirname(destination))\n        shutil.copy(source, destination)\n\n    for attribute, value in attribute_changes.items():\n        cmds.setAttr(attribute, value, type=\"string\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html","title":"plugin","text":""},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.Loader","title":"<code>Loader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>class Loader(LoaderPlugin):\n    hosts = [\"maya\"]\n    settings_category = SETTINGS_CATEGORY\n    load_settings = {}  # defined in settings\n\n    use_ayon_entity_uri = False\n\n    @classmethod\n    def filepath_from_context(cls, context):\n        # TODO: This is a 1:1 copy from ayon-houdini and may be good to\n        #  refactor and de-duplicate across the codebase, e.g. to core\n        if cls.use_ayon_entity_uri:\n            return get_ayon_entity_uri_from_representation_context(context)\n\n        return super().filepath_from_context(context)\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        super(Loader, cls).apply_settings(project_settings)\n        cls.load_settings = project_settings['maya']['load']\n\n    def get_custom_namespace_and_group(self, context, options, loader_key):\n        \"\"\"Queries Settings to get custom template for namespace and group.\n\n        Group template might be empty &gt;&gt; this forces to not wrap imported items\n        into separate group.\n\n        Args:\n            context (dict)\n            options (dict): artist modifiable options from dialog\n            loader_key (str): key to get separate configuration from Settings\n                ('reference_loader'|'import_loader')\n        \"\"\"\n\n        options[\"attach_to_root\"] = True\n        custom_naming = self.load_settings[loader_key]\n\n        if not custom_naming[\"namespace\"]:\n            raise LoadError(\"No namespace specified in \"\n                            \"Maya ReferenceLoader settings\")\n        elif not custom_naming[\"group_name\"]:\n            self.log.debug(\"No custom group_name, no group will be created.\")\n            options[\"attach_to_root\"] = False\n\n        folder_entity = context[\"folder\"]\n        product_entity = context[\"product\"]\n        product_name = product_entity[\"name\"]\n        product_type = product_entity[\"productType\"]\n        formatting_data = {\n            \"asset_name\": folder_entity[\"name\"],\n            \"asset_type\": \"asset\",\n            \"folder\": {\n                \"name\": folder_entity[\"name\"],\n            },\n            \"subset\": product_name,\n            \"product\": {\n                \"name\": product_name,\n                \"type\": product_type,\n            },\n            \"family\": product_type\n        }\n\n        custom_namespace = custom_naming[\"namespace\"].format(\n            **formatting_data\n        )\n\n        custom_group_name = custom_naming[\"group_name\"].format(\n            **formatting_data\n        )\n\n        return custom_group_name, custom_namespace, options\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.Loader.get_custom_namespace_and_group","title":"<code>get_custom_namespace_and_group(context, options, loader_key)</code>","text":"<p>Queries Settings to get custom template for namespace and group.</p> <p>Group template might be empty &gt;&gt; this forces to not wrap imported items into separate group.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>dict</code> <p>artist modifiable options from dialog</p> required <code>loader_key</code> <code>str</code> <p>key to get separate configuration from Settings ('reference_loader'|'import_loader')</p> required Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>def get_custom_namespace_and_group(self, context, options, loader_key):\n    \"\"\"Queries Settings to get custom template for namespace and group.\n\n    Group template might be empty &gt;&gt; this forces to not wrap imported items\n    into separate group.\n\n    Args:\n        context (dict)\n        options (dict): artist modifiable options from dialog\n        loader_key (str): key to get separate configuration from Settings\n            ('reference_loader'|'import_loader')\n    \"\"\"\n\n    options[\"attach_to_root\"] = True\n    custom_naming = self.load_settings[loader_key]\n\n    if not custom_naming[\"namespace\"]:\n        raise LoadError(\"No namespace specified in \"\n                        \"Maya ReferenceLoader settings\")\n    elif not custom_naming[\"group_name\"]:\n        self.log.debug(\"No custom group_name, no group will be created.\")\n        options[\"attach_to_root\"] = False\n\n    folder_entity = context[\"folder\"]\n    product_entity = context[\"product\"]\n    product_name = product_entity[\"name\"]\n    product_type = product_entity[\"productType\"]\n    formatting_data = {\n        \"asset_name\": folder_entity[\"name\"],\n        \"asset_type\": \"asset\",\n        \"folder\": {\n            \"name\": folder_entity[\"name\"],\n        },\n        \"subset\": product_name,\n        \"product\": {\n            \"name\": product_name,\n            \"type\": product_type,\n        },\n        \"family\": product_type\n    }\n\n    custom_namespace = custom_naming[\"namespace\"].format(\n        **formatting_data\n    )\n\n    custom_group_name = custom_naming[\"group_name\"].format(\n        **formatting_data\n    )\n\n    return custom_group_name, custom_namespace, options\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.MayaAutoCreator","title":"<code>MayaAutoCreator</code>","text":"<p>               Bases: <code>AutoCreator</code>, <code>MayaCreatorBase</code></p> <p>Automatically triggered creator for Maya.</p> <p>The plugin is not visible in UI, and 'create' method does not expect     any arguments.</p> Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>class MayaAutoCreator(AutoCreator, MayaCreatorBase):\n    \"\"\"Automatically triggered creator for Maya.\n\n    The plugin is not visible in UI, and 'create' method does not expect\n        any arguments.\n    \"\"\"\n\n    settings_category = \"maya\"\n\n    def collect_instances(self):\n        return self._default_collect_instances()\n\n    def update_instances(self, update_list):\n        return self._default_update_instances(update_list)\n\n    def remove_instances(self, instances):\n        return self._default_remove_instances(instances)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.MayaContextPlugin","title":"<code>MayaContextPlugin</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Base class for context publish plugins.</p> Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>class MayaContextPlugin(ContextPlugin):\n    \"\"\"Base class for context publish plugins.\"\"\"\n\n    settings_category = SETTINGS_CATEGORY\n    hosts = [\"maya\"]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.MayaCreatorBase","title":"<code>MayaCreatorBase</code>","text":"Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>class MayaCreatorBase:\n    @staticmethod\n    def cache_instance_data(shared_data):\n        \"\"\"Cache instances for Creators to shared data.\n\n        Create `maya_cached_instance_data` key when needed in shared data and\n        fill it with all collected instances from the scene under its\n        respective creator identifiers.\n\n        If legacy instances are detected in the scene, create\n        `maya_cached_legacy_instances` there and fill it with\n        all legacy products under product type as a key.\n\n        Args:\n            Dict[str, Any]: Shared data.\n\n        \"\"\"\n        if shared_data.get(\"maya_cached_instance_data\") is None:\n            cache = dict()\n            cache_legacy = dict()\n\n            for node in cmds.ls(type=\"objectSet\"):\n\n                if _get_attr(node, attr=\"id\") not in {\n                    AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n                }:\n                    continue\n\n                creator_id = _get_attr(node, attr=\"creator_identifier\")\n                if creator_id is not None:\n                    # creator instance\n                    cache.setdefault(creator_id, []).append(node)\n                else:\n                    # legacy instance\n                    family = _get_attr(node, attr=\"family\")\n                    if family is None:\n                        # must be a broken instance\n                        continue\n\n                    cache_legacy.setdefault(family, []).append(node)\n\n            shared_data[\"maya_cached_instance_data\"] = cache\n            shared_data[\"maya_cached_legacy_instances\"] = cache_legacy\n        return shared_data\n\n    def get_publish_families(self):\n        \"\"\"Return families for the instances of this creator.\n\n        Allow a Creator to define multiple families so that a creator can\n        e.g. specify `usd` and `usdMaya` and another USD creator can also\n        specify `usd` but apply different extractors like `usdMultiverse`.\n\n        There is no need to override this method if you only have the\n        'product_type' required for publish filtering.\n\n        Returns:\n            list: families for instances of this creator\n\n        \"\"\"\n        return []\n\n    def imprint_instance_node(self, node, data):\n\n        # We never store the instance_node as value on the node since\n        # it's the node name itself\n        data.pop(\"instance_node\", None)\n        data.pop(\"instance_id\", None)\n\n        # Don't store `families` since it's up to the creator itself\n        # to define the initial publish families - not a stored attribute of\n        # `families`\n        data.pop(\"families\", None)\n\n        # We store creator attributes at the root level and assume they\n        # will not clash in names with `product`, `task`, etc. and other\n        # default names. This is just so these attributes in many cases\n        # are still editable in the maya UI by artists.\n        # note: pop to move to end of dict to sort attributes last on the node\n        creator_attributes = data.pop(\"creator_attributes\", {})\n\n        # We only flatten value types which `imprint` function supports\n        json_creator_attributes = {}\n        for key, value in dict(creator_attributes).items():\n            if isinstance(value, (list, tuple, dict)):\n                creator_attributes.pop(key)\n                json_creator_attributes[key] = value\n\n        # Flatten remaining creator attributes to the node itself\n        data.update(creator_attributes)\n\n        # We know the \"publish_attributes\" will be complex data of\n        # settings per plugins, we'll store this as a flattened json structure\n        # pop to move to end of dict to sort attributes last on the node\n        data[\"publish_attributes\"] = json.dumps(\n            data.pop(\"publish_attributes\", {})\n        )\n\n        # Persist the non-flattened creator attributes (special value types,\n        # like multiselection EnumDef)\n        data[\"creator_attributes\"] = json.dumps(json_creator_attributes)\n\n        # Since we flattened the data structure for creator attributes we want\n        # to correctly detect which flattened attributes should end back in the\n        # creator attributes when reading the data from the node, so we store\n        # the relevant keys as a string\n        data[\"__creator_attributes_keys\"] = \",\".join(creator_attributes.keys())\n\n        # Kill any existing attributes just so we can imprint cleanly again\n        for attr in data.keys():\n            if cmds.attributeQuery(attr, node=node, exists=True):\n                cmds.deleteAttr(\"{}.{}\".format(node, attr))\n\n        return imprint(node, data)\n\n    def read_instance_node(self, node):\n        node_data = read(node)\n\n        # Never care about a cbId attribute on the object set\n        # being read as 'data'\n        node_data.pop(\"cbId\", None)\n\n        # Make sure we convert any creator attributes from the json string\n        creator_attributes = node_data.get(\"creator_attributes\")\n        if creator_attributes:\n            node_data[\"creator_attributes\"] = json.loads(creator_attributes)\n        else:\n            node_data[\"creator_attributes\"] = {}\n\n        # Move the relevant attributes into \"creator_attributes\" that\n        # we flattened originally\n        creator_attribute_keys = node_data.pop(\"__creator_attributes_keys\",\n                                               \"\").split(\",\")\n        for key in creator_attribute_keys:\n            if key in node_data:\n                node_data[\"creator_attributes\"][key] = node_data.pop(key)\n\n        # Make sure we convert any publish attributes from the json string\n        publish_attributes = node_data.get(\"publish_attributes\")\n        if publish_attributes:\n            node_data[\"publish_attributes\"] = json.loads(publish_attributes)\n\n        # Explicitly re-parse the node name\n        node_data[\"instance_node\"] = node\n        node_data[\"instance_id\"] = node\n\n        # If the creator plug-in specifies\n        families = self.get_publish_families()\n        if families:\n            node_data[\"families\"] = families\n\n        return node_data\n\n    def _default_collect_instances(self):\n        self.cache_instance_data(self.collection_shared_data)\n        cached_instances = (\n            self.collection_shared_data[\"maya_cached_instance_data\"]\n        )\n        for node in cached_instances.get(self.identifier, []):\n            node_data = self.read_instance_node(node)\n\n            created_instance = CreatedInstance.from_existing(node_data, self)\n            self._add_instance_to_context(created_instance)\n\n    def _default_update_instances(self, update_list):\n\n        for created_inst, _changes in update_list:\n            data = created_inst.data_to_store()\n            node = data.get(\"instance_node\")\n            with unlocked(node):\n                self.imprint_instance_node(node, data)\n\n    @lib.undo_chunk()\n    def _default_remove_instances(self, instances):\n        \"\"\"Remove specified instance from the scene.\n\n        This is only removing `id` parameter so instance is no longer\n        instance, because it might contain valuable data for artist.\n\n        \"\"\"\n        for instance in instances:\n            node = instance.data.get(\"instance_node\")\n            if node:\n                cmds.lockNode(node, lock=False)\n                cmds.delete(node)\n\n            self._remove_instance_from_context(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.MayaCreatorBase.cache_instance_data","title":"<code>cache_instance_data(shared_data)</code>  <code>staticmethod</code>","text":"<p>Cache instances for Creators to shared data.</p> <p>Create <code>maya_cached_instance_data</code> key when needed in shared data and fill it with all collected instances from the scene under its respective creator identifiers.</p> <p>If legacy instances are detected in the scene, create <code>maya_cached_legacy_instances</code> there and fill it with all legacy products under product type as a key.</p> <p>Parameters:</p> Name Type Description Default <code>Dict[str, Any]</code> <p>Shared data.</p> required Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>@staticmethod\ndef cache_instance_data(shared_data):\n    \"\"\"Cache instances for Creators to shared data.\n\n    Create `maya_cached_instance_data` key when needed in shared data and\n    fill it with all collected instances from the scene under its\n    respective creator identifiers.\n\n    If legacy instances are detected in the scene, create\n    `maya_cached_legacy_instances` there and fill it with\n    all legacy products under product type as a key.\n\n    Args:\n        Dict[str, Any]: Shared data.\n\n    \"\"\"\n    if shared_data.get(\"maya_cached_instance_data\") is None:\n        cache = dict()\n        cache_legacy = dict()\n\n        for node in cmds.ls(type=\"objectSet\"):\n\n            if _get_attr(node, attr=\"id\") not in {\n                AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n            }:\n                continue\n\n            creator_id = _get_attr(node, attr=\"creator_identifier\")\n            if creator_id is not None:\n                # creator instance\n                cache.setdefault(creator_id, []).append(node)\n            else:\n                # legacy instance\n                family = _get_attr(node, attr=\"family\")\n                if family is None:\n                    # must be a broken instance\n                    continue\n\n                cache_legacy.setdefault(family, []).append(node)\n\n        shared_data[\"maya_cached_instance_data\"] = cache\n        shared_data[\"maya_cached_legacy_instances\"] = cache_legacy\n    return shared_data\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.MayaCreatorBase.get_publish_families","title":"<code>get_publish_families()</code>","text":"<p>Return families for the instances of this creator.</p> <p>Allow a Creator to define multiple families so that a creator can e.g. specify <code>usd</code> and <code>usdMaya</code> and another USD creator can also specify <code>usd</code> but apply different extractors like <code>usdMultiverse</code>.</p> <p>There is no need to override this method if you only have the 'product_type' required for publish filtering.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>families for instances of this creator</p> Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>def get_publish_families(self):\n    \"\"\"Return families for the instances of this creator.\n\n    Allow a Creator to define multiple families so that a creator can\n    e.g. specify `usd` and `usdMaya` and another USD creator can also\n    specify `usd` but apply different extractors like `usdMultiverse`.\n\n    There is no need to override this method if you only have the\n    'product_type' required for publish filtering.\n\n    Returns:\n        list: families for instances of this creator\n\n    \"\"\"\n    return []\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.MayaExtractorPlugin","title":"<code>MayaExtractorPlugin</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Base class for extract plugins.</p> Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>class MayaExtractorPlugin(publish.Extractor):\n    \"\"\"Base class for extract plugins.\"\"\"\n\n    settings_category = SETTINGS_CATEGORY\n    hosts = [\"maya\"]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.MayaHiddenCreator","title":"<code>MayaHiddenCreator</code>","text":"<p>               Bases: <code>HiddenCreator</code>, <code>MayaCreatorBase</code></p> <p>Hidden creator for Maya.</p> <p>The plugin is not visible in UI, and it does not have strictly defined     arguments for 'create' method.</p> Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>class MayaHiddenCreator(HiddenCreator, MayaCreatorBase):\n    \"\"\"Hidden creator for Maya.\n\n    The plugin is not visible in UI, and it does not have strictly defined\n        arguments for 'create' method.\n    \"\"\"\n\n    settings_category = \"maya\"\n\n    def create(self, *args, **kwargs):\n        return MayaCreator.create(self, *args, **kwargs)\n\n    def collect_instances(self):\n        return self._default_collect_instances()\n\n    def update_instances(self, update_list):\n        return self._default_update_instances(update_list)\n\n    def remove_instances(self, instances):\n        return self._default_remove_instances(instances)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.MayaInstancePlugin","title":"<code>MayaInstancePlugin</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Base class for instance publish plugins.</p> Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>class MayaInstancePlugin(InstancePlugin):\n    \"\"\"Base class for instance publish plugins.\"\"\"\n\n    settings_category = SETTINGS_CATEGORY\n    hosts = [\"maya\"]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.MayaLoader","title":"<code>MayaLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Base class for loader plugins.</p> Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>class MayaLoader(LoaderPlugin):\n    \"\"\"Base class for loader plugins.\"\"\"\n\n    settings_category = SETTINGS_CATEGORY\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.ReferenceLoader","title":"<code>ReferenceLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>A basic ReferenceLoader for Maya</p> <p>This will implement the basic behavior for a loader to inherit from that will containerize the reference and will implement the <code>remove</code> and <code>update</code> logic.</p> Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>class ReferenceLoader(Loader):\n    \"\"\"A basic ReferenceLoader for Maya\n\n    This will implement the basic behavior for a loader to inherit from that\n    will containerize the reference and will implement the `remove` and\n    `update` logic.\n\n    \"\"\"\n\n    options = [\n        qargparse.Integer(\n            \"count\",\n            label=\"Count\",\n            default=1,\n            min=1,\n            help=\"How many times to load?\"\n        ),\n        qargparse.Double3(\n            \"offset\",\n            label=\"Position Offset\",\n            help=\"Offset loaded models for easier selection.\"\n        ),\n        qargparse.Boolean(\n            \"attach_to_root\",\n            label=\"Group imported asset\",\n            default=True,\n            help=\"Should a group be created to encapsulate\"\n                 \" imported representation ?\"\n        )\n    ]\n\n    def load(\n        self,\n        context,\n        name=None,\n        namespace=None,\n        options=None\n    ):\n        path = self.filepath_from_context(context)\n        assert os.path.exists(path), \"%s does not exist.\" % path\n\n        custom_group_name, custom_namespace, options = \\\n            self.get_custom_namespace_and_group(context, options,\n                                                \"reference_loader\")\n\n        count = options.get(\"count\") or 1\n\n        loaded_containers = []\n        for c in range(0, count):\n            namespace = lib.get_custom_namespace(custom_namespace)\n            group_name = \"{}:{}\".format(\n                namespace,\n                custom_group_name\n            )\n\n            options['group_name'] = group_name\n\n            # Offset loaded product\n            if \"offset\" in options:\n                offset = [i * c for i in options[\"offset\"]]\n                options[\"translate\"] = offset\n\n            self.log.info(options)\n\n            self.process_reference(\n                context=context,\n                name=name,\n                namespace=namespace,\n                options=options\n            )\n\n            # Only containerize if any nodes were loaded by the Loader\n            nodes = self[:]\n            if not nodes:\n                return\n\n            ref_node = lib.get_reference_node(nodes, self.log)\n            container = containerise(\n                name=name,\n                namespace=namespace,\n                nodes=[ref_node],\n                context=context,\n                loader=self.__class__.__name__\n            )\n            loaded_containers.append(container)\n            c += 1\n\n        return loaded_containers\n\n    def process_reference(self, context, name, namespace, options):\n        \"\"\"To be implemented by subclass\"\"\"\n        raise NotImplementedError(\"Must be implemented by subclass\")\n\n    def update(self, container, context):\n        from ayon_maya.api.lib import get_container_members\n        from maya import cmds\n\n        node = container[\"objectName\"]\n\n        project_name = context[\"project\"][\"name\"]\n        repre_entity = context[\"representation\"]\n\n        path = self.filepath_from_context(context)\n        # Get reference node from container members\n        members = get_container_members(node)\n        reference_node = lib.get_reference_node(members, self.log)\n        if reference_node is None:\n            raise LoadError(\"No reference node found in container\")\n        namespace = cmds.referenceQuery(reference_node, namespace=True)\n\n        file_type = {\n            \"ma\": \"mayaAscii\",\n            \"mb\": \"mayaBinary\",\n            \"abc\": \"Alembic\",\n            \"fbx\": \"FBX\",\n            \"usd\": \"USD Import\"\n        }.get(repre_entity[\"name\"])\n\n        if file_type is None:\n            raise LoadError(f\"Unsupported representation: {repre_entity}\")\n\n        assert os.path.exists(path), \"%s does not exist.\" % path\n\n        # Need to save alembic settings and reapply, cause referencing resets\n        # them to incoming data.\n        alembic_attrs = [\"speed\", \"offset\", \"cycleType\", \"time\"]\n        alembic_data = {}\n        if repre_entity[\"name\"] == \"abc\":\n            alembic_nodes = cmds.ls(\n                \"{}:*\".format(namespace), type=\"AlembicNode\"\n            )\n            if alembic_nodes:\n                for attr in alembic_attrs:\n                    node_attr = \"{}.{}\".format(alembic_nodes[0], attr)\n                    data = {\n                        \"input\": lib.get_attribute_input(node_attr),\n                        \"value\": cmds.getAttr(node_attr)\n                    }\n\n                    alembic_data[attr] = data\n            else:\n                self.log.debug(\"No alembic nodes found in {}\".format(members))\n\n        try:\n            path = self.prepare_root_value(path, project_name)\n            content = cmds.file(path,\n                                loadReference=reference_node,\n                                type=file_type,\n                                returnNewNodes=True)\n        except RuntimeError as exc:\n            # When changing a reference to a file that has load errors the\n            # command will raise an error even if the file is still loaded\n            # correctly (e.g. when raising errors on Arnold attributes)\n            # When the file is loaded and has content, we consider it's fine.\n            if not cmds.referenceQuery(reference_node, isLoaded=True):\n                raise\n\n            content = cmds.referenceQuery(reference_node,\n                                          nodes=True,\n                                          dagPath=True)\n            if not content:\n                raise\n\n            self.log.warning(\"Ignoring file read error:\\n%s\", exc)\n\n\n        # Reapply alembic settings.\n        if repre_entity[\"name\"] == \"abc\" and alembic_data:\n            alembic_nodes = cmds.ls(\n                \"{}:*\".format(namespace), type=\"AlembicNode\"\n            )\n            if alembic_nodes:\n                alembic_node = alembic_nodes[0]  # assume single AlembicNode\n                for attr, data in alembic_data.items():\n                    node_attr = \"{}.{}\".format(alembic_node, attr)\n                    input = lib.get_attribute_input(node_attr)\n                    if data[\"input\"]:\n                        if data[\"input\"] != input:\n                            cmds.connectAttr(\n                                data[\"input\"], node_attr, force=True\n                            )\n                    else:\n                        if input:\n                            cmds.disconnectAttr(input, node_attr)\n                        cmds.setAttr(node_attr, data[\"value\"])\n\n        # Fix PLN-40 for older containers created with AYON that had the\n        # `.verticesOnlySet` set to True.\n        if cmds.getAttr(\"{}.verticesOnlySet\".format(node)):\n            self.log.info(\"Setting %s.verticesOnlySet to False\", node)\n            cmds.setAttr(\"{}.verticesOnlySet\".format(node), False)\n\n        # Remove any placeHolderList attribute entries from the set that\n        # are remaining from nodes being removed from the referenced file.\n        members = cmds.sets(node, query=True)\n        invalid = [x for x in members if \".placeHolderList\" in x]\n        if invalid:\n            cmds.sets(invalid, remove=node)\n\n        # Update metadata\n        for attr_name, value in [\n            (\"representation\", repre_entity[\"id\"]),\n            (\"project_name\", context[\"project\"][\"name\"]),\n        ]:\n            lib.set_attribute(node=node, attribute=attr_name, value=value)\n\n        # When an animation or pointcache gets connected to an Xgen container,\n        # the compound attribute \"xgenContainers\" gets created. When animation\n        # containers gets updated we also need to update the cacheFileName on\n        # the Xgen collection.\n        compound_name = \"xgenContainers\"\n        if cmds.objExists(\"{}.{}\".format(node, compound_name)):\n            import xgenm\n            container_amount = cmds.getAttr(\n                \"{}.{}\".format(node, compound_name), size=True\n            )\n            # loop through all compound children\n            for i in range(container_amount):\n                attr = \"{}.{}[{}].container\".format(node, compound_name, i)\n                objectset = cmds.listConnections(attr)[0]\n                reference_node = cmds.sets(objectset, query=True)[0]\n                palettes = cmds.ls(\n                    cmds.referenceQuery(reference_node, nodes=True),\n                    type=\"xgmPalette\"\n                )\n                for palette in palettes:\n                    for description in xgenm.descriptions(palette):\n                        xgenm.setAttr(\n                            \"cacheFileName\",\n                            path.replace(\"\\\\\", \"/\"),\n                            palette,\n                            description,\n                            \"SplinePrimitive\"\n                        )\n\n            # Refresh UI and viewport.\n            de = xgenm.xgGlobal.DescriptionEditor\n            de.refresh(\"Full\")\n\n    def remove(self, container):\n        \"\"\"Remove an existing `container` from Maya scene\n\n        Deprecated; this functionality is replaced by `api.remove()`\n\n        Arguments:\n            container (openpype:container-1.0): Which container\n                to remove from scene.\n\n        \"\"\"\n        from maya import cmds\n\n        node = container[\"objectName\"]\n\n        # Assume asset has been referenced\n        members = cmds.sets(node, query=True)\n        reference_node = lib.get_reference_node(members, self.log)\n        assert reference_node, (\"Imported container not supported; \"\n                                \"container must be referenced.\")\n\n        self.log.info(\"Removing '%s' from Maya..\" % container[\"name\"])\n\n        namespace = cmds.referenceQuery(reference_node, namespace=True)\n        fname = cmds.referenceQuery(reference_node, filename=True)\n        cmds.file(fname, removeReference=True)\n\n        try:\n            cmds.delete(node)\n\n        except ValueError:\n            # Already implicitly deleted by Maya upon removing reference\n            pass\n\n        try:\n            # If container is not automatically cleaned up by May (issue #118)\n            cmds.namespace(removeNamespace=namespace,\n                           deleteNamespaceContent=True)\n\n        except RuntimeError:\n            pass\n\n    def prepare_root_value(self, file_url, project_name):\n        \"\"\"Replace root value with env var placeholder.\n\n        Use ${AYON_PROJECT_ROOT_WORK} (or any other root) instead of proper\n        root value when storing referenced url into a workfile.\n        Useful for remote workflows with SiteSync.\n\n        Args:\n            file_url (str)\n            project_name (dict)\n        Returns:\n            (str)\n        \"\"\"\n        settings = get_project_settings(project_name)\n        use_env_var_as_root = settings[\"maya\"][\"dirmap\"][\"use_env_var_as_root\"]\n        if use_env_var_as_root:\n            anatomy = Anatomy(project_name)\n            file_url = anatomy.replace_root_with_env_key(file_url, '${{{}}}')\n\n        return file_url\n\n    @classmethod\n    def get_representation_name_aliases(cls, representation_name):\n        # Allow switching between `ma` and `mb` representations if new\n        # version happens to contain only the other representation\n        return {\n            \"ma\": [\"mb\"],\n            \"mb\": [\"ma\"]\n        }.get(representation_name, [])\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.ReferenceLoader.prepare_root_value","title":"<code>prepare_root_value(file_url, project_name)</code>","text":"<p>Replace root value with env var placeholder.</p> <p>Use ${AYON_PROJECT_ROOT_WORK} (or any other root) instead of proper root value when storing referenced url into a workfile. Useful for remote workflows with SiteSync.</p> <p>Returns:     (str)</p> Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>def prepare_root_value(self, file_url, project_name):\n    \"\"\"Replace root value with env var placeholder.\n\n    Use ${AYON_PROJECT_ROOT_WORK} (or any other root) instead of proper\n    root value when storing referenced url into a workfile.\n    Useful for remote workflows with SiteSync.\n\n    Args:\n        file_url (str)\n        project_name (dict)\n    Returns:\n        (str)\n    \"\"\"\n    settings = get_project_settings(project_name)\n    use_env_var_as_root = settings[\"maya\"][\"dirmap\"][\"use_env_var_as_root\"]\n    if use_env_var_as_root:\n        anatomy = Anatomy(project_name)\n        file_url = anatomy.replace_root_with_env_key(file_url, '${{{}}}')\n\n    return file_url\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.ReferenceLoader.process_reference","title":"<code>process_reference(context, name, namespace, options)</code>","text":"<p>To be implemented by subclass</p> Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>def process_reference(self, context, name, namespace, options):\n    \"\"\"To be implemented by subclass\"\"\"\n    raise NotImplementedError(\"Must be implemented by subclass\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.ReferenceLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove an existing <code>container</code> from Maya scene</p> <p>Deprecated; this functionality is replaced by <code>api.remove()</code></p> <p>Parameters:</p> Name Type Description Default <code>container (openpype</code> <p>container-1.0): Which container to remove from scene.</p> required Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>def remove(self, container):\n    \"\"\"Remove an existing `container` from Maya scene\n\n    Deprecated; this functionality is replaced by `api.remove()`\n\n    Arguments:\n        container (openpype:container-1.0): Which container\n            to remove from scene.\n\n    \"\"\"\n    from maya import cmds\n\n    node = container[\"objectName\"]\n\n    # Assume asset has been referenced\n    members = cmds.sets(node, query=True)\n    reference_node = lib.get_reference_node(members, self.log)\n    assert reference_node, (\"Imported container not supported; \"\n                            \"container must be referenced.\")\n\n    self.log.info(\"Removing '%s' from Maya..\" % container[\"name\"])\n\n    namespace = cmds.referenceQuery(reference_node, namespace=True)\n    fname = cmds.referenceQuery(reference_node, filename=True)\n    cmds.file(fname, removeReference=True)\n\n    try:\n        cmds.delete(node)\n\n    except ValueError:\n        # Already implicitly deleted by Maya upon removing reference\n        pass\n\n    try:\n        # If container is not automatically cleaned up by May (issue #118)\n        cmds.namespace(removeNamespace=namespace,\n                       deleteNamespaceContent=True)\n\n    except RuntimeError:\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.RenderlayerCreator","title":"<code>RenderlayerCreator</code>","text":"<p>               Bases: <code>Creator</code>, <code>MayaCreatorBase</code></p> <p>Creator which creates an instance per renderlayer in the workfile.</p> <p>Create and manages renderlayer product per renderLayer in workfile. This generates a singleton node in the scene which, if it exists, tells the Creator to collect Maya rendersetup renderlayers as individual instances. As such, triggering create doesn't actually create the instance node per layer but only the node which tells the Creator it may now collect an instance per renderlayer.</p> Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>class RenderlayerCreator(Creator, MayaCreatorBase):\n    \"\"\"Creator which creates an instance per renderlayer in the workfile.\n\n    Create and manages renderlayer product per renderLayer in workfile.\n    This generates a singleton node in the scene which, if it exists, tells the\n    Creator to collect Maya rendersetup renderlayers as individual instances.\n    As such, triggering create doesn't actually create the instance node per\n    layer but only the node which tells the Creator it may now collect\n    an instance per renderlayer.\n\n    \"\"\"\n    settings_category = \"maya\"\n    # These are required to be overridden in subclass\n    singleton_node_name = \"\"\n\n    # These are optional to be overridden in subclass\n    layer_instance_prefix = None\n\n    def _get_singleton_node(self, return_all=False):\n        nodes = lib.lsattr(\"pre_creator_identifier\", self.identifier)\n        if nodes:\n            return nodes if return_all else nodes[0]\n\n    def create(self, product_name, instance_data, pre_create_data):\n        # A Renderlayer is never explicitly created using the create method.\n        # Instead, renderlayers from the scene are collected. Thus \"create\"\n        # would only ever be called to say, 'hey, please refresh collect'\n        self.create_singleton_node()\n\n        variant_name: str = instance_data.get(\"variant\", \"Main\")\n\n        # if no render layers are present, create default one with\n        # asterisk selector using the chosen variant name\n        rs = renderSetup.instance()\n        if not rs.getRenderLayers():\n            render_layer = rs.createRenderLayer(variant_name)\n            collection = render_layer.createCollection(\"defaultCollection\")\n            collection.getSelector().setPattern('*')\n\n        # By RenderLayerCreator.create we make it so that the renderlayer\n        # instances directly appear even though it just collects scene\n        # renderlayers. This doesn't actually 'create' any scene contents.\n        self.collect_instances()\n\n    def create_singleton_node(self):\n        if self._get_singleton_node():\n            raise CreatorError(\"A Render instance already exists - only \"\n                               \"one can be configured.\")\n\n        with lib.undo_chunk():\n            node = cmds.sets(empty=True, name=self.singleton_node_name)\n            lib.imprint(node, data={\n                \"pre_creator_identifier\": self.identifier\n            })\n\n        return node\n\n    def collect_instances(self):\n\n        # We only collect if the global render instance exists\n        if not self._get_singleton_node():\n            return\n\n        host_name = self.create_context.host_name\n        rs = renderSetup.instance()\n        layers = rs.getRenderLayers()\n        for layer in layers:\n            layer_instance_node = self.find_layer_instance_node(layer)\n            if layer_instance_node:\n                data = self.read_instance_node(layer_instance_node)\n                instance = CreatedInstance.from_existing(data, creator=self)\n            else:\n                # No existing scene instance node for this layer. Note that\n                # this instance will not have the `instance_node` data yet\n                # until it's been saved/persisted at least once.\n                project_name = self.create_context.get_current_project_name()\n                folder_entity = self.create_context.get_current_folder_entity()\n                folder_path: str = folder_entity[\"path\"]\n                task_entity = self.create_context.get_current_task_entity()\n                task_name: str = task_entity[\"name\"]\n                instance_data = {\n                    \"folderPath\": folder_path,\n                    \"task\": task_name,\n                    \"variant\": layer.name(),\n                }\n                product_name = self.get_product_name(\n                    project_name,\n                    folder_entity,\n                    task_entity,\n                    layer.name(),\n                    host_name,\n                )\n\n                instance = CreatedInstance(\n                    product_type=self.product_type,\n                    product_name=product_name,\n                    data=instance_data,\n                    creator=self\n                )\n\n            instance.transient_data[\"layer\"] = layer\n            self._add_instance_to_context(instance)\n\n    def find_layer_instance_node(self, layer):\n        connected_sets = cmds.listConnections(\n            \"{}.message\".format(layer.name()),\n            source=False,\n            destination=True,\n            type=\"objectSet\"\n        ) or []\n\n        for node in connected_sets:\n            if not cmds.attributeQuery(\"creator_identifier\",\n                                       node=node,\n                                       exists=True):\n                continue\n\n            creator_identifier = cmds.getAttr(node + \".creator_identifier\")\n            if creator_identifier == self.identifier:\n                self.log.info(\"Found node: {}\".format(node))\n                return node\n\n    def _create_layer_instance_node(self, layer):\n\n        # We only collect if a CreateRender instance exists\n        create_render_set = self._get_singleton_node()\n        if not create_render_set:\n            raise CreatorError(\"Creating a renderlayer instance node is not \"\n                               \"allowed if no 'CreateRender' instance exists\")\n\n        namespace = \"_{}\".format(self.singleton_node_name)\n        namespace = ensure_namespace(namespace)\n\n        name = \"{}:{}\".format(namespace, layer.name())\n        render_set = cmds.sets(name=name, empty=True)\n\n        # Keep an active link with the renderlayer so we can retrieve it\n        # later by a physical maya connection instead of relying on the layer\n        # name\n        cmds.addAttr(render_set, longName=\"renderlayer\", at=\"message\")\n        cmds.connectAttr(\"{}.message\".format(layer.name()),\n                         \"{}.renderlayer\".format(render_set), force=True)\n\n        # Add the set to the 'CreateRender' set.\n        cmds.sets(render_set, forceElement=create_render_set)\n\n        return render_set\n\n    def update_instances(self, update_list):\n        # We only generate the persisting layer data into the scene once\n        # we save with the UI on e.g. validate or publish\n        for instance, _changes in update_list:\n            instance_node = instance.data.get(\"instance_node\")\n\n            # Ensure a node exists to persist the data to\n            if not instance_node:\n                layer = instance.transient_data[\"layer\"]\n                instance_node = self._create_layer_instance_node(layer)\n                instance.data[\"instance_node\"] = instance_node\n\n            self.imprint_instance_node(instance_node,\n                                       data=instance.data_to_store())\n\n    def imprint_instance_node(self, node, data):\n        # Do not ever try to update the `renderlayer` since it'll try\n        # to remove the attribute and recreate it but fail to keep it a\n        # message attribute link. We only ever imprint that on the initial\n        # node creation.\n        # TODO: Improve how this is handled\n        data.pop(\"renderlayer\", None)\n        data.get(\"creator_attributes\", {}).pop(\"renderlayer\", None)\n\n        return super(RenderlayerCreator, self).imprint_instance_node(node,\n                                                                     data=data)\n\n    def remove_instances(self, instances):\n        \"\"\"Remove specified instances from the scene.\n\n        This is only removing `id` parameter so instance is no longer\n        instance, because it might contain valuable data for artist.\n\n        \"\"\"\n        # Instead of removing the single instance or renderlayers we instead\n        # remove the CreateRender node this creator relies on to decide whether\n        # it should collect anything at all.\n        nodes = self._get_singleton_node(return_all=True)\n        if nodes:\n            cmds.delete(nodes)\n\n        # Remove ALL the instances even if only one gets deleted\n        for instance in list(self.create_context.instances):\n            if instance.get(\"creator_identifier\") == self.identifier:\n                self._remove_instance_from_context(instance)\n\n                # Remove the stored settings per renderlayer too\n                node = instance.data.get(\"instance_node\")\n                if node and cmds.objExists(node):\n                    cmds.delete(node)\n\n    def get_product_name(\n        self,\n        project_name,\n        folder_entity,\n        task_entity,\n        variant,\n        host_name=None,\n        instance=None\n    ):\n        if host_name is None:\n            host_name = self.create_context.host_name\n        dynamic_data = self.get_dynamic_data(\n            project_name,\n            folder_entity,\n            task_entity,\n            variant,\n            host_name,\n            instance\n        )\n        task_name = task_type = None\n        if task_entity:\n            task_name = task_entity[\"name\"]\n            task_type = task_entity[\"taskType\"]\n        # creator.product_type != 'render' as expected\n        return get_product_name(\n            project_name=project_name,\n            task_name=task_name,\n            task_type=task_type,\n            host_name=host_name,\n            product_type=self.layer_instance_prefix or self.product_type,\n            variant=variant,\n            dynamic_data=dynamic_data,\n            project_settings=self.project_settings\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.RenderlayerCreator.remove_instances","title":"<code>remove_instances(instances)</code>","text":"<p>Remove specified instances from the scene.</p> <p>This is only removing <code>id</code> parameter so instance is no longer instance, because it might contain valuable data for artist.</p> Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>def remove_instances(self, instances):\n    \"\"\"Remove specified instances from the scene.\n\n    This is only removing `id` parameter so instance is no longer\n    instance, because it might contain valuable data for artist.\n\n    \"\"\"\n    # Instead of removing the single instance or renderlayers we instead\n    # remove the CreateRender node this creator relies on to decide whether\n    # it should collect anything at all.\n    nodes = self._get_singleton_node(return_all=True)\n    if nodes:\n        cmds.delete(nodes)\n\n    # Remove ALL the instances even if only one gets deleted\n    for instance in list(self.create_context.instances):\n        if instance.get(\"creator_identifier\") == self.identifier:\n            self._remove_instance_from_context(instance)\n\n            # Remove the stored settings per renderlayer too\n            node = instance.data.get(\"instance_node\")\n            if node and cmds.objExists(node):\n                cmds.delete(node)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.ensure_namespace","title":"<code>ensure_namespace(namespace)</code>","text":"<p>Make sure the namespace exists.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str</code> <p>The preferred namespace name.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The generated or existing namespace</p> Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>def ensure_namespace(namespace):\n    \"\"\"Make sure the namespace exists.\n\n    Args:\n        namespace (str): The preferred namespace name.\n\n    Returns:\n        str: The generated or existing namespace\n\n    \"\"\"\n    exists = cmds.namespace(exists=namespace)\n    if exists:\n        return namespace\n    else:\n        return cmds.namespace(add=namespace)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.get_ayon_entity_uri_from_representation_context","title":"<code>get_ayon_entity_uri_from_representation_context(context)</code>","text":"<p>Resolve AYON Entity URI from representation context.</p> Note <p>The representation context is the <code>get_representation_context</code> dict containing the <code>project</code>, <code>folder,</code>representation<code>and so forth. It is not the representation entity</code>context` key.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>The representation context.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Unable to resolve to a single valid URI.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The AYON entity URI.</p> Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>def get_ayon_entity_uri_from_representation_context(context: dict) -&gt; str:\n    \"\"\"Resolve AYON Entity URI from representation context.\n\n    Note:\n        The representation context is the `get_representation_context` dict\n        containing the `project`, `folder, `representation` and so forth.\n        It is not the representation entity `context` key.\n\n    Arguments:\n        context (dict): The representation context.\n\n    Raises:\n        RuntimeError: Unable to resolve to a single valid URI.\n\n    Returns:\n        str: The AYON entity URI.\n\n    \"\"\"\n    # TODO: This is a 1:1 copy from ayon-houdini and may be good to refactor\n    #    and de-duplicate across the codebase, e.g. to core functionality\n    project_name = context[\"project\"][\"name\"]\n    representation_id = context[\"representation\"][\"id\"]\n    response = ayon_api.post(\n        f\"projects/{project_name}/uris\",\n        entityType=\"representation\",\n        ids=[representation_id])\n    if response.status_code != 200:\n        raise RuntimeError(\n            f\"Unable to resolve AYON entity URI for '{project_name}' \"\n            f\"representation id '{representation_id}': {response.text}\"\n        )\n    uris = response.data[\"uris\"]\n    if len(uris) != 1:\n        raise RuntimeError(\n            f\"Unable to resolve AYON entity URI for '{project_name}' \"\n            f\"representation id '{representation_id}' to single URI. \"\n            f\"Received data: {response.data}\"\n        )\n    return uris[0][\"uri\"]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.get_load_color_for_product_type","title":"<code>get_load_color_for_product_type(product_type, settings=None)</code>","text":"<p>Get color for product type from settings.</p> <p>Parameters:</p> Name Type Description Default <code>product_type</code> <code>str</code> <p>Family name.</p> required <code>settings</code> <code>Optional[dict]</code> <p>Settings dictionary.</p> <code>None</code> <p>Returns:</p> Type Description <p>Union[tuple[float, float, float], None]: RGB color.</p> Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>def get_load_color_for_product_type(product_type, settings=None):\n    \"\"\"Get color for product type from settings.\n\n    Args:\n        product_type (str): Family name.\n        settings (Optional[dict]): Settings dictionary.\n\n    Returns:\n        Union[tuple[float, float, float], None]: RGB color.\n\n    \"\"\"\n    if settings is None:\n        settings = get_project_settings(get_current_project_name())\n\n    colors = settings[\"maya\"][\"load\"][\"colors\"]\n    color = colors.get(product_type)\n    if not color:\n        return None\n\n    if len(color) == 3:\n        red, green, blue = color\n    elif len(color) == 4:\n        red, green, blue, _ = color\n    else:\n        raise ValueError(\"Invalid color definition {}\".format(str(color)))\n\n    if isinstance(red, int):\n        red = red / 255.0\n        green = green / 255.0\n        blue = blue / 255.0\n    return red, green, blue\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.get_reference_node","title":"<code>get_reference_node(*args, **kwargs)</code>","text":"<p>Get the reference node from the container members</p> Deprecated <p>This function was moved and will be removed in 3.16.x.</p> Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>def get_reference_node(*args, **kwargs):\n    \"\"\"Get the reference node from the container members\n\n    Deprecated:\n        This function was moved and will be removed in 3.16.x.\n    \"\"\"\n    msg = \"Function 'get_reference_node' has been moved.\"\n    log.warning(msg)\n    cmds.warning(msg)\n    return lib.get_reference_node(*args, **kwargs)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/plugin.html#client.ayon_maya.api.plugin.get_reference_node_parents","title":"<code>get_reference_node_parents(*args, **kwargs)</code>","text":"Deprecated <p>This function was moved and will be removed in 3.16.x.</p> Source code in <code>client/ayon_maya/api/plugin.py</code> <pre><code>def get_reference_node_parents(*args, **kwargs):\n    \"\"\"\n    Deprecated:\n        This function was moved and will be removed in 3.16.x.\n    \"\"\"\n    msg = \"Function 'get_reference_node_parents' has been moved.\"\n    log.warning(msg)\n    cmds.warning(msg)\n    return lib.get_reference_node_parents(*args, **kwargs)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/render_setup_tools.html","title":"render_setup_tools","text":"<p>Export stuff in render setup layer context.</p> <p>Export Maya nodes from Render Setup layer as if flattened in that layer instead of exporting the defaultRenderLayer as Maya forces by default</p> <p>Credits: Roy Nieterau (BigRoy) / Colorbleed Modified for use in AYON</p>"},{"location":"autoapi/client/ayon_maya/api/render_setup_tools.html#client.ayon_maya.api.render_setup_tools.allow_export_from_render_setup_layer","title":"<code>allow_export_from_render_setup_layer()</code>","text":"<p>Context manager to override Maya settings to allow RS layer export</p> Source code in <code>client/ayon_maya/api/render_setup_tools.py</code> <pre><code>@contextlib.contextmanager\ndef allow_export_from_render_setup_layer():\n    \"\"\"Context manager to override Maya settings to allow RS layer export\"\"\"\n    try:\n\n        rs = renderSetup.instance()\n\n        # Exclude Render Setup nodes from the export\n        rs._setAllRSNodesDoNotWrite(True)\n\n        # Disable Render Setup forcing the switch to master layer\n        os.environ[\"MAYA_BATCH_RENDER_EXPORT\"] = \"1\"\n\n        yield\n\n    finally:\n        # Reset original state\n        rs._setAllRSNodesDoNotWrite(False)\n        os.environ.pop(\"MAYA_BATCH_RENDER_EXPORT\", None)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/render_setup_tools.html#client.ayon_maya.api.render_setup_tools.export_in_rs_layer","title":"<code>export_in_rs_layer(path, nodes, export=None)</code>","text":"<p>Export nodes from Render Setup layer.</p> <p>When exporting from Render Setup layer Maya by default forces a switch to the defaultRenderLayer as such making it impossible to export the contents of a Render Setup layer. Maya presents this warning message:     # Warning: Exporting Render Setup master layer content #</p> <p>This function however avoids the renderlayer switch and exports from the Render Setup layer as if the edits were 'flattened' in the master layer.</p> It does so by <ul> <li>Allowing export from Render Setup Layer</li> <li>Enforce Render Setup nodes to NOT be written on export</li> <li>Disconnect connections from any <code>applyOverride</code> nodes   to flatten the values (so they are written correctly)*</li> </ul> <p>*Connection overrides like Shader Override and Material Overrides export correctly out of the box since they don't create an intermediate connection to an 'applyOverride' node. However, any scalar override (absolute or relative override) will get input connections in the layer so we'll break those to 'store' the values on the attribute itself and write value out instead.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>File path to export to.</p> required <code>nodes</code> <code>list</code> <p>Maya nodes to export.</p> required <code>export</code> <code>callable</code> <p>Callback to be used for exporting. If not specified, default export to <code>.ma</code> will be called.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>When not in a Render Setup layer an AssertionError is raised. This command assumes you are currently in a Render Setup layer.</p> Source code in <code>client/ayon_maya/api/render_setup_tools.py</code> <pre><code>def export_in_rs_layer(path, nodes, export=None):\n    \"\"\"Export nodes from Render Setup layer.\n\n    When exporting from Render Setup layer Maya by default\n    forces a switch to the defaultRenderLayer as such making\n    it impossible to export the contents of a Render Setup\n    layer. Maya presents this warning message:\n        # Warning: Exporting Render Setup master layer content #\n\n    This function however avoids the renderlayer switch and\n    exports from the Render Setup layer as if the edits were\n    'flattened' in the master layer.\n\n    It does so by:\n        - Allowing export from Render Setup Layer\n        - Enforce Render Setup nodes to NOT be written on export\n        - Disconnect connections from any `applyOverride` nodes\n          to flatten the values (so they are written correctly)*\n    *Connection overrides like Shader Override and Material\n    Overrides export correctly out of the box since they don't\n    create an intermediate connection to an 'applyOverride' node.\n    However, any scalar override (absolute or relative override)\n    will get input connections in the layer so we'll break those\n    to 'store' the values on the attribute itself and write value\n    out instead.\n\n    Args:\n        path (str): File path to export to.\n        nodes (list): Maya nodes to export.\n        export (callable, optional): Callback to be used for exporting. If\n            not specified, default export to `.ma` will be called.\n\n    Returns:\n        None\n\n    Raises:\n        AssertionError: When not in a Render Setup layer an\n            AssertionError is raised. This command assumes\n            you are currently in a Render Setup layer.\n\n    \"\"\"\n    rs = renderSetup.instance()\n    assert rs.getVisibleRenderLayer().name() != \"defaultRenderLayer\", \\\n        (\"Export in Render Setup layer is only supported when in \"\n         \"Render Setup layer\")\n\n    # Break connection to any value overrides\n    history = cmds.listHistory(nodes) or []\n    nodes_all = list(\n        set(cmds.ls(nodes + history, long=True, objectsOnly=True)))\n    overrides = cmds.listConnections(nodes_all,\n                                     source=True,\n                                     destination=False,\n                                     type=\"applyOverride\",\n                                     plugs=True,\n                                     connections=True) or []\n    for dest, src in pairwise(overrides):\n        # Even after disconnecting the values\n        # should be preserved as they were\n        # Note: animated overrides would be lost for export\n        cmds.disconnectAttr(src, dest)\n\n    # Export Selected\n    with allow_export_from_render_setup_layer():\n        cmds.select(nodes, noExpand=True)\n        if export:\n            export()\n        else:\n            cmds.file(path,\n                      force=True,\n                      typ=\"mayaAscii\",\n                      exportSelected=True,\n                      preserveReferences=False,\n                      channels=True,\n                      constraints=True,\n                      expressions=True,\n                      constructionHistory=True)\n\n    if overrides:\n        # If we have broken override connections then Maya\n        # is unaware that the Render Setup layer is in an\n        # invalid state. So let's 'hard reset' the state\n        # by going to default render layer and switching back\n        layer = rs.getVisibleRenderLayer()\n        rs.switchToLayer(None)\n        rs.switchToLayer(layer)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/setdress.html","title":"setdress","text":""},{"location":"autoapi/client/ayon_maya/api/setdress.html#client.ayon_maya.api.setdress.compare_representations","title":"<code>compare_representations(current_repre, current_parents, new_repre, new_parents)</code>","text":"<p>Check if the old representation given can be updated</p> <p>Due to limitations of the <code>update_container</code> function we cannot allow differences in the following data:</p> <ul> <li>Representation name (extension)</li> <li>Folder id</li> <li>Product id</li> </ul> <p>If any of those data values differs, the function will raise an RuntimeError</p> <p>Parameters:</p> Name Type Description Default <code>current_repre</code> <code>dict[str, Any]</code> <p>Current representation entity.</p> required <code>current_parents</code> <code>RepresentationParents</code> <p>Current representation parents.</p> required <code>new_repre</code> <code>dict[str, Any]</code> <p>New representation entity.</p> required <code>new_parents</code> <code>RepresentationParents</code> <p>New representation parents.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>False if the representation is not invalid else True</p> Source code in <code>client/ayon_maya/api/setdress.py</code> <pre><code>def compare_representations(\n    current_repre, current_parents, new_repre, new_parents\n):\n    \"\"\"Check if the old representation given can be updated\n\n    Due to limitations of the `update_container` function we cannot allow\n    differences in the following data:\n\n    * Representation name (extension)\n    * Folder id\n    * Product id\n\n    If any of those data values differs, the function will raise an\n    RuntimeError\n\n    Args:\n        current_repre (dict[str, Any]): Current representation entity.\n        current_parents (RepresentationParents): Current\n            representation parents.\n        new_repre (dict[str, Any]): New representation entity.\n        new_parents (RepresentationParents): New representation parents.\n\n    Returns:\n        bool: False if the representation is not invalid else True\n\n    \"\"\"\n    if current_repre[\"name\"] != new_repre[\"name\"]:\n        log.error(\"Cannot switch extensions\")\n        return False\n\n    # TODO add better validation e.g. based on parent ids\n    if current_parents.folder[\"id\"] != new_parents.folder[\"id\"]:\n        log.error(\"Changing folders between updates is not supported.\")\n        return False\n\n    if current_parents.product[\"id\"] != new_parents.product[\"id\"]:\n        log.error(\"Changing products between updates is not supported.\")\n        return False\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/setdress.html#client.ayon_maya.api.setdress.get_contained_containers","title":"<code>get_contained_containers(container)</code>","text":"<p>Get the AYON containers in this container</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>dict</code> <p>The container dict.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of member container dictionaries.</p> Source code in <code>client/ayon_maya/api/setdress.py</code> <pre><code>def get_contained_containers(container):\n    \"\"\"Get the AYON containers in this container\n\n    Args:\n        container (dict): The container dict.\n\n    Returns:\n        list: A list of member container dictionaries.\n\n    \"\"\"\n\n    from .pipeline import parse_container\n\n    # Get AYON containers in this package setdress container\n    containers = []\n    members = cmds.sets(container['objectName'], query=True)\n    for node in cmds.ls(members, type=\"objectSet\"):\n        member_container = parse_container(node)\n        if not member_container:\n            # Skip invalid container (missing partial metadata)\n            continue\n        containers.append(member_container)\n\n    return containers\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/setdress.html#client.ayon_maya.api.setdress.load_package","title":"<code>load_package(filepath, name, namespace=None)</code>","text":"<p>Load a package that was gathered elsewhere.</p> <p>A package is a group of published instances, possibly with additional data in a hierarchy.</p> Source code in <code>client/ayon_maya/api/setdress.py</code> <pre><code>def load_package(filepath, name, namespace=None):\n    \"\"\"Load a package that was gathered elsewhere.\n\n    A package is a group of published instances, possibly with additional data\n    in a hierarchy.\n\n    \"\"\"\n\n    if namespace is None:\n        # Define a unique namespace for the package\n        namespace = os.path.basename(filepath).split(\".\")[0]\n        unique_namespace(namespace)\n    assert isinstance(namespace, str)\n\n    # Load the setdress package data\n    with open(filepath, \"r\") as fp:\n        data = json.load(fp)\n\n    # Load the setdress alembic hierarchy\n    #   We import this into the namespace in which we'll load the package's\n    #   instances into afterwards.\n    alembic = filepath.replace(\".json\", \".abc\")\n    hierarchy = cmds.file(alembic,\n                          reference=True,\n                          namespace=namespace,\n                          returnNewNodes=True,\n                          groupReference=True,\n                          groupName=\"{}:{}\".format(namespace, name),\n                          typ=\"Alembic\")\n\n    # Get the top root node (the reference group)\n    root = \"{}:{}\".format(namespace, name)\n\n    containers = []\n    all_loaders = discover_loader_plugins()\n    for representation_id, instances in data.items():\n\n        # Find the compatible loaders\n        loaders = loaders_from_representation(\n            all_loaders, representation_id\n        )\n\n        for instance in instances:\n            container = _add(instance=instance,\n                             representation_id=representation_id,\n                             loaders=loaders,\n                             namespace=namespace,\n                             root=root)\n            containers.append(container)\n\n    # TODO: Do we want to cripple? Or do we want to add a 'parent' parameter?\n    # Cripple the original AYON containers so they don't show up in the\n    # manager\n    # for container in containers:\n    #     cmds.setAttr(\"%s.id\" % container,\n    #                  \"setdress.container\",\n    #                  type=\"string\")\n\n    # TODO: Lock all loaded nodes\n    #   This is to ensure the hierarchy remains unaltered by the artists\n    # for node in nodes:\n    #      cmds.lockNode(node, lock=True)\n\n    return containers + hierarchy\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/setdress.html#client.ayon_maya.api.setdress.namespaced","title":"<code>namespaced(namespace, new=True)</code>","text":"<p>Work inside namespace during context</p> <p>Parameters:</p> Name Type Description Default <code>new</code> <code>bool</code> <p>When enabled this will rename the namespace to a unique namespace if the input namespace already exists.</p> <code>True</code> <p>Yields:</p> Name Type Description <code>str</code> <p>The namespace that is used during the context</p> Source code in <code>client/ayon_maya/api/setdress.py</code> <pre><code>@contextlib.contextmanager\ndef namespaced(namespace, new=True):\n    \"\"\"Work inside namespace during context\n\n    Args:\n        new (bool): When enabled this will rename the namespace to a unique\n            namespace if the input namespace already exists.\n\n    Yields:\n        str: The namespace that is used during the context\n\n    \"\"\"\n    original = cmds.namespaceInfo(cur=True)\n    if new:\n        namespace = unique_namespace(namespace)\n        cmds.namespace(add=namespace)\n\n    try:\n        cmds.namespace(set=namespace)\n        yield namespace\n    finally:\n        cmds.namespace(set=original)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/setdress.html#client.ayon_maya.api.setdress.to_namespace","title":"<code>to_namespace(node, namespace)</code>","text":"<p>Return node name as if it's inside the namespace.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>Node name</p> required <code>namespace</code> <code>str</code> <p>Namespace</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The node in the namespace.</p> Source code in <code>client/ayon_maya/api/setdress.py</code> <pre><code>def to_namespace(node, namespace):\n    \"\"\"Return node name as if it's inside the namespace.\n\n    Args:\n        node (str): Node name\n        namespace (str): Namespace\n\n    Returns:\n        str: The node in the namespace.\n\n    \"\"\"\n    namespace_prefix = \"|{}:\".format(namespace)\n    node = namespace_prefix.join(node.split(\"|\"))\n    return node\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/setdress.html#client.ayon_maya.api.setdress.update_package","title":"<code>update_package(set_container, context)</code>","text":"<p>Update any matrix changes in the scene based on the new data</p> <p>Parameters:</p> Name Type Description Default <code>set_container</code> <code>dict</code> <p>container data from <code>ls()</code></p> required <code>context</code> <code>dict</code> <p>the representation document from the database</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_maya/api/setdress.py</code> <pre><code>def update_package(set_container, context):\n    \"\"\"Update any matrix changes in the scene based on the new data\n\n    Args:\n        set_container (dict): container data from `ls()`\n        context (dict): the representation document from the database\n\n    Returns:\n        None\n\n    \"\"\"\n\n    # Load the original package data\n    project_name = context[\"project\"][\"name\"]\n    repre_entity = context[\"representation\"]\n    current_representation = ayon_api.get_representation_by_id(\n        project_name, set_container[\"representation\"]\n    )\n\n    current_file = get_representation_path_by_project(\n        project_name, current_representation\n    )\n    assert current_file.endswith(\".json\")\n    with open(current_file, \"r\") as fp:\n        current_data = json.load(fp)\n\n    # Load the new package data\n    new_file = get_representation_path_by_project(\n        project_name, repre_entity\n    )\n    assert new_file.endswith(\".json\")\n    with open(new_file, \"r\") as fp:\n        new_data = json.load(fp)\n\n    # Update scene content\n    containers = get_contained_containers(set_container)\n    update_scene(set_container, containers, current_data, new_data, new_file)\n\n    # TODO: This should be handled by the pipeline itself\n    cmds.setAttr(set_container['objectName'] + \".representation\",\n                 context[\"representation\"][\"id\"], type=\"string\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/setdress.html#client.ayon_maya.api.setdress.update_package_version","title":"<code>update_package_version(container, version)</code>","text":"<p>Update package by version number</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>dict</code> <p>container data of the container node</p> required <code>version</code> <code>int</code> <p>the new version number of the package</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_maya/api/setdress.py</code> <pre><code>def update_package_version(container, version):\n    \"\"\"\n    Update package by version number\n\n    Args:\n        container (dict): container data of the container node\n        version (int): the new version number of the package\n\n    Returns:\n        None\n\n    \"\"\"\n\n    # Versioning (from `core.maya.pipeline`)\n    project_name = get_current_project_name()\n    repre_id = container[\"representation\"]\n    current_representation = ayon_api.get_representation_by_id(\n        project_name, repre_id\n    )\n\n    assert current_representation is not None, \"This is a bug\"\n\n    (\n        version_entity,\n        product_entity,\n        folder_entity,\n        project_entity\n    ) = ayon_api.get_representation_parents(project_name, repre_id)\n\n    if version == -1:\n        new_version = ayon_api.get_last_version_by_product_id(\n            project_name, product_entity[\"id\"]\n        )\n    else:\n        new_version = ayon_api.get_version_by_name(\n            project_name, version, product_entity[\"id\"]\n        )\n\n    if new_version is None:\n        raise ValueError(\"Version not found: {}\".format(version))\n\n    # Get the new representation (new file)\n    new_representation = ayon_api.get_representation_by_name(\n        project_name, current_representation[\"name\"], new_version[\"id\"]\n    )\n    # TODO there is 'get_representation_context' to get the context which\n    #   could be possible to use here\n    new_context = {\n        \"project\": project_entity,\n        \"folder\": folder_entity,\n        \"product\": product_entity,\n        \"version\": version_entity,\n        \"representation\": new_representation,\n    }\n    update_package(container, new_context)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/setdress.html#client.ayon_maya.api.setdress.update_scene","title":"<code>update_scene(set_container, containers, current_data, new_data, new_file)</code>","text":"<p>Updates the hierarchy, assets and their matrix</p> Updates the following within the scene <ul> <li>Setdress hierarchy alembic</li> <li>Matrix</li> <li>Parenting</li> <li>Representations</li> </ul> <p>It removes any assets which are not present in the new build data</p> <p>Parameters:</p> Name Type Description Default <code>set_container</code> <code>dict</code> <p>the setdress container of the scene</p> required <code>containers</code> <code>list</code> <p>the list of containers under the setdress container</p> required <code>current_data</code> <code>dict</code> <p>the current build data of the setdress</p> required <code>new_data</code> <code>dict</code> <p>the new build data of the setdres</p> required <p>Returns:</p> Name Type Description <code>processed_containers</code> <code>list</code> <p>all new and updated containers</p> Source code in <code>client/ayon_maya/api/setdress.py</code> <pre><code>def update_scene(set_container, containers, current_data, new_data, new_file):\n    \"\"\"Updates the hierarchy, assets and their matrix\n\n    Updates the following within the scene:\n        * Setdress hierarchy alembic\n        * Matrix\n        * Parenting\n        * Representations\n\n    It removes any assets which are not present in the new build data\n\n    Args:\n        set_container (dict): the setdress container of the scene\n        containers (list): the list of containers under the setdress container\n        current_data (dict): the current build data of the setdress\n        new_data (dict): the new build data of the setdres\n\n    Returns:\n        processed_containers (list): all new and updated containers\n\n    \"\"\"\n\n    set_namespace = set_container['namespace']\n    project_name = get_current_project_name()\n\n    # Update the setdress hierarchy alembic\n    set_root = get_container_transforms(set_container, root=True)\n    set_hierarchy_root = cmds.listRelatives(set_root, fullPath=True)[0]\n    set_hierarchy_reference = cmds.referenceQuery(set_hierarchy_root,\n                                                  referenceNode=True)\n    new_alembic = new_file.replace(\".json\", \".abc\")\n    assert os.path.exists(new_alembic), \"%s does not exist.\" % new_alembic\n    with unlocked(cmds.listRelatives(set_root, ad=True, fullPath=True)):\n        cmds.file(new_alembic,\n                  loadReference=set_hierarchy_reference,\n                  type=\"Alembic\")\n\n    identity = DEFAULT_MATRIX[:]\n\n    processed_namespaces = set()\n    processed_containers = list()\n\n    new_lookup = _instances_by_namespace(new_data)\n    old_lookup = _instances_by_namespace(current_data)\n    repre_ids = set()\n    containers_for_repre_compare = []\n    for container in containers:\n        container_ns = container['namespace']\n\n        # Consider it processed here, even it it fails we want to store that\n        # the namespace was already available.\n        processed_namespaces.add(container_ns)\n        processed_containers.append(container['objectName'])\n\n        if container_ns not in new_lookup:\n            # Remove this container because it's not in the new data\n            log.warning(\"Removing content: %s\", container_ns)\n            remove_container(container)\n            continue\n\n        root = get_container_transforms(container, root=True)\n        if not root:\n            log.error(\"Can't find root for %s\", container['objectName'])\n            continue\n\n        old_instance = old_lookup.get(container_ns, {})\n        new_instance = new_lookup[container_ns]\n\n        # Update the matrix\n        # check matrix against old_data matrix to find local overrides\n        current_matrix = cmds.xform(root,\n                                    query=True,\n                                    matrix=True,\n                                    objectSpace=True)\n\n        original_matrix = old_instance.get(\"matrix\", identity)\n        has_matrix_override = not matrix_equals(current_matrix,\n                                                original_matrix)\n\n        if has_matrix_override:\n            log.warning(\"Matrix override preserved on %s\", container_ns)\n        else:\n            new_matrix = new_instance.get(\"matrix\", identity)\n            cmds.xform(root, matrix=new_matrix, objectSpace=True)\n\n        # Update the parenting\n        if old_instance.get(\"parent\", None) != new_instance[\"parent\"]:\n\n            parent = to_namespace(new_instance['parent'], set_namespace)\n            if not cmds.objExists(parent):\n                log.error(\"Can't find parent %s\", parent)\n                continue\n\n            # Set the new parent\n            cmds.lockNode(root, lock=False)\n            root = cmds.parent(root, parent, relative=True)\n            cmds.lockNode(root, lock=True)\n\n        # Update the representation\n        representation_current = container['representation']\n        representation_old = old_instance['representation']\n        representation_new = new_instance['representation']\n        has_representation_override = (representation_current !=\n                                       representation_old)\n\n        if representation_new == representation_current:\n            continue\n\n        if has_representation_override:\n            log.warning(\"Your scene had local representation \"\n                        \"overrides within the set. New \"\n                        \"representations not loaded for %s.\",\n                        container_ns)\n            continue\n\n        # We check it against the current 'loader' in the scene instead\n        # of the original data of the package that was loaded because\n        # an Artist might have made scene local overrides\n        if new_instance['loader'] != container['loader']:\n            log.warning(\"Loader is switched - local edits will be \"\n                        \"lost. Removing: %s\",\n                        container_ns)\n\n            # Remove this from the \"has been processed\" list so it's\n            # considered as new element and added afterwards.\n            processed_containers.pop()\n            processed_namespaces.remove(container_ns)\n            remove_container(container)\n            continue\n\n        # Check whether the conversion can be done by the Loader.\n        # They *must* use the same folder, product and Loader for\n        # `update_container` to make sense.\n        repre_ids.add(representation_current)\n        repre_ids.add(representation_new)\n\n        containers_for_repre_compare.append(\n            (container, representation_current, representation_new)\n        )\n\n    repre_entities_by_id = {\n        repre_entity[\"id\"]: repre_entity\n        for repre_entity in ayon_api.get_representations(\n            project_name, representation_ids=repre_ids\n        )\n    }\n    repre_parents_by_id = ayon_api.get_representations_parents(\n        project_name, repre_ids\n    )\n    for (\n        container,\n        repre_current_id,\n        repre_new_id\n    ) in containers_for_repre_compare:\n        current_repre = repre_entities_by_id[repre_current_id]\n        current_parents = repre_parents_by_id[repre_current_id]\n        new_repre = repre_entities_by_id[repre_new_id]\n        new_parents = repre_parents_by_id[repre_new_id]\n\n        is_valid = compare_representations(\n            current_repre, current_parents, new_repre, new_parents\n        )\n        if not is_valid:\n            log.error(\"Skipping: %s. See log for details.\",\n                      container[\"namespace\"])\n            continue\n\n        new_version = new_parents.version[\"version\"]\n        update_container(container, version=new_version)\n\n    # Add new assets\n    all_loaders = discover_loader_plugins()\n    for representation_id, instances in new_data.items():\n\n        # Find the compatible loaders\n        loaders = loaders_from_representation(\n            all_loaders, representation_id\n        )\n        for instance in instances:\n\n            # Already processed in update functionality\n            if instance['namespace'] in processed_namespaces:\n                continue\n\n            container = _add(instance=instance,\n                             representation_id=representation_id,\n                             loaders=loaders,\n                             namespace=set_container['namespace'],\n                             root=set_root)\n\n            # Add to the setdress container\n            cmds.sets(container,\n                      addElement=set_container['objectName'])\n\n            processed_containers.append(container)\n\n    return processed_containers\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/workfile_template_builder.html","title":"workfile_template_builder","text":""},{"location":"autoapi/client/ayon_maya/api/workfile_template_builder.html#client.ayon_maya.api.workfile_template_builder.MayaPlaceholderPlugin","title":"<code>MayaPlaceholderPlugin</code>","text":"<p>               Bases: <code>PlaceholderPlugin</code></p> <p>Base Placeholder Plugin for Maya with one unified cache.</p> <p>Creates a locator as placeholder node, which during populate provide all of its attributes defined on the locator's transform in <code>placeholder.data</code> and where <code>placeholder.scene_identifier</code> is the full path to the node.</p> <p>Inherited classes must still implement <code>populate_placeholder</code></p> Source code in <code>client/ayon_maya/api/workfile_template_builder.py</code> <pre><code>class MayaPlaceholderPlugin(PlaceholderPlugin):\n    \"\"\"Base Placeholder Plugin for Maya with one unified cache.\n\n    Creates a locator as placeholder node, which during populate provide\n    all of its attributes defined on the locator's transform in\n    `placeholder.data` and where `placeholder.scene_identifier` is the\n    full path to the node.\n\n    Inherited classes must still implement `populate_placeholder`\n\n    \"\"\"\n\n    use_selection_as_parent = True\n    item_class = PlaceholderItem\n\n    def _create_placeholder_name(self, placeholder_data):\n        return self.identifier.replace(\".\", \"_\")\n\n    def _collect_scene_placeholders(self):\n        nodes_by_identifier = self.builder.get_shared_populate_data(\n            \"placeholder_nodes\"\n        )\n        if nodes_by_identifier is None:\n            # Cache placeholder data to shared data\n            nodes = cmds.ls(\"*.plugin_identifier\", long=True, objectsOnly=True)\n\n            nodes_by_identifier = {}\n            for node in nodes:\n                identifier = cmds.getAttr(\"{}.plugin_identifier\".format(node))\n                nodes_by_identifier.setdefault(identifier, []).append(node)\n\n            # Set the cache\n            self.builder.set_shared_populate_data(\n                \"placeholder_nodes\", nodes_by_identifier\n            )\n\n        return nodes_by_identifier\n\n    def create_placeholder(self, placeholder_data):\n\n        parent = None\n        if self.use_selection_as_parent:\n            selection = cmds.ls(selection=True)\n            if len(selection) &gt; 1:\n                raise ValueError(\n                    \"More than one node is selected. \"\n                    \"Please select only one to define the parent.\"\n                )\n            parent = selection[0] if selection else None\n\n        placeholder_data[\"plugin_identifier\"] = self.identifier\n        placeholder_name = self._create_placeholder_name(placeholder_data)\n\n        placeholder = cmds.spaceLocator(name=placeholder_name)[0]\n        if parent:\n            placeholder = cmds.parent(placeholder, selection[0])[0]\n\n        self.imprint(placeholder, placeholder_data)\n\n    def update_placeholder(self, placeholder_item, placeholder_data):\n        node_name = placeholder_item.scene_identifier\n\n        changed_values = {}\n        for key, value in placeholder_data.items():\n            if value != placeholder_item.data.get(key):\n                changed_values[key] = value\n\n        # Delete attributes to ensure we imprint new data with correct type\n        for key in changed_values.keys():\n            placeholder_item.data[key] = value\n            if cmds.attributeQuery(key, node=node_name, exists=True):\n                attribute = \"{}.{}\".format(node_name, key)\n                cmds.deleteAttr(attribute)\n\n        self.imprint(node_name, changed_values)\n\n    def collect_placeholders(self):\n        placeholders = []\n        nodes_by_identifier = self._collect_scene_placeholders()\n        for node in nodes_by_identifier.get(self.identifier, []):\n            # TODO do data validations and maybe upgrades if they are invalid\n            placeholder_data = self.read(node)\n            placeholders.append(\n                self.item_class(scene_identifier=node,\n                                data=placeholder_data,\n                                plugin=self)\n            )\n\n        return placeholders\n\n    def post_placeholder_process(self, placeholder, failed):\n        \"\"\"Cleanup placeholder after load of its corresponding representations.\n\n        Hide placeholder, add them to placeholder set.\n        Used only by PlaceholderCreateMixin and PlaceholderLoadMixin\n\n        Args:\n            placeholder (PlaceholderItem): Item which was just used to load\n                representation.\n            failed (bool): Loading of representation failed.\n        \"\"\"\n        # Hide placeholder and add them to placeholder set\n        node = placeholder.scene_identifier\n\n        # If we just populate the placeholders from current scene, the\n        # placeholder set will not be created so account for that.\n        if not cmds.objExists(PLACEHOLDER_SET):\n            cmds.sets(name=PLACEHOLDER_SET, empty=True)\n\n        cmds.sets(node, addElement=PLACEHOLDER_SET)\n        cmds.hide(node)\n        cmds.setAttr(\"{}.hiddenInOutliner\".format(node), True)\n\n    def delete_placeholder(self, placeholder):\n        \"\"\"Remove placeholder if building was successful\n\n        Used only by PlaceholderCreateMixin and PlaceholderLoadMixin.\n        \"\"\"\n        node = placeholder.scene_identifier\n\n        # To avoid that deleting a placeholder node will have Maya delete\n        # any objectSets the node was a member of we will first remove it\n        # from any sets it was a member of. This way the `PLACEHOLDERS_SET`\n        # will survive long enough\n        sets = cmds.listSets(o=node) or []\n        for object_set in sets:\n            cmds.sets(node, remove=object_set)\n\n        cmds.delete(node)\n\n    def imprint(self, node, data):\n        \"\"\"Imprint call for placeholder node\"\"\"\n\n        # Complicated data that can't be represented as flat maya attributes\n        # we write to json strings, e.g. multiselection EnumDef\n        for key, value in data.items():\n            if isinstance(value, (list, tuple, dict)):\n                data[key] = \"JSON::{}\".format(json.dumps(value))\n\n        imprint(node, data)\n\n    def read(self, node):\n        \"\"\"Read call for placeholder node\"\"\"\n\n        data = read(node)\n\n        # Complicated data that can't be represented as flat maya attributes\n        # we read from json strings, e.g. multiselection EnumDef\n        for key, value in data.items():\n            if isinstance(value, str) and value.startswith(\"JSON::\"):\n                value = value[len(\"JSON::\"):]   # strip of JSON:: prefix\n                data[key] = json.loads(value)\n\n        return data\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/workfile_template_builder.html#client.ayon_maya.api.workfile_template_builder.MayaPlaceholderPlugin.delete_placeholder","title":"<code>delete_placeholder(placeholder)</code>","text":"<p>Remove placeholder if building was successful</p> <p>Used only by PlaceholderCreateMixin and PlaceholderLoadMixin.</p> Source code in <code>client/ayon_maya/api/workfile_template_builder.py</code> <pre><code>def delete_placeholder(self, placeholder):\n    \"\"\"Remove placeholder if building was successful\n\n    Used only by PlaceholderCreateMixin and PlaceholderLoadMixin.\n    \"\"\"\n    node = placeholder.scene_identifier\n\n    # To avoid that deleting a placeholder node will have Maya delete\n    # any objectSets the node was a member of we will first remove it\n    # from any sets it was a member of. This way the `PLACEHOLDERS_SET`\n    # will survive long enough\n    sets = cmds.listSets(o=node) or []\n    for object_set in sets:\n        cmds.sets(node, remove=object_set)\n\n    cmds.delete(node)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/workfile_template_builder.html#client.ayon_maya.api.workfile_template_builder.MayaPlaceholderPlugin.imprint","title":"<code>imprint(node, data)</code>","text":"<p>Imprint call for placeholder node</p> Source code in <code>client/ayon_maya/api/workfile_template_builder.py</code> <pre><code>def imprint(self, node, data):\n    \"\"\"Imprint call for placeholder node\"\"\"\n\n    # Complicated data that can't be represented as flat maya attributes\n    # we write to json strings, e.g. multiselection EnumDef\n    for key, value in data.items():\n        if isinstance(value, (list, tuple, dict)):\n            data[key] = \"JSON::{}\".format(json.dumps(value))\n\n    imprint(node, data)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/workfile_template_builder.html#client.ayon_maya.api.workfile_template_builder.MayaPlaceholderPlugin.post_placeholder_process","title":"<code>post_placeholder_process(placeholder, failed)</code>","text":"<p>Cleanup placeholder after load of its corresponding representations.</p> <p>Hide placeholder, add them to placeholder set. Used only by PlaceholderCreateMixin and PlaceholderLoadMixin</p> <p>Parameters:</p> Name Type Description Default <code>placeholder</code> <code>PlaceholderItem</code> <p>Item which was just used to load representation.</p> required <code>failed</code> <code>bool</code> <p>Loading of representation failed.</p> required Source code in <code>client/ayon_maya/api/workfile_template_builder.py</code> <pre><code>def post_placeholder_process(self, placeholder, failed):\n    \"\"\"Cleanup placeholder after load of its corresponding representations.\n\n    Hide placeholder, add them to placeholder set.\n    Used only by PlaceholderCreateMixin and PlaceholderLoadMixin\n\n    Args:\n        placeholder (PlaceholderItem): Item which was just used to load\n            representation.\n        failed (bool): Loading of representation failed.\n    \"\"\"\n    # Hide placeholder and add them to placeholder set\n    node = placeholder.scene_identifier\n\n    # If we just populate the placeholders from current scene, the\n    # placeholder set will not be created so account for that.\n    if not cmds.objExists(PLACEHOLDER_SET):\n        cmds.sets(name=PLACEHOLDER_SET, empty=True)\n\n    cmds.sets(node, addElement=PLACEHOLDER_SET)\n    cmds.hide(node)\n    cmds.setAttr(\"{}.hiddenInOutliner\".format(node), True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/workfile_template_builder.html#client.ayon_maya.api.workfile_template_builder.MayaPlaceholderPlugin.read","title":"<code>read(node)</code>","text":"<p>Read call for placeholder node</p> Source code in <code>client/ayon_maya/api/workfile_template_builder.py</code> <pre><code>def read(self, node):\n    \"\"\"Read call for placeholder node\"\"\"\n\n    data = read(node)\n\n    # Complicated data that can't be represented as flat maya attributes\n    # we read from json strings, e.g. multiselection EnumDef\n    for key, value in data.items():\n        if isinstance(value, str) and value.startswith(\"JSON::\"):\n            value = value[len(\"JSON::\"):]   # strip of JSON:: prefix\n            data[key] = json.loads(value)\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/workfile_template_builder.html#client.ayon_maya.api.workfile_template_builder.MayaTemplateBuilder","title":"<code>MayaTemplateBuilder</code>","text":"<p>               Bases: <code>AbstractTemplateBuilder</code></p> <p>Concrete implementation of AbstractTemplateBuilder for maya</p> Source code in <code>client/ayon_maya/api/workfile_template_builder.py</code> <pre><code>class MayaTemplateBuilder(AbstractTemplateBuilder):\n    \"\"\"Concrete implementation of AbstractTemplateBuilder for maya\"\"\"\n\n    def import_template(self, path):\n        \"\"\"Import template into current scene.\n        Block if a template is already loaded.\n\n        Args:\n            path (str): A path to current template (usually given by\n            get_template_preset implementation)\n\n        Returns:\n            bool: Whether the template was successfully imported or not\n        \"\"\"\n\n        if cmds.objExists(PLACEHOLDER_SET):\n            raise TemplateAlreadyImported((\n                \"Build template already loaded\\n\"\n                \"Clean scene if needed (File &gt; New Scene)\"\n            ))\n\n        cmds.sets(name=PLACEHOLDER_SET, empty=True)\n        new_nodes = cmds.file(\n            path,\n            i=True,\n            returnNewNodes=True,\n            preserveReferences=True,\n            loadReferenceDepth=\"all\",\n        )\n\n        # make default cameras non-renderable\n        default_cameras = [cam for cam in cmds.ls(cameras=True)\n                           if cmds.camera(cam, query=True, startupCamera=True)]\n        for cam in default_cameras:\n            if not cmds.attributeQuery(\"renderable\", node=cam, exists=True):\n                self.log.debug(\n                    \"Camera {} has no attribute 'renderable'\".format(cam)\n                )\n                continue\n            cmds.setAttr(\"{}.renderable\".format(cam), 0)\n\n        cmds.setAttr(PLACEHOLDER_SET + \".hiddenInOutliner\", True)\n\n        imported_sets = cmds.ls(new_nodes, set=True)\n        if not imported_sets:\n            return True\n\n        # update imported sets information\n        folder_path = get_current_folder_path()\n        for node in imported_sets:\n            if not cmds.attributeQuery(\"id\", node=node, exists=True):\n                continue\n            if cmds.getAttr(\"{}.id\".format(node)) not in {\n                AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n            }:\n                continue\n            if not cmds.attributeQuery(\"folderPath\", node=node, exists=True):\n                continue\n\n            cmds.setAttr(\n                \"{}.folderPath\".format(node), folder_path, type=\"string\")\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/workfile_template_builder.html#client.ayon_maya.api.workfile_template_builder.MayaTemplateBuilder.import_template","title":"<code>import_template(path)</code>","text":"<p>Import template into current scene. Block if a template is already loaded.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>A path to current template (usually given by</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether the template was successfully imported or not</p> Source code in <code>client/ayon_maya/api/workfile_template_builder.py</code> <pre><code>def import_template(self, path):\n    \"\"\"Import template into current scene.\n    Block if a template is already loaded.\n\n    Args:\n        path (str): A path to current template (usually given by\n        get_template_preset implementation)\n\n    Returns:\n        bool: Whether the template was successfully imported or not\n    \"\"\"\n\n    if cmds.objExists(PLACEHOLDER_SET):\n        raise TemplateAlreadyImported((\n            \"Build template already loaded\\n\"\n            \"Clean scene if needed (File &gt; New Scene)\"\n        ))\n\n    cmds.sets(name=PLACEHOLDER_SET, empty=True)\n    new_nodes = cmds.file(\n        path,\n        i=True,\n        returnNewNodes=True,\n        preserveReferences=True,\n        loadReferenceDepth=\"all\",\n    )\n\n    # make default cameras non-renderable\n    default_cameras = [cam for cam in cmds.ls(cameras=True)\n                       if cmds.camera(cam, query=True, startupCamera=True)]\n    for cam in default_cameras:\n        if not cmds.attributeQuery(\"renderable\", node=cam, exists=True):\n            self.log.debug(\n                \"Camera {} has no attribute 'renderable'\".format(cam)\n            )\n            continue\n        cmds.setAttr(\"{}.renderable\".format(cam), 0)\n\n    cmds.setAttr(PLACEHOLDER_SET + \".hiddenInOutliner\", True)\n\n    imported_sets = cmds.ls(new_nodes, set=True)\n    if not imported_sets:\n        return True\n\n    # update imported sets information\n    folder_path = get_current_folder_path()\n    for node in imported_sets:\n        if not cmds.attributeQuery(\"id\", node=node, exists=True):\n            continue\n        if cmds.getAttr(\"{}.id\".format(node)) not in {\n            AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n        }:\n            continue\n        if not cmds.attributeQuery(\"folderPath\", node=node, exists=True):\n            continue\n\n        cmds.setAttr(\n            \"{}.folderPath\".format(node), folder_path, type=\"string\")\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/workio.html","title":"workio","text":"<p>Host API required Work Files tool</p>"},{"location":"autoapi/client/ayon_maya/api/yeti.html","title":"yeti","text":""},{"location":"autoapi/client/ayon_maya/api/yeti.html#client.ayon_maya.api.yeti.create_yeti_variable","title":"<code>create_yeti_variable(yeti_shape_node, attr_name, value=None, force_value=False)</code>","text":"<p>Get user defined yeti user variables for a <code>pgYetiMaya</code> shape node.</p> <p>Parameters:</p> Name Type Description Default <code>yeti_shape_node</code> <code>str</code> <p>The <code>pgYetiMaya</code> shape node.</p> required <code>attr_name</code> <code>str</code> <p>The fully qualified yeti variable name, e.g. \"yetiVariableF_myfloat\" or \"yetiVariableV_myvector\"</p> required <code>value</code> <code>object</code> <p>The value to set (must match the type of the attribute) When value is None it will ignored and not be set.</p> <code>None</code> <code>force_value</code> <code>bool</code> <p>Whether to set the value if the attribute already exists or not.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the attribute value was set or not.</p> Source code in <code>client/ayon_maya/api/yeti.py</code> <pre><code>def create_yeti_variable(yeti_shape_node: str,\n                         attr_name: str,\n                         value=None,\n                         force_value: bool = False) -&gt; bool:\n    \"\"\"Get user defined yeti user variables for a `pgYetiMaya` shape node.\n\n    Arguments:\n        yeti_shape_node (str): The `pgYetiMaya` shape node.\n        attr_name (str): The fully qualified yeti variable name, e.g.\n            \"yetiVariableF_myfloat\" or \"yetiVariableV_myvector\"\n        value (object): The value to set (must match the type of the attribute)\n            When value is None it will ignored and not be set.\n        force_value (bool): Whether to set the value if the attribute already\n            exists or not.\n\n    Returns:\n        bool: Whether the attribute value was set or not.\n\n    \"\"\"\n    exists = cmds.attributeQuery(attr_name, node=yeti_shape_node, exists=True)\n    if not exists:\n        if attr_name.startswith(\"yetiVariableV_\"):\n            _create_vector_yeti_user_variable(yeti_shape_node, attr_name)\n        if attr_name.startswith(\"yetiVariableF_\"):\n            _create_float_yeti_user_variable(yeti_shape_node, attr_name)\n\n    if value is not None and (not exists or force_value):\n        plug = \"{}.{}\".format(yeti_shape_node, attr_name)\n        if (\n                isinstance(value, (list, tuple))\n                and attr_name.startswith(\"yetiVariableV_\")\n        ):\n            cmds.setAttr(plug, *value, type=\"double3\")\n        else:\n            cmds.setAttr(plug, value)\n\n        return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/yeti.html#client.ayon_maya.api.yeti.get_yeti_user_variables","title":"<code>get_yeti_user_variables(yeti_shape_node)</code>","text":"<p>Get user defined yeti user variables for a <code>pgYetiMaya</code> shape node.</p> <p>Parameters:</p> Name Type Description Default <code>yeti_shape_node</code> <code>str</code> <p>The <code>pgYetiMaya</code> shape node.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>List[str]</code> <p>Attribute names (for a vector attribute it only lists the top parent attribute, not the attribute per axis)</p> Source code in <code>client/ayon_maya/api/yeti.py</code> <pre><code>def get_yeti_user_variables(yeti_shape_node: str) -&gt; List[str]:\n    \"\"\"Get user defined yeti user variables for a `pgYetiMaya` shape node.\n\n    Arguments:\n        yeti_shape_node (str): The `pgYetiMaya` shape node.\n\n    Returns:\n        list: Attribute names (for a vector attribute it only lists the top\n            parent attribute, not the attribute per axis)\n    \"\"\"\n\n    attrs = cmds.listAttr(yeti_shape_node,\n                          userDefined=True,\n                          string=(\"yetiVariableV_*\",\n                                  \"yetiVariableF_*\")) or []\n    valid_attrs = []\n    for attr in attrs:\n        attr_type = cmds.attributeQuery(attr, node=yeti_shape_node,\n                                        attributeType=True)\n        if attr.startswith(\"yetiVariableV_\") and attr_type == \"double3\":\n            # vector\n            valid_attrs.append(attr)\n        elif attr.startswith(\"yetiVariableF_\") and attr_type == \"double\":\n            valid_attrs.append(attr)\n\n    return valid_attrs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/chasers/index.html","title":"chasers","text":""},{"location":"autoapi/client/ayon_maya/api/chasers/export_filter_properties.html","title":"export_filter_properties","text":""},{"location":"autoapi/client/ayon_maya/api/chasers/export_filter_properties.html#client.ayon_maya.api.chasers.export_filter_properties.FilterPropertiesExportChaser","title":"<code>FilterPropertiesExportChaser</code>","text":"<p>               Bases: <code>ExportChaser</code></p> <p>Remove property specs based on pattern</p> Source code in <code>client/ayon_maya/api/chasers/export_filter_properties.py</code> <pre><code>class FilterPropertiesExportChaser(mayaUsdLib.ExportChaser):\n    \"\"\"Remove property specs based on pattern\"\"\"\n\n    name = \"AYON_filterProperties\"\n\n    def __init__(self, factoryContext, *args, **kwargs):\n        super().__init__(factoryContext, *args, **kwargs)\n        self.log = logging.getLogger(self.__class__.__name__)\n        self.stage = factoryContext.GetStage()\n        self.job_args = factoryContext.GetJobArgs()\n\n    @log_errors\n    def PostExport(self):\n\n        chaser_args = self.job_args.allChaserArgs[self.name]\n        # strip all or use user-specified pattern\n        pattern = chaser_args.get(\"pattern\", \"*\")\n        for layer in self.stage.GetLayerStack():\n\n            specs_to_remove = []\n\n            def find_attribute_specs_to_remove(path: Sdf.Path):\n                if not path.IsPropertyPath():\n                    return\n\n                spec = layer.GetObjectAtPath(path)\n                if not spec:\n                    return\n\n                if not isinstance(spec, Sdf.PropertySpec):\n                    return\n\n                if not match_pattern(spec.name, pattern):\n                    self.log.debug(\"Removing spec: %s\", path)\n                    specs_to_remove.append(path)\n                else:\n                    self.log.debug(\"Keeping spec: %s\", path)\n\n            layer.Traverse(\"/\", find_attribute_specs_to_remove)\n\n            remove_layer_specs(layer, specs_to_remove)\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/chasers/export_filter_properties.html#client.ayon_maya.api.chasers.export_filter_properties.log_errors","title":"<code>log_errors(fn)</code>","text":"<p>Decorator to log errors on error</p> Source code in <code>client/ayon_maya/api/chasers/export_filter_properties.py</code> <pre><code>def log_errors(fn):\n    \"\"\"Decorator to log errors on error\"\"\"\n\n    def wrap(*args, **kwargs):\n\n        try:\n            return fn(*args, **kwargs)\n        except Exception as exc:\n            logging.error(exc, exc_info=True)\n            raise\n\n    return wrap\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/chasers/export_filter_properties.html#client.ayon_maya.api.chasers.export_filter_properties.match_pattern","title":"<code>match_pattern(name, text_pattern)</code>","text":"<p>SideFX Houdini like pattern matching</p> Source code in <code>client/ayon_maya/api/chasers/export_filter_properties.py</code> <pre><code>def match_pattern(name: str, text_pattern: str) -&gt; bool:\n    \"\"\"SideFX Houdini like pattern matching\"\"\"\n    patterns = text_pattern.split(\" \")\n    is_match = False\n    for pattern in patterns:\n        # * means any character\n        # ? means any single character\n        # [abc] means a, b, or c\n        pattern = pattern.strip(\" \")\n        if not pattern:\n            continue\n\n        excludes = pattern[0] == \"^\"\n\n        # If name is already matched against earlier pattern in the text\n        # pattern, then we can skip the pattern if it is not an exclude pattern\n        if is_match and not excludes:\n            continue\n\n        if excludes:\n            pattern = pattern[1:]\n\n        regex = fnmatch.translate(pattern)\n        match = re.match(regex, name)\n        if match:\n            is_match = not excludes\n    return is_match\n</code></pre>"},{"location":"autoapi/client/ayon_maya/api/chasers/export_filter_properties.html#client.ayon_maya.api.chasers.export_filter_properties.remove_spec","title":"<code>remove_spec(spec)</code>","text":"<p>Remove Sdf.Spec authored opinion.</p> Source code in <code>client/ayon_maya/api/chasers/export_filter_properties.py</code> <pre><code>def remove_spec(spec: Sdf.Spec):\n    \"\"\"Remove Sdf.Spec authored opinion.\"\"\"\n    if spec.expired:\n        return\n\n    if isinstance(spec, Sdf.PrimSpec):\n        # PrimSpec\n        parent = spec.nameParent\n        if parent:\n            view = parent.nameChildren\n        else:\n            # Assume PrimSpec is root prim\n            view = spec.layer.rootPrims\n        del view[spec.name]\n\n    elif isinstance(spec, Sdf.PropertySpec):\n        # Relationship and Attribute specs\n        del spec.owner.properties[spec.name]\n\n    elif isinstance(spec, Sdf.VariantSetSpec):\n        # Owner is Sdf.PrimSpec (or can also be Sdf.VariantSpec)\n        del spec.owner.variantSets[spec.name]\n\n    elif isinstance(spec, Sdf.VariantSpec):\n        # Owner is Sdf.VariantSetSpec\n        spec.owner.RemoveVariant(spec)\n\n    else:\n        raise TypeError(f\"Unsupported spec type: {spec}\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/hooks/index.html","title":"hooks","text":""},{"location":"autoapi/client/ayon_maya/hooks/pre_auto_load_plugins.html","title":"pre_auto_load_plugins","text":""},{"location":"autoapi/client/ayon_maya/hooks/pre_auto_load_plugins.html#client.ayon_maya.hooks.pre_auto_load_plugins.MayaPreAutoLoadPlugins","title":"<code>MayaPreAutoLoadPlugins</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Define -noAutoloadPlugins command flag.</p> Source code in <code>client/ayon_maya/hooks/pre_auto_load_plugins.py</code> <pre><code>class MayaPreAutoLoadPlugins(PreLaunchHook):\n    \"\"\"Define -noAutoloadPlugins command flag.\"\"\"\n\n    # Before AddLastWorkfileToLaunchArgs\n    order = 9\n    app_groups = {\"maya\"}\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n\n        # Ignore if there's no last workfile to start.\n        if not self.data.get(\"start_last_workfile\"):\n            return\n\n        maya_settings = self.data[\"project_settings\"][\"maya\"]\n        enabled = maya_settings[\"explicit_plugins_loading\"][\"enabled\"]\n        if enabled:\n            # Force disable the `AddLastWorkfileToLaunchArgs`.\n            self.data.pop(\"start_last_workfile\", None)\n\n            # Force post initialization so our dedicated plug-in load can run\n            # prior to Maya opening a scene file.\n            key = \"AYON_OPEN_WORKFILE_POST_INITIALIZATION\"\n            self.launch_context.env[key] = \"1\"\n\n            self.log.debug(\"Explicit plugins loading.\")\n            self.launch_context.launch_args.append(\"-noAutoloadPlugins\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/hooks/pre_copy_mel.html","title":"pre_copy_mel","text":""},{"location":"autoapi/client/ayon_maya/hooks/pre_copy_mel.html#client.ayon_maya.hooks.pre_copy_mel.PreCopyMel","title":"<code>PreCopyMel</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Copy workspace.mel to workdir.</p> <p>Hook <code>GlobalHostDataHook</code> must be executed before this hook.</p> Source code in <code>client/ayon_maya/hooks/pre_copy_mel.py</code> <pre><code>class PreCopyMel(PreLaunchHook):\n    \"\"\"Copy workspace.mel to workdir.\n\n    Hook `GlobalHostDataHook` must be executed before this hook.\n    \"\"\"\n    app_groups = {\"maya\", \"mayapy\"}\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        project_entity = self.data[\"project_entity\"]\n        workdir = self.launch_context.env.get(\"AYON_WORKDIR\")\n        if not workdir:\n            self.log.warning(\"BUG: Workdir is not filled.\")\n            return\n\n        project_settings = self.data[\"project_settings\"]\n        create_workspace_mel(\n            workdir, project_entity[\"name\"], project_settings\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/hooks/pre_open_workfile_post_initialization.html","title":"pre_open_workfile_post_initialization","text":""},{"location":"autoapi/client/ayon_maya/hooks/pre_open_workfile_post_initialization.html#client.ayon_maya.hooks.pre_open_workfile_post_initialization.MayaPreOpenWorkfilePostInitialization","title":"<code>MayaPreOpenWorkfilePostInitialization</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Define whether open last workfile should run post initialize.</p> Source code in <code>client/ayon_maya/hooks/pre_open_workfile_post_initialization.py</code> <pre><code>class MayaPreOpenWorkfilePostInitialization(PreLaunchHook):\n    \"\"\"Define whether open last workfile should run post initialize.\"\"\"\n\n    # Before AddLastWorkfileToLaunchArgs.\n    order = 9\n    app_groups = {\"maya\"}\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        # Do nothing if post workfile initialization is disabled.\n        maya_settings = self.data[\"project_settings\"][\"maya\"]\n        if not maya_settings[\"open_workfile_post_initialization\"]:\n            return\n\n        # Force disable the `AddLastWorkfileToLaunchArgs`.\n        start_last_workfile = self.data.pop(\"start_last_workfile\", None)\n\n        # Ignore if there's no last workfile to start.\n        if not start_last_workfile:\n            return\n\n        # Ignore if the last workfile path does not exist, this may be the case\n        # when starting a context that has no workfiles yet.\n        last_workfile_path: str = self.data.get(\"last_workfile_path\")\n        if not last_workfile_path or not os.path.exists(last_workfile_path):\n            self.log.info(\"Current context does not have any workfile yet.\")\n            return\n\n        self.log.debug(\"Opening workfile post initialization.\")\n        key = \"AYON_OPEN_WORKFILE_POST_INITIALIZATION\"\n        self.launch_context.env[key] = \"1\"\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/convert_legacy.html","title":"convert_legacy","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/convert_legacy.html#client.ayon_maya.plugins.create.convert_legacy.MayaLegacyConvertor","title":"<code>MayaLegacyConvertor</code>","text":"<p>               Bases: <code>ProductConvertorPlugin</code>, <code>MayaCreatorBase</code></p> <p>Find and convert any legacy products in the scene.</p> <p>This Converter will find all legacy products in the scene and will transform them to the current system. Since the old products doesn't retain any information about their original creators, the only mapping we can do is based on their families.</p> <p>Its limitation is that you can have multiple creators creating product of the same type and there is no way to handle it. This code should nevertheless cover all creators that came with AYON.</p> Source code in <code>client/ayon_maya/plugins/create/convert_legacy.py</code> <pre><code>class MayaLegacyConvertor(ProductConvertorPlugin,\n                          plugin.MayaCreatorBase):\n    \"\"\"Find and convert any legacy products in the scene.\n\n    This Converter will find all legacy products in the scene and will\n    transform them to the current system. Since the old products doesn't\n    retain any information about their original creators, the only mapping\n    we can do is based on their families.\n\n    Its limitation is that you can have multiple creators creating product\n    of the same type and there is no way to handle it. This code should\n    nevertheless cover all creators that came with AYON.\n\n    \"\"\"\n    identifier = \"io.openpype.creators.maya.legacy\"\n\n    # Cases where the identifier or new product type doesn't correspond to the\n    # original family on the legacy instances\n    product_type_mapping = {\n        \"rendering\": \"io.openpype.creators.maya.renderlayer\",\n    }\n\n    def find_instances(self):\n\n        self.cache_instance_data(self.collection_shared_data)\n        legacy = self.collection_shared_data.get(\n            \"maya_cached_legacy_instances\"\n        )\n        if not legacy:\n            return\n\n        self.add_convertor_item(\"Convert legacy instances\")\n\n    def convert(self):\n        self.remove_convertor_item()\n\n        # We can't use the collected shared data cache here\n        # we re-query it here directly to convert all found.\n        cache = {}\n        self.cache_instance_data(cache)\n        legacy = cache.get(\"maya_cached_legacy_instances\")\n        if not legacy:\n            return\n\n        # From all current new style manual creators find the mapping\n        # from product type to identifier\n        product_type_to_id = {}\n        for identifier, creator in self.create_context.creators.items():\n            product_type = getattr(creator, \"product_type\", None)\n            if not product_type:\n                continue\n\n            if product_type in product_type_to_id:\n                # We have a clash of product type -&gt; identifier. Multiple\n                # new style creators use the same product type\n                self.log.warning(\n                    \"Clash on product type-&gt;identifier: {}\".format(identifier)\n                )\n            product_type_to_id[product_type] = identifier\n\n        product_type_to_id.update(self.product_type_mapping)\n\n        # We also embed the current 'task' into the instance since legacy\n        # instances didn't store that data on the instances. The old style\n        # logic was thus to be live to the current task to begin with.\n        data = dict()\n        data[\"task\"] = self.create_context.get_current_task_name()\n        for product_type, instance_nodes in legacy.items():\n            if product_type not in product_type_to_id:\n                self.log.warning((\n                    \"Unable to convert legacy instance with family '{}'\"\n                    \" because there is no matching new creator\"\n                ).format(product_type))\n                continue\n\n            creator_id = product_type_to_id[product_type]\n            creator = self.create_context.creators[creator_id]\n            data[\"creator_identifier\"] = creator_id\n\n            if isinstance(creator, plugin.RenderlayerCreator):\n                self._convert_per_renderlayer(instance_nodes, data, creator)\n            else:\n                self._convert_regular(instance_nodes, data)\n\n    def _convert_regular(self, instance_nodes, data):\n        # We only imprint the creator identifier for it to identify\n        # as the new style creator\n        for instance_node in instance_nodes:\n            self.imprint_instance_node(instance_node,\n                                       data=data.copy())\n\n    def _convert_per_renderlayer(self, instance_nodes, data, creator):\n        # Split the instance into an instance per layer\n        rs = renderSetup.instance()\n        layers = rs.getRenderLayers()\n        if not layers:\n            self.log.error(\n                \"Can't convert legacy renderlayer instance because no existing\"\n                \" renderSetup layers exist in the scene.\"\n            )\n            return\n\n        creator_attribute_names = {\n            attr_def.key for attr_def in creator.get_instance_attr_defs()\n        }\n\n        for instance_node in instance_nodes:\n\n            # Ensure we have the new style singleton node generated\n            # TODO: Make function public\n            singleton_node = creator._get_singleton_node()\n            if singleton_node:\n                self.log.error(\n                    \"Can't convert legacy renderlayer instance '{}' because\"\n                    \" new style instance '{}' already exists\".format(\n                        instance_node,\n                        singleton_node\n                    )\n                )\n                continue\n\n            creator.create_singleton_node()\n\n            # We are creating new nodes to replace the original instance\n            # Copy the attributes of the original instance to the new node\n            original_data = read(instance_node)\n\n            # The product type gets converted to the new product type (this\n            # is due to \"rendering\" being converted to \"renderlayer\")\n            original_data[\"productType\"] = creator.product_type\n\n            # recreate product name as without it would be\n            # `renderingMain` vs correct `renderMain`\n            project_name = self.create_context.get_current_project_name()\n            folder_entities = list(ayon_api.get_folders(\n                project_name, folder_names=[original_data[\"asset\"]]\n            ))\n            if not folder_entities:\n                cmds.delete(instance_node)\n                continue\n            folder_entity = folder_entities[0]\n            task_entity = ayon_api.get_task_by_name(\n                project_name, folder_entity[\"id\"], data[\"task\"]\n            )\n\n            product_name = creator.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                original_data[\"variant\"],\n            )\n            original_data[\"productName\"] = product_name\n\n            # Convert to creator attributes when relevant\n            creator_attributes = {}\n            for key in list(original_data.keys()):\n                # Iterate in order of the original attributes to preserve order\n                # in the output creator attributes\n                if key in creator_attribute_names:\n                    creator_attributes[key] = original_data.pop(key)\n            original_data[\"creator_attributes\"] = creator_attributes\n\n            # For layer in maya layers\n            for layer in layers:\n                layer_instance_node = creator.find_layer_instance_node(layer)\n                if not layer_instance_node:\n                    # TODO: Make function public\n                    layer_instance_node = creator._create_layer_instance_node(\n                        layer\n                    )\n\n                # Transfer the main attributes of the original instance\n                layer_data = original_data.copy()\n                layer_data.update(data)\n\n                self.imprint_instance_node(layer_instance_node,\n                                           data=layer_data)\n\n            # Delete the legacy instance node\n            cmds.delete(instance_node)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_animation_pointcache.html","title":"create_animation_pointcache","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_animation_pointcache.html#client.ayon_maya.plugins.create.create_animation_pointcache.CreateAnimation","title":"<code>CreateAnimation</code>","text":"<p>               Bases: <code>MayaHiddenCreator</code></p> <p>Animation output for character rigs</p> <p>We hide the animation creator from the UI since the creation of it is automated upon loading a rig. There's an inventory action to recreate it for loaded rigs if by chance someone deleted the animation instance.</p> Source code in <code>client/ayon_maya/plugins/create/create_animation_pointcache.py</code> <pre><code>class CreateAnimation(plugin.MayaHiddenCreator):\n    \"\"\"Animation output for character rigs\n\n    We hide the animation creator from the UI since the creation of it is\n    automated upon loading a rig. There's an inventory action to recreate it\n    for loaded rigs if by chance someone deleted the animation instance.\n    \"\"\"\n\n    identifier = \"io.openpype.creators.maya.animation\"\n    name = \"animationDefault\"\n    label = \"Animation\"\n    product_type = \"animation\"\n    icon = \"male\"\n\n    include_parent_hierarchy = False\n    include_user_defined_attributes = False\n\n    def read_instance_node(self, node):\n        node_data = super(CreateAnimation, self).read_instance_node(node)\n        node_data = convert_legacy_alembic_creator_attributes(\n            node_data, \"ExtractAnimation\"\n        )\n        return node_data\n\n    def get_instance_attr_defs(self):\n        return _get_animation_attr_defs(self.create_context,\n                                        self.include_user_defined_attributes,\n                                        self.include_parent_hierarchy)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_animation_pointcache.html#client.ayon_maya.plugins.create.create_animation_pointcache.CreatePointCache","title":"<code>CreatePointCache</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Alembic pointcache for animated data</p> Source code in <code>client/ayon_maya/plugins/create/create_animation_pointcache.py</code> <pre><code>class CreatePointCache(plugin.MayaCreator):\n    \"\"\"Alembic pointcache for animated data\"\"\"\n\n    identifier = \"io.openpype.creators.maya.pointcache\"\n    label = \"Pointcache\"\n    product_type = \"pointcache\"\n    icon = \"gears\"\n    include_user_defined_attributes = False\n\n    def read_instance_node(self, node):\n        node_data = super(CreatePointCache, self).read_instance_node(node)\n        node_data = convert_legacy_alembic_creator_attributes(\n            node_data, \"ExtractAlembic\"\n        )\n        return node_data\n\n    def get_instance_attr_defs(self):\n        return _get_animation_attr_defs(self.create_context,\n                                        self.include_user_defined_attributes)\n\n    def create(self, product_name, instance_data, pre_create_data):\n        instance = super(CreatePointCache, self).create(\n            product_name, instance_data, pre_create_data\n        )\n        instance_node = instance.get(\"instance_node\")\n\n        # For Arnold standin proxy\n        proxy_set = cmds.sets(name=instance_node + \"_proxy_SET\", empty=True)\n        cmds.sets(proxy_set, forceElement=instance_node)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_animation_pointcache.html#client.ayon_maya.plugins.create.create_animation_pointcache.convert_legacy_alembic_creator_attributes","title":"<code>convert_legacy_alembic_creator_attributes(node_data, class_name)</code>","text":"<p>This is a legacy transfer of creator attributes to publish attributes for ExtractAlembic/ExtractAnimation plugin.</p> Source code in <code>client/ayon_maya/plugins/create/create_animation_pointcache.py</code> <pre><code>def convert_legacy_alembic_creator_attributes(node_data, class_name):\n    \"\"\"This is a legacy transfer of creator attributes to publish attributes\n    for ExtractAlembic/ExtractAnimation plugin.\n    \"\"\"\n    publish_attributes = node_data[\"publish_attributes\"]\n\n    if class_name in publish_attributes:\n        return node_data\n\n    attributes = [\n        \"attr\",\n        \"attrPrefix\",\n        \"visibleOnly\",\n        \"writeColorSets\",\n        \"writeFaceSets\",\n        \"writeNormals\",\n        \"renderableOnly\",\n        \"visibleOnly\",\n        \"worldSpace\",\n        \"renderableOnly\"\n    ]\n    plugin_attributes = {}\n    for attr in attributes:\n        if attr not in node_data[\"creator_attributes\"]:\n            continue\n        value = node_data[\"creator_attributes\"].pop(attr)\n\n        plugin_attributes[attr] = value\n\n    publish_attributes[class_name] = plugin_attributes\n\n    return node_data\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_arnold_scene_source.html","title":"create_arnold_scene_source","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_arnold_scene_source.html#client.ayon_maya.plugins.create.create_arnold_scene_source.CreateArnoldSceneSource","title":"<code>CreateArnoldSceneSource</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Arnold Scene Source</p> Source code in <code>client/ayon_maya/plugins/create/create_arnold_scene_source.py</code> <pre><code>class CreateArnoldSceneSource(plugin.MayaCreator):\n    \"\"\"Arnold Scene Source\"\"\"\n\n    identifier = \"io.openpype.creators.maya.ass\"\n    label = \"Arnold Scene Source\"\n    product_type = \"ass\"\n    icon = \"cube\"\n    settings_name = \"CreateAss\"\n\n    # File Type Specific Options\n    compressed = False\n    boundingBox = True\n\n    # Export\n    expandProcedurals = False\n    motionBlur = True\n    motionBlurKeys = 2\n    motionBlurLength = 0.5\n    maskOptions = False\n    maskCamera = False\n    maskLight = False\n    maskShape = False\n    maskShader = False\n    maskOverride = False\n    maskDriver = False\n    maskFilter = False\n    maskColor_manager = False\n    maskOperator = False\n    maskImager = False\n\n    def get_instance_attr_defs(self):\n\n        defs = lib.collect_animation_defs(create_context=self.create_context)\n\n        defs.extend([\n            BoolDef(\"farm\",\n                    label=\"Submit to Farm\",\n                    default=False),\n            BoolDef(\"motionBlur\",\n                    label=\"Motion Blur\",\n                    default=self.motionBlur),\n            NumberDef(\"motionBlurKeys\",\n                      label=\"Motion Blur Keys\",\n                      decimals=0,\n                      default=self.motionBlurKeys),\n            NumberDef(\"motionBlurLength\",\n                      label=\"Motion Blur Length\",\n                      decimals=3,\n                      default=self.motionBlurLength),\n            BoolDef(\"expandProcedural\",\n                    label=\"Expand Procedurals\",\n                    default=self.expandProcedurals),\n            BoolDef(\"compressed\",\n                    label=\"Use gzip Compression (.ass.gz)\",\n                    default=self.compressed),\n\n            # Masks\n            UISeparatorDef(\"maskSectionStart\"),\n            UILabelDef(\"&lt;b&gt;Export&lt;/b&gt;\", key=\"maskHeaderLabel\"),\n            BoolDef(\"maskOptions\",\n                    label=\"Options\",\n                    tooltip=\"Export Options\",\n                    default=self.maskOptions),\n            BoolDef(\"maskCamera\",\n                    label=\"Cameras\",\n                    tooltip=\"Export Cameras\",\n                    default=self.maskCamera),\n            BoolDef(\"maskLight\",\n                    label=\"Lights\",\n                    tooltip=\"Export Lights\",\n                    default=self.maskLight),\n            BoolDef(\"maskShape\",\n                    label=\"Shapes\",\n                    tooltip=\"Export Shapes\",\n                    default=self.maskShape),\n            BoolDef(\"maskShader\",\n                    label=\"Shaders\",\n                    tooltip=\"Export Shaders\",\n                    default=self.maskShader),\n            BoolDef(\"maskOverride\",\n                    label=\"Override Nodes\",\n                    tooltip=\"Export Override Nodes\",\n                    default=self.maskOverride),\n            BoolDef(\"maskDriver\",\n                    label=\"Drivers\",\n                    tooltip=\"Export Drivers\",\n                    default=self.maskDriver),\n            BoolDef(\"maskFilter\",\n                    label=\"Filters\",\n                    tooltip=\"Export Filters\",\n                    default=self.maskFilter),\n            BoolDef(\"maskOperator\",\n                    label=\"Operators\",\n                    tooltip=\"Export Operators\",\n                    default=self.maskOperator),\n            BoolDef(\"maskColor_manager\",\n                    label=\"Color Managers\",\n                    tooltip=\"Export Color Managers\",\n                    default=self.maskColor_manager),\n            BoolDef(\"maskImager\",\n                    label=\"Imagers\",\n                    tooltip=\"Export Imagers\",\n                    default=self.maskImager),\n            BoolDef(\"boundingBox\",\n                    label=\"Bounding Box\",\n                    tooltip=\"Export Bounding Box\",\n                    default=self.boundingBox),\n        ])\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_arnold_scene_source.html#client.ayon_maya.plugins.create.create_arnold_scene_source.CreateArnoldSceneSourceProxy","title":"<code>CreateArnoldSceneSourceProxy</code>","text":"<p>               Bases: <code>CreateArnoldSceneSource</code></p> <p>Arnold Scene Source Proxy</p> <p>This product type facilitates working with proxy geometry in the viewport.</p> Source code in <code>client/ayon_maya/plugins/create/create_arnold_scene_source.py</code> <pre><code>class CreateArnoldSceneSourceProxy(CreateArnoldSceneSource):\n    \"\"\"Arnold Scene Source Proxy\n\n    This product type facilitates working with proxy geometry in the viewport.\n    \"\"\"\n\n    identifier = \"io.openpype.creators.maya.assproxy\"\n    label = \"Arnold Scene Source Proxy\"\n    product_type = \"assProxy\"\n    icon = \"cube\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        instance = super(CreateArnoldSceneSource, self).create(\n            product_name, instance_data, pre_create_data\n        )\n\n        instance_node = instance.get(\"instance_node\")\n\n        proxy = cmds.sets(name=instance_node + \"_proxy_SET\", empty=True)\n        cmds.sets([proxy], forceElement=instance_node)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_assembly.html","title":"create_assembly","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_assembly.html#client.ayon_maya.plugins.create.create_assembly.CreateAssembly","title":"<code>CreateAssembly</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>A grouped package of loaded content</p> Source code in <code>client/ayon_maya/plugins/create/create_assembly.py</code> <pre><code>class CreateAssembly(plugin.MayaCreator):\n    \"\"\"A grouped package of loaded content\"\"\"\n\n    identifier = \"io.openpype.creators.maya.assembly\"\n    label = \"Assembly\"\n    product_type = \"assembly\"\n    icon = \"cubes\"\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_camera.html","title":"create_camera","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_camera.html#client.ayon_maya.plugins.create.create_camera.CreateCamera","title":"<code>CreateCamera</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Single baked camera</p> Source code in <code>client/ayon_maya/plugins/create/create_camera.py</code> <pre><code>class CreateCamera(plugin.MayaCreator):\n    \"\"\"Single baked camera\"\"\"\n\n    identifier = \"io.openpype.creators.maya.camera\"\n    label = \"Camera\"\n    product_type = \"camera\"\n    icon = \"video-camera\"\n\n    def get_instance_attr_defs(self):\n\n        defs = lib.collect_animation_defs(create_context=self.create_context)\n\n        defs.extend([\n            BoolDef(\"bakeToWorldSpace\",\n                    label=\"Bake to World-Space\",\n                    tooltip=\"Bake to World-Space\",\n                    default=True),\n        ])\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_camera.html#client.ayon_maya.plugins.create.create_camera.CreateCameraRig","title":"<code>CreateCameraRig</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Complex hierarchy with camera.</p> Source code in <code>client/ayon_maya/plugins/create/create_camera.py</code> <pre><code>class CreateCameraRig(plugin.MayaCreator):\n    \"\"\"Complex hierarchy with camera.\"\"\"\n\n    identifier = \"io.openpype.creators.maya.camerarig\"\n    label = \"Camera Rig\"\n    product_type = \"camerarig\"\n    icon = \"video-camera\"\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_layout.html","title":"create_layout","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_layout.html#client.ayon_maya.plugins.create.create_layout.CreateLayout","title":"<code>CreateLayout</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>A grouped package of loaded content</p> Source code in <code>client/ayon_maya/plugins/create/create_layout.py</code> <pre><code>class CreateLayout(plugin.MayaCreator):\n    \"\"\"A grouped package of loaded content\"\"\"\n\n    identifier = \"io.openpype.creators.maya.layout\"\n    label = \"Layout\"\n    product_type = \"layout\"\n    icon = \"cubes\"\n\n    def get_instance_attr_defs(self):\n\n        return [\n            BoolDef(\"groupLoadedAssets\",\n                    label=\"Group Loaded Assets\",\n                    tooltip=\"Enable this when you want to publish group of \"\n                            \"loaded asset\",\n                    default=False),\n            BoolDef(\"allowObjectTransforms\",\n                    label=\"Allow Object Transforms\",\n                    tooltip=\"Enable this when include all the transform data\"\n                            \"of objects\"\n                    )\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_look.html","title":"create_look","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_look.html#client.ayon_maya.plugins.create.create_look.CreateLook","title":"<code>CreateLook</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Shader connections defining shape look</p> Source code in <code>client/ayon_maya/plugins/create/create_look.py</code> <pre><code>class CreateLook(plugin.MayaCreator):\n    \"\"\"Shader connections defining shape look\"\"\"\n\n    identifier = \"io.openpype.creators.maya.look\"\n    label = \"Look\"\n    product_type = \"look\"\n    icon = \"paint-brush\"\n\n    make_tx = True\n    rs_tex = False\n    include_texture_reference_objects = False\n\n    def create(self, product_name, instance_data, pre_create_data):\n        creator_attributes = instance_data.setdefault(\n            \"creator_attributes\", dict())\n        for key in [\n            \"maketx\",\n            \"rstex\",\n            \"includeTextureReferenceObjects\"\n        ]:\n            if key in pre_create_data:\n                creator_attributes[key] = pre_create_data[key]\n        return super().create(product_name, instance_data, pre_create_data)\n\n    def get_instance_attr_defs(self):\n\n        return [\n            # TODO: This value should actually get set on create!\n            TextDef(\"renderLayer\",\n                    # TODO: Bug: Hidden attribute's label is still shown in UI?\n                    hidden=True,\n                    default=lib.get_current_renderlayer(),\n                    label=\"Renderlayer\",\n                    tooltip=\"Renderlayer to extract the look from\"),\n            BoolDef(\"maketx\",\n                    label=\"MakeTX\",\n                    tooltip=\"Whether to generate .tx files for your textures\",\n                    default=self.make_tx),\n            BoolDef(\"rstex\",\n                    label=\"Convert textures to .rstex\",\n                    tooltip=\"Whether to generate Redshift .rstex files for \"\n                            \"your textures\",\n                    default=self.rs_tex),\n            BoolDef(\"includeTextureReferenceObjects\",\n                    label=\"Texture Reference Objects\",\n                    tooltip=(\n                        \"Whether to include texture reference objects \"\n                        \"with the published look to reconnect to geometry \"\n                        \"when assigning the look.\"\n                    ),\n                    default=self.include_texture_reference_objects)\n        ]\n\n    def get_pre_create_attr_defs(self):\n        # Show same attributes on create but include use selection\n        defs = list(super().get_pre_create_attr_defs())\n        defs.extend(self.get_instance_attr_defs())\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_matchmove.html","title":"create_matchmove","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_matchmove.html#client.ayon_maya.plugins.create.create_matchmove.CreateMatchmove","title":"<code>CreateMatchmove</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Instance for more complex setup of cameras.</p> <p>Might contain multiple cameras, geometries etc.</p> <p>It is expected to be extracted into .abc or .ma</p> Source code in <code>client/ayon_maya/plugins/create/create_matchmove.py</code> <pre><code>class CreateMatchmove(plugin.MayaCreator):\n    \"\"\"Instance for more complex setup of cameras.\n\n    Might contain multiple cameras, geometries etc.\n\n    It is expected to be extracted into .abc or .ma\n    \"\"\"\n\n    identifier = \"io.openpype.creators.maya.matchmove\"\n    label = \"Matchmove\"\n    product_type = \"matchmove\"\n    icon = \"video-camera\"\n\n    def get_instance_attr_defs(self):\n\n        defs = lib.collect_animation_defs()\n\n        defs.extend([\n            BoolDef(\"bakeToWorldSpace\",\n                    label=\"Bake Cameras to World-Space\",\n                    tooltip=\"Bake Cameras to World-Space\",\n                    default=True),\n        ])\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_maya_usd.html","title":"create_maya_usd","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_maya_usd.html#client.ayon_maya.plugins.create.create_maya_usd.CreateMayaUsd","title":"<code>CreateMayaUsd</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Create Maya USD Export from maya scene objects</p> Source code in <code>client/ayon_maya/plugins/create/create_maya_usd.py</code> <pre><code>class CreateMayaUsd(plugin.MayaCreator):\n    \"\"\"Create Maya USD Export from maya scene objects\"\"\"\n\n    identifier = \"io.openpype.creators.maya.mayausd\"\n    label = \"Maya USD\"\n    product_type = \"usd\"\n    icon = \"cubes\"\n    description = \"Create Maya USD Export\"\n    cache = {}\n\n    def register_callbacks(self):\n        self.create_context.add_value_changed_callback(self.on_values_changed)\n\n    def on_values_changed(self, event):\n        \"\"\"Update instance attribute definitions on attribute changes.\"\"\"\n\n        for instance_change in event[\"changes\"]:\n            # First check if there's a change we want to respond to\n            instance = instance_change[\"instance\"]\n            if instance is None:\n                # Change is on context\n                continue\n\n            if instance[\"creator_identifier\"] != self.identifier:\n                continue\n\n            value_changes = instance_change[\"changes\"]\n            if (\n                \"exportAnimationData\"\n                not in value_changes.get(\"creator_attributes\", {})\n            ):\n                continue\n\n            # Update the attribute definitions\n            new_attrs = self.get_attr_defs_for_instance(instance)\n            instance.set_create_attr_defs(new_attrs)\n\n    def get_publish_families(self):\n        return [\"usd\", \"mayaUsd\"]\n\n    def get_attr_defs_for_instance(self, instance):\n\n        if \"jobContextItems\" not in self.cache:\n            # Query once instead of per instance\n            job_context_items = {}\n            try:\n                cmds.loadPlugin(\"mayaUsdPlugin\", quiet=True)\n                job_context_items = {\n                    cmds.mayaUSDListJobContexts(jobContext=name): name\n                    for name in cmds.mayaUSDListJobContexts(export=True) or []\n                }\n            except RuntimeError:\n                # Likely `mayaUsdPlugin` plug-in not available\n                self.log.warning(\"Unable to retrieve available job \"\n                                 \"contexts for `mayaUsdPlugin` exports\")\n\n            if not job_context_items:\n                # enumdef multiselection may not be empty\n                job_context_items = [\"&lt;placeholder; do not use&gt;\"]\n\n            self.cache[\"jobContextItems\"] = job_context_items\n\n        defs = [\n            BoolDef(\"exportAnimationData\",\n                    label=\"Export Animation Data\",\n                    tooltip=\"When disabled no frame range is exported and \"\n                            \"only the start frame is used to define the \"\n                            \"static export frame.\",\n                    default=True)\n        ]\n        defs.extend(lib.collect_animation_defs(\n            create_context=self.create_context))\n        defs.extend([\n            EnumDef(\"defaultUSDFormat\",\n                    label=\"File format\",\n                    items={\n                        \"usdc\": \"Binary\",\n                        \"usda\": \"ASCII\"\n                    },\n                    default=\"usdc\"),\n            # TODO: Remove note from tooltip when issue is resolved, see:\n            #  https://github.com/Autodesk/maya-usd/issues/3389\n            BoolDef(\"exportRoots\",\n                    label=\"Export as roots\",\n                    tooltip=(\n                        \"Export the members of the object sets without \"\n                        \"their parents.\\n\"\n                        \"Note: There's an export bug that when this is \"\n                        \"enabled MayaUsd fails to export instance meshes\"\n                    ),\n                    default=True),\n            BoolDef(\"stripNamespaces\",\n                    label=\"Strip Namespaces\",\n                    tooltip=(\n                        \"Remove namespaces during export. By default, \"\n                        \"namespaces are exported to the USD file in the \"\n                        \"following format: nameSpaceExample_pPlatonic1\"\n                    ),\n                    default=True),\n            BoolDef(\"includeUserDefinedAttributes\",\n                    label=\"Include User Defined Attributes\",\n                    tooltip=(\n                        \"Whether to include all custom maya attributes found \"\n                        \"on nodes as metadata (userProperties) in USD.\"\n                    ),\n                    default=False),\n            TextDef(\"attr\",\n                    label=\"Custom Attributes\",\n                    default=\"\",\n                    placeholder=\"attr1, attr2\"),\n            TextDef(\"attrPrefix\",\n                    label=\"Custom Attributes Prefix\",\n                    default=\"\",\n                    placeholder=\"prefix1, prefix2\"),\n            EnumDef(\"jobContext\",\n                    label=\"Job Context\",\n                    items=self.cache[\"jobContextItems\"],\n                    tooltip=(\n                        \"Specifies an additional export context to handle.\\n\"\n                        \"These usually contain extra schemas, primitives,\\n\"\n                        \"and materials that are to be exported for a \"\n                        \"specific\\ntask, a target renderer for example.\"\n                    ),\n                    multiselection=True),\n        ])\n\n        # Disable the frame range attributes if `exportAnimationData` is\n        # disabled.\n        use_anim = instance[\"creator_attributes\"].get(\n            \"exportAnimationData\", True)\n        if not use_anim:\n            anim_defs = {\n                \"frameStart\", \"frameEnd\", \"handleStart\", \"handleEnd\", \"step\"\n            }\n            for attr_def in defs:\n                if attr_def.key in anim_defs:\n                    attr_def.disabled = True\n\n        return defs\n\n    def get_pre_create_attr_defs(self):\n        defs = super().get_pre_create_attr_defs()\n        defs.extend([\n            BoolDef(\"createAssetTemplateHierarchy\",\n                    label=\"Create asset hierarchy\",\n                    tooltip=(\n                        \"Create the root hierarchy for '{folder_name}/geo'\"\n                        \" as per the USD Asset Structure guidelines to\"\n                        \" add your geometry into.\"\n                    ),\n                    default=False)\n        ])\n        return defs\n\n    def _create_template_hierarchy(self, folder_name, variant):\n        \"\"\"Create the asset root template to hold the geo for the usd asset.\n\n        Args:\n            folder_name: Asset name to use for the group\n            variant: Variant name to use as namespace.\n                This is needed so separate asset contributions can be\n                correctly created from a single scene.\n\n        Returns:\n            list: The root node and geometry group.\n\n        \"\"\"\n\n        def set_usd_type(node, value):\n            attr = \"USD_typeName\"\n            if not cmds.attributeQuery(attr, node=node, exists=True):\n                cmds.addAttr(node, ln=attr, dt=\"string\")\n            cmds.setAttr(f\"{node}.{attr}\", value, type=\"string\")\n\n        # Ensure simple unique namespace (add trailing number)\n        namespace = variant\n        name = f\"{namespace}:{folder_name}\"\n        i = 1\n        while cmds.objExists(name):\n            name = f\"{namespace}{i}:{folder_name}\"\n            i += 1\n\n        # Define template hierarchy {folder_name}/geo\n        root = cmds.createNode(\"transform\",\n                               name=name,\n                               skipSelect=True)\n        geo = cmds.createNode(\"transform\",\n                              name=\"geo\",\n                              parent=root,\n                              skipSelect=True)\n        set_usd_type(geo, \"Scope\")\n        # Lock + hide transformations since we're exporting as Scope\n        for attr in [\"tx\", \"ty\", \"tz\", \"rx\", \"ry\", \"rz\", \"sx\", \"sy\", \"sz\"]:\n            cmds.setAttr(f\"{geo}.{attr}\", lock=True, keyable=False)\n\n        return [root, geo]\n\n    def create(self, product_name, instance_data, pre_create_data):\n\n        # Create template hierarchy\n        if pre_create_data.get(\"createAssetTemplateHierarchy\", False):\n            members = []\n            if pre_create_data.get(\"use_selection\"):\n                members = cmds.ls(selection=True,\n                                  long=True,\n                                  type=\"dagNode\")\n\n            folder_path = instance_data[\"folderPath\"]\n            folder_name = folder_path.rsplit(\"/\", 1)[-1]\n\n            root, geo = self._create_template_hierarchy(\n                folder_name=folder_name,\n                variant=instance_data[\"variant\"]\n            )\n\n            if members:\n                cmds.parent(members, geo)\n\n            # Select root and enable selection just so parent class'\n            # create adds it to the created instance\n            cmds.select(root, replace=True, noExpand=True)\n\n        super().create(product_name, instance_data, pre_create_data)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_maya_usd.html#client.ayon_maya.plugins.create.create_maya_usd.CreateMayaUsd.on_values_changed","title":"<code>on_values_changed(event)</code>","text":"<p>Update instance attribute definitions on attribute changes.</p> Source code in <code>client/ayon_maya/plugins/create/create_maya_usd.py</code> <pre><code>def on_values_changed(self, event):\n    \"\"\"Update instance attribute definitions on attribute changes.\"\"\"\n\n    for instance_change in event[\"changes\"]:\n        # First check if there's a change we want to respond to\n        instance = instance_change[\"instance\"]\n        if instance is None:\n            # Change is on context\n            continue\n\n        if instance[\"creator_identifier\"] != self.identifier:\n            continue\n\n        value_changes = instance_change[\"changes\"]\n        if (\n            \"exportAnimationData\"\n            not in value_changes.get(\"creator_attributes\", {})\n        ):\n            continue\n\n        # Update the attribute definitions\n        new_attrs = self.get_attr_defs_for_instance(instance)\n        instance.set_create_attr_defs(new_attrs)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_maya_usd_layer.html","title":"create_maya_usd_layer","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_maya_usd_layer.html#client.ayon_maya.plugins.create.create_maya_usd_layer.CreateMayaUsdLayer","title":"<code>CreateMayaUsdLayer</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Create Maya USD Export from <code>mayaUsdProxyShape</code> layer</p> Source code in <code>client/ayon_maya/plugins/create/create_maya_usd_layer.py</code> <pre><code>class CreateMayaUsdLayer(plugin.MayaCreator):\n    \"\"\"Create Maya USD Export from `mayaUsdProxyShape` layer\"\"\"\n\n    identifier = \"io.openpype.creators.maya.mayausdlayer\"\n    label = \"Maya USD Export Layer\"\n    product_type = \"usd\"\n    icon = \"cubes\"\n    description = \"Create mayaUsdProxyShape layer export\"\n\n    def get_publish_families(self):\n        return [\"usd\", \"mayaUsdLayer\"]\n\n    def get_instance_attr_defs(self):\n\n        from maya import cmds\n        import mayaUsd\n\n        # Construct the stage + layer EnumDef from the maya proxies in the\n        # scene and the Sdf.Layer stack of the Usd.Stage per proxy.\n        items = []\n        for proxy in cmds.ls(type=\"mayaUsdProxyShape\", long=True):\n            stage = mayaUsd.ufe.getStage(proxy)\n            if not stage:\n                continue\n\n            for layer in stage.GetLayerStack(includeSessionLayers=False):\n\n                proxy_nice_name = proxy.rsplit(\"|\", 2)[-2]\n                layer_nice_name = layer.GetDisplayName()\n                label = \"{} -&gt; {}\".format(proxy_nice_name, layer_nice_name)\n                value = \"&gt;\".join([proxy, layer.identifier])\n\n                items.append({\n                    \"label\": label,\n                    \"value\": value\n                })\n\n        if not items:\n            # EnumDef is not allowed to be empty\n            items.append(\"&lt;NONE&gt;\")\n\n        defs = [\n            EnumDef(\"defaultUSDFormat\",\n                    label=\"File format\",\n                    items={\n                        \"usdc\": \"Binary\",\n                        \"usda\": \"ASCII\"\n                    },\n                    default=\"usdc\"),\n            EnumDef(\"stageLayerIdentifier\",\n                    label=\"Stage and Layer Identifier\",\n                    items=items)\n        ]\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_mayascene.html","title":"create_mayascene","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_mayascene.html#client.ayon_maya.plugins.create.create_mayascene.CreateMayaScene","title":"<code>CreateMayaScene</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Raw Maya Scene file export</p> Source code in <code>client/ayon_maya/plugins/create/create_mayascene.py</code> <pre><code>class CreateMayaScene(plugin.MayaCreator):\n    \"\"\"Raw Maya Scene file export\"\"\"\n\n    identifier = \"io.openpype.creators.maya.mayascene\"\n    name = \"mayaScene\"\n    label = \"Maya Scene\"\n    product_type = \"mayaScene\"\n    icon = \"file-archive-o\"\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_model.html","title":"create_model","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_model.html#client.ayon_maya.plugins.create.create_model.CreateModel","title":"<code>CreateModel</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Polygonal static geometry</p> Source code in <code>client/ayon_maya/plugins/create/create_model.py</code> <pre><code>class CreateModel(plugin.MayaCreator):\n    \"\"\"Polygonal static geometry\"\"\"\n\n    identifier = \"io.openpype.creators.maya.model\"\n    label = \"Model\"\n    product_type = \"model\"\n    icon = \"cube\"\n    default_variants = [\"Main\", \"Proxy\", \"_MD\", \"_HD\", \"_LD\"]\n\n    write_face_sets = True\n    include_shaders = False\n\n    def get_instance_attr_defs(self):\n\n        return [\n            # TODO: Differentiate this more clearly from the exact Alembic\n            #  export feature to 'write face sets'\n            #  This particular toggle here implements an additional process\n            #  step for exports where ANY shader assignment is turned into an\n            #  explicit 'per face' assignment even if it was just a regular\n            #  full object material assignment in Maya.\n            #  See: https://github.com/ynput/ayon-maya/pull/37\n            BoolDef(\"writeFaceSets\",\n                    label=\"Write face sets\",\n                    tooltip=\"Write face sets with the geometry\",\n                    default=self.write_face_sets),\n            BoolDef(\"includeParentHierarchy\",\n                    label=\"Include Parent Hierarchy\",\n                    tooltip=\"Whether to include parent hierarchy of nodes in \"\n                            \"the publish instance\",\n                    default=False),\n            BoolDef(\"include_shaders\",\n                    label=\"Include Shaders\",\n                    tooltip=\"Include shaders in the geometry export.\",\n                    default=self.include_shaders),\n            # TODO: Remove these `attr` and `attrPrefix` attributes to avoid\n            #  confusion. This currently does NOT influence the model product\n            #  `mayaScene` nor `Alembic` output. It only influences the Maya\n            #  USD exported output. Which is confusing, because the attr def\n            #  is ALSO exposed in the Alembic export plugin as attr defs.\n            #  Preferably we unify them or clean it up some way so they are\n            #  not duplicated.\n            TextDef(\"attr\",\n                    label=\"Custom Attributes\",\n                    tooltip=\"Relevant to Maya USD Export only\",\n                    default=\"\",\n                    placeholder=\"attr1, attr2\"),\n            TextDef(\"attrPrefix\",\n                    label=\"Custom Attributes Prefix\",\n                    tooltip=\"Relevant to Maya USD Export only\",\n                    placeholder=\"prefix1, prefix2\"),\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_multishot_layout.html","title":"create_multishot_layout","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_multishot_layout.html#client.ayon_maya.plugins.create.create_multishot_layout.CreateMultishotLayout","title":"<code>CreateMultishotLayout</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Create a multi-shot layout in the Maya scene.</p> <p>This creator will create a Camera Sequencer in the Maya scene based on the shots found under the specified folder. The shots will be added to the sequencer in the order of their clipIn and clipOut values. For each shot a Layout will be created.</p> Source code in <code>client/ayon_maya/plugins/create/create_multishot_layout.py</code> <pre><code>class CreateMultishotLayout(plugin.MayaCreator):\n    \"\"\"Create a multi-shot layout in the Maya scene.\n\n    This creator will create a Camera Sequencer in the Maya scene based on\n    the shots found under the specified folder. The shots will be added to\n    the sequencer in the order of their clipIn and clipOut values. For each\n    shot a Layout will be created.\n\n    \"\"\"\n    identifier = \"io.openpype.creators.maya.multishotlayout\"\n    label = \"Multi-shot Layout\"\n    product_type = \"layout\"\n    icon = \"project-diagram\"\n\n    def get_pre_create_attr_defs(self):\n        # Present artist with a list of parents of the current context\n        # to choose from. This will be used to get the shots under the\n        # selected folder to create the Camera Sequencer.\n\n        \"\"\"\n        Todo: `get_folder_by_name` should be switched to `get_folder_by_path`\n              once the fork to pure AYON is done.\n\n        Warning: this will not work for projects where the folder name\n                 is not unique across the project until the switch mentioned\n                 above is done.\n        \"\"\"\n\n        project_name = get_current_project_name()\n        folder_path = get_current_folder_path()\n        if \"/\" in folder_path:\n            current_folder = get_folder_by_path(project_name, folder_path)\n        else:\n            current_folder = get_folder_by_name(\n                project_name, folder_name=folder_path\n            )\n\n        current_path_parts = current_folder[\"path\"].split(\"/\")\n\n        # populate the list with parents of the current folder\n        # this will create menu items like:\n        # [\n        #   {\n        #       \"value\": \"\",\n        #       \"label\": \"project (shots directly under the project)\"\n        #   }, {\n        #       \"value\": \"shots/shot_01\", \"label\": \"shot_01 (current)\"\n        #   }, {\n        #       \"value\": \"shots\", \"label\": \"shots\"\n        #   }\n        # ]\n\n        # add the project as the first item\n        items_with_label = [\n            {\n                \"label\": f\"{self.project_name} \"\n                         \"(shots directly under the project)\",\n                \"value\": \"\"\n            }\n        ]\n\n        # go through the current folder path and add each part to the list,\n        # but mark the current folder.\n        for part_idx, part in enumerate(current_path_parts):\n            label = part\n            if label == current_folder[\"name\"]:\n                label = f\"{label} (current)\"\n\n            value = \"/\".join(current_path_parts[:part_idx + 1])\n\n            items_with_label.append({\"label\": label, \"value\": value})\n\n        return [\n            EnumDef(\"shotParent\",\n                    default=current_folder[\"name\"],\n                    label=\"Shot Parent Folder\",\n                    items=items_with_label,\n                    ),\n            BoolDef(\"groupLoadedAssets\",\n                    label=\"Group Loaded Assets\",\n                    tooltip=\"Enable this when you want to publish group of \"\n                            \"loaded asset\",\n                    default=False),\n            TextDef(\"taskName\",\n                    label=\"Associated Task Name\",\n                    tooltip=(\"Task name to be associated \"\n                             \"with the created Layout\"),\n                    default=\"layout\"),\n        ]\n\n    def create(self, product_name, instance_data, pre_create_data):\n        shots = list(\n            self.get_related_shots(folder_path=pre_create_data[\"shotParent\"])\n        )\n        if not shots:\n            # There are no shot folders under the specified folder.\n            # We are raising an error here but in the future we might\n            # want to create a new shot folders by publishing the layouts\n            # and shot defined in the sequencer. Sort of editorial publish\n            # in side of Maya.\n            raise CreatorError((\n                \"No shots found under the specified \"\n                f\"folder: {pre_create_data['shotParent']}.\"))\n\n        # Get layout creator\n        layout_creator_id = \"io.openpype.creators.maya.layout\"\n        layout_creator: Creator = self.create_context.creators.get(\n            layout_creator_id)\n        if not layout_creator:\n            raise CreatorError(\n                f\"Creator {layout_creator_id} not found.\")\n\n        folder_ids = {s[\"id\"] for s in shots}\n        folder_entities = get_folders(self.project_name, folder_ids)\n        task_entities = get_tasks(\n            self.project_name, folder_ids=folder_ids\n        )\n        task_entities_by_folder_id = collections.defaultdict(dict)\n        for task_entity in task_entities:\n            folder_id = task_entity[\"folderId\"]\n            task_name = task_entity[\"name\"]\n            task_entities_by_folder_id[folder_id][task_name] = task_entity\n\n        folder_entities_by_id = {fe[\"id\"]: fe for fe in folder_entities}\n        for shot in shots:\n            # we are setting shot name to be displayed in the sequencer to\n            # `shot name (shot label)` if the label is set, otherwise just\n            # `shot name`. So far, labels are used only when the name is set\n            # with characters that are not allowed in the shot name.\n            if not shot[\"active\"]:\n                continue\n\n            # get task for shot\n            folder_id = shot[\"id\"]\n            folder_entity = folder_entities_by_id[folder_id]\n            task_entities = task_entities_by_folder_id[folder_id]\n\n            layout_task_name = None\n            layout_task_entity = None\n            if pre_create_data[\"taskName\"] in task_entities:\n                layout_task_name = pre_create_data[\"taskName\"]\n                layout_task_entity = task_entities[layout_task_name]\n\n            shot_name = shot['name']\n            if shot[\"label\"] and shot[\"label\"] != shot_name:\n                shot_name += f\" ({shot['label']})\"\n\n            cmds.shot(sequenceStartTime=shot[\"attrib\"][\"clipIn\"],\n                      sequenceEndTime=shot[\"attrib\"][\"clipOut\"],\n                      shotName=shot_name)\n\n            # Create layout instance by the layout creator\n\n            instance_data = {\n                \"folderPath\": shot[\"path\"],\n                \"variant\": layout_creator.get_default_variant()\n            }\n            if layout_task_name:\n                instance_data[\"task\"] = layout_task_name\n\n            layout_creator.create(\n                product_name=layout_creator.get_product_name(\n                    self.project_name,\n                    folder_entity,\n                    layout_task_entity,\n                    layout_creator.get_default_variant(),\n                ),\n                instance_data=instance_data,\n                pre_create_data={\n                    \"groupLoadedAssets\": pre_create_data[\"groupLoadedAssets\"]\n                }\n            )\n\n    def get_related_shots(self, folder_path: str):\n        \"\"\"Get all shots related to the current folder.\n\n        Get all folders of type Shot under specified folder.\n\n        Args:\n            folder_path (str): Path of the folder.\n\n        Returns:\n            list: List of dicts with folder data.\n\n        \"\"\"\n        # if folder_path is None, project is selected as a root\n        # and its name is used as a parent id\n        parent_id = self.project_name\n        if folder_path:\n            current_folder = get_folder_by_path(\n                project_name=self.project_name,\n                folder_path=folder_path,\n            )\n            parent_id = current_folder[\"id\"]\n\n        # get all child folders of the current one\n        return get_folders(\n            project_name=self.project_name,\n            parent_ids=[parent_id],\n            fields=[\n                \"attrib.clipIn\", \"attrib.clipOut\",\n                \"attrib.frameStart\", \"attrib.frameEnd\",\n                \"name\", \"label\", \"path\", \"folderType\", \"id\"\n            ]\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_multishot_layout.html#client.ayon_maya.plugins.create.create_multishot_layout.CreateMultishotLayout.get_pre_create_attr_defs","title":"<code>get_pre_create_attr_defs()</code>","text":"<code>get_folder_by_name</code> should be switched to <code>get_folder_by_path</code> <p>once the fork to pure AYON is done.</p> this will not work for projects where the folder name <p>is not unique across the project until the switch mentioned above is done.</p> Source code in <code>client/ayon_maya/plugins/create/create_multishot_layout.py</code> <pre><code>def get_pre_create_attr_defs(self):\n    # Present artist with a list of parents of the current context\n    # to choose from. This will be used to get the shots under the\n    # selected folder to create the Camera Sequencer.\n\n    \"\"\"\n    Todo: `get_folder_by_name` should be switched to `get_folder_by_path`\n          once the fork to pure AYON is done.\n\n    Warning: this will not work for projects where the folder name\n             is not unique across the project until the switch mentioned\n             above is done.\n    \"\"\"\n\n    project_name = get_current_project_name()\n    folder_path = get_current_folder_path()\n    if \"/\" in folder_path:\n        current_folder = get_folder_by_path(project_name, folder_path)\n    else:\n        current_folder = get_folder_by_name(\n            project_name, folder_name=folder_path\n        )\n\n    current_path_parts = current_folder[\"path\"].split(\"/\")\n\n    # populate the list with parents of the current folder\n    # this will create menu items like:\n    # [\n    #   {\n    #       \"value\": \"\",\n    #       \"label\": \"project (shots directly under the project)\"\n    #   }, {\n    #       \"value\": \"shots/shot_01\", \"label\": \"shot_01 (current)\"\n    #   }, {\n    #       \"value\": \"shots\", \"label\": \"shots\"\n    #   }\n    # ]\n\n    # add the project as the first item\n    items_with_label = [\n        {\n            \"label\": f\"{self.project_name} \"\n                     \"(shots directly under the project)\",\n            \"value\": \"\"\n        }\n    ]\n\n    # go through the current folder path and add each part to the list,\n    # but mark the current folder.\n    for part_idx, part in enumerate(current_path_parts):\n        label = part\n        if label == current_folder[\"name\"]:\n            label = f\"{label} (current)\"\n\n        value = \"/\".join(current_path_parts[:part_idx + 1])\n\n        items_with_label.append({\"label\": label, \"value\": value})\n\n    return [\n        EnumDef(\"shotParent\",\n                default=current_folder[\"name\"],\n                label=\"Shot Parent Folder\",\n                items=items_with_label,\n                ),\n        BoolDef(\"groupLoadedAssets\",\n                label=\"Group Loaded Assets\",\n                tooltip=\"Enable this when you want to publish group of \"\n                        \"loaded asset\",\n                default=False),\n        TextDef(\"taskName\",\n                label=\"Associated Task Name\",\n                tooltip=(\"Task name to be associated \"\n                         \"with the created Layout\"),\n                default=\"layout\"),\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_multishot_layout.html#client.ayon_maya.plugins.create.create_multishot_layout.CreateMultishotLayout.get_related_shots","title":"<code>get_related_shots(folder_path)</code>","text":"<p>Get all shots related to the current folder.</p> <p>Get all folders of type Shot under specified folder.</p> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>str</code> <p>Path of the folder.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of dicts with folder data.</p> Source code in <code>client/ayon_maya/plugins/create/create_multishot_layout.py</code> <pre><code>def get_related_shots(self, folder_path: str):\n    \"\"\"Get all shots related to the current folder.\n\n    Get all folders of type Shot under specified folder.\n\n    Args:\n        folder_path (str): Path of the folder.\n\n    Returns:\n        list: List of dicts with folder data.\n\n    \"\"\"\n    # if folder_path is None, project is selected as a root\n    # and its name is used as a parent id\n    parent_id = self.project_name\n    if folder_path:\n        current_folder = get_folder_by_path(\n            project_name=self.project_name,\n            folder_path=folder_path,\n        )\n        parent_id = current_folder[\"id\"]\n\n    # get all child folders of the current one\n    return get_folders(\n        project_name=self.project_name,\n        parent_ids=[parent_id],\n        fields=[\n            \"attrib.clipIn\", \"attrib.clipOut\",\n            \"attrib.frameStart\", \"attrib.frameEnd\",\n            \"name\", \"label\", \"path\", \"folderType\", \"id\"\n        ]\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_multiverse_look.html","title":"create_multiverse_look","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_multiverse_look.html#client.ayon_maya.plugins.create.create_multiverse_look.CreateMultiverseLook","title":"<code>CreateMultiverseLook</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Create Multiverse Look</p> Source code in <code>client/ayon_maya/plugins/create/create_multiverse_look.py</code> <pre><code>class CreateMultiverseLook(plugin.MayaCreator):\n    \"\"\"Create Multiverse Look\"\"\"\n\n    identifier = \"io.openpype.creators.maya.mvlook\"\n    label = \"Multiverse Look\"\n    product_type = \"mvLook\"\n    icon = \"cubes\"\n\n    def get_instance_attr_defs(self):\n\n        return [\n            EnumDef(\"fileFormat\",\n                    label=\"File Format\",\n                    tooltip=\"USD export file format\",\n                    items=[\"usda\", \"usd\"],\n                    default=\"usda\"),\n            BoolDef(\"publishMipMap\",\n                    label=\"Publish MipMap\",\n                    default=True),\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_multiverse_usd.html","title":"create_multiverse_usd","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_multiverse_usd.html#client.ayon_maya.plugins.create.create_multiverse_usd.CreateMultiverseUsd","title":"<code>CreateMultiverseUsd</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Create Multiverse USD Asset</p> Source code in <code>client/ayon_maya/plugins/create/create_multiverse_usd.py</code> <pre><code>class CreateMultiverseUsd(plugin.MayaCreator):\n    \"\"\"Create Multiverse USD Asset\"\"\"\n\n    identifier = \"io.openpype.creators.maya.mvusdasset\"\n    label = \"Multiverse USD Asset\"\n    product_type = \"usd\"\n    icon = \"cubes\"\n    description = \"Create Multiverse USD Asset\"\n\n    def get_publish_families(self):\n        return [\"usd\", \"mvUsd\"]\n\n    def get_instance_attr_defs(self):\n\n        defs = lib.collect_animation_defs(\n            fps=True, create_context=self.create_context)\n        defs.extend([\n            EnumDef(\"fileFormat\",\n                    label=\"File format\",\n                    items=[\"usd\", \"usda\", \"usdz\"],\n                    default=\"usd\"),\n            BoolDef(\"stripNamespaces\",\n                    label=\"Strip Namespaces\",\n                    default=True),\n            BoolDef(\"mergeTransformAndShape\",\n                    label=\"Merge Transform and Shape\",\n                    default=False),\n            BoolDef(\"writeAncestors\",\n                    label=\"Write Ancestors\",\n                    default=True),\n            BoolDef(\"flattenParentXforms\",\n                    label=\"Flatten Parent Xforms\",\n                    default=False),\n            BoolDef(\"writeSparseOverrides\",\n                    label=\"Write Sparse Overrides\",\n                    default=False),\n            BoolDef(\"useMetaPrimPath\",\n                    label=\"Use Meta Prim Path\",\n                    default=False),\n            TextDef(\"customRootPath\",\n                    label=\"Custom Root Path\",\n                    default=''),\n            TextDef(\"customAttributes\",\n                    label=\"Custom Attributes\",\n                    tooltip=\"Comma-separated list of attribute names\",\n                    default=''),\n            TextDef(\"nodeTypesToIgnore\",\n                    label=\"Node Types to Ignore\",\n                    tooltip=\"Comma-separated list of node types to be ignored\",\n                    default=''),\n            BoolDef(\"writeMeshes\",\n                    label=\"Write Meshes\",\n                    default=True),\n            BoolDef(\"writeCurves\",\n                    label=\"Write Curves\",\n                    default=True),\n            BoolDef(\"writeParticles\",\n                    label=\"Write Particles\",\n                    default=True),\n            BoolDef(\"writeCameras\",\n                    label=\"Write Cameras\",\n                    default=False),\n            BoolDef(\"writeLights\",\n                    label=\"Write Lights\",\n                    default=False),\n            BoolDef(\"writeJoints\",\n                    label=\"Write Joints\",\n                    default=False),\n            BoolDef(\"writeCollections\",\n                    label=\"Write Collections\",\n                    default=False),\n            BoolDef(\"writePositions\",\n                    label=\"Write Positions\",\n                    default=True),\n            BoolDef(\"writeNormals\",\n                    label=\"Write Normals\",\n                    default=True),\n            BoolDef(\"writeUVs\",\n                    label=\"Write UVs\",\n                    default=True),\n            BoolDef(\"writeColorSets\",\n                    label=\"Write Color Sets\",\n                    default=False),\n            BoolDef(\"writeTangents\",\n                    label=\"Write Tangents\",\n                    default=False),\n            BoolDef(\"writeRefPositions\",\n                    label=\"Write Ref Positions\",\n                    default=True),\n            BoolDef(\"writeBlendShapes\",\n                    label=\"Write BlendShapes\",\n                    default=False),\n            BoolDef(\"writeDisplayColor\",\n                    label=\"Write Display Color\",\n                    default=True),\n            BoolDef(\"writeSkinWeights\",\n                    label=\"Write Skin Weights\",\n                    default=False),\n            BoolDef(\"writeMaterialAssignment\",\n                    label=\"Write Material Assignment\",\n                    default=False),\n            BoolDef(\"writeHardwareShader\",\n                    label=\"Write Hardware Shader\",\n                    default=False),\n            BoolDef(\"writeShadingNetworks\",\n                    label=\"Write Shading Networks\",\n                    default=False),\n            BoolDef(\"writeTransformMatrix\",\n                    label=\"Write Transform Matrix\",\n                    default=True),\n            BoolDef(\"writeUsdAttributes\",\n                    label=\"Write USD Attributes\",\n                    default=True),\n            BoolDef(\"writeInstancesAsReferences\",\n                    label=\"Write Instances as References\",\n                    default=False),\n            BoolDef(\"timeVaryingTopology\",\n                    label=\"Time Varying Topology\",\n                    default=False),\n            TextDef(\"customMaterialNamespace\",\n                    label=\"Custom Material Namespace\",\n                    default=''),\n            NumberDef(\"numTimeSamples\",\n                      label=\"Num Time Samples\",\n                      default=1),\n            NumberDef(\"timeSamplesSpan\",\n                      label=\"Time Samples Span\",\n                      default=0.0),\n        ])\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_multiverse_usd_comp.html","title":"create_multiverse_usd_comp","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_multiverse_usd_comp.html#client.ayon_maya.plugins.create.create_multiverse_usd_comp.CreateMultiverseUsdComp","title":"<code>CreateMultiverseUsdComp</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Create Multiverse USD Composition</p> Source code in <code>client/ayon_maya/plugins/create/create_multiverse_usd_comp.py</code> <pre><code>class CreateMultiverseUsdComp(plugin.MayaCreator):\n    \"\"\"Create Multiverse USD Composition\"\"\"\n\n    identifier = \"io.openpype.creators.maya.mvusdcomposition\"\n    label = \"Multiverse USD Composition\"\n    product_type = \"mvUsdComposition\"\n    icon = \"cubes\"\n\n    def get_instance_attr_defs(self):\n\n        defs = lib.collect_animation_defs(\n            fps=True, create_context=self.create_context)\n        defs.extend([\n            EnumDef(\"fileFormat\",\n                    label=\"File format\",\n                    items=[\"usd\", \"usda\"],\n                    default=\"usd\"),\n            BoolDef(\"stripNamespaces\",\n                    label=\"Strip Namespaces\",\n                    default=False),\n            BoolDef(\"mergeTransformAndShape\",\n                    label=\"Merge Transform and Shape\",\n                    default=False),\n            BoolDef(\"flattenContent\",\n                    label=\"Flatten Content\",\n                    default=False),\n            BoolDef(\"writeAsCompoundLayers\",\n                    label=\"Write As Compound Layers\",\n                    default=False),\n            BoolDef(\"writePendingOverrides\",\n                    label=\"Write Pending Overrides\",\n                    default=False),\n            NumberDef(\"numTimeSamples\",\n                      label=\"Num Time Samples\",\n                      default=1),\n            NumberDef(\"timeSamplesSpan\",\n                      label=\"Time Samples Span\",\n                      default=0.0),\n        ])\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_multiverse_usd_over.html","title":"create_multiverse_usd_over","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_multiverse_usd_over.html#client.ayon_maya.plugins.create.create_multiverse_usd_over.CreateMultiverseUsdOver","title":"<code>CreateMultiverseUsdOver</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Create Multiverse USD Override</p> Source code in <code>client/ayon_maya/plugins/create/create_multiverse_usd_over.py</code> <pre><code>class CreateMultiverseUsdOver(plugin.MayaCreator):\n    \"\"\"Create Multiverse USD Override\"\"\"\n\n    identifier = \"io.openpype.creators.maya.mvusdoverride\"\n    label = \"Multiverse USD Override\"\n    product_type = \"mvUsdOverride\"\n    icon = \"cubes\"\n\n    def get_instance_attr_defs(self):\n        defs = lib.collect_animation_defs(\n            fps=True, create_context=self.create_context)\n        defs.extend([\n            EnumDef(\"fileFormat\",\n                    label=\"File format\",\n                    items=[\"usd\", \"usda\"],\n                    default=\"usd\"),\n            BoolDef(\"writeAll\",\n                    label=\"Write All\",\n                    default=False),\n            BoolDef(\"writeTransforms\",\n                    label=\"Write Transforms\",\n                    default=True),\n            BoolDef(\"writeVisibility\",\n                    label=\"Write Visibility\",\n                    default=True),\n            BoolDef(\"writeAttributes\",\n                    label=\"Write Attributes\",\n                    default=True),\n            BoolDef(\"writeMaterials\",\n                    label=\"Write Materials\",\n                    default=True),\n            BoolDef(\"writeVariants\",\n                    label=\"Write Variants\",\n                    default=True),\n            BoolDef(\"writeVariantsDefinition\",\n                    label=\"Write Variants Definition\",\n                    default=True),\n            BoolDef(\"writeActiveState\",\n                    label=\"Write Active State\",\n                    default=True),\n            BoolDef(\"writeNamespaces\",\n                    label=\"Write Namespaces\",\n                    default=False),\n            NumberDef(\"numTimeSamples\",\n                      label=\"Num Time Samples\",\n                      default=1),\n            NumberDef(\"timeSamplesSpan\",\n                      label=\"Time Samples Span\",\n                      default=0.0),\n        ])\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_ornatrix_cache.html","title":"create_ornatrix_cache","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_ornatrix_cache.html#client.ayon_maya.plugins.create.create_ornatrix_cache.CreateOxCache","title":"<code>CreateOxCache</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Output for procedural plugin nodes of Ornatrix</p> Source code in <code>client/ayon_maya/plugins/create/create_ornatrix_cache.py</code> <pre><code>class CreateOxCache(plugin.MayaCreator):\n    \"\"\"Output for procedural plugin nodes of Ornatrix \"\"\"\n\n    identifier = \"io.ayon.creators.maya.oxcache\"\n    label = \"Ornatrix Cache\"\n    product_type = \"oxcache\"\n    icon = \"pagelines\"\n    description = \"Ornatrix Cache\"\n\n    def get_instance_attr_defs(self):\n\n        # Add animation data without step and handles\n        remove = {\"handleStart\", \"handleEnd\"}\n        defs = [\n            attr_def for attr_def in lib.collect_animation_defs(\n                create_context=self.create_context)\n            if attr_def.key not in remove\n        ]\n        defs.extend(\n            [\n                BoolDef(\"farm\",\n                        label=\"Submit to Farm\",\n                        default=False),\n                EnumDef(\"format\",\n                        items={\n                            0: \"Ogawa\",\n                            1: \"HDF5\",\n                        },\n                        label=\"Format\",\n                        default=0),\n                BoolDef(\"renderVersion\",\n                        label=\"Use Render Version\",\n                        tooltip=\"When on, hair in the scene will be \"\n                                \"switched to render mode and dense hair \"\n                                \"strands will be exported. Otherwise, what \"\n                                \"is seen in the viewport will be exported.\",\n                        default=True),\n                EnumDef(\"upDirection\",\n                        items={\n                            0: \"X\",\n                            1: \"Y\",\n                            2: \"Z\"\n                        },\n                        label=\"Up Direction\",\n                        default=1),\n                BoolDef(\"useWorldCoordinates\",\n                        label=\"Use World Coordinates\",\n                        default=False),\n                BoolDef(\"exportStrandData\",\n                        label=\"Export Strand Data\",\n                        default=True),\n                BoolDef(\"exportSurfacePositions\",\n                        label=\"Export Surface Positions\",\n                        default=False),\n                # TODO: Should we support this?\n                # BoolDef(\"oneObjectPerFile\",\n                #         label=\"One Object Per File\",\n                #         default=False),\n                BoolDef(\"exportStrandIds\",\n                        label=\"Export Strand Ids\",\n                        default=True),\n                BoolDef(\"exportStrandGroups\",\n                        label=\"Export Strand Groups\",\n                        default=True),\n                BoolDef(\"exportWidths\",\n                        label=\"Export Widths\",\n                        default=True),\n                BoolDef(\"exportTextureCoordinates\",\n                        label=\"Export Texture Coordinates\",\n                        default=True),\n                BoolDef(\"exportNormals\",\n                        label=\"Export Normals\",\n                        default=False),\n                BoolDef(\"exportVelocities\",\n                        label=\"Export Velocities\",\n                        default=False),\n                NumberDef(\"velocityIntervalCenter\",\n                          label=\"Velocity Interval Center\",\n                          default=0.0),\n                NumberDef(\"velocityIntervalLength\",\n                          label=\"Velocity Interval Length\",\n                          default=0.5),\n                BoolDef(\"unrealEngineExport\",\n                        label=\"Unreal Engine Export\",\n                        default=False),\n                BoolDef(\"exportEachStrandAsSeparateObject\",\n                        label=\"Export Each Strand As Separate Object\",\n                        default=False)\n            ]\n        )\n\n        return defs\n\n    def get_detail_description(self):\n        return inspect.cleandoc(\"\"\"\n            ### Ornatrix Cache\n\n            The Ornatrix cache creator allows you to cache Ornatrix\n            hair shapes to an Ornatrix Alembic.\n\n            For more details, see the [AYON Maya Ornatrix Artist documentation](https://ayon.ynput.io/docs/addon_maya_ornatrix_artist/).\n        \"\"\"  # noqa\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_ornatrix_rig.html","title":"create_ornatrix_rig","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_ornatrix_rig.html#client.ayon_maya.plugins.create.create_ornatrix_rig.CreateOxRig","title":"<code>CreateOxRig</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Output for Ornatrix nodes</p> Source code in <code>client/ayon_maya/plugins/create/create_ornatrix_rig.py</code> <pre><code>class CreateOxRig(plugin.MayaCreator):\n    \"\"\"Output for Ornatrix nodes\"\"\"\n\n    identifier = \"io.ayon.creators.maya.oxrig\"\n    label = \"Ornatrix Rig\"\n    product_type = \"oxrig\"\n    icon = \"usb\"\n    description = \"Ornatrix Rig\"\n\n    def get_detail_description(self):\n        return inspect.cleandoc(\"\"\"\n            ### Ornatrix Rig\n\n            The Ornatrix rig creator allows you to publish a re-usable rig to\n            easily load your prepared Ornatrix hair/fur for an asset and apply\n            them elsewhere for simulation or rendering by connecting it to \n            the animated pointcaches.\n\n            The Ornatrix Rig instance object set should include the meshes with\n            the connected Ornatrix hairs, usually the `HairShape` with the \n            `EditGuidesShape`.\n\n            For more details, see the [AYON Maya Ornatrix Artist documentation](https://ayon.ynput.io/docs/addon_maya_ornatrix_artist/).\n        \"\"\"  # noqa\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_proxy_abc.html","title":"create_proxy_abc","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_proxy_abc.html#client.ayon_maya.plugins.create.create_proxy_abc.CreateProxyAlembic","title":"<code>CreateProxyAlembic</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Proxy Alembic for animated data</p> Source code in <code>client/ayon_maya/plugins/create/create_proxy_abc.py</code> <pre><code>class CreateProxyAlembic(plugin.MayaCreator):\n    \"\"\"Proxy Alembic for animated data\"\"\"\n\n    identifier = \"io.openpype.creators.maya.proxyabc\"\n    label = \"Proxy Alembic\"\n    product_type = \"proxyAbc\"\n    icon = \"gears\"\n    write_color_sets = False\n    write_face_sets = False\n\n    def get_instance_attr_defs(self):\n\n        defs = lib.collect_animation_defs()\n\n        defs.extend([\n            BoolDef(\"farm\",\n                    label=\"Submit to Farm\",\n                    default=False),\n            BoolDef(\"writeColorSets\",\n                    label=\"Write vertex colors\",\n                    tooltip=\"Write vertex colors with the geometry\",\n                    default=self.write_color_sets),\n            BoolDef(\"writeFaceSets\",\n                    label=\"Write face sets\",\n                    tooltip=\"Write face sets with the geometry\",\n                    default=self.write_face_sets),\n            BoolDef(\"worldSpace\",\n                    label=\"World-Space Export\",\n                    default=True),\n            TextDef(\"nameSuffix\",\n                    label=\"Name Suffix for Bounding Box\",\n                    default=\"_BBox\",\n                    placeholder=\"_BBox\"),\n            TextDef(\"attr\",\n                    label=\"Custom Attributes\",\n                    default=\"\",\n                    placeholder=\"attr1, attr2\"),\n            TextDef(\"attrPrefix\",\n                    label=\"Custom Attributes Prefix\",\n                    placeholder=\"prefix1, prefix2\")\n        ])\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_redshift_proxy.html","title":"create_redshift_proxy","text":"<p>Creator of Redshift proxy product types.</p>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_redshift_proxy.html#client.ayon_maya.plugins.create.create_redshift_proxy.CreateRedshiftProxy","title":"<code>CreateRedshiftProxy</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Create instance of Redshift Proxy product.</p> Source code in <code>client/ayon_maya/plugins/create/create_redshift_proxy.py</code> <pre><code>class CreateRedshiftProxy(plugin.MayaCreator):\n    \"\"\"Create instance of Redshift Proxy product.\"\"\"\n\n    identifier = \"io.openpype.creators.maya.redshiftproxy\"\n    label = \"Redshift Proxy\"\n    product_type = \"redshiftproxy\"\n    icon = \"gears\"\n\n    def get_instance_attr_defs(self):\n\n        defs = [\n            BoolDef(\"farm\",\n                    label=\"Submit to Farm\",\n                    default=False),\n            BoolDef(\"animation\",\n                    label=\"Export animation\",\n                    default=False)\n        ]\n\n        defs.extend(lib.collect_animation_defs(\n            create_context=self.create_context))\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_render.html","title":"create_render","text":"<p>Create <code>Render</code> instance in Maya.</p>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_render.html#client.ayon_maya.plugins.create.create_render.CreateRender","title":"<code>CreateRender</code>","text":"<p>               Bases: <code>RenderlayerCreator</code></p> <p>Create and manages renderlayer product per renderLayer in workfile.</p> <p>This generates a single node in the scene which tells the Creator to if it exists collect Maya rendersetup renderlayers as individual instances. As such, triggering create doesn't actually create the instance node per layer but only the node which tells the Creator it may now collect the renderlayers.</p> Source code in <code>client/ayon_maya/plugins/create/create_render.py</code> <pre><code>class CreateRender(plugin.RenderlayerCreator):\n    \"\"\"Create and manages renderlayer product per renderLayer in workfile.\n\n    This generates a single node in the scene which tells the Creator to if\n    it exists collect Maya rendersetup renderlayers as individual instances.\n    As such, triggering create doesn't actually create the instance node per\n    layer but only the node which tells the Creator it may now collect\n    the renderlayers.\n\n    \"\"\"\n\n    identifier = \"io.openpype.creators.maya.renderlayer\"\n    product_type = \"renderlayer\"\n    label = \"Render\"\n    icon = \"eye\"\n\n    layer_instance_prefix = \"render\"\n    singleton_node_name = \"renderingMain\"\n\n    render_settings = {}\n\n    def apply_settings(self, project_settings):\n        super().apply_settings(project_settings)\n        self.render_settings = project_settings[\"maya\"][\"render_settings\"]\n\n    def create(self, product_name, instance_data, pre_create_data):\n        # Only allow a single render instance to exist\n        if self._get_singleton_node():\n            raise CreatorError(\n                \"A Render instance already exists - only one can be \"\n                \"configured.\\n\\n\"\n                \"To render multiple render layers, create extra Render Setup \"\n                \"Layers via Maya's Render Setup UI.\\n\"\n                \"Then refresh the publisher to detect the new layers for \"\n                \"rendering.\\n\\n\"\n                \"With a render instance present all Render Setup layers in \"\n                \"your workfile are renderable instances.\")\n\n        # Apply default project render settings on create\n        if self.render_settings.get(\"apply_render_settings\"):\n            lib_rendersettings.RenderSettings().set_default_renderer_settings()\n\n        super().create(product_name, instance_data, pre_create_data)\n\n    def get_instance_attr_defs(self):\n        \"\"\"Create instance settings.\"\"\"\n\n        return [\n            BoolDef(\"review\",\n                    label=\"Review\",\n                    tooltip=\"Mark as reviewable\",\n                    default=True),\n            BoolDef(\"extendFrames\",\n                    label=\"Extend Frames\",\n                    tooltip=\"Extends the frames on top of the previous \"\n                            \"publish.\\nIf the previous was 1001-1050 and you \"\n                            \"would now submit 1020-1070 only the new frames \"\n                            \"1051-1070 would be rendered and published \"\n                            \"together with the previously rendered frames.\\n\"\n                            \"If 'overrideExistingFrame' is enabled it *will* \"\n                            \"render any existing frames.\",\n                    default=False),\n            BoolDef(\"overrideExistingFrame\",\n                    label=\"Override Existing Frame\",\n                    tooltip=\"Override existing rendered frames \"\n                            \"(if they exist).\",\n                    default=True),\n\n            # TODO: Should these move to submit_maya_deadline plugin?\n            # Tile rendering\n            BoolDef(\"tileRendering\",\n                    label=\"Enable tiled rendering\",\n                    default=False),\n            NumberDef(\"tilesX\",\n                      label=\"Tiles X\",\n                      default=2,\n                      minimum=1,\n                      decimals=0),\n            NumberDef(\"tilesY\",\n                      label=\"Tiles Y\",\n                      default=2,\n                      minimum=1,\n                      decimals=0),\n\n            # Additional settings\n            BoolDef(\"convertToScanline\",\n                    label=\"Convert to Scanline\",\n                    tooltip=\"Convert the output images to scanline images\",\n                    default=False),\n            BoolDef(\"useReferencedAovs\",\n                    label=\"Use Referenced AOVs\",\n                    tooltip=\"Consider the AOVs from referenced scenes as well\",\n                    default=False),\n\n            BoolDef(\"renderSetupIncludeLights\",\n                    label=\"Render Setup Include Lights\",\n                    default=self.render_settings.get(\"enable_all_lights\",\n                                                     False))\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_render.html#client.ayon_maya.plugins.create.create_render.CreateRender.get_instance_attr_defs","title":"<code>get_instance_attr_defs()</code>","text":"<p>Create instance settings.</p> Source code in <code>client/ayon_maya/plugins/create/create_render.py</code> <pre><code>def get_instance_attr_defs(self):\n    \"\"\"Create instance settings.\"\"\"\n\n    return [\n        BoolDef(\"review\",\n                label=\"Review\",\n                tooltip=\"Mark as reviewable\",\n                default=True),\n        BoolDef(\"extendFrames\",\n                label=\"Extend Frames\",\n                tooltip=\"Extends the frames on top of the previous \"\n                        \"publish.\\nIf the previous was 1001-1050 and you \"\n                        \"would now submit 1020-1070 only the new frames \"\n                        \"1051-1070 would be rendered and published \"\n                        \"together with the previously rendered frames.\\n\"\n                        \"If 'overrideExistingFrame' is enabled it *will* \"\n                        \"render any existing frames.\",\n                default=False),\n        BoolDef(\"overrideExistingFrame\",\n                label=\"Override Existing Frame\",\n                tooltip=\"Override existing rendered frames \"\n                        \"(if they exist).\",\n                default=True),\n\n        # TODO: Should these move to submit_maya_deadline plugin?\n        # Tile rendering\n        BoolDef(\"tileRendering\",\n                label=\"Enable tiled rendering\",\n                default=False),\n        NumberDef(\"tilesX\",\n                  label=\"Tiles X\",\n                  default=2,\n                  minimum=1,\n                  decimals=0),\n        NumberDef(\"tilesY\",\n                  label=\"Tiles Y\",\n                  default=2,\n                  minimum=1,\n                  decimals=0),\n\n        # Additional settings\n        BoolDef(\"convertToScanline\",\n                label=\"Convert to Scanline\",\n                tooltip=\"Convert the output images to scanline images\",\n                default=False),\n        BoolDef(\"useReferencedAovs\",\n                label=\"Use Referenced AOVs\",\n                tooltip=\"Consider the AOVs from referenced scenes as well\",\n                default=False),\n\n        BoolDef(\"renderSetupIncludeLights\",\n                label=\"Render Setup Include Lights\",\n                default=self.render_settings.get(\"enable_all_lights\",\n                                                 False))\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_rendersetup.html","title":"create_rendersetup","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_rendersetup.html#client.ayon_maya.plugins.create.create_rendersetup.CreateRenderSetup","title":"<code>CreateRenderSetup</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Create rendersetup template json data</p> Source code in <code>client/ayon_maya/plugins/create/create_rendersetup.py</code> <pre><code>class CreateRenderSetup(plugin.MayaCreator):\n    \"\"\"Create rendersetup template json data\"\"\"\n\n    identifier = \"io.openpype.creators.maya.rendersetup\"\n    label = \"Render Setup Preset\"\n    product_type = \"rendersetup\"\n    icon = \"tablet\"\n\n    def get_pre_create_attr_defs(self):\n        # Do not show the \"use_selection\" setting from parent class\n        return []\n\n    def create(self, product_name, instance_data, pre_create_data):\n\n        existing_instance = None\n        for instance in self.create_context.instances:\n            if instance.product_type == self.product_type:\n                existing_instance = instance\n                break\n\n        if existing_instance:\n            raise CreatorError(\"A RenderSetup instance already exists - only \"\n                               \"one can be configured.\")\n\n        super(CreateRenderSetup, self).create(product_name,\n                                              instance_data,\n                                              pre_create_data)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_review.html","title":"create_review","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_review.html#client.ayon_maya.plugins.create.create_review.CreateReview","title":"<code>CreateReview</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Playblast reviewable</p> Source code in <code>client/ayon_maya/plugins/create/create_review.py</code> <pre><code>class CreateReview(plugin.MayaCreator):\n    \"\"\"Playblast reviewable\"\"\"\n\n    identifier = \"io.openpype.creators.maya.review\"\n    label = \"Review\"\n    product_type = \"review\"\n    icon = \"video-camera\"\n\n    useMayaTimeline = True\n    panZoom = False\n\n    def get_attr_defs_for_instance(self, instance):\n        create_context = self.create_context\n        defs = lib.collect_animation_defs(create_context=create_context)\n\n        # Option for using Maya or folder frame range in settings.\n        if not self.useMayaTimeline:\n            # Update the defaults to be the folder frame range\n            frame_range = lib.get_frame_range()\n            defs_by_key = {attr_def.key: attr_def for attr_def in defs}\n            for key, value in frame_range.items():\n                if key not in defs_by_key:\n                    raise RuntimeError(\"Attribute definition not found to be \"\n                                       \"updated for key: {}\".format(key))\n                attr_def = defs_by_key[key]\n                attr_def.default = value\n\n        product_name: str = instance.data[\"productName\"]\n        folder_path: str = instance.data[\"folderPath\"]\n        task_name: str = instance.data[\"task\"]\n        task_entity = create_context.get_task_entity(folder_path, task_name)\n        preset = lib.get_capture_preset(\n            task_name,\n            task_entity[\"taskType\"] if task_entity else None,\n            product_name,\n            create_context.get_current_project_settings(),\n            log=self.log\n        )\n\n        defs.extend([\n            NumberDef(\"review_width\",\n                      label=\"Review width\",\n                      tooltip=\"A value of zero will use the folder resolution.\",\n                      decimals=0,\n                      minimum=0,\n                      default=preset[\"Resolution\"][\"width\"]),\n            NumberDef(\"review_height\",\n                      label=\"Review height\",\n                      tooltip=\"A value of zero will use the folder resolution.\",\n                      decimals=0,\n                      minimum=0,\n                      default=preset[\"Resolution\"][\"height\"]),\n            BoolDef(\"keepImages\",\n                    label=\"Keep Images\",\n                    tooltip=\"Whether to also publish along the image sequence \"\n                            \"next to the video reviewable.\",\n                    default=False),\n            BoolDef(\"isolate\",\n                    label=\"Isolate render members of instance\",\n                    tooltip=\"When enabled only the members of the instance \"\n                            \"will be included in the playblast review.\",\n                    default=preset[\"Generic\"][\"isolate_view\"]),\n            BoolDef(\"imagePlane\",\n                    label=\"Show Image Plane\",\n                    default=preset[\"ViewportOptions\"][\"imagePlane\"]),\n            EnumDef(\"transparency\",\n                    label=\"Transparency\",\n                    items=TRANSPARENCIES),\n            BoolDef(\"panZoom\",\n                    label=\"Enable camera pan/zoom\",\n                    default=preset[\"Generic\"][\"pan_zoom\"]),\n            EnumDef(\"displayLights\",\n                    label=\"Display Lights\",\n                    items=lib.DISPLAY_LIGHTS_ENUM),\n        ])\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_rig.html","title":"create_rig","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_rig.html#client.ayon_maya.plugins.create.create_rig.CreateRig","title":"<code>CreateRig</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Artist-friendly rig with controls to direct motion</p> Source code in <code>client/ayon_maya/plugins/create/create_rig.py</code> <pre><code>class CreateRig(plugin.MayaCreator):\n    \"\"\"Artist-friendly rig with controls to direct motion\"\"\"\n\n    identifier = \"io.openpype.creators.maya.rig\"\n    label = \"Rig\"\n    product_type = \"rig\"\n    icon = \"wheelchair\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n\n        instance = super(CreateRig, self).create(product_name,\n                                                 instance_data,\n                                                 pre_create_data)\n\n        instance_node = instance.get(\"instance_node\")\n\n        self.log.info(\"Creating Rig instance set up ...\")\n        # TODO\uff1achange name (_controls_SET -&gt; _rigs_SET)\n        controls = cmds.sets(name=product_name + \"_controls_SET\", empty=True)\n        # TODO\uff1achange name (_out_SET -&gt; _geo_SET)\n        pointcache = cmds.sets(name=product_name + \"_out_SET\", empty=True)\n        skeleton = cmds.sets(\n            name=product_name + \"_skeletonAnim_SET\", empty=True)\n        skeleton_mesh = cmds.sets(\n            name=product_name + \"_skeletonMesh_SET\", empty=True)\n        cmds.sets([controls, pointcache,\n                   skeleton, skeleton_mesh], forceElement=instance_node)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_setdress.html","title":"create_setdress","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_setdress.html#client.ayon_maya.plugins.create.create_setdress.CreateSetDress","title":"<code>CreateSetDress</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>A grouped package of loaded content</p> Source code in <code>client/ayon_maya/plugins/create/create_setdress.py</code> <pre><code>class CreateSetDress(plugin.MayaCreator):\n    \"\"\"A grouped package of loaded content\"\"\"\n\n    identifier = \"io.openpype.creators.maya.setdress\"\n    label = \"Set Dress\"\n    product_type = \"setdress\"\n    icon = \"cubes\"\n    exactSetMembersOnly = True\n    shader = True\n    default_variants = [\"Main\", \"Anim\"]\n\n    def get_instance_attr_defs(self):\n        return [\n            BoolDef(\"exactSetMembersOnly\",\n                    label=\"Exact Set Members Only\",\n                    default=self.exactSetMembersOnly),\n            BoolDef(\"shader\",\n                    label=\"Include shader\",\n                    default=self.shader)\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_unreal_skeletalmesh.html","title":"create_unreal_skeletalmesh","text":"<p>Creator for Unreal Skeletal Meshes.</p>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_unreal_skeletalmesh.html#client.ayon_maya.plugins.create.create_unreal_skeletalmesh.CreateUnrealSkeletalMesh","title":"<code>CreateUnrealSkeletalMesh</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Unreal Static Meshes with collisions.</p> Source code in <code>client/ayon_maya/plugins/create/create_unreal_skeletalmesh.py</code> <pre><code>class CreateUnrealSkeletalMesh(plugin.MayaCreator):\n    \"\"\"Unreal Static Meshes with collisions.\"\"\"\n\n    identifier = \"io.openpype.creators.maya.unrealskeletalmesh\"\n    label = \"Unreal - Skeletal Mesh\"\n    product_type = \"skeletalMesh\"\n    icon = \"thumbs-up\"\n\n    # Defined in settings\n    joint_hints = set()\n\n    def get_dynamic_data(\n        self,\n        project_name,\n        folder_entity,\n        task_entity,\n        variant,\n        host_name,\n        instance\n    ):\n        \"\"\"\n        The default product name templates for Unreal include {asset} and thus\n        we should pass that along as dynamic data.\n        \"\"\"\n        dynamic_data = super(CreateUnrealSkeletalMesh, self).get_dynamic_data(\n            project_name,\n            folder_entity,\n            task_entity,\n            variant,\n            host_name,\n            instance\n        )\n\n        dynamic_data.update(\n            {\n                \"asset\": folder_entity[\"name\"],\n                \"folder\": {\n                            \"name\": folder_entity[\"name\"]\n                }\n            }\n        )\n\n        return dynamic_data\n\n    def create(self, product_name, instance_data, pre_create_data):\n\n        with lib.undo_chunk():\n            instance = super(CreateUnrealSkeletalMesh, self).create(\n                product_name, instance_data, pre_create_data)\n            instance_node = instance.get(\"instance_node\")\n\n            # We reorganize the geometry that was originally added into the\n            # set into either 'joints_SET' or 'geometry_SET' based on the\n            # joint_hints from project settings\n            members = cmds.sets(instance_node, query=True) or []\n            cmds.sets(clear=instance_node)\n\n            geometry_set = cmds.sets(name=\"geometry_SET\", empty=True)\n            joints_set = cmds.sets(name=\"joints_SET\", empty=True)\n\n            cmds.sets([geometry_set, joints_set], forceElement=instance_node)\n\n            for node in members:\n                if node in self.joint_hints:\n                    cmds.sets(node, forceElement=joints_set)\n                else:\n                    cmds.sets(node, forceElement=geometry_set)\n\n    def get_instance_attr_defs(self):\n\n        defs = lib.collect_animation_defs()\n\n        defs.extend([\n            BoolDef(\"renderableOnly\",\n                    label=\"Renderable Only\",\n                    tooltip=\"Only export renderable visible shapes\",\n                    default=False),\n            BoolDef(\"visibleOnly\",\n                    label=\"Visible Only\",\n                    tooltip=\"Only export dag objects visible during \"\n                            \"frame range\",\n                    default=False),\n            BoolDef(\"includeParentHierarchy\",\n                    label=\"Include Parent Hierarchy\",\n                    tooltip=\"Whether to include parent hierarchy of nodes in \"\n                            \"the publish instance\",\n                    default=False),\n            BoolDef(\"worldSpace\",\n                    label=\"World-Space Export\",\n                    default=True),\n            BoolDef(\"refresh\",\n                    label=\"Refresh viewport during export\",\n                    default=False),\n            TextDef(\"attr\",\n                    label=\"Custom Attributes\",\n                    default=\"\",\n                    placeholder=\"attr1, attr2\"),\n            TextDef(\"attrPrefix\",\n                    label=\"Custom Attributes Prefix\",\n                    placeholder=\"prefix1, prefix2\")\n        ])\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_unreal_skeletalmesh.html#client.ayon_maya.plugins.create.create_unreal_skeletalmesh.CreateUnrealSkeletalMesh.get_dynamic_data","title":"<code>get_dynamic_data(project_name, folder_entity, task_entity, variant, host_name, instance)</code>","text":"<p>The default product name templates for Unreal include {asset} and thus we should pass that along as dynamic data.</p> Source code in <code>client/ayon_maya/plugins/create/create_unreal_skeletalmesh.py</code> <pre><code>def get_dynamic_data(\n    self,\n    project_name,\n    folder_entity,\n    task_entity,\n    variant,\n    host_name,\n    instance\n):\n    \"\"\"\n    The default product name templates for Unreal include {asset} and thus\n    we should pass that along as dynamic data.\n    \"\"\"\n    dynamic_data = super(CreateUnrealSkeletalMesh, self).get_dynamic_data(\n        project_name,\n        folder_entity,\n        task_entity,\n        variant,\n        host_name,\n        instance\n    )\n\n    dynamic_data.update(\n        {\n            \"asset\": folder_entity[\"name\"],\n            \"folder\": {\n                        \"name\": folder_entity[\"name\"]\n            }\n        }\n    )\n\n    return dynamic_data\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_unreal_staticmesh.html","title":"create_unreal_staticmesh","text":"<p>Creator for Unreal Static Meshes.</p>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_unreal_staticmesh.html#client.ayon_maya.plugins.create.create_unreal_staticmesh.CreateUnrealStaticMesh","title":"<code>CreateUnrealStaticMesh</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Unreal Static Meshes with collisions.</p> Source code in <code>client/ayon_maya/plugins/create/create_unreal_staticmesh.py</code> <pre><code>class CreateUnrealStaticMesh(plugin.MayaCreator):\n    \"\"\"Unreal Static Meshes with collisions.\"\"\"\n\n    identifier = \"io.openpype.creators.maya.unrealstaticmesh\"\n    label = \"Unreal - Static Mesh\"\n    product_type = \"staticMesh\"\n    icon = \"cube\"\n\n    # Defined in settings\n    collision_prefixes = []\n\n    def get_dynamic_data(\n        self,\n        project_name,\n        folder_entity,\n        task_entity,\n        variant,\n        host_name,\n        instance\n    ):\n        \"\"\"\n        The default product name templates for Unreal include {asset} and thus\n        we should pass that along as dynamic data.\n        \"\"\"\n        dynamic_data = super(CreateUnrealStaticMesh, self).get_dynamic_data(\n            project_name,\n            folder_entity,\n            task_entity,\n            variant,\n            host_name,\n            instance\n        )\n\n        dynamic_data.update(\n            {\n                \"asset\": folder_entity[\"name\"],\n                \"folder\": {\n                            \"name\": folder_entity[\"name\"]\n                }\n            }\n        )\n\n        return dynamic_data\n\n    def create(self, product_name, instance_data, pre_create_data):\n\n        with lib.undo_chunk():\n            instance = super(CreateUnrealStaticMesh, self).create(\n                product_name, instance_data, pre_create_data)\n            instance_node = instance.get(\"instance_node\")\n\n            # We reorganize the geometry that was originally added into the\n            # set into either 'collision_SET' or 'geometry_SET' based on the\n            # collision_prefixes from project settings\n            members = cmds.sets(instance_node, query=True)\n            cmds.sets(clear=instance_node)\n\n            geometry_set = cmds.sets(name=\"geometry_SET\", empty=True)\n            collisions_set = cmds.sets(name=\"collisions_SET\", empty=True)\n\n            cmds.sets([geometry_set, collisions_set],\n                      forceElement=instance_node)\n\n            members = cmds.ls(members, long=True) or []\n            children = cmds.listRelatives(members, allDescendents=True,\n                                          fullPath=True) or []\n            transforms = cmds.ls(members + children, type=\"transform\")\n            for transform in transforms:\n\n                if not cmds.listRelatives(transform,\n                                          type=\"shape\",\n                                          noIntermediate=True):\n                    # Exclude all transforms that have no direct shapes\n                    continue\n\n                if self.has_collision_prefix(transform):\n                    cmds.sets(transform, forceElement=collisions_set)\n                else:\n                    cmds.sets(transform, forceElement=geometry_set)\n\n    def has_collision_prefix(self, node_path):\n        \"\"\"Return whether node name of path matches collision prefix.\n\n        If the node name matches the collision prefix we add it to the\n        `collisions_SET` instead of the `geometry_SET`.\n\n        Args:\n            node_path (str): Maya node path.\n\n        Returns:\n            bool: Whether the node should be considered a collision mesh.\n\n        \"\"\"\n        node_name = node_path.rsplit(\"|\", 1)[-1]\n        for prefix in self.collision_prefixes:\n            if node_name.startswith(prefix):\n                return True\n        return False\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_unreal_staticmesh.html#client.ayon_maya.plugins.create.create_unreal_staticmesh.CreateUnrealStaticMesh.get_dynamic_data","title":"<code>get_dynamic_data(project_name, folder_entity, task_entity, variant, host_name, instance)</code>","text":"<p>The default product name templates for Unreal include {asset} and thus we should pass that along as dynamic data.</p> Source code in <code>client/ayon_maya/plugins/create/create_unreal_staticmesh.py</code> <pre><code>def get_dynamic_data(\n    self,\n    project_name,\n    folder_entity,\n    task_entity,\n    variant,\n    host_name,\n    instance\n):\n    \"\"\"\n    The default product name templates for Unreal include {asset} and thus\n    we should pass that along as dynamic data.\n    \"\"\"\n    dynamic_data = super(CreateUnrealStaticMesh, self).get_dynamic_data(\n        project_name,\n        folder_entity,\n        task_entity,\n        variant,\n        host_name,\n        instance\n    )\n\n    dynamic_data.update(\n        {\n            \"asset\": folder_entity[\"name\"],\n            \"folder\": {\n                        \"name\": folder_entity[\"name\"]\n            }\n        }\n    )\n\n    return dynamic_data\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_unreal_staticmesh.html#client.ayon_maya.plugins.create.create_unreal_staticmesh.CreateUnrealStaticMesh.has_collision_prefix","title":"<code>has_collision_prefix(node_path)</code>","text":"<p>Return whether node name of path matches collision prefix.</p> <p>If the node name matches the collision prefix we add it to the <code>collisions_SET</code> instead of the <code>geometry_SET</code>.</p> <p>Parameters:</p> Name Type Description Default <code>node_path</code> <code>str</code> <p>Maya node path.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether the node should be considered a collision mesh.</p> Source code in <code>client/ayon_maya/plugins/create/create_unreal_staticmesh.py</code> <pre><code>def has_collision_prefix(self, node_path):\n    \"\"\"Return whether node name of path matches collision prefix.\n\n    If the node name matches the collision prefix we add it to the\n    `collisions_SET` instead of the `geometry_SET`.\n\n    Args:\n        node_path (str): Maya node path.\n\n    Returns:\n        bool: Whether the node should be considered a collision mesh.\n\n    \"\"\"\n    node_name = node_path.rsplit(\"|\", 1)[-1]\n    for prefix in self.collision_prefixes:\n        if node_name.startswith(prefix):\n            return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_unreal_yeticache.html","title":"create_unreal_yeticache","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_unreal_yeticache.html#client.ayon_maya.plugins.create.create_unreal_yeticache.CreateUnrealYetiCache","title":"<code>CreateUnrealYetiCache</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Output for procedural plugin nodes of Yeti</p> Source code in <code>client/ayon_maya/plugins/create/create_unreal_yeticache.py</code> <pre><code>class CreateUnrealYetiCache(plugin.MayaCreator):\n    \"\"\"Output for procedural plugin nodes of Yeti \"\"\"\n\n    identifier = \"io.openpype.creators.maya.unrealyeticache\"\n    label = \"Unreal - Yeti Cache\"\n    product_type = \"yeticacheUE\"\n    icon = \"pagelines\"\n\n    def get_instance_attr_defs(self):\n\n        defs = [\n            NumberDef(\"preroll\",\n                      label=\"Preroll\",\n                      minimum=0,\n                      default=0,\n                      decimals=0)\n        ]\n\n        # Add animation data without step and handles\n        defs.extend(lib.collect_animation_defs(\n            create_context=self.create_context))\n        remove = {\"step\", \"handleStart\", \"handleEnd\"}\n        defs = [attr_def for attr_def in defs if attr_def.key not in remove]\n\n        # Add samples after frame range\n        defs.append(\n            NumberDef(\"samples\",\n                      label=\"Samples\",\n                      default=3,\n                      decimals=0)\n        )\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_vrayproxy.html","title":"create_vrayproxy","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_vrayproxy.html#client.ayon_maya.plugins.create.create_vrayproxy.CreateVrayProxy","title":"<code>CreateVrayProxy</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Alembic pointcache for animated data</p> Source code in <code>client/ayon_maya/plugins/create/create_vrayproxy.py</code> <pre><code>class CreateVrayProxy(plugin.MayaCreator):\n    \"\"\"Alembic pointcache for animated data\"\"\"\n\n    identifier = \"io.openpype.creators.maya.vrayproxy\"\n    label = \"VRay Proxy\"\n    product_type = \"vrayproxy\"\n    icon = \"gears\"\n\n    vrmesh = True\n    alembic = True\n\n    def get_instance_attr_defs(self):\n\n        defs = [\n            BoolDef(\"farm\",\n                    label=\"Submit to Farm\",\n                    default=False),\n            BoolDef(\"animation\",\n                    label=\"Export Animation\",\n                    default=False)\n        ]\n\n        # Add time range attributes but remove some attributes\n        # which this instance actually doesn't use\n        defs.extend(lib.collect_animation_defs(\n            create_context=self.create_context))\n        remove = {\"handleStart\", \"handleEnd\", \"step\"}\n        defs = [attr_def for attr_def in defs if attr_def.key not in remove]\n\n        defs.extend([\n            BoolDef(\"vertexColors\",\n                    label=\"Write vertex colors\",\n                    tooltip=\"Write vertex colors with the geometry\",\n                    default=False),\n            BoolDef(\"vrmesh\",\n                    label=\"Export VRayMesh\",\n                    tooltip=\"Publish a .vrmesh (VRayMesh) file for \"\n                            \"this VRayProxy\",\n                    default=self.vrmesh),\n            BoolDef(\"alembic\",\n                    label=\"Export Alembic\",\n                    tooltip=\"Publish a .abc (Alembic) file for \"\n                            \"this VRayProxy\",\n                    default=self.alembic),\n        ])\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_vrayscene.html","title":"create_vrayscene","text":"<p>Create instance of vrayscene.</p>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_vrayscene.html#client.ayon_maya.plugins.create.create_vrayscene.CreateVRayScene","title":"<code>CreateVRayScene</code>","text":"<p>               Bases: <code>RenderlayerCreator</code></p> <p>Create Vray Scene.</p> Source code in <code>client/ayon_maya/plugins/create/create_vrayscene.py</code> <pre><code>class CreateVRayScene(plugin.RenderlayerCreator):\n    \"\"\"Create Vray Scene.\"\"\"\n\n    identifier = \"io.openpype.creators.maya.vrayscene\"\n\n    product_type = \"vrayscene\"\n    label = \"VRay Scene\"\n    icon = \"cubes\"\n\n    render_settings = {}\n    singleton_node_name = \"vraysceneMain\"\n\n    def apply_settings(self, project_settings):\n        super().apply_settings(project_settings)\n        self.render_settings = project_settings[\"maya\"][\"render_settings\"]\n\n    def create(self, product_name, instance_data, pre_create_data):\n        # Only allow a single render instance to exist\n        if self._get_singleton_node():\n            raise CreatorError(\"A Render instance already exists - only \"\n                               \"one can be configured.\")\n\n        super(CreateVRayScene, self).create(product_name,\n                                            instance_data,\n                                            pre_create_data)\n\n        # Apply default project render settings on create\n        if self.render_settings.get(\"apply_render_settings\"):\n            lib_rendersettings.RenderSettings().set_default_renderer_settings()\n\n    def get_instance_attr_defs(self):\n        \"\"\"Create instance settings.\"\"\"\n\n        return [\n            BoolDef(\"vraySceneMultipleFiles\",\n                    label=\"V-Ray Scene Multiple Files\",\n                    default=False),\n            BoolDef(\"exportOnFarm\",\n                    label=\"Export on farm\",\n                    default=False)\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_vrayscene.html#client.ayon_maya.plugins.create.create_vrayscene.CreateVRayScene.get_instance_attr_defs","title":"<code>get_instance_attr_defs()</code>","text":"<p>Create instance settings.</p> Source code in <code>client/ayon_maya/plugins/create/create_vrayscene.py</code> <pre><code>def get_instance_attr_defs(self):\n    \"\"\"Create instance settings.\"\"\"\n\n    return [\n        BoolDef(\"vraySceneMultipleFiles\",\n                label=\"V-Ray Scene Multiple Files\",\n                default=False),\n        BoolDef(\"exportOnFarm\",\n                label=\"Export on farm\",\n                default=False)\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_workfile.html","title":"create_workfile","text":"<p>Creator plugin for creating workfiles.</p>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_workfile.html#client.ayon_maya.plugins.create.create_workfile.CreateWorkfile","title":"<code>CreateWorkfile</code>","text":"<p>               Bases: <code>MayaCreatorBase</code>, <code>AutoCreator</code></p> <p>Workfile auto-creator.</p> Source code in <code>client/ayon_maya/plugins/create/create_workfile.py</code> <pre><code>class CreateWorkfile(plugin.MayaCreatorBase, AutoCreator):\n    \"\"\"Workfile auto-creator.\"\"\"\n    identifier = \"io.openpype.creators.maya.workfile\"\n    label = \"Workfile\"\n    product_type = \"workfile\"\n    icon = \"fa5.file\"\n\n    default_variant = \"Main\"\n\n    settings_category = \"maya\"\n    is_mandatory = False\n\n    def create(self):\n\n        variant = self.default_variant\n        current_instance = next(\n            (\n                instance for instance in self.create_context.instances\n                if instance.creator_identifier == self.identifier\n            ), None)\n\n        project_entity = self.create_context.get_current_project_entity()\n        project_name = project_entity[\"name\"]\n        folder_entity = self.create_context.get_current_folder_entity()\n        folder_path = folder_entity[\"path\"]\n        task_entity = self.create_context.get_current_task_entity()\n        task_name = task_entity[\"name\"]\n        host_name = self.create_context.host_name\n\n        if current_instance is None:\n            product_name = self.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                variant,\n                host_name,\n            )\n            data = {\n                \"folderPath\": folder_path,\n                \"task\": task_name,\n                \"variant\": variant\n            }\n            data.update(\n                self.get_dynamic_data(\n                    project_name,\n                    folder_entity,\n                    task_entity,\n                    variant,\n                    host_name,\n                    current_instance)\n            )\n            self.log.info(\"Auto-creating workfile instance...\")\n            current_instance = CreatedInstance(\n                self.product_type, product_name, data, self\n            )\n            self._add_instance_to_context(current_instance)\n        elif (\n            current_instance[\"folderPath\"] != folder_path\n            or current_instance[\"task\"] != task_name\n        ):\n            # Update instance context if is not the same\n            product_name = self.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                variant,\n                host_name,\n            )\n\n            current_instance[\"folderPath\"] = folder_path\n            current_instance[\"task\"] = task_name\n            current_instance[\"productName\"] = product_name\n\n        # The 'mandatory' functionality is available since ayon-core 1.4.1\n        #   or later.\n        if hasattr(current_instance, \"set_mandatory\"):\n            current_instance.set_mandatory(self.is_mandatory)\n\n    def collect_instances(self):\n        self.cache_instance_data(self.collection_shared_data)\n        cached_instances = (\n            self.collection_shared_data[\"maya_cached_instance_data\"]\n        )\n        for node in cached_instances.get(self.identifier, []):\n            node_data = self.read_instance_node(node)\n\n            created_instance = CreatedInstance.from_existing(node_data, self)\n            self._add_instance_to_context(created_instance)\n\n    def remove_instances(self, instances):\n        self._default_remove_instances(instances)\n\n    def update_instances(self, update_list):\n        for created_inst, _changes in update_list:\n            data = created_inst.data_to_store()\n            node = data.get(\"instance_node\")\n            if not node:\n                node = self.create_node()\n                created_inst[\"instance_node\"] = node\n                data = created_inst.data_to_store()\n\n            self.imprint_instance_node(node, data)\n\n    def create_node(self):\n        node = cmds.sets(empty=True, name=\"workfileMain\")\n        cmds.setAttr(node + \".hiddenInOutliner\", True)\n        return node\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_xgen.html","title":"create_xgen","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_xgen.html#client.ayon_maya.plugins.create.create_xgen.CreateXgen","title":"<code>CreateXgen</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Xgen</p> Source code in <code>client/ayon_maya/plugins/create/create_xgen.py</code> <pre><code>class CreateXgen(plugin.MayaCreator):\n    \"\"\"Xgen\"\"\"\n\n    identifier = \"io.openpype.creators.maya.xgen\"\n    label = \"Xgen\"\n    product_type = \"xgen\"\n    icon = \"pagelines\"\n\n    def get_instance_attr_defs(self):\n        return [\n            BoolDef(\"farm\",\n                    label=\"Submit to Farm\",\n                    default=False),\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_yeti_cache.html","title":"create_yeti_cache","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_yeti_cache.html#client.ayon_maya.plugins.create.create_yeti_cache.CreateYetiCache","title":"<code>CreateYetiCache</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Output for procedural plugin nodes of Yeti</p> Source code in <code>client/ayon_maya/plugins/create/create_yeti_cache.py</code> <pre><code>class CreateYetiCache(plugin.MayaCreator):\n    \"\"\"Output for procedural plugin nodes of Yeti \"\"\"\n\n    identifier = \"io.openpype.creators.maya.yeticache\"\n    label = \"Yeti Cache\"\n    product_type = \"yeticache\"\n    icon = \"pagelines\"\n\n    def get_instance_attr_defs(self):\n\n        defs = [\n            BoolDef(\"farm\",\n                    label=\"Submit to Farm\",\n                    default=False),\n            NumberDef(\"preroll\",\n                      label=\"Preroll\",\n                      minimum=0,\n                      default=0,\n                      decimals=0)\n        ]\n\n        # Add animation data without step and handles\n        defs.extend(lib.collect_animation_defs(\n            create_context=self.create_context))\n        remove = {\"step\", \"handleStart\", \"handleEnd\"}\n        defs = [attr_def for attr_def in defs if attr_def.key not in remove]\n\n        # Add samples after frame range\n        defs.append(\n            NumberDef(\"samples\",\n                      label=\"Samples\",\n                      default=3,\n                      decimals=0)\n        )\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/create/create_yeti_rig.html","title":"create_yeti_rig","text":""},{"location":"autoapi/client/ayon_maya/plugins/create/create_yeti_rig.html#client.ayon_maya.plugins.create.create_yeti_rig.CreateYetiRig","title":"<code>CreateYetiRig</code>","text":"<p>               Bases: <code>MayaCreator</code></p> <p>Output for procedural plugin nodes ( Yeti / XGen / etc)</p> Source code in <code>client/ayon_maya/plugins/create/create_yeti_rig.py</code> <pre><code>class CreateYetiRig(plugin.MayaCreator):\n    \"\"\"Output for procedural plugin nodes ( Yeti / XGen / etc)\"\"\"\n\n    identifier = \"io.openpype.creators.maya.yetirig\"\n    label = \"Yeti Rig\"\n    product_type = \"yetiRig\"\n    icon = \"usb\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n\n        with lib.undo_chunk():\n            instance = super(CreateYetiRig, self).create(product_name,\n                                                         instance_data,\n                                                         pre_create_data)\n            instance_node = instance.get(\"instance_node\")\n\n            self.log.info(\"Creating Rig instance set up ...\")\n            input_meshes = cmds.sets(name=\"input_SET\", empty=True)\n            cmds.sets(input_meshes, forceElement=instance_node)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/inventory/index.html","title":"inventory","text":""},{"location":"autoapi/client/ayon_maya/plugins/inventory/connect_geometry.html","title":"connect_geometry","text":""},{"location":"autoapi/client/ayon_maya/plugins/inventory/connect_geometry.html#client.ayon_maya.plugins.inventory.connect_geometry.ConnectGeometry","title":"<code>ConnectGeometry</code>","text":"<p>               Bases: <code>InventoryAction</code></p> <p>Connect geometries within containers.</p> <p>Source container will connect to the target containers, by searching for matching geometry IDs (cbid). Source containers are of product type: \"animation\" and \"pointcache\". The connection with be done with a live world space blendshape.</p> Source code in <code>client/ayon_maya/plugins/inventory/connect_geometry.py</code> <pre><code>class ConnectGeometry(InventoryAction):\n    \"\"\"Connect geometries within containers.\n\n    Source container will connect to the target containers, by searching for\n    matching geometry IDs (cbid).\n    Source containers are of product type: \"animation\" and \"pointcache\".\n    The connection with be done with a live world space blendshape.\n    \"\"\"\n\n    label = \"Connect Geometry\"\n    icon = \"link\"\n    color = \"white\"\n\n    def process(self, containers):\n        # Validate selection is more than 1.\n        message = (\n            \"Only 1 container selected. 2+ containers needed for this action.\"\n        )\n        if len(containers) == 1:\n            self.display_warning(message)\n            return\n\n        # Categorize containers by family.\n        containers_by_product_type = {}\n        repre_ids = {\n            container[\"representation\"]\n            for container in containers\n        }\n        repre_contexts_by_id = get_repres_contexts(repre_ids)\n        for container in containers:\n            repre_id = container[\"representation\"]\n            repre_context = repre_contexts_by_id[repre_id]\n\n            product_type = repre_context[\"product\"][\"productType\"]\n\n            containers_by_product_type.setdefault(product_type, [])\n            containers_by_product_type[product_type].append(container)\n\n        # Validate to only 1 source container.\n        source_containers = containers_by_product_type.get(\"animation\", [])\n        source_containers += containers_by_product_type.get(\"pointcache\", [])\n        source_container_namespaces = [\n            x[\"namespace\"] for x in source_containers\n        ]\n        message = (\n            \"{} animation containers selected:\\n\\n{}\\n\\nOnly select 1 of type \"\n            \"\\\"animation\\\" or \\\"pointcache\\\".\".format(\n                len(source_containers), source_container_namespaces\n            )\n        )\n        if len(source_containers) != 1:\n            self.display_warning(message)\n            return\n\n        source_object = source_containers[0][\"objectName\"]\n\n        # Collect matching geometry transforms based cbId attribute.\n        target_containers = []\n        for product_type, containers in containers_by_product_type.items():\n            if product_type in [\"animation\", \"pointcache\"]:\n                continue\n\n            target_containers.extend(containers)\n\n        source_data = self.get_container_data(source_object)\n        matches = []\n        node_types = set()\n        for target_container in target_containers:\n            target_data = self.get_container_data(\n                target_container[\"objectName\"]\n            )\n            node_types.update(target_data[\"node_types\"])\n            for id, transform in target_data[\"ids\"].items():\n                source_match = source_data[\"ids\"].get(id)\n                if source_match:\n                    matches.append([source_match, transform])\n\n        # Message user about what is about to happen.\n        if not matches:\n            self.display_warning(\"No matching geometries found.\")\n            return\n\n        message = \"Connecting geometries:\\n\\n\"\n        for match in matches:\n            message += \"{} &gt; {}\\n\".format(match[0], match[1])\n\n        choice = self.display_warning(message, show_cancel=True)\n        if choice is False:\n            return\n\n        # Setup live worldspace blendshape connection.\n        for source, target in matches:\n            self.connect_geometry(source, target)\n\n        # Update Xgen if in any of the containers.\n        if \"xgmPalette\" in node_types:\n            cmds.xgmPreview()\n\n    def connect_geometry(self, source: str, target: str):\n        # Get the target mesh shape before applying the blendshape,\n        # because we may need to validate the ID on the output mesh of\n        # the blendshape.\n        if cmds.objectType(target, isAType=\"deformableShape\"):\n            target_shapes = [target]\n        else:\n            target_shapes = cmds.listRelatives(\n                target,\n                type=\"deformableShape\",\n                fullPath=True,\n                noIntermediate=True,\n            ) or []\n\n        # Add blendshape\n        blendshape = cmds.blendShape(source, target)[0]\n        cmds.setAttr(blendshape + \".origin\", 0)\n        cmds.setAttr(blendshape + \".\" + target.split(\":\")[-1], 1)\n\n        if not target_shapes:\n            self.log.warning(\n                \"No shape found for target: {}\".format(target)\n            )\n            return\n        target_shape = target_shapes[0]\n\n        # If the target was a referenced mesh then it may have generated\n        # a new \"DeformedShape\" node which may be lacking any custom\n        # attributes the original mesh had, like e.g. `cbId`. We will\n        # want to make sure to preserve those attributes so look\n        # assignments can still work.\n        if not cmds.referenceQuery(target_shape, isNodeReferenced=True):\n            return\n\n        # Target mesh has no ID to maintain, so we can skip this.\n        if not get_id(target_shape):\n            return\n\n        output = cmds.listConnections(\n            f\"{blendshape}.outputGeometry[0]\",\n            source=False,\n            destination=True,\n            shapes=True\n        )[0]\n        if output != target_shape and not get_id(output):\n            self.log.info(\n                \"Transferring ID from target shape to new output shape: \"\n                f\"{target_shape} -&gt; {output}\"\n            )\n            set_id(output, get_id(target_shape))\n\n    def get_container_data(self, container):\n        \"\"\"Collects data about the container nodes.\n\n        Args:\n            container (dict): Container instance.\n\n        Returns:\n            data (dict):\n                \"node_types\": All node types in container nodes.\n                \"ids\": If the node is a mesh, we collect its parent transform\n                    id.\n        \"\"\"\n        data = {\"node_types\": set(), \"ids\": {}}\n        for node in get_container_members(container):\n            node_type = cmds.nodeType(node)\n            data[\"node_types\"].add(node_type)\n\n            # Only interested in mesh transforms for connecting geometry with\n            # blendshape.\n            if node_type != \"mesh\":\n                continue\n\n            transform = cmds.listRelatives(node, parent=True, fullPath=True)[0]\n            data[\"ids\"][get_id(transform)] = transform\n\n        return data\n\n    def display_warning(self, message, show_cancel=False):\n        \"\"\"Show feedback to user.\n\n        Returns:\n            bool\n        \"\"\"\n\n        from qtpy import QtWidgets\n\n        accept = QtWidgets.QMessageBox.Ok\n        if show_cancel:\n            buttons = accept | QtWidgets.QMessageBox.Cancel\n        else:\n            buttons = accept\n\n        state = QtWidgets.QMessageBox.warning(\n            None,\n            \"\",\n            message,\n            buttons=buttons,\n            defaultButton=accept\n        )\n\n        return state == accept\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/inventory/connect_geometry.html#client.ayon_maya.plugins.inventory.connect_geometry.ConnectGeometry.display_warning","title":"<code>display_warning(message, show_cancel=False)</code>","text":"<p>Show feedback to user.</p> <p>Returns:</p> Type Description <p>bool</p> Source code in <code>client/ayon_maya/plugins/inventory/connect_geometry.py</code> <pre><code>def display_warning(self, message, show_cancel=False):\n    \"\"\"Show feedback to user.\n\n    Returns:\n        bool\n    \"\"\"\n\n    from qtpy import QtWidgets\n\n    accept = QtWidgets.QMessageBox.Ok\n    if show_cancel:\n        buttons = accept | QtWidgets.QMessageBox.Cancel\n    else:\n        buttons = accept\n\n    state = QtWidgets.QMessageBox.warning(\n        None,\n        \"\",\n        message,\n        buttons=buttons,\n        defaultButton=accept\n    )\n\n    return state == accept\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/inventory/connect_geometry.html#client.ayon_maya.plugins.inventory.connect_geometry.ConnectGeometry.get_container_data","title":"<code>get_container_data(container)</code>","text":"<p>Collects data about the container nodes.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>dict</code> <p>Container instance.</p> required <p>Returns:</p> Name Type Description <code>data</code> <code>dict</code> <p>\"node_types\": All node types in container nodes. \"ids\": If the node is a mesh, we collect its parent transform     id.</p> Source code in <code>client/ayon_maya/plugins/inventory/connect_geometry.py</code> <pre><code>def get_container_data(self, container):\n    \"\"\"Collects data about the container nodes.\n\n    Args:\n        container (dict): Container instance.\n\n    Returns:\n        data (dict):\n            \"node_types\": All node types in container nodes.\n            \"ids\": If the node is a mesh, we collect its parent transform\n                id.\n    \"\"\"\n    data = {\"node_types\": set(), \"ids\": {}}\n    for node in get_container_members(container):\n        node_type = cmds.nodeType(node)\n        data[\"node_types\"].add(node_type)\n\n        # Only interested in mesh transforms for connecting geometry with\n        # blendshape.\n        if node_type != \"mesh\":\n            continue\n\n        transform = cmds.listRelatives(node, parent=True, fullPath=True)[0]\n        data[\"ids\"][get_id(transform)] = transform\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/inventory/connect_ornatrix_rig.html","title":"connect_ornatrix_rig","text":""},{"location":"autoapi/client/ayon_maya/plugins/inventory/connect_ornatrix_rig.html#client.ayon_maya.plugins.inventory.connect_ornatrix_rig.ConnectOrnatrixRig","title":"<code>ConnectOrnatrixRig</code>","text":"<p>               Bases: <code>InventoryAction</code></p> <p>Connect Ornatrix Rig with an animation or pointcache.</p> <p>Connect one animation or pointcache instance to one or multiple ornatrix rig instances.</p> Source code in <code>client/ayon_maya/plugins/inventory/connect_ornatrix_rig.py</code> <pre><code>class ConnectOrnatrixRig(InventoryAction):\n    \"\"\"Connect Ornatrix Rig with an animation or pointcache.\n\n    Connect one animation or pointcache instance to one or multiple ornatrix\n    rig instances.\n    \"\"\"\n\n    label = \"Connect Ornatrix Rig\"\n    icon = \"link\"\n    color = \"white\"\n\n    def process(self, containers):\n        # Categorize containers by product type.\n        containers_by_product_type = defaultdict(list)\n        repre_ids = {\n            container[\"representation\"]\n            for container in containers\n        }\n        repre_contexts_by_id = get_repres_contexts(repre_ids)\n        for container in containers:\n            repre_id = container[\"representation\"]\n            repre_context = repre_contexts_by_id[repre_id]\n\n            product_type = repre_context[\"product\"][\"productType\"]\n            containers_by_product_type[product_type].append(container)\n\n        # Validate to only 1 source container.\n        source_containers = containers_by_product_type.get(\"animation\", [])\n        source_containers += containers_by_product_type.get(\"pointcache\", [])\n        source_container_namespaces = [\n            x[\"namespace\"] for x in source_containers\n        ]\n        message = (\n            \"{} animation containers selected:\\n\\n{}\\n\\nOnly select 1 of type \"\n            \"\\\"animation\\\" or \\\"pointcache\\\".\".format(\n                len(source_containers), source_container_namespaces\n            )\n        )\n        if len(source_containers) != 1:\n            self.display_warning(message)\n            return\n\n        source_container = source_containers[0]\n        source_repre_id = source_container[\"representation\"]\n        source_namespace = source_container[\"namespace\"]\n        source_project = source_container.get(\n            \"project_name\", get_current_project_name()\n        )\n\n        # Validate source representation is an alembic.\n        source_path = get_representation_path_by_project(\n            source_project,\n            repre_contexts_by_id[source_repre_id][\"representation\"]\n        ).replace(\"\\\\\", \"/\")\n        message = \"Animation container \\\"{}\\\" is not an alembic:\\n{}\".format(\n            source_container[\"namespace\"], source_path\n        )\n        if not source_path.endswith(\".abc\"):\n            self.display_warning(message)\n            return\n\n        ox_rig_containers = containers_by_product_type.get(\"oxrig\")\n        if not ox_rig_containers:\n            self.display_warning(\n                \"Select at least one oxrig container\"\n            )\n            return\n\n        # Define a mapping to quickly search among the members\n        source_nodes = get_container_members(source_container)\n        source_nodes_by_name = {\n            get_node_name(node_path): node_path\n            for node_path in source_nodes\n        }\n\n        project_name = get_current_project_name()\n        for container in ox_rig_containers:\n            # Get relevant ornatrix rig .rigsettings representation path\n            repre_id = container[\"representation\"]\n            settings_repre = get_sibling_representation(\n                project_name,\n                repre_id,\n                representation_name=\"rigsettings\")\n            if not settings_repre:\n                continue\n            settings_file = get_representation_path_by_project(\n                project_name, settings_repre\n            )\n            if not os.path.exists(settings_file):\n                continue\n\n            with open(settings_file, \"r\") as fp:\n                rig_source_nodes: List[Dict[str, Any]] = json.load(fp)\n            if not rig_source_nodes:\n                self.log.warning(\n                    f\"No source nodes in the .rigsettings file \"\n                    f\"to process: {settings_file}\")\n                continue\n\n            rig_nodes = get_container_members(container)\n\n            # Find the node in the source\n            for node in rig_source_nodes:\n                node_name = get_node_name(node[\"node\"])\n\n                # Find the source node we want to connect to the target rig\n                source_node = source_nodes_by_name.get(node_name)\n                if not source_node:\n                    self.log.warning(\n                        \"No source node found for '%s' searching in \"\n                        \"namespace: %s\", node_name, source_namespace)\n                    self.display_warning(\n                        \"No source node found \"\n                        \"in \\\"animation\\\" or \\\"pointcache\\\".\"\n                    )\n                    return\n\n                # Find matching target node\n                for target_node in rig_nodes:\n                    if get_node_name(target_node) != node_name:\n                        continue\n\n                    # Connect source mesh to target mesh\n                    self.log.info(\"Connecting mesh %s -&gt; %s\",\n                                  source_node, target_node)\n                    connect_mesh(source_node, target_node)\n\n    def display_warning(self, message, show_cancel=False):\n        \"\"\"Show feedback to user.\n\n        Returns:\n            bool\n        \"\"\"\n\n        from qtpy import QtWidgets\n\n        accept = QtWidgets.QMessageBox.Ok\n        if show_cancel:\n            buttons = accept | QtWidgets.QMessageBox.Cancel\n        else:\n            buttons = accept\n\n        state = QtWidgets.QMessageBox.warning(\n            None,\n            \"\",\n            message,\n            buttons=buttons,\n            defaultButton=accept\n        )\n\n        return state == accept\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/inventory/connect_ornatrix_rig.html#client.ayon_maya.plugins.inventory.connect_ornatrix_rig.ConnectOrnatrixRig.display_warning","title":"<code>display_warning(message, show_cancel=False)</code>","text":"<p>Show feedback to user.</p> <p>Returns:</p> Type Description <p>bool</p> Source code in <code>client/ayon_maya/plugins/inventory/connect_ornatrix_rig.py</code> <pre><code>def display_warning(self, message, show_cancel=False):\n    \"\"\"Show feedback to user.\n\n    Returns:\n        bool\n    \"\"\"\n\n    from qtpy import QtWidgets\n\n    accept = QtWidgets.QMessageBox.Ok\n    if show_cancel:\n        buttons = accept | QtWidgets.QMessageBox.Cancel\n    else:\n        buttons = accept\n\n    state = QtWidgets.QMessageBox.warning(\n        None,\n        \"\",\n        message,\n        buttons=buttons,\n        defaultButton=accept\n    )\n\n    return state == accept\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/inventory/connect_ornatrix_rig.html#client.ayon_maya.plugins.inventory.connect_ornatrix_rig.connect","title":"<code>connect(src, dest)</code>","text":"<p>Connect attribute but ignore warnings on existing connections</p> Source code in <code>client/ayon_maya/plugins/inventory/connect_ornatrix_rig.py</code> <pre><code>def connect(src, dest):\n    \"\"\"Connect attribute but ignore warnings on existing connections\"\"\"\n    if not cmds.isConnected(src, dest):\n        cmds.connectAttr(src, dest, force=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/inventory/connect_ornatrix_rig.html#client.ayon_maya.plugins.inventory.connect_ornatrix_rig.get_sibling_representation","title":"<code>get_sibling_representation(project_name, representation_id, representation_name)</code>","text":"<p>Return sibling representation entity under parent version from representation id.</p> Source code in <code>client/ayon_maya/plugins/inventory/connect_ornatrix_rig.py</code> <pre><code>def get_sibling_representation(project_name: str,\n                               representation_id: str,\n                               representation_name: str) -&gt; Optional[dict]:\n    \"\"\"Return sibling representation entity under parent version from\n    representation id.\"\"\"\n    repre_entity = get_representation_by_id(project_name, representation_id,\n                                            fields={\"versionId\"})\n    version_id = repre_entity[\"versionId\"]\n    return get_representation_by_name(\n        project_name, representation_name, version_id=version_id)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/inventory/connect_xgen.html","title":"connect_xgen","text":""},{"location":"autoapi/client/ayon_maya/plugins/inventory/connect_xgen.html#client.ayon_maya.plugins.inventory.connect_xgen.ConnectXgen","title":"<code>ConnectXgen</code>","text":"<p>               Bases: <code>InventoryAction</code></p> <p>Connect Xgen with an animation or pointcache.</p> Source code in <code>client/ayon_maya/plugins/inventory/connect_xgen.py</code> <pre><code>class ConnectXgen(InventoryAction):\n    \"\"\"Connect Xgen with an animation or pointcache.\n    \"\"\"\n\n    label = \"Connect Xgen\"\n    icon = \"link\"\n    color = \"white\"\n\n    def process(self, containers):\n        # Validate selection is more than 1.\n        message = (\n            \"Only 1 container selected. 2+ containers needed for this action.\"\n        )\n        if len(containers) == 1:\n            self.display_warning(message)\n            return\n\n        # Categorize containers by product type.\n        containers_by_product_type = {}\n        repre_ids = {\n            container[\"representation\"]\n            for container in containers\n        }\n        repre_contexts_by_id = get_repres_contexts(repre_ids)\n        for container in containers:\n            repre_id = container[\"representation\"]\n            repre_context = repre_contexts_by_id[repre_id]\n\n            product_type = repre_context[\"product\"][\"productType\"]\n\n            containers_by_product_type.setdefault(product_type, [])\n            containers_by_product_type[product_type].append(container)\n\n        # Validate to only 1 source container.\n        source_containers = containers_by_product_type.get(\"animation\", [])\n        source_containers += containers_by_product_type.get(\"pointcache\", [])\n        source_container_namespaces = [\n            x[\"namespace\"] for x in source_containers\n        ]\n        message = (\n            \"{} animation containers selected:\\n\\n{}\\n\\nOnly select 1 of type \"\n            \"\\\"animation\\\" or \\\"pointcache\\\".\".format(\n                len(source_containers), source_container_namespaces\n            )\n        )\n        if len(source_containers) != 1:\n            self.display_warning(message)\n            return\n\n        source_container = source_containers[0]\n        source_repre_id = source_container[\"representation\"]\n        source_object = source_container[\"objectName\"]\n        source_project = source_container.get(\n            \"project_name\", get_current_project_name()\n        )\n\n        # Validate source representation is an alembic.\n        source_path = get_representation_path_by_project(\n            source_project,\n            repre_contexts_by_id[source_repre_id][\"representation\"]\n        ).replace(\"\\\\\", \"/\")\n        message = \"Animation container \\\"{}\\\" is not an alembic:\\n{}\".format(\n            source_container[\"namespace\"], source_path\n        )\n        if not source_path.endswith(\".abc\"):\n            self.display_warning(message)\n            return\n\n        # Target containers.\n        target_containers = []\n        for product_type, containers in containers_by_product_type.items():\n            if product_type in [\"animation\", \"pointcache\"]:\n                continue\n\n            target_containers.extend(containers)\n\n        # Inform user of connections from source representation to target\n        # descriptions.\n        descriptions_data = []\n        connections_msg = \"\"\n        for target_container in target_containers:\n            reference_node = cmds.sets(\n                target_container[\"objectName\"], query=True\n            )[0]\n            palettes = cmds.ls(\n                cmds.referenceQuery(reference_node, nodes=True),\n                type=\"xgmPalette\"\n            )\n            for palette in palettes:\n                for description in xgenm.descriptions(palette):\n                    descriptions_data.append([palette, description])\n                    connections_msg += \"\\n{}/{}\".format(palette, description)\n\n        message = \"Connecting \\\"{}\\\" to:\\n\".format(\n            source_container[\"namespace\"]\n        )\n        message += connections_msg\n        choice = self.display_warning(message, show_cancel=True)\n        if choice is False:\n            return\n\n        # Recreate \"xgenContainers\" attribute to reset.\n        compound_name = \"xgenContainers\"\n        attr = \"{}.{}\".format(source_object, compound_name)\n        if cmds.objExists(attr):\n            cmds.deleteAttr(attr)\n\n        cmds.addAttr(\n            source_object,\n            longName=compound_name,\n            attributeType=\"compound\",\n            numberOfChildren=1,\n            multi=True\n        )\n\n        # Connect target containers.\n        for target_container in target_containers:\n            cmds.addAttr(\n                source_object,\n                longName=\"container\",\n                attributeType=\"message\",\n                parent=compound_name\n            )\n            index = target_containers.index(target_container)\n            cmds.connectAttr(\n                target_container[\"objectName\"] + \".message\",\n                source_object + \".{}[{}].container\".format(\n                    compound_name, index\n                )\n            )\n\n        # Setup cache on Xgen\n        object = \"SplinePrimitive\"\n        for palette, description in descriptions_data:\n            xgenm.setAttr(\"useCache\", \"true\", palette, description, object)\n            xgenm.setAttr(\"liveMode\", \"false\", palette, description, object)\n            xgenm.setAttr(\n                \"cacheFileName\", source_path, palette, description, object\n            )\n\n        # Refresh UI and viewport.\n        de = xgenm.xgGlobal.DescriptionEditor\n        de.refresh(\"Full\")\n\n    def display_warning(self, message, show_cancel=False):\n        \"\"\"Show feedback to user.\n\n        Returns:\n            bool\n        \"\"\"\n\n        from qtpy import QtWidgets\n\n        accept = QtWidgets.QMessageBox.Ok\n        if show_cancel:\n            buttons = accept | QtWidgets.QMessageBox.Cancel\n        else:\n            buttons = accept\n\n        state = QtWidgets.QMessageBox.warning(\n            None,\n            \"\",\n            message,\n            buttons=buttons,\n            defaultButton=accept\n        )\n\n        return state == accept\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/inventory/connect_xgen.html#client.ayon_maya.plugins.inventory.connect_xgen.ConnectXgen.display_warning","title":"<code>display_warning(message, show_cancel=False)</code>","text":"<p>Show feedback to user.</p> <p>Returns:</p> Type Description <p>bool</p> Source code in <code>client/ayon_maya/plugins/inventory/connect_xgen.py</code> <pre><code>def display_warning(self, message, show_cancel=False):\n    \"\"\"Show feedback to user.\n\n    Returns:\n        bool\n    \"\"\"\n\n    from qtpy import QtWidgets\n\n    accept = QtWidgets.QMessageBox.Ok\n    if show_cancel:\n        buttons = accept | QtWidgets.QMessageBox.Cancel\n    else:\n        buttons = accept\n\n    state = QtWidgets.QMessageBox.warning(\n        None,\n        \"\",\n        message,\n        buttons=buttons,\n        defaultButton=accept\n    )\n\n    return state == accept\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/inventory/connect_yeti_rig.html","title":"connect_yeti_rig","text":""},{"location":"autoapi/client/ayon_maya/plugins/inventory/connect_yeti_rig.html#client.ayon_maya.plugins.inventory.connect_yeti_rig.ConnectYetiRig","title":"<code>ConnectYetiRig</code>","text":"<p>               Bases: <code>InventoryAction</code></p> <p>Connect Yeti Rig with an animation or pointcache.</p> Source code in <code>client/ayon_maya/plugins/inventory/connect_yeti_rig.py</code> <pre><code>class ConnectYetiRig(InventoryAction):\n    \"\"\"Connect Yeti Rig with an animation or pointcache.\"\"\"\n\n    label = \"Connect Yeti Rig\"\n    icon = \"link\"\n    color = \"white\"\n\n    def process(self, containers):\n        # Validate selection is more than 1.\n        message = (\n            \"Only 1 container selected. 2+ containers needed for this action.\"\n        )\n        if len(containers) == 1:\n            self.display_warning(message)\n            return\n\n        # Categorize containers by product type.\n        containers_by_product_type = defaultdict(list)\n        repre_ids = {\n            container[\"representation\"]\n            for container in containers\n        }\n        repre_contexts_by_id = get_repres_contexts(repre_ids)\n        for container in containers:\n            repre_id = container[\"representation\"]\n            repre_context = repre_contexts_by_id[repre_id]\n\n            product_type = repre_context[\"product\"][\"productType\"]\n\n            containers_by_product_type.setdefault(product_type, [])\n            containers_by_product_type[product_type].append(container)\n\n        # Validate to only 1 source container.\n        source_containers = containers_by_product_type.get(\"animation\", [])\n        source_containers += containers_by_product_type.get(\"pointcache\", [])\n        source_container_namespaces = [\n            x[\"namespace\"] for x in source_containers\n        ]\n        message = (\n            \"{} animation containers selected:\\n\\n{}\\n\\nOnly select 1 of type \"\n            \"\\\"animation\\\" or \\\"pointcache\\\".\".format(\n                len(source_containers), source_container_namespaces\n            )\n        )\n        if len(source_containers) != 1:\n            self.display_warning(message)\n            return\n\n        source_container = source_containers[0]\n        source_ids = self.nodes_by_id(source_container)\n        source_project = source_container.get(\n            \"project_name\", get_current_project_name()\n        )\n\n        # Target containers.\n        target_ids = {}\n        inputs = []\n\n        yeti_rig_containers = containers_by_product_type.get(\"yetiRig\")\n        if not yeti_rig_containers:\n            self.display_warning(\n                \"Select at least one yetiRig container\"\n            )\n            return\n\n        for container in yeti_rig_containers:\n            target_ids.update(self.nodes_by_id(container))\n            repre_id = container[\"representation\"]\n\n            maya_file = get_representation_path_by_project(\n                source_project,\n                repre_contexts_by_id[repre_id][\"representation\"]\n            )\n            _, ext = os.path.splitext(maya_file)\n            settings_file = maya_file.replace(ext, \".rigsettings\")\n            if not os.path.exists(settings_file):\n                continue\n\n            with open(settings_file) as f:\n                inputs.extend(json.load(f)[\"inputs\"])\n\n            # Compare loaded connections to scene.\n            for input in inputs:\n                source_node = source_ids.get(input[\"sourceID\"])\n                target_node = target_ids.get(input[\"destinationID\"])\n\n                if not source_node or not target_node:\n                    self.log.debug(\n                        \"Could not find nodes for input:\\n\" +\n                        json.dumps(input, indent=4, sort_keys=True)\n                    )\n                    continue\n                source_attr, target_attr = input[\"connections\"]\n\n                if not cmds.attributeQuery(\n                    source_attr, node=source_node, exists=True\n                ):\n                    self.log.debug(\n                        \"Could not find attribute {} on node {} for \"\n                        \"input:\\n{}\".format(\n                            source_attr,\n                            source_node,\n                            json.dumps(input, indent=4, sort_keys=True)\n                        )\n                    )\n                    continue\n\n                if not cmds.attributeQuery(\n                    target_attr, node=target_node, exists=True\n                ):\n                    self.log.debug(\n                        \"Could not find attribute {} on node {} for \"\n                        \"input:\\n{}\".format(\n                            target_attr,\n                            target_node,\n                            json.dumps(input, indent=4, sort_keys=True)\n                        )\n                    )\n                    continue\n\n                source_plug = \"{}.{}\".format(\n                    source_node, source_attr\n                )\n                target_plug = \"{}.{}\".format(\n                    target_node, target_attr\n                )\n                if cmds.isConnected(\n                    source_plug, target_plug, ignoreUnitConversion=True\n                ):\n                    self.log.debug(\n                        \"Connection already exists: {} -&gt; {}\".format(\n                            source_plug, target_plug\n                        )\n                    )\n                    continue\n\n                cmds.connectAttr(source_plug, target_plug, force=True)\n                self.log.debug(\n                    \"Connected attributes: {} -&gt; {}\".format(\n                        source_plug, target_plug\n                    )\n                )\n\n    def nodes_by_id(self, container):\n        ids = {}\n        for member in get_container_members(container):\n            id = get_id(member)\n            if not id:\n                continue\n            ids[id] = member\n\n        return ids\n\n    def display_warning(self, message, show_cancel=False):\n        \"\"\"Show feedback to user.\n\n        Returns:\n            bool\n        \"\"\"\n\n        from qtpy import QtWidgets\n\n        accept = QtWidgets.QMessageBox.Ok\n        if show_cancel:\n            buttons = accept | QtWidgets.QMessageBox.Cancel\n        else:\n            buttons = accept\n\n        state = QtWidgets.QMessageBox.warning(\n            None,\n            \"\",\n            message,\n            buttons=buttons,\n            defaultButton=accept\n        )\n\n        return state == accept\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/inventory/connect_yeti_rig.html#client.ayon_maya.plugins.inventory.connect_yeti_rig.ConnectYetiRig.display_warning","title":"<code>display_warning(message, show_cancel=False)</code>","text":"<p>Show feedback to user.</p> <p>Returns:</p> Type Description <p>bool</p> Source code in <code>client/ayon_maya/plugins/inventory/connect_yeti_rig.py</code> <pre><code>def display_warning(self, message, show_cancel=False):\n    \"\"\"Show feedback to user.\n\n    Returns:\n        bool\n    \"\"\"\n\n    from qtpy import QtWidgets\n\n    accept = QtWidgets.QMessageBox.Ok\n    if show_cancel:\n        buttons = accept | QtWidgets.QMessageBox.Cancel\n    else:\n        buttons = accept\n\n    state = QtWidgets.QMessageBox.warning(\n        None,\n        \"\",\n        message,\n        buttons=buttons,\n        defaultButton=accept\n    )\n\n    return state == accept\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/inventory/import_modelrender.html","title":"import_modelrender","text":""},{"location":"autoapi/client/ayon_maya/plugins/inventory/import_modelrender.html#client.ayon_maya.plugins.inventory.import_modelrender.ImportModelRender","title":"<code>ImportModelRender</code>","text":"<p>               Bases: <code>InventoryAction</code></p> Source code in <code>client/ayon_maya/plugins/inventory/import_modelrender.py</code> <pre><code>class ImportModelRender(InventoryAction):\n\n    label = \"Import Model Render Sets\"\n    icon = \"industry\"\n    color = \"#55DDAA\"\n\n    scene_type_regex = \"meta.render.m[ab]\"\n    look_data_type = \"meta.render.json\"\n\n    @staticmethod\n    def is_compatible(container):\n        return (\n            container.get(\"loader\") == \"ReferenceLoader\"\n            and container.get(\"name\", \"\").startswith(\"model\")\n        )\n\n    def process(self, containers):\n        from maya import cmds  # noqa: F401\n\n        # --- Query entities that will be used ---\n        project_name = get_current_project_name()\n        # Collect representation ids from all containers\n        repre_ids = {\n            container[\"representation\"]\n            for container in containers\n        }\n        # Create mapping of representation id to version id\n        # - used in containers loop\n        version_id_by_repre_id = {\n            repre_entity[\"id\"]: repre_entity[\"versionId\"]\n            for repre_entity in ayon_api.get_representations(\n                project_name,\n                representation_ids=repre_ids,\n                fields={\"id\", \"versionId\"}\n            )\n        }\n\n        # Find all representations of the versions\n        version_ids = set(version_id_by_repre_id.values())\n        repre_entities = ayon_api.get_representations(\n            project_name,\n            version_ids=version_ids,\n            fields={\"id\", \"name\", \"versionId\"}\n        )\n        repre_entities_by_version_id = {\n            version_id: []\n            for version_id in version_ids\n        }\n        for repre_entity in repre_entities:\n            version_id = repre_entity[\"versionId\"]\n            repre_entities_by_version_id[version_id].append(repre_entity)\n\n        look_repres_by_version_id = {}\n        look_repre_ids = set()\n        for version_id, repre_entities in (\n            repre_entities_by_version_id.items()\n        ):\n            json_repre = None\n            look_repres = []\n            scene_type_regex = re.compile(self.scene_type_regex)\n            for repre_entity in repre_entities:\n                repre_name = repre_entity[\"name\"]\n                if repre_name == self.look_data_type:\n                    json_repre = repre_entity\n\n                elif scene_type_regex.fullmatch(repre_name):\n                    look_repres.append(repre_entity)\n\n            look_repre = look_repres[0] if look_repres else None\n            if look_repre:\n                look_repre_ids.add(look_repre[\"id\"])\n            if json_repre:\n                look_repre_ids.add(json_repre[\"id\"])\n\n            look_repres_by_version_id[version_id] = (json_repre, look_repre)\n\n        contexts_by_repre_id = get_representation_contexts_by_ids(\n            project_name, look_repre_ids\n        )\n\n        # --- Real process logic ---\n        # Loop over containers and assign the looks\n        for container in containers:\n            con_name = container[\"objectName\"]\n            nodes = []\n            for n in cmds.sets(con_name, query=True, nodesOnly=True) or []:\n                if cmds.nodeType(n) == \"reference\":\n                    nodes += cmds.referenceQuery(n, nodes=True)\n                else:\n                    nodes.append(n)\n\n            repre_id = container[\"representation\"]\n            version_id = version_id_by_repre_id.get(repre_id)\n            if version_id is None:\n                print(\"Representation '{}' was not found\".format(repre_id))\n                continue\n\n            json_repre, look_repre = look_repres_by_version_id[version_id]\n\n            print(\"Importing render sets for model %r\" % con_name)\n            self._assign_model_render(\n                nodes, json_repre, look_repre, contexts_by_repre_id\n            )\n\n    def _assign_model_render(\n        self, nodes, json_repre, look_repre, contexts_by_repre_id\n    ):\n        \"\"\"Assign nodes a specific published model render data version by id.\n\n        This assumes the nodes correspond with the asset.\n\n        Args:\n            nodes (list): nodes to assign render data to\n            json_repre (dict[str, Any]): Representation entity of the json\n                file.\n            look_repre (dict[str, Any]): First representation entity of the\n                look files.\n            contexts_by_repre_id (dict[str, Any]): Mapping of representation\n                id to its context.\n\n        Returns:\n            None\n        \"\"\"\n\n        from maya import cmds  # noqa: F401\n\n        # QUESTION shouldn't be json representation validated too?\n        if not look_repre:\n            print(\"No model render sets for this model version..\")\n            return\n\n        # TODO use 'get_representation_path_with_anatomy' instead\n        #   of 'filepath_from_context'\n        context = contexts_by_repre_id.get(look_repre[\"id\"])\n        maya_file = self.filepath_from_context(context)\n\n        context = contexts_by_repre_id.get(json_repre[\"id\"])\n        json_file = self.filepath_from_context(context)\n\n        # Import the look file\n        with maintained_selection():\n            shader_nodes = cmds.file(maya_file,\n                                     i=True,  # import\n                                     returnNewNodes=True)\n            # imprint context data\n\n        # Load relationships\n        shader_relation = json_file\n        with open(shader_relation, \"r\") as f:\n            relationships = json.load(f)\n\n        # Assign relationships\n        apply_shaders(relationships, shader_nodes, nodes)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/inventory/import_reference.html","title":"import_reference","text":""},{"location":"autoapi/client/ayon_maya/plugins/inventory/import_reference.html#client.ayon_maya.plugins.inventory.import_reference.ImportReference","title":"<code>ImportReference</code>","text":"<p>               Bases: <code>InventoryAction</code></p> <p>Imports selected reference to inside of the file.</p> Source code in <code>client/ayon_maya/plugins/inventory/import_reference.py</code> <pre><code>class ImportReference(InventoryAction):\n    \"\"\"Imports selected reference to inside of the file.\"\"\"\n\n    label = \"Import Reference\"\n    icon = \"download\"\n    color = \"#d8d8d8\"\n\n    supported_loaders = {\"ReferenceLoader\", \"MayaUSDReferenceLoader\"}\n\n    def process(self, containers):\n        for container in containers:\n            if container[\"loader\"] not in self.supported_loaders:\n                print(\"Not a reference, skipping\")\n                continue\n\n            node = container[\"objectName\"]\n            members = cmds.sets(node, query=True, nodesOnly=True)\n            ref_node = get_reference_node(members)\n\n            ref_file = cmds.referenceQuery(ref_node, f=True)\n            cmds.file(ref_file, importReference=True)\n\n        return True  # return anything to trigger model refresh\n\n    @classmethod\n    def is_compatible(cls, container):\n        return container.get(\"loader\") in cls.supported_loaders\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/inventory/lock_version.html","title":"lock_version","text":""},{"location":"autoapi/client/ayon_maya/plugins/inventory/rig_recreate_animation_instance.html","title":"rig_recreate_animation_instance","text":""},{"location":"autoapi/client/ayon_maya/plugins/inventory/rig_recreate_animation_instance.html#client.ayon_maya.plugins.inventory.rig_recreate_animation_instance.RecreateRigAnimationInstance","title":"<code>RecreateRigAnimationInstance</code>","text":"<p>               Bases: <code>InventoryAction</code></p> <p>Recreate animation publish instance for loaded rigs</p> Source code in <code>client/ayon_maya/plugins/inventory/rig_recreate_animation_instance.py</code> <pre><code>class RecreateRigAnimationInstance(InventoryAction):\n    \"\"\"Recreate animation publish instance for loaded rigs\"\"\"\n\n    label = \"Recreate rig animation instance\"\n    icon = \"wrench\"\n    color = \"#888888\"\n\n    @staticmethod\n    def is_compatible(container):\n        return (\n            container.get(\"loader\") == \"ReferenceLoader\"\n            and container.get(\"name\", \"\").startswith(\"rig\")\n        )\n\n    def process(self, containers):\n        project_name = get_current_project_name()\n        repre_ids = {\n            container[\"representation\"]\n            for container in containers\n        }\n        contexts_by_repre_id = get_representation_contexts_by_ids(\n            project_name, repre_ids\n        )\n\n        for container in containers:\n            # todo: delete an existing entry if it exist or skip creation\n\n            namespace = container[\"namespace\"]\n            repre_id = container[\"representation\"]\n            context = contexts_by_repre_id[repre_id]\n            nodes = get_container_members(container)\n\n            create_rig_animation_instance(nodes, context, namespace)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/inventory/select_containers.html","title":"select_containers","text":""},{"location":"autoapi/client/ayon_maya/plugins/inventory/select_containers.html#client.ayon_maya.plugins.inventory.select_containers.HighlightBySceneSelection","title":"<code>HighlightBySceneSelection</code>","text":"<p>               Bases: <code>InventoryAction</code></p> <p>Select containers in scene inventory from the current scene selection</p> Source code in <code>client/ayon_maya/plugins/inventory/select_containers.py</code> <pre><code>class HighlightBySceneSelection(InventoryAction):\n    \"\"\"Select containers in scene inventory from the current scene selection\"\"\"\n\n    label = \"Highlight by scene selection\"\n    icon = \"search\"\n    color = \"#888888\"\n    order = 100\n\n    def process(self, containers):\n\n        selection = set(cmds.ls(selection=True, long=True, objectsOnly=True))\n        host = registered_host()\n\n        to_select = []\n        for container in host.get_containers():\n            members = get_container_members(container)\n            if any(member in selection for member in members):\n                to_select.append(container[\"objectName\"])\n\n        return {\n            \"objectNames\": to_select,\n            \"options\": {\"clear\": True}\n        }\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/inventory/select_containers.html#client.ayon_maya.plugins.inventory.select_containers.SelectInScene","title":"<code>SelectInScene</code>","text":"<p>               Bases: <code>InventoryAction</code></p> <p>Select nodes in the scene from selected containers in scene inventory</p> Source code in <code>client/ayon_maya/plugins/inventory/select_containers.py</code> <pre><code>class SelectInScene(InventoryAction):\n    \"\"\"Select nodes in the scene from selected containers in scene inventory\"\"\"\n\n    label = \"Select in scene\"\n    icon = \"search\"\n    color = \"#888888\"\n    order = 99\n\n    def process(self, containers):\n\n        all_members = []\n        for container in containers:\n            members = get_container_members(container)\n            all_members.extend(members)\n        cmds.select(all_members, replace=True, noExpand=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/_load_animation.html","title":"_load_animation","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/_load_animation.html#client.ayon_maya.plugins.load._load_animation.AbcLoader","title":"<code>AbcLoader</code>","text":"<p>               Bases: <code>ReferenceLoader</code></p> <p>Loader to reference an Alembic file</p> Source code in <code>client/ayon_maya/plugins/load/_load_animation.py</code> <pre><code>class AbcLoader(ayon_maya.api.plugin.ReferenceLoader):\n    \"\"\"Loader to reference an Alembic file\"\"\"\n\n    product_types = {\n        \"animation\",\n        \"camera\",\n        \"pointcache\",\n    }\n    representations = {\"abc\"}\n\n    label = \"Reference animation\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def process_reference(self, context, name, namespace, options):\n\n        cmds.loadPlugin(\"AbcImport.mll\", quiet=True)\n        # hero_001 (abc)\n        # asset_counter{optional}\n        path = self.filepath_from_context(context)\n        file_url = self.prepare_root_value(path,\n                                           context[\"project\"][\"name\"])\n\n        nodes = _process_reference(file_url, name, namespace, options)\n        # load colorbleed ID attribute\n        self[:] = nodes\n\n        return nodes\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/_load_animation.html#client.ayon_maya.plugins.load._load_animation.FbxLoader","title":"<code>FbxLoader</code>","text":"<p>               Bases: <code>ReferenceLoader</code></p> <p>Loader to reference an Fbx files</p> Source code in <code>client/ayon_maya/plugins/load/_load_animation.py</code> <pre><code>class FbxLoader(ayon_maya.api.plugin.ReferenceLoader):\n    \"\"\"Loader to reference an Fbx files\"\"\"\n\n    product_types = {\n        \"animation\",\n        \"camera\",\n    }\n    representations = {\"fbx\"}\n\n    label = \"Reference animation\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def process_reference(self, context, name, namespace, options):\n\n        cmds.loadPlugin(\"fbx4maya.mll\", quiet=True)\n\n        path = self.filepath_from_context(context)\n        file_url = self.prepare_root_value(path,\n                                           context[\"project\"][\"name\"])\n\n        nodes = _process_reference(file_url, name, namespace, options)\n\n        self[:] = nodes\n\n        return nodes\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/actions.html","title":"actions","text":"<p>A module containing generic loader actions that will display in the Loader.</p>"},{"location":"autoapi/client/ayon_maya/plugins/load/actions.html#client.ayon_maya.plugins.load.actions.ImportMayaLoader","title":"<code>ImportMayaLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Import action for Maya (unmanaged)</p> Warning <p>The loaded content will be unmanaged and is not visible in the scene inventory. It's purely intended to merge content into your scene so you could also use it as a new base.</p> Source code in <code>client/ayon_maya/plugins/load/actions.py</code> <pre><code>class ImportMayaLoader(ayon_maya.api.plugin.Loader):\n    \"\"\"Import action for Maya (unmanaged)\n\n    Warning:\n        The loaded content will be unmanaged and is *not* visible in the\n        scene inventory. It's purely intended to merge content into your scene\n        so you could also use it as a new base.\n\n    \"\"\"\n    representations = {\"ma\", \"mb\", \"obj\"}\n    product_types = {\n        \"model\",\n        \"pointcache\",\n        \"proxyAbc\",\n        \"animation\",\n        \"mayaAscii\",\n        \"mayaScene\",\n        \"setdress\",\n        \"layout\",\n        \"camera\",\n        \"rig\",\n        \"camerarig\",\n        \"staticMesh\",\n        \"workfile\",\n    }\n\n    label = \"Import\"\n    order = 10\n    icon = \"arrow-circle-down\"\n    color = \"#775555\"\n\n    options = [\n        BoolDef(\n            \"clean_import\",\n            label=\"Strip existing AYON asset metadata\",\n            default=False,\n            tooltip=(\n                \"When enabled, existing AYON 'cbId' attributes on nodes will \"\n                \"be removed upon import.\"\n            )\n        )\n    ]\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        super(ImportMayaLoader, cls).apply_settings(project_settings)\n        cls.enabled = cls.load_settings[\"import_loader\"].get(\"enabled\", True)\n\n    def load(self, context, name=None, namespace=None, data=None):\n        import maya.cmds as cmds\n\n        choice = self.display_warning()\n        if choice is False:\n            return\n\n        custom_group_name, custom_namespace, options = \\\n            self.get_custom_namespace_and_group(context, data,\n                                                \"import_loader\")\n\n        namespace = get_custom_namespace(custom_namespace)\n\n        if not options.get(\"attach_to_root\", True):\n            custom_group_name = namespace\n\n        path = self.filepath_from_context(context)\n        with maintained_selection():\n            nodes = cmds.file(path,\n                              i=True,\n                              preserveReferences=True,\n                              namespace=namespace,\n                              returnNewNodes=True,\n                              groupReference=options.get(\"attach_to_root\",\n                                                         True),\n                              groupName=custom_group_name)\n\n            if data.get(\"clean_import\", False):\n                remove_attributes = [\"cbId\"]\n                for node in nodes:\n                    for attr in remove_attributes:\n                        if cmds.attributeQuery(attr, node=node, exists=True):\n                            full_attr = \"{}.{}\".format(node, attr)\n                            print(\"Removing {}\".format(full_attr))\n                            cmds.deleteAttr(full_attr)\n\n        # We do not containerize imported content, it remains unmanaged\n        return\n\n    def display_warning(self):\n        \"\"\"Show warning to ensure the user can't import models by accident\n\n        Returns:\n            bool\n\n        \"\"\"\n\n        from qtpy import QtWidgets\n\n        accept = QtWidgets.QMessageBox.Ok\n        buttons = accept | QtWidgets.QMessageBox.Cancel\n\n        message = \"Are you sure you want import this\"\n        state = QtWidgets.QMessageBox.warning(None,\n                                              \"Are you sure?\",\n                                              message,\n                                              buttons=buttons,\n                                              defaultButton=accept)\n\n        return state == accept\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/actions.html#client.ayon_maya.plugins.load.actions.ImportMayaLoader.display_warning","title":"<code>display_warning()</code>","text":"<p>Show warning to ensure the user can't import models by accident</p> <p>Returns:</p> Type Description <p>bool</p> Source code in <code>client/ayon_maya/plugins/load/actions.py</code> <pre><code>def display_warning(self):\n    \"\"\"Show warning to ensure the user can't import models by accident\n\n    Returns:\n        bool\n\n    \"\"\"\n\n    from qtpy import QtWidgets\n\n    accept = QtWidgets.QMessageBox.Ok\n    buttons = accept | QtWidgets.QMessageBox.Cancel\n\n    message = \"Are you sure you want import this\"\n    state = QtWidgets.QMessageBox.warning(None,\n                                          \"Are you sure?\",\n                                          message,\n                                          buttons=buttons,\n                                          defaultButton=accept)\n\n    return state == accept\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/actions.html#client.ayon_maya.plugins.load.actions.SetFrameRangeLoader","title":"<code>SetFrameRangeLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Set frame range excluding pre- and post-handles</p> Source code in <code>client/ayon_maya/plugins/load/actions.py</code> <pre><code>class SetFrameRangeLoader(load.LoaderPlugin):\n    \"\"\"Set frame range excluding pre- and post-handles\"\"\"\n\n    product_types = {\n        \"animation\",\n        \"camera\",\n        \"proxyAbc\",\n        \"pointcache\",\n    }\n    representations = {\"abc\"}\n\n    label = \"Set frame range\"\n    order = 11\n    icon = \"clock-o\"\n    color = \"white\"\n\n    def load(self, context, name, namespace, data):\n\n        import maya.cmds as cmds\n\n        version_attributes = context[\"version\"][\"attrib\"]\n        start = version_attributes.get(\"frameStart\")\n        end = version_attributes.get(\"frameEnd\")\n\n        if start is None or end is None:\n            print(\"Skipping setting frame range because start or \"\n                  \"end frame data is missing..\")\n            return\n\n        cmds.playbackOptions(minTime=start,\n                             maxTime=end,\n                             animationStartTime=start,\n                             animationEndTime=end)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/actions.html#client.ayon_maya.plugins.load.actions.SetFrameRangeWithHandlesLoader","title":"<code>SetFrameRangeWithHandlesLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Set frame range including pre- and post-handles</p> Source code in <code>client/ayon_maya/plugins/load/actions.py</code> <pre><code>class SetFrameRangeWithHandlesLoader(load.LoaderPlugin):\n    \"\"\"Set frame range including pre- and post-handles\"\"\"\n\n    product_types = {\n        \"animation\",\n        \"camera\",\n        \"proxyAbc\",\n        \"pointcache\",\n    }\n    representations = {\"abc\"}\n\n    label = \"Set frame range (with handles)\"\n    order = 12\n    icon = \"clock-o\"\n    color = \"white\"\n\n    def load(self, context, name, namespace, data):\n\n        import maya.cmds as cmds\n\n        version_attributes = context[\"version\"][\"attrib\"]\n\n        start = version_attributes.get(\"frameStart\")\n        end = version_attributes.get(\"frameEnd\")\n\n        if start is None or end is None:\n            print(\"Skipping setting frame range because start or \"\n                  \"end frame data is missing..\")\n            return\n\n        # Include handles\n        start -= version_attributes.get(\"handleStart\", 0)\n        end += version_attributes.get(\"handleEnd\", 0)\n\n        cmds.playbackOptions(minTime=start,\n                             maxTime=end,\n                             animationStartTime=start,\n                             animationEndTime=end)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_arnold_standin.html","title":"load_arnold_standin","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_arnold_standin.html#client.ayon_maya.plugins.load.load_arnold_standin.ArnoldStandinLoader","title":"<code>ArnoldStandinLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load as Arnold standin</p> Source code in <code>client/ayon_maya/plugins/load/load_arnold_standin.py</code> <pre><code>class ArnoldStandinLoader(plugin.Loader):\n    \"\"\"Load as Arnold standin\"\"\"\n\n    product_types = {\n        \"ass\",\n        \"assProxy\",\n        \"animation\",\n        \"model\",\n        \"proxyAbc\",\n        \"pointcache\",\n        \"usd\",\n        \"oxcache\"\n    }\n    representations = {\"ass\", \"abc\", \"usda\", \"usdc\", \"usd\"}\n\n    label = \"Load as Arnold standin\"\n    order = -5\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name, namespace, options):\n        if not cmds.pluginInfo(\"mtoa\", query=True, loaded=True):\n            cmds.loadPlugin(\"mtoa\")\n            # Create defaultArnoldRenderOptions before creating aiStandin\n            # which tries to connect it. Since we load the plugin and directly\n            # create aiStandin without the defaultArnoldRenderOptions,\n            # we need to create the render options for aiStandin creation.\n            from mtoa.core import createOptions\n            createOptions()\n\n        import mtoa.ui.arnoldmenu\n\n        version_attributes = context[\"version\"][\"attrib\"]\n\n        self.log.info(\"version_attributes: {}\\n\".format(version_attributes))\n\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = namespace or unique_namespace(\n            folder_name + \"_\",\n            prefix=\"_\" if folder_name[0].isdigit() else \"\",\n            suffix=\"_\",\n        )\n\n        # Root group\n        label = \"{}:{}\".format(namespace, name)\n        root = cmds.group(name=label, empty=True)\n\n        # Set color.\n        settings = get_project_settings(context[\"project\"][\"name\"])\n        color = get_load_color_for_product_type(\"ass\", settings)\n        if color is not None:\n            red, green, blue = color\n            cmds.setAttr(root + \".useOutlinerColor\", True)\n            cmds.setAttr(\n                root + \".outlinerColor\", red, green, blue\n            )\n\n        with maintained_selection():\n            # Create transform with shape\n            transform_name = label + \"_standin\"\n\n            standin_shape = mtoa.ui.arnoldmenu.createStandIn()\n            standin = cmds.listRelatives(standin_shape, parent=True)[0]\n            standin = cmds.rename(standin, transform_name)\n            standin_shape = cmds.listRelatives(standin, shapes=True)[0]\n\n            cmds.parent(standin, root)\n\n            # Set the standin filepath\n            repre_path = self.filepath_from_context(context)\n            path, operator = self._setup_proxy(\n                standin_shape, repre_path, namespace\n            )\n            cmds.setAttr(standin_shape + \".dso\", path, type=\"string\")\n            sequence = is_sequence(os.listdir(os.path.dirname(repre_path)))\n            cmds.setAttr(standin_shape + \".useFrameExtension\", sequence)\n            cmds.setAttr(standin_shape + \".aiNamespace\", namespace, type=\"string\")\n\n            fps = (\n                version_attributes.get(\"fps\") or get_fps_for_current_context()\n            )\n            cmds.setAttr(standin_shape + \".abcFPS\", float(fps))\n\n        nodes = [root, standin, standin_shape]\n        if operator is not None:\n            nodes.append(operator)\n        self[:] = nodes\n\n        return containerise(\n            name=name,\n            namespace=namespace,\n            nodes=nodes,\n            context=context,\n            loader=self.__class__.__name__)\n\n    def get_next_free_multi_index(self, attr_name):\n        \"\"\"Find the next unconnected multi index at the input attribute.\"\"\"\n        for index in range(10000000):\n            connection_info = cmds.connectionInfo(\n                \"{}[{}]\".format(attr_name, index),\n                sourceFromDestination=True\n            )\n            if len(connection_info or []) == 0:\n                return index\n\n    def _get_proxy_path(self, path):\n        basename_split = os.path.basename(path).split(\".\")\n        proxy_basename = (\n            basename_split[0] + \"_proxy.\" + \".\".join(basename_split[1:])\n        )\n        proxy_path = \"/\".join([os.path.dirname(path), proxy_basename])\n        return proxy_basename, proxy_path\n\n    def _update_operators(self, string_replace_operator, proxy_basename, path):\n        cmds.setAttr(\n            string_replace_operator + \".match\",\n            proxy_basename.split(\".\")[0],\n            type=\"string\"\n        )\n        cmds.setAttr(\n            string_replace_operator + \".replace\",\n            os.path.basename(path).split(\".\")[0],\n            type=\"string\"\n        )\n\n    def _setup_proxy(self, shape, path, namespace):\n        proxy_basename, proxy_path = self._get_proxy_path(path)\n\n        options_node = \"defaultArnoldRenderOptions\"\n        merge_operator = get_attribute_input(options_node + \".operator\")\n        if merge_operator is None:\n            merge_operator = cmds.createNode(\"aiMerge\")\n            cmds.connectAttr(\n                merge_operator + \".message\", options_node + \".operator\"\n            )\n\n        merge_operator = merge_operator.split(\".\")[0]\n\n        string_replace_operator = cmds.createNode(\n            \"aiStringReplace\", name=namespace + \":string_replace_operator\"\n        )\n        node_type = \"alembic\" if path.endswith(\".abc\") else \"procedural\"\n        cmds.setAttr(\n            string_replace_operator + \".selection\",\n            \"*.(@node=='{}')\".format(node_type),\n            type=\"string\"\n        )\n        self._update_operators(string_replace_operator, proxy_basename, path)\n\n        cmds.connectAttr(\n            string_replace_operator + \".out\",\n            \"{}.inputs[{}]\".format(\n                merge_operator,\n                self.get_next_free_multi_index(merge_operator + \".inputs\")\n            )\n        )\n\n        # We setup the string operator no matter whether there is a proxy or\n        # not. This makes it easier to update since the string operator will\n        # always be created. Return original path to use for standin.\n        if not os.path.exists(proxy_path):\n            return path, string_replace_operator\n\n        return proxy_path, string_replace_operator\n\n    def update(self, container, context):\n        # Update the standin\n        members = cmds.sets(container['objectName'], query=True)\n        for member in members:\n            if cmds.nodeType(member) == \"aiStringReplace\":\n                string_replace_operator = member\n\n            shapes = cmds.listRelatives(member, shapes=True)\n            if not shapes:\n                continue\n            if cmds.nodeType(shapes[0]) == \"aiStandIn\":\n                standin = shapes[0]\n\n        repre_entity = context[\"representation\"]\n        path = self.filepath_from_context(context)\n        proxy_basename, proxy_path = self._get_proxy_path(path)\n\n        # Whether there is proxy or not, we still update the string operator.\n        # If no proxy exists, the string operator won't replace anything.\n        self._update_operators(string_replace_operator, proxy_basename, path)\n\n        dso_path = path\n        if os.path.exists(proxy_path):\n            dso_path = proxy_path\n        cmds.setAttr(standin + \".dso\", dso_path, type=\"string\")\n\n        sequence = is_sequence(os.listdir(os.path.dirname(path)))\n        cmds.setAttr(standin + \".useFrameExtension\", sequence)\n\n        cmds.setAttr(\n            container[\"objectName\"] + \".representation\",\n            repre_entity[\"id\"],\n            type=\"string\"\n        )\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        members = cmds.sets(container['objectName'], query=True)\n        cmds.lockNode(members, lock=False)\n        cmds.delete([container['objectName']] + members)\n\n        # Clean up the namespace\n        try:\n            cmds.namespace(removeNamespace=container['namespace'],\n                           deleteNamespaceContent=True)\n        except RuntimeError:\n            pass\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_arnold_standin.html#client.ayon_maya.plugins.load.load_arnold_standin.ArnoldStandinLoader.get_next_free_multi_index","title":"<code>get_next_free_multi_index(attr_name)</code>","text":"<p>Find the next unconnected multi index at the input attribute.</p> Source code in <code>client/ayon_maya/plugins/load/load_arnold_standin.py</code> <pre><code>def get_next_free_multi_index(self, attr_name):\n    \"\"\"Find the next unconnected multi index at the input attribute.\"\"\"\n    for index in range(10000000):\n        connection_info = cmds.connectionInfo(\n            \"{}[{}]\".format(attr_name, index),\n            sourceFromDestination=True\n        )\n        if len(connection_info or []) == 0:\n            return index\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_as_template.html","title":"load_as_template","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_as_template.html#client.ayon_maya.plugins.load.load_as_template.LoadAsTemplate","title":"<code>LoadAsTemplate</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load workfile as a template</p> Source code in <code>client/ayon_maya/plugins/load/load_as_template.py</code> <pre><code>class LoadAsTemplate(plugin.Loader):\n    \"\"\"Load workfile as a template \"\"\"\n\n    product_types = {\"workfile\", \"mayaScene\"}\n    label = \"Load as template\"\n    representations = [\"ma\", \"mb\"]\n    icon = \"wrench\"\n    color = \"#775555\"\n    order = 10\n\n    options = [\n        BoolDef(\"keep_placeholders\",\n                label=\"Keep Placeholders\",\n                default=False),\n        BoolDef(\"create_first_version\",\n                label=\"Create First Version\",\n                default=False),\n    ]\n\n    def load(self, context, name, namespace, data):\n        keep_placeholders = data.get(\"keep_placeholders\", False)\n        create_first_version = data.get(\"create_first_version\", False)\n        path = self.filepath_from_context(context)\n        builder = MayaTemplateBuilder(registered_host())\n        builder.build_template(template_path=path,\n                               keep_placeholders=keep_placeholders,\n                               create_first_version=create_first_version)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_assembly.html","title":"load_assembly","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_assembly.html#client.ayon_maya.plugins.load.load_assembly.AssemblyLoader","title":"<code>AssemblyLoader</code>","text":"<p>               Bases: <code>Loader</code></p> Source code in <code>client/ayon_maya/plugins/load/load_assembly.py</code> <pre><code>class AssemblyLoader(plugin.Loader):\n\n    product_types = {\"assembly\"}\n    representations = {\"json\"}\n\n    label = \"Load Set Dress\"\n    order = -9\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name, namespace, data):\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = namespace or unique_namespace(\n            folder_name + \"_\",\n            prefix=\"_\" if folder_name[0].isdigit() else \"\",\n            suffix=\"_\",\n        )\n\n        containers = setdress.load_package(\n            filepath=self.filepath_from_context(context),\n            name=name,\n            namespace=namespace\n        )\n\n        self[:] = containers\n\n        # Only containerize if any nodes were loaded by the Loader\n        nodes = self[:]\n        if not nodes:\n            return\n\n        return containerise(\n            name=name,\n            namespace=namespace,\n            nodes=nodes,\n            context=context,\n            loader=self.__class__.__name__)\n\n    def update(self, container, context):\n\n        return setdress.update_package(container, context)\n\n    def remove(self, container):\n        \"\"\"Remove all sub containers\"\"\"\n\n        # Remove all members\n        member_containers = setdress.get_contained_containers(container)\n        for member_container in member_containers:\n            self.log.info(\"Removing container %s\",\n                          member_container['objectName'])\n            remove_container(member_container)\n\n        # Remove alembic hierarchy reference\n        # TODO: Check whether removing all contained references is safe enough\n        members = cmds.sets(container['objectName'], query=True) or []\n        references = cmds.ls(members, type=\"reference\")\n        for reference in references:\n            self.log.info(\"Removing %s\", reference)\n            fname = cmds.referenceQuery(reference, filename=True)\n            cmds.file(fname, removeReference=True)\n\n        # Delete container and its contents\n        if cmds.objExists(container['objectName']):\n            members = cmds.sets(container['objectName'], query=True) or []\n            cmds.delete([container['objectName']] + members)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_assembly.html#client.ayon_maya.plugins.load.load_assembly.AssemblyLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove all sub containers</p> Source code in <code>client/ayon_maya/plugins/load/load_assembly.py</code> <pre><code>def remove(self, container):\n    \"\"\"Remove all sub containers\"\"\"\n\n    # Remove all members\n    member_containers = setdress.get_contained_containers(container)\n    for member_container in member_containers:\n        self.log.info(\"Removing container %s\",\n                      member_container['objectName'])\n        remove_container(member_container)\n\n    # Remove alembic hierarchy reference\n    # TODO: Check whether removing all contained references is safe enough\n    members = cmds.sets(container['objectName'], query=True) or []\n    references = cmds.ls(members, type=\"reference\")\n    for reference in references:\n        self.log.info(\"Removing %s\", reference)\n        fname = cmds.referenceQuery(reference, filename=True)\n        cmds.file(fname, removeReference=True)\n\n    # Delete container and its contents\n    if cmds.objExists(container['objectName']):\n        members = cmds.sets(container['objectName'], query=True) or []\n        cmds.delete([container['objectName']] + members)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_audio.html","title":"load_audio","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_audio.html#client.ayon_maya.plugins.load.load_audio.AudioLoader","title":"<code>AudioLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Specific loader of audio.</p> Source code in <code>client/ayon_maya/plugins/load/load_audio.py</code> <pre><code>class AudioLoader(plugin.Loader):\n    \"\"\"Specific loader of audio.\"\"\"\n\n    product_types = {\"audio\"}\n    label = \"Load audio\"\n    representations = {\"wav\"}\n    icon = \"volume-up\"\n    color = \"orange\"\n\n    def load(self, context, name, namespace, data):\n\n        start_frame = cmds.playbackOptions(query=True, min=True)\n        sound_node = cmds.sound(\n            file=self.filepath_from_context(context), offset=start_frame\n        )\n        cmds.timeControl(\n            mel.eval(\"$gPlayBackSlider=$gPlayBackSlider\"),\n            edit=True,\n            sound=sound_node,\n            displaySound=True\n        )\n\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = namespace or unique_namespace(\n            folder_name + \"_\",\n            prefix=\"_\" if folder_name[0].isdigit() else \"\",\n            suffix=\"_\",\n        )\n\n        return containerise(\n            name=name,\n            namespace=namespace,\n            nodes=[sound_node],\n            context=context,\n            loader=self.__class__.__name__\n        )\n\n    def update(self, container, context):\n        repre_entity = context[\"representation\"]\n\n        members = get_container_members(container)\n        audio_nodes = cmds.ls(members, type=\"audio\")\n\n        assert audio_nodes is not None, \"Audio node not found.\"\n        audio_node = audio_nodes[0]\n\n        current_sound = cmds.timeControl(\n            mel.eval(\"$gPlayBackSlider=$gPlayBackSlider\"),\n            query=True,\n            sound=True\n        )\n        activate_sound = current_sound == audio_node\n\n        path = self.filepath_from_context(context)\n\n        cmds.sound(\n            audio_node,\n            edit=True,\n            file=path\n        )\n\n        # The source start + end does not automatically update itself to the\n        # length of thew new audio file, even though maya does do that when\n        # creating a new audio node. So to update we compute it manually.\n        # This would however override any source start and source end a user\n        # might have done on the original audio node after load.\n        audio_frame_count = cmds.getAttr(\"{}.frameCount\".format(audio_node))\n        audio_sample_rate = cmds.getAttr(\"{}.sampleRate\".format(audio_node))\n        duration_in_seconds = audio_frame_count / audio_sample_rate\n        fps = mel.eval('currentTimeUnitToFPS()')  # workfile FPS\n        source_start = 0\n        source_end = (duration_in_seconds * fps)\n        cmds.setAttr(\"{}.sourceStart\".format(audio_node), source_start)\n        cmds.setAttr(\"{}.sourceEnd\".format(audio_node), source_end)\n\n        if activate_sound:\n            # maya by default deactivates it from timeline on file change\n            cmds.timeControl(\n                mel.eval(\"$gPlayBackSlider=$gPlayBackSlider\"),\n                edit=True,\n                sound=audio_node,\n                displaySound=True\n            )\n\n        cmds.setAttr(\n            container[\"objectName\"] + \".representation\",\n            repre_entity[\"id\"],\n            type=\"string\"\n        )\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        members = cmds.sets(container['objectName'], query=True)\n        cmds.lockNode(members, lock=False)\n        cmds.delete([container['objectName']] + members)\n\n        # Clean up the namespace\n        try:\n            cmds.namespace(removeNamespace=container['namespace'],\n                           deleteNamespaceContent=True)\n        except RuntimeError:\n            pass\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_gpucache.html","title":"load_gpucache","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_gpucache.html#client.ayon_maya.plugins.load.load_gpucache.GpuCacheLoader","title":"<code>GpuCacheLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load Alembic as gpuCache</p> Source code in <code>client/ayon_maya/plugins/load/load_gpucache.py</code> <pre><code>class GpuCacheLoader(plugin.Loader):\n    \"\"\"Load Alembic as gpuCache\"\"\"\n\n    product_types = {\"model\", \"animation\", \"proxyAbc\", \"pointcache\"}\n    representations = {\"abc\", \"gpu_cache\"}\n\n    label = \"Load Gpu Cache\"\n    order = -5\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name, namespace, data):\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = namespace or unique_namespace(\n            folder_name + \"_\",\n            prefix=\"_\" if folder_name[0].isdigit() else \"\",\n            suffix=\"_\",\n        )\n\n        cmds.loadPlugin(\"gpuCache\", quiet=True)\n\n        # Root group\n        label = \"{}:{}\".format(namespace, name)\n        root = cmds.group(name=label, empty=True)\n\n        project_name = context[\"project\"][\"name\"]\n        settings = get_project_settings(project_name)\n        color = get_load_color_for_product_type(\"model\", settings)\n        if color is not None:\n            red, green, blue = color\n            cmds.setAttr(root + \".useOutlinerColor\", 1)\n            cmds.setAttr(\n                root + \".outlinerColor\", red, green, blue\n            )\n\n        # Create transform with shape\n        transform_name = label + \"_GPU\"\n        transform = cmds.createNode(\"transform\", name=transform_name,\n                                    parent=root)\n        cache = cmds.createNode(\"gpuCache\",\n                                parent=transform,\n                                name=\"{0}Shape\".format(transform_name))\n\n        # Set the cache filepath\n        path = self.filepath_from_context(context)\n        cmds.setAttr(cache + '.cacheFileName', path, type=\"string\")\n        cmds.setAttr(cache + '.cacheGeomPath', \"|\", type=\"string\")    # root\n        if cmds.attributeQuery(\"aiNamespace\", node=cache, exists=True):\n            # Set Arnold namespace attribute to ensure shaders are loaded uniquely\n            # when a gpu cache is loaded multiple times\n            cmds.setAttr(cache + '.aiNamespace', namespace, type=\"string\")\n\n        # Lock parenting of the transform and cache\n        cmds.lockNode([transform, cache], lock=True)\n\n        nodes = [root, transform, cache]\n        self[:] = nodes\n\n        return containerise(\n            name=name,\n            namespace=namespace,\n            nodes=nodes,\n            context=context,\n            loader=self.__class__.__name__)\n\n    def update(self, container, context):\n        repre_entity = context[\"representation\"]\n        path = self.filepath_from_context(context)\n\n        # Update the cache\n        members = cmds.sets(container['objectName'], query=True)\n        caches = cmds.ls(members, type=\"gpuCache\", long=True)\n\n        assert len(caches) == 1, \"This is a bug\"\n\n        for cache in caches:\n            cmds.setAttr(cache + \".cacheFileName\", path, type=\"string\")\n\n        cmds.setAttr(container[\"objectName\"] + \".representation\",\n                     repre_entity[\"id\"],\n                     type=\"string\")\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        members = cmds.sets(container['objectName'], query=True)\n        cmds.lockNode(members, lock=False)\n        cmds.delete([container['objectName']] + members)\n\n        # Clean up the namespace\n        try:\n            cmds.namespace(removeNamespace=container['namespace'],\n                           deleteNamespaceContent=True)\n        except RuntimeError:\n            pass\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_image.html","title":"load_image","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_image.html#client.ayon_maya.plugins.load.load_image.FileNodeLoader","title":"<code>FileNodeLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>File node loader.</p> Source code in <code>client/ayon_maya/plugins/load/load_image.py</code> <pre><code>class FileNodeLoader(plugin.Loader):\n    \"\"\"File node loader.\"\"\"\n\n    product_types = {\"*\"}\n    label = \"Load file node\"\n    representations = {\"*\"}\n    extensions = {\"exr\", \"tif\", \"png\", \"jpg\", \"jpeg\"}\n    icon = \"image\"\n    color = \"orange\"\n    order = 2\n\n    options = [\n        EnumDef(\n            \"mode\",\n            items={\n                \"texture\": \"Texture\",\n                \"projection\": \"Projection\",\n                \"stencil\": \"Stencil\"\n            },\n            default=\"texture\",\n            label=\"Texture Mode\"\n        )\n    ]\n\n    def load(self, context, name, namespace, data):\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = namespace or unique_namespace(\n            folder_name + \"_\",\n            prefix=\"_\" if folder_name[0].isdigit() else \"\",\n            suffix=\"_\",\n        )\n\n        with namespaced(namespace, new=True) as namespace:\n            # Create the nodes within the namespace\n            nodes = {\n                \"texture\": create_texture,\n                \"projection\": create_projection,\n                \"stencil\": create_stencil\n            }[data.get(\"mode\", \"texture\")]()\n\n        file_node = cmds.ls(nodes, type=\"file\")[0]\n\n        self._apply_representation_context(context, file_node)\n\n        # For ease of access for the user select all the nodes and select\n        # the file node last so that UI shows its attributes by default\n        cmds.select(list(nodes) + [file_node], replace=True)\n\n        return containerise(\n            name=name,\n            namespace=namespace,\n            nodes=nodes,\n            context=context,\n            loader=self.__class__.__name__\n        )\n\n    def update(self, container, context):\n        repre_entity = context[\"representation\"]\n\n        members = cmds.sets(container['objectName'], query=True)\n        file_node = cmds.ls(members, type=\"file\")[0]\n\n        self._apply_representation_context(context, file_node)\n\n        # Update representation\n        cmds.setAttr(\n            container[\"objectName\"] + \".representation\",\n            repre_entity[\"id\"],\n            type=\"string\"\n        )\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        members = cmds.sets(container['objectName'], query=True)\n        cmds.lockNode(members, lock=False)\n        cmds.delete([container['objectName']] + members)\n\n        # Clean up the namespace\n        try:\n            cmds.namespace(removeNamespace=container['namespace'],\n                           deleteNamespaceContent=True)\n        except RuntimeError:\n            pass\n\n    def _apply_representation_context(self, context, file_node):\n        \"\"\"Update the file node to match the context.\n\n        This sets the file node's attributes for:\n            - file path\n            - udim tiling mode (if it is an udim tile)\n            - use frame extension (if it is a sequence)\n            - colorspace\n\n        \"\"\"\n\n        repre_context = context[\"representation\"][\"context\"]\n        has_frames = repre_context.get(\"frame\") is not None\n        has_udim = repre_context.get(\"udim\") is not None\n\n        # Set UV tiling mode if UDIM tiles\n        if has_udim:\n            cmds.setAttr(file_node + \".uvTilingMode\", 3)    # UDIM-tiles\n        else:\n            cmds.setAttr(file_node + \".uvTilingMode\", 0)    # off\n\n        # Enable sequence if publish has `startFrame` and `endFrame` and\n        # `startFrame != endFrame`\n        if has_frames and self._is_sequence(context):\n            # When enabling useFrameExtension maya automatically\n            # connects an expression to &lt;file&gt;.frameExtension to set\n            # the current frame. However, this expression  is generated\n            # with some delay and thus it'll show a warning if frame 0\n            # doesn't exist because we're explicitly setting the &lt;f&gt;\n            # token.\n            cmds.setAttr(file_node + \".useFrameExtension\", True)\n        else:\n            cmds.setAttr(file_node + \".useFrameExtension\", False)\n\n        # Set the file node path attribute\n        path = self._format_path(context)\n        cmds.setAttr(file_node + \".fileTextureName\", path, type=\"string\")\n\n        # Set colorspace\n        colorspace = self._get_colorspace(context)\n        if colorspace:\n            cmds.setAttr(file_node + \".colorSpace\", colorspace, type=\"string\")\n        else:\n            self.log.debug(\"Unknown colorspace - setting colorspace skipped.\")\n\n    def _is_sequence(self, context):\n        \"\"\"Check whether frameStart and frameEnd are not the same.\"\"\"\n        version = context[\"version\"]\n        representation = context[\"representation\"]\n\n        # TODO this is invalid logic, it should be based only on\n        #   representation entity\n        for entity in [representation, version]:\n            # Frame range can be set on version or representation.\n            # When set on representation it overrides version data.\n            attributes = entity[\"attrib\"]\n            data = entity[\"data\"]\n            start = data.get(\"frameStartHandle\", attributes.get(\"frameStart\"))\n            end = data.get(\"frameEndHandle\", attributes.get(\"frameEnd\"))\n\n            if start is None or end is None:\n                continue\n\n            if start != end:\n                return True\n            else:\n                return False\n\n        return False\n\n    def _get_colorspace(self, context):\n        \"\"\"Return colorspace of the file to load.\n\n        Retrieves the explicit colorspace from the publish. If no colorspace\n        data is stored with published content then project imageio settings\n        are used to make an assumption of the colorspace based on the file\n        rules. If no file rules match then None is returned.\n\n        Returns:\n            str or None: The colorspace of the file or None if not detected.\n\n        \"\"\"\n\n        # We can't apply color spaces if management is not enabled\n        if not cmds.colorManagementPrefs(query=True, cmEnabled=True):\n            return\n\n        representation = context[\"representation\"]\n        colorspace_data = representation.get(\"data\", {}).get(\"colorspaceData\")\n        if colorspace_data:\n            return colorspace_data[\"colorspace\"]\n\n        # Assume colorspace from filepath based on project settings\n        project_name = context[\"project\"][\"name\"]\n        host_name = get_current_host_name()\n        project_settings = get_project_settings(project_name)\n\n        config_data = get_current_context_imageio_config_preset(\n            project_settings=project_settings\n        )\n\n        # ignore if host imageio is not enabled\n        if not config_data:\n            return\n\n        file_rules = get_imageio_file_rules(\n            project_name, host_name,\n            project_settings=project_settings\n        )\n\n        path = self.filepath_from_context(context)\n        colorspace = get_imageio_file_rules_colorspace_from_filepath(\n            path,\n            host_name,\n            project_name,\n            config_data=config_data,\n            file_rules=file_rules,\n            project_settings=project_settings\n        )\n\n        return colorspace\n\n    def _format_path(self, context):\n        \"\"\"Format the path with correct tokens for frames and udim tiles.\"\"\"\n\n        context = copy.deepcopy(context)\n        representation = context[\"representation\"]\n        template = representation.get(\"attrib\", {}).get(\"template\")\n        if not template:\n            # No template to find token locations for\n            return self.filepath_from_context(context)\n\n        def _placeholder(key):\n            # Substitute with a long placeholder value so that potential\n            # custom formatting with padding doesn't find its way into\n            # our formatting, so that &lt;f&gt; wouldn't be padded as 0&lt;f&gt;\n            return \"___{}___\".format(key)\n\n        # We format UDIM and Frame numbers with their specific tokens. To do so\n        # we in-place change the representation context data to format the path\n        # with our own data\n        tokens = {\n            \"frame\": \"&lt;f&gt;\",\n            # We do not enforce the UDIM token in the filepath because it\n            # generates the issue that Maya does not detect the file correctly\n            # in e.g. the File Path Editor. Instead, we set the regular\n            # filepath and allow Maya to 'compute' the UDIM token.\n            # \"udim\": \"&lt;UDIM&gt;\"\n        }\n        has_tokens = False\n        repre_context = representation[\"context\"]\n        for key, _token in tokens.items():\n            if key in repre_context:\n                repre_context[key] = _placeholder(key)\n                has_tokens = True\n\n        # Replace with our custom template that has the tokens set\n        representation[\"attrib\"][\"template\"] = template\n        path = self.filepath_from_context(context)\n\n        if has_tokens:\n            for key, token in tokens.items():\n                if key in repre_context:\n                    path = path.replace(_placeholder(key), token)\n\n        return path\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_image.html#client.ayon_maya.plugins.load.load_image.create_projection","title":"<code>create_projection()</code>","text":"<p>Create texture with place3dTexture and projection</p> <p>Mimics Maya \"file [Projection]\" creation.</p> Source code in <code>client/ayon_maya/plugins/load/load_image.py</code> <pre><code>def create_projection():\n    \"\"\"Create texture with place3dTexture and projection\n\n    Mimics Maya \"file [Projection]\" creation.\n    \"\"\"\n\n    file, place = create_texture()\n    projection = cmds.shadingNode(\"projection\", asTexture=True,\n                                  name=\"projection\")\n    place3d = cmds.shadingNode(\"place3dTexture\", asUtility=True,\n                               name=\"place3d\")\n\n    cmds.connectAttr(place3d + '.worldInverseMatrix[0]',\n                     projection + \".placementMatrix\")\n    cmds.connectAttr(file + '.outColor', projection + \".image\")\n\n    return file, place, projection, place3d\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_image.html#client.ayon_maya.plugins.load.load_image.create_stencil","title":"<code>create_stencil()</code>","text":"<p>Create texture with extra place2dTexture offset and stencil</p> <p>Mimics Maya \"file [Stencil]\" creation.</p> Source code in <code>client/ayon_maya/plugins/load/load_image.py</code> <pre><code>def create_stencil():\n    \"\"\"Create texture with extra place2dTexture offset and stencil\n\n    Mimics Maya \"file [Stencil]\" creation.\n    \"\"\"\n\n    file, place = create_texture()\n\n    place_stencil = cmds.shadingNode(\"place2dTexture\", asUtility=True,\n                                     name=\"place2d_stencil\")\n    stencil = cmds.shadingNode(\"stencil\", asTexture=True, name=\"stencil\")\n\n    for src_attr, dest_attr in [\n        (\"outUV\", \"uvCoord\"),\n        (\"outUvFilterSize\", \"uvFilterSize\")\n    ]:\n        src_plug = \"{}.{}\".format(place_stencil, src_attr)\n        cmds.connectAttr(src_plug, \"{}.{}\".format(place, dest_attr))\n        cmds.connectAttr(src_plug, \"{}.{}\".format(stencil, dest_attr))\n\n    return file, place, stencil, place_stencil\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_image.html#client.ayon_maya.plugins.load.load_image.create_texture","title":"<code>create_texture()</code>","text":"<p>Create place2dTexture with file node with uv connections</p> <p>Mimics Maya \"file [Texture]\" creation.</p> Source code in <code>client/ayon_maya/plugins/load/load_image.py</code> <pre><code>def create_texture():\n    \"\"\"Create place2dTexture with file node with uv connections\n\n    Mimics Maya \"file [Texture]\" creation.\n    \"\"\"\n\n    place = cmds.shadingNode(\"place2dTexture\", asUtility=True, name=\"place2d\")\n    file = cmds.shadingNode(\"file\", asTexture=True, name=\"file\")\n\n    connections = [\"coverage\", \"translateFrame\", \"rotateFrame\", \"rotateUV\",\n                   \"mirrorU\", \"mirrorV\", \"stagger\", \"wrapV\", \"wrapU\",\n                   \"repeatUV\", \"offset\", \"noiseUV\", \"vertexUvThree\",\n                   \"vertexUvTwo\", \"vertexUvOne\", \"vertexCameraOne\"]\n    for attr in connections:\n        src = \"{}.{}\".format(place, attr)\n        dest = \"{}.{}\".format(file, attr)\n        cmds.connectAttr(src, dest)\n\n    cmds.connectAttr(place + '.outUV', file + '.uvCoord')\n    cmds.connectAttr(place + '.outUvFilterSize', file + '.uvFilterSize')\n\n    return file, place\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_image_plane.html","title":"load_image_plane","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_image_plane.html#client.ayon_maya.plugins.load.load_image_plane.ImagePlaneLoader","title":"<code>ImagePlaneLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Specific loader of plate for image planes on selected camera.</p> Source code in <code>client/ayon_maya/plugins/load/load_image_plane.py</code> <pre><code>class ImagePlaneLoader(plugin.Loader):\n    \"\"\"Specific loader of plate for image planes on selected camera.\"\"\"\n\n    product_types = {\"image\", \"plate\", \"render\"}\n    label = \"Load imagePlane\"\n    representations = {\"*\"}\n    extensions = {\"mov\", \"mp4\", \"exr\", \"png\", \"jpg\", \"jpeg\"}\n    icon = \"image\"\n    color = \"orange\"\n\n    def load(self, context, name, namespace, data, options=None):\n\n        image_plane_depth = 1000\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = namespace or unique_namespace(\n            folder_name + \"_\",\n            prefix=\"_\" if folder_name[0].isdigit() else \"\",\n            suffix=\"_\",\n        )\n\n        # Get camera from user selection.\n        # is_static_image_plane = None\n        # is_in_all_views = None\n        camera = data.get(\"camera\") if data else None\n\n        if not camera:\n            cameras = cmds.ls(type=\"camera\")\n\n            # Cameras by names\n            camera_names = {}\n            for camera in cameras:\n                parent = cmds.listRelatives(camera, parent=True, path=True)[0]\n                camera_names[parent] = camera\n\n            camera_names[\"Create new camera.\"] = \"create-camera\"\n            window = CameraWindow(camera_names.keys())\n            window.exec_()\n            # Skip if no camera was selected (Dialog was closed)\n            if window.camera not in camera_names:\n                return\n            camera = camera_names[window.camera]\n\n        if camera == \"create-camera\":\n            camera = cmds.createNode(\"camera\")\n\n        if camera is None:\n            return\n\n        try:\n            cmds.setAttr(\"{}.displayResolution\".format(camera), True)\n            cmds.setAttr(\"{}.farClipPlane\".format(camera),\n                         image_plane_depth * 10)\n        except RuntimeError:\n            pass\n\n        # Create image plane\n        with namespaced(namespace):\n            # Create inside the namespace\n            image_plane_transform, image_plane_shape = cmds.imagePlane(\n                fileName=self.filepath_from_context(context),\n                camera=camera\n            )\n\n        # Set colorspace\n        colorspace = self.get_colorspace(context[\"representation\"])\n        if colorspace:\n            cmds.setAttr(\n                \"{}.ignoreColorSpaceFileRules\".format(image_plane_shape),\n                True\n            )\n            cmds.setAttr(\"{}.colorSpace\".format(image_plane_shape),\n                         colorspace, type=\"string\")\n\n        # Set offset frame range\n        start_frame = cmds.playbackOptions(query=True, min=True)\n        end_frame = cmds.playbackOptions(query=True, max=True)\n\n        for attr, value in {\n            \"depth\": image_plane_depth,\n            \"frameOffset\": 0,\n            \"frameIn\": start_frame,\n            \"frameOut\": end_frame,\n            \"frameCache\": end_frame,\n            \"useFrameExtension\": True\n        }.items():\n            plug = \"{}.{}\".format(image_plane_shape, attr)\n            cmds.setAttr(plug, value)\n\n        movie_representations = {\"mov\", \"preview\"}\n        if context[\"representation\"][\"name\"] in movie_representations:\n            cmds.setAttr(image_plane_shape + \".type\", 2)\n\n        # Ask user whether to use sequence or still image.\n        if context[\"representation\"][\"name\"] == \"exr\":\n            # Ensure OpenEXRLoader plugin is loaded.\n            cmds.loadPlugin(\"OpenEXRLoader\", quiet=True)\n\n            message = (\n                \"Hold image sequence on first frame?\"\n                \"\\n{} files available.\".format(\n                    len(context[\"representation\"][\"files\"])\n                )\n            )\n            reply = QtWidgets.QMessageBox.information(\n                None,\n                \"Frame Hold.\",\n                message,\n                QtWidgets.QMessageBox.Yes,\n                QtWidgets.QMessageBox.No\n            )\n            if reply == QtWidgets.QMessageBox.Yes:\n                frame_extension_plug = \"{}.frameExtension\".format(image_plane_shape)  # noqa\n\n                # Remove current frame expression\n                disconnect_inputs(frame_extension_plug)\n\n                cmds.setAttr(frame_extension_plug, start_frame)\n\n        new_nodes = [image_plane_transform, image_plane_shape]\n\n        return containerise(\n            name=name,\n            namespace=namespace,\n            nodes=new_nodes,\n            context=context,\n            loader=self.__class__.__name__\n        )\n\n    def update(self, container, context):\n        folder_entity = context[\"folder\"]\n        repre_entity = context[\"representation\"]\n\n        members = get_container_members(container)\n        image_planes = cmds.ls(members, type=\"imagePlane\")\n        assert image_planes, \"Image plane not found.\"\n        image_plane_shape = image_planes[0]\n\n        path = self.filepath_from_context(context)\n        cmds.setAttr(\"{}.imageName\".format(image_plane_shape),\n                     path,\n                     type=\"string\")\n        cmds.setAttr(\"{}.representation\".format(container[\"objectName\"]),\n                     repre_entity[\"id\"],\n                     type=\"string\")\n\n        colorspace = self.get_colorspace(repre_entity)\n        if colorspace:\n            cmds.setAttr(\n                \"{}.ignoreColorSpaceFileRules\".format(image_plane_shape),\n                True\n            )\n            cmds.setAttr(\"{}.colorSpace\".format(image_plane_shape),\n                         colorspace, type=\"string\")\n\n        # Set frame range.\n        start_frame = folder_entity[\"attrib\"][\"frameStart\"]\n        end_frame = folder_entity[\"attrib\"][\"frameEnd\"]\n\n        for attr, value in {\n            \"frameOffset\": 0,\n            \"frameIn\": start_frame,\n            \"frameOut\": end_frame,\n            \"frameCache\": end_frame\n        }:\n            plug = \"{}.{}\".format(image_plane_shape, attr)\n            cmds.setAttr(plug, value)\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        members = cmds.sets(container['objectName'], query=True)\n        cmds.lockNode(members, lock=False)\n        cmds.delete([container['objectName']] + members)\n\n        # Clean up the namespace\n        try:\n            cmds.namespace(removeNamespace=container['namespace'],\n                           deleteNamespaceContent=True)\n        except RuntimeError:\n            pass\n\n    def get_colorspace(self, representation):\n\n        data = representation.get(\"data\", {}).get(\"colorspaceData\", {})\n        if not data:\n            return\n\n        colorspace = data.get(\"colorspace\")\n        return colorspace\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_layout.html","title":"load_layout","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_layout.html#client.ayon_maya.plugins.load.load_layout.LayoutLoader","title":"<code>LayoutLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Layout Loader (json)</p> Source code in <code>client/ayon_maya/plugins/load/load_layout.py</code> <pre><code>class LayoutLoader(plugin.Loader):\n    \"\"\"Layout Loader (json)\"\"\"\n\n    product_types = {\"layout\"}\n    representations = {\"json\"}\n\n    label = \"Load Layout\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def _get_repre_entities_by_version_id(self, data):\n        version_ids = {\n            element.get(\"version\")\n            for element in data\n        }\n        version_ids.discard(None)\n\n        output = collections.defaultdict(list)\n        if not version_ids:\n            return output\n\n        project_name = get_current_project_name()\n        repre_entities = ayon_api.get_representations(\n            project_name,\n            representation_names={\"fbx\", \"abc\"},\n            version_ids=version_ids,\n            fields={\"id\", \"versionId\", \"name\"}\n        )\n        for repre_entity in repre_entities:\n            version_id = repre_entity[\"versionId\"]\n            output[version_id].append(repre_entity)\n        return output\n\n    @staticmethod\n    def _get_loader(loaders, product_type):\n        name = \"\"\n        if product_type in {\n            \"rig\", \"model\", \"camera\",\n            \"animation\", \"staticMesh\",\n            \"skeletalMesh\"}:\n                name = \"ReferenceLoader\"\n\n        if name == \"\":\n            return None\n\n        for loader in loaders:\n            if loader.__name__ == name:\n                return loader\n\n        return None\n\n    def get_asset(self, containers, element):\n        \"\"\"Get the container root and check with the\n        namespace of the root aligning to the instance_name\n        from element.\n        If it does not match, the instance_name from the element\n        is set to the namespace of the container root.\n\n        Args:\n            containers (list): containers\n            element (Dict): element data from layout json\n\n        Returns:\n            str: container root\n        \"\"\"\n        # TODO: Improve this logic to support multiples of same asset\n        #  and to avoid bugs with containers getting renamed by artists\n        # Find container names that starts with 'instance name'\n        containers = [con for con in containers]\n        # Get the highest root node from the loaded container\n        for container in containers:\n            members = get_container_members(container)\n            transforms = cmds.ls(members, transforms=True)\n            roots = get_highest_in_hierarchy(transforms)\n            root = next(iter(\n                cmds.listRelatives(\n                    root, parent=True, fullPath=True, type=\"transform\"\n                ) for root in roots), None)\n            if root is not None:\n                # For loading multiple layouts with the same namespaces\n                # Once namespace is already found, it would be replaced\n                # by new namespace but still applies the correct\n                # transformation data\n                element[\"instance_name\"] = cmds.getAttr(f\"{container}.namespace\")\n                return root\n            else:\n                self.log.error(\"No container root found.\")\n\n    def _process_element(self, element, repre_entities_by_version_id):\n        repre_id = None\n        repr_format = None\n        version_id = element.get(\"version\")\n        if version_id:\n            repre_entities = repre_entities_by_version_id[version_id]\n            if not repre_entities:\n                self.log.error(\n                    \"No valid representation found for version\"\n                    f\" {version_id}\")\n                return\n            # always use the first representation to load\n            # If reference is None, this element is skipped, as it cannot be\n            # imported in Maya, repre_entities must always be the first one\n            repre_entity = repre_entities[0]\n            repre_id = repre_entity[\"id\"]\n            repr_format = repre_entity[\"name\"]\n\n        # If reference is None, this element is skipped, as it cannot be\n        # imported in Maya\n        if not repr_format:\n            self.log.warning(f\"Representation name not defined for element: {element}\")\n            return\n\n        instance_name: str = element['instance_name']\n        all_loaders = discover_loader_plugins()\n        product_type = element.get(\"product_type\")\n        if product_type is None:\n            product_type = element.get(\"family\")\n        loaders = loaders_from_representation(\n            all_loaders, repre_id)\n\n        loader = self._get_loader(loaders, product_type)\n\n        if not loader:\n            self.log.error(\n                f\"No valid loader found for {repre_id}\")\n            return\n        options = {\n            # \"asset_dir\": asset_dir\n        }\n        assets = load_container(\n            loader,\n            repre_id,\n            namespace=instance_name,\n            options=options\n        )\n        self.set_transformation(assets, element)\n        return assets\n\n    def set_transformation(self, assets, element):\n        asset = self.get_asset(assets, element)\n        unreal_import = True if \"unreal\" in element.get(\"host\", []) else False\n        if unreal_import:\n            transform = element[\"transform\"]\n            self._set_transformation(asset, transform)\n        else:\n            transform = element[\"transform_matrix\"]\n            # flatten matrix to a list\n            maya_transform_matrix = [element for row in transform for element in row]\n            self._set_transformation_by_matrix(asset, maya_transform_matrix)\n\n            instance_name = element[\"instance_name\"]\n            for object_data in element.get(\"object_transform\", []):\n                for obj_name, transform_matrix in object_data.items():\n                    obj_transforms = cmds.ls(\n                        f\"{instance_name}:{obj_name}\",\n                        type=\"transform\",\n                        long=True\n                    )\n                    if len(obj_transforms) &gt; 1:\n                        self.log.warning(\n                            f\"Multiple transforms found for {instance_name}:{obj_name}. \"\n                            \"Using the first one instead.\"\n                        )\n                    obj_root = next(iter(obj_transforms), None)\n                    if obj_root is not None:\n                        # flatten matrix to a list\n                        maya_transform_matrix = [\n                            element for row in transform_matrix for element in row\n                        ]\n                        self._set_transformation_by_matrix(obj_root, maya_transform_matrix)\n\n    def _set_transformation(self, asset, transform):\n        translation = [\n            transform[\"translation\"][\"x\"],\n            transform[\"translation\"][\"z\"],\n            transform[\"translation\"][\"y\"]\n            ]\n\n        rotation = [\n            math.degrees(transform[\"rotation\"][\"x\"]),\n            -math.degrees(transform[\"rotation\"][\"z\"]),\n            math.degrees(transform[\"rotation\"][\"y\"]),\n        ]\n        scale = [\n            transform[\"scale\"][\"x\"],\n            transform[\"scale\"][\"z\"],\n            transform[\"scale\"][\"y\"]\n        ]\n        cmds.xform(\n            asset,\n            translation=translation,\n            rotation=rotation,\n            scale=scale\n        )\n\n    def _set_transformation_by_matrix(self, asset, transform):\n        \"\"\"Set transformation with transform matrix and rotation data\n        for the imported asset.\n\n        Args:\n            transform (list): Transformations of the asset\n        \"\"\"\n        transform_mm = om.MMatrix(transform)\n        convert_transform = om.MTransformationMatrix(transform_mm)\n        convert_translation = convert_transform.translation(om.MSpace.kWorld)\n        convert_scale = convert_transform.scale(om.MSpace.kWorld)\n        convert_rotation = convert_transform.rotation()\n        rotation_degrees = [om.MAngle(convert_rotation.x).asDegrees(),\n                            om.MAngle(convert_rotation.z).asDegrees(),\n                            om.MAngle(convert_rotation.y).asDegrees()]\n        translation = [\n            convert_translation.x,\n            convert_translation.z,\n            convert_translation.y\n        ]\n        cmds.xform(\n            asset,\n            translation=translation,\n            rotation=rotation_degrees,\n            scale=[convert_scale[0], convert_scale[2], convert_scale[1]]\n        )\n\n    def _get_asset_container_by_instance_name(self, container_node, element):\n        \"\"\"Get existing asset container by instance name\n\n        Args:\n            container_node (dict): container_node\n            element (dict): element data\n\n        Returns:\n            list: asset container\n        \"\"\"\n        container_nodes = cmds.sets(container_node, query=True)\n        instance_name = element.get(\"instance_name\")\n        return [\n            node for node in container_nodes if instance_name in node\n        ]\n\n    def load(self, context, name, namespace, options):\n        path = self.filepath_from_context(context)\n        self.log.info(f\"&gt;&gt;&gt; loading json [ {path} ]\")\n        with open(path, \"r\") as fp:\n            data = json.load(fp)\n\n        # get the list of representations by using version id\n        repre_entities_by_version_id = self._get_repre_entities_by_version_id(\n            data\n        )\n        assets = []\n        for element in data:\n            elements = self._process_element(element, repre_entities_by_version_id)\n            assets.extend(elements)\n\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = namespace or unique_namespace(\n            folder_name + \"_\",\n            prefix=\"_\" if folder_name[0].isdigit() else \"\",\n            suffix=\"_\",\n        )\n\n        return containerise(\n            name=name,\n            namespace=namespace,\n            nodes=assets,\n            context=context,\n            loader=self.__class__.__name__)\n\n    def update(self, container, context):\n        repre_entity = context[\"representation\"]\n        path = self.filepath_from_context(context)\n        self.log.info(f\"&gt;&gt;&gt; loading json [ {path} ]\")\n        with open(path, \"r\") as fp:\n            data = json.load(fp)\n\n        # get the list of representations by using version id\n        repre_entities_by_version_id = self._get_repre_entities_by_version_id(\n            data\n        )\n\n        node = container[\"objectName\"]\n        for element in data:\n            asset_container = self._get_asset_container_by_instance_name(\n                node, element)\n            if asset_container:\n                self.set_transformation(asset_container, element)\n            else:\n                elements = self._process_element(\n                    element, repre_entities_by_version_id\n                )\n                cmds.sets(elements, add=node)\n\n        # Update metadata\n        cmds.setAttr(\"{}.representation\".format(node),\n                     repre_entity[\"id\"],\n                     type=\"string\")\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        members = cmds.sets(container['objectName'], query=True)\n        cmds.lockNode(members, lock=False)\n        cmds.delete([container['objectName']] + members)\n        # Clean up the namespace\n        try:\n            cmds.namespace(removeNamespace=container['namespace'],\n                        deleteNamespaceContent=True)\n        except RuntimeError:\n            pass\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_layout.html#client.ayon_maya.plugins.load.load_layout.LayoutLoader.get_asset","title":"<code>get_asset(containers, element)</code>","text":"<p>Get the container root and check with the namespace of the root aligning to the instance_name from element. If it does not match, the instance_name from the element is set to the namespace of the container root.</p> <p>Parameters:</p> Name Type Description Default <code>containers</code> <code>list</code> <p>containers</p> required <code>element</code> <code>Dict</code> <p>element data from layout json</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>container root</p> Source code in <code>client/ayon_maya/plugins/load/load_layout.py</code> <pre><code>def get_asset(self, containers, element):\n    \"\"\"Get the container root and check with the\n    namespace of the root aligning to the instance_name\n    from element.\n    If it does not match, the instance_name from the element\n    is set to the namespace of the container root.\n\n    Args:\n        containers (list): containers\n        element (Dict): element data from layout json\n\n    Returns:\n        str: container root\n    \"\"\"\n    # TODO: Improve this logic to support multiples of same asset\n    #  and to avoid bugs with containers getting renamed by artists\n    # Find container names that starts with 'instance name'\n    containers = [con for con in containers]\n    # Get the highest root node from the loaded container\n    for container in containers:\n        members = get_container_members(container)\n        transforms = cmds.ls(members, transforms=True)\n        roots = get_highest_in_hierarchy(transforms)\n        root = next(iter(\n            cmds.listRelatives(\n                root, parent=True, fullPath=True, type=\"transform\"\n            ) for root in roots), None)\n        if root is not None:\n            # For loading multiple layouts with the same namespaces\n            # Once namespace is already found, it would be replaced\n            # by new namespace but still applies the correct\n            # transformation data\n            element[\"instance_name\"] = cmds.getAttr(f\"{container}.namespace\")\n            return root\n        else:\n            self.log.error(\"No container root found.\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_look.html","title":"load_look","text":"<p>Look loader.</p>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_look.html#client.ayon_maya.plugins.load.load_look.LookLoader","title":"<code>LookLoader</code>","text":"<p>               Bases: <code>ReferenceLoader</code></p> <p>Specific loader for lookdev</p> Source code in <code>client/ayon_maya/plugins/load/load_look.py</code> <pre><code>class LookLoader(ayon_maya.api.plugin.ReferenceLoader):\n    \"\"\"Specific loader for lookdev\"\"\"\n\n    product_types = {\"look\"}\n    representations = {\"ma\"}\n\n    label = \"Reference look\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def process_reference(self, context, name, namespace, options):\n        from maya import cmds\n\n        with lib.maintained_selection():\n            file_url = self.prepare_root_value(\n                file_url=self.filepath_from_context(context),\n                project_name=context[\"project\"][\"name\"]\n            )\n            nodes = cmds.file(file_url,\n                              namespace=namespace,\n                              reference=True,\n                              returnNewNodes=True)\n\n        self[:] = nodes\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def update(self, container, context):\n        \"\"\"\n            Called by Scene Inventory when look should be updated to current\n            version.\n            If any reference edits cannot be applied, eg. shader renamed and\n            material not present, reference is unloaded and cleaned.\n            All failed edits are highlighted to the user via message box.\n\n        Args:\n            container: object that has look to be updated\n            context: (dict): relationship data to get proper\n                                       representation from DB and persisted\n                                       data in .json\n        Returns:\n            None\n        \"\"\"\n        from maya import cmds\n\n        # Get reference node from container members\n        members = lib.get_container_members(container)\n        reference_node = get_reference_node(members, log=self.log)\n\n        shader_nodes = cmds.ls(members, type='shadingEngine')\n        orig_nodes = set(self._get_nodes_with_shader(shader_nodes))\n\n        # Trigger the regular reference update on the ReferenceLoader\n        super(LookLoader, self).update(container, context)\n\n        # get new applied shaders and nodes from new version\n        shader_nodes = cmds.ls(members, type='shadingEngine')\n        nodes = set(self._get_nodes_with_shader(shader_nodes))\n\n        version_id = context[\"version\"][\"id\"]\n        project_name = context[\"project\"][\"name\"]\n        json_representation = get_representation_by_name(\n            project_name, \"json\", version_id\n        )\n\n        # Load relationships\n        shader_relation = get_representation_path_by_project(\n            project_name, json_representation\n        )\n        with open(shader_relation, \"r\") as f:\n            json_data = json.load(f)\n\n        # update of reference could result in failed edits - material is not\n        # present because of renaming etc. If so highlight failed edits to user\n        failed_edits = cmds.referenceQuery(reference_node,\n                                           editStrings=True,\n                                           failedEdits=True,\n                                           successfulEdits=False)\n        if failed_edits:\n            # clean references - removes failed reference edits\n            cmds.file(cr=reference_node)  # cleanReference\n\n            # reapply shading groups from json representation on orig nodes\n            lib.apply_shaders(json_data, shader_nodes, orig_nodes)\n\n            msg = [\"During reference update some edits failed.\",\n                   \"All successful edits were kept intact.\\n\",\n                   \"Failed and removed edits:\"]\n            msg.extend(failed_edits)\n\n            msg = ScrollMessageBox(QtWidgets.QMessageBox.Warning,\n                                   \"Some reference edit failed\",\n                                   msg)\n            msg.exec_()\n\n        attributes = json_data.get(\"attributes\", [])\n\n        # region compute lookup\n        nodes_by_id = defaultdict(list)\n        for node in nodes:\n            nodes_by_id[lib.get_id(node)].append(node)\n        lib.apply_attributes(attributes, nodes_by_id)\n\n    def _get_nodes_with_shader(self, shader_nodes):\n        \"\"\"\n            Returns list of nodes belonging to specific shaders\n        Args:\n            shader_nodes: &lt;list&gt; of Shader groups\n        Returns\n            &lt;list&gt; node names\n        \"\"\"\n        from maya import cmds\n\n        for shader in shader_nodes:\n            future = cmds.listHistory(shader, future=True)\n            connections = cmds.listConnections(future,\n                                               type='mesh')\n            if connections:\n                # Ensure unique entries only to optimize query and results\n                connections = list(set(connections))\n                return cmds.listRelatives(connections,\n                                          shapes=True,\n                                          fullPath=True) or []\n        return []\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_look.html#client.ayon_maya.plugins.load.load_look.LookLoader.update","title":"<code>update(container, context)</code>","text":"<pre><code>Called by Scene Inventory when look should be updated to current\nversion.\nIf any reference edits cannot be applied, eg. shader renamed and\nmaterial not present, reference is unloaded and cleaned.\nAll failed edits are highlighted to the user via message box.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>container</code> <p>object that has look to be updated</p> required <code>context</code> <p>(dict): relationship data to get proper                        representation from DB and persisted                        data in .json</p> required <p>Returns:     None</p> Source code in <code>client/ayon_maya/plugins/load/load_look.py</code> <pre><code>def update(self, container, context):\n    \"\"\"\n        Called by Scene Inventory when look should be updated to current\n        version.\n        If any reference edits cannot be applied, eg. shader renamed and\n        material not present, reference is unloaded and cleaned.\n        All failed edits are highlighted to the user via message box.\n\n    Args:\n        container: object that has look to be updated\n        context: (dict): relationship data to get proper\n                                   representation from DB and persisted\n                                   data in .json\n    Returns:\n        None\n    \"\"\"\n    from maya import cmds\n\n    # Get reference node from container members\n    members = lib.get_container_members(container)\n    reference_node = get_reference_node(members, log=self.log)\n\n    shader_nodes = cmds.ls(members, type='shadingEngine')\n    orig_nodes = set(self._get_nodes_with_shader(shader_nodes))\n\n    # Trigger the regular reference update on the ReferenceLoader\n    super(LookLoader, self).update(container, context)\n\n    # get new applied shaders and nodes from new version\n    shader_nodes = cmds.ls(members, type='shadingEngine')\n    nodes = set(self._get_nodes_with_shader(shader_nodes))\n\n    version_id = context[\"version\"][\"id\"]\n    project_name = context[\"project\"][\"name\"]\n    json_representation = get_representation_by_name(\n        project_name, \"json\", version_id\n    )\n\n    # Load relationships\n    shader_relation = get_representation_path_by_project(\n        project_name, json_representation\n    )\n    with open(shader_relation, \"r\") as f:\n        json_data = json.load(f)\n\n    # update of reference could result in failed edits - material is not\n    # present because of renaming etc. If so highlight failed edits to user\n    failed_edits = cmds.referenceQuery(reference_node,\n                                       editStrings=True,\n                                       failedEdits=True,\n                                       successfulEdits=False)\n    if failed_edits:\n        # clean references - removes failed reference edits\n        cmds.file(cr=reference_node)  # cleanReference\n\n        # reapply shading groups from json representation on orig nodes\n        lib.apply_shaders(json_data, shader_nodes, orig_nodes)\n\n        msg = [\"During reference update some edits failed.\",\n               \"All successful edits were kept intact.\\n\",\n               \"Failed and removed edits:\"]\n        msg.extend(failed_edits)\n\n        msg = ScrollMessageBox(QtWidgets.QMessageBox.Warning,\n                               \"Some reference edit failed\",\n                               msg)\n        msg.exec_()\n\n    attributes = json_data.get(\"attributes\", [])\n\n    # region compute lookup\n    nodes_by_id = defaultdict(list)\n    for node in nodes:\n        nodes_by_id[lib.get_id(node)].append(node)\n    lib.apply_attributes(attributes, nodes_by_id)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_matchmove.html","title":"load_matchmove","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_matchmove.html#client.ayon_maya.plugins.load.load_matchmove.MatchmoveLoader","title":"<code>MatchmoveLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>This will run matchmove script to create track in scene.</p> <p>Supported script types are .py and .mel</p> Source code in <code>client/ayon_maya/plugins/load/load_matchmove.py</code> <pre><code>class MatchmoveLoader(plugin.Loader):\n    \"\"\"\n    This will run matchmove script to create track in scene.\n\n    Supported script types are .py and .mel\n    \"\"\"\n\n    product_types = {\"matchmove\"}\n    representations = {\"py\", \"mel\"}\n    defaults = [\"Camera\", \"Object\", \"Mocap\"]\n\n    label = \"Run matchmove script\"\n    icon = \"empire\"\n    color = \"orange\"\n\n    def load(self,\n             context: dict,\n             name: Optional[str] = None,\n             namespace: Optional[str] = None,\n             options: Optional[dict] = None) -&gt; None:\n        \"\"\"Load the matchmove script.\"\"\"\n        path = Path(self.filepath_from_context(context))\n        if path.suffix.lower() == \".py\":\n            runpy.run_path(path.as_posix(), run_name=\"__main__\")\n\n        elif path.suffix.lower() == \".mel\":\n            cmds.file(\n                path.as_posix(), type=\"mel\",\n                renameAll=True, i=True, ignoreVersion=True,\n                importTimeRange=\"override\",\n                options=\"v=0;\", pr=True, loadReferenceDepth=\"all\")\n        else:\n            self.log.error(\"Unsupported script type %s\", path.suffix)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_matchmove.html#client.ayon_maya.plugins.load.load_matchmove.MatchmoveLoader.load","title":"<code>load(context, name=None, namespace=None, options=None)</code>","text":"<p>Load the matchmove script.</p> Source code in <code>client/ayon_maya/plugins/load/load_matchmove.py</code> <pre><code>def load(self,\n         context: dict,\n         name: Optional[str] = None,\n         namespace: Optional[str] = None,\n         options: Optional[dict] = None) -&gt; None:\n    \"\"\"Load the matchmove script.\"\"\"\n    path = Path(self.filepath_from_context(context))\n    if path.suffix.lower() == \".py\":\n        runpy.run_path(path.as_posix(), run_name=\"__main__\")\n\n    elif path.suffix.lower() == \".mel\":\n        cmds.file(\n            path.as_posix(), type=\"mel\",\n            renameAll=True, i=True, ignoreVersion=True,\n            importTimeRange=\"override\",\n            options=\"v=0;\", pr=True, loadReferenceDepth=\"all\")\n    else:\n        self.log.error(\"Unsupported script type %s\", path.suffix)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_maya_usd.html","title":"load_maya_usd","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_maya_usd.html#client.ayon_maya.plugins.load.load_maya_usd.MayaUsdLoader","title":"<code>MayaUsdLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Read USD data in a Maya USD Proxy</p> Source code in <code>client/ayon_maya/plugins/load/load_maya_usd.py</code> <pre><code>class MayaUsdLoader(plugin.Loader):\n    \"\"\"Read USD data in a Maya USD Proxy\"\"\"\n\n    product_types = {\"model\", \"usd\", \"pointcache\", \"animation\"}\n    representations = {\"usd\", \"usda\", \"usdc\", \"usdz\", \"abc\"}\n\n    label = \"Load USD to Maya Proxy\"\n    order = -1\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name=None, namespace=None, options=None):\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = namespace or unique_namespace(\n            folder_name + \"_\",\n            prefix=\"_\" if folder_name[0].isdigit() else \"\",\n            suffix=\"_\",\n        )\n\n        # Make sure we can load the plugin\n        cmds.loadPlugin(\"mayaUsdPlugin\", quiet=True)\n\n        path = self.filepath_from_context(context)\n\n        # Create the shape\n        cmds.namespace(addNamespace=namespace)\n        with namespaced(namespace, new=False):\n            transform = cmds.createNode(\"transform\",\n                                        name=name,\n                                        skipSelect=True)\n            proxy = cmds.createNode('mayaUsdProxyShape',\n                                    name=\"{}Shape\".format(name),\n                                    parent=transform,\n                                    skipSelect=True)\n\n            cmds.connectAttr(\"time1.outTime\", \"{}.time\".format(proxy))\n            cmds.setAttr(\"{}.filePath\".format(proxy), path, type=\"string\")\n\n            # By default, we force the proxy to not use a shared stage because\n            # when doing so Maya will quite easily allow to save into the\n            # loaded usd file. Since we are loading published files we want to\n            # avoid altering them. Unshared stages also save their edits into\n            # the workfile as an artist might expect it to do.\n            cmds.setAttr(\"{}.shareStage\".format(proxy), False)\n            # cmds.setAttr(\"{}.shareStage\".format(proxy), lock=True)\n\n        nodes = [transform, proxy]\n        self[:] = nodes\n\n        return containerise(\n            name=name,\n            namespace=namespace,\n            nodes=nodes,\n            context=context,\n            loader=self.__class__.__name__)\n\n    def update(self, container, context):\n        # type: (dict, dict) -&gt; None\n        \"\"\"Update container with specified representation.\"\"\"\n        node = container['objectName']\n        assert cmds.objExists(node), \"Missing container\"\n\n        members = cmds.sets(node, query=True) or []\n        shapes = cmds.ls(members, type=\"mayaUsdProxyShape\")\n\n        path = self.filepath_from_context(context)\n        for shape in shapes:\n            cmds.setAttr(\"{}.filePath\".format(shape), path, type=\"string\")\n\n        cmds.setAttr(\"{}.representation\".format(node),\n                     context[\"representation\"][\"id\"],\n                     type=\"string\")\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        # type: (dict) -&gt; None\n        \"\"\"Remove loaded container.\"\"\"\n        # Delete container and its contents\n        if cmds.objExists(container['objectName']):\n            members = cmds.sets(container['objectName'], query=True) or []\n            cmds.delete([container['objectName']] + members)\n\n        # Remove the namespace, if empty\n        namespace = container['namespace']\n        if cmds.namespace(exists=namespace):\n            members = cmds.namespaceInfo(namespace, listNamespace=True)\n            if not members:\n                cmds.namespace(removeNamespace=namespace)\n            else:\n                self.log.warning(\"Namespace not deleted because it \"\n                                 \"still has members: %s\", namespace)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_maya_usd.html#client.ayon_maya.plugins.load.load_maya_usd.MayaUsdLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove loaded container.</p> Source code in <code>client/ayon_maya/plugins/load/load_maya_usd.py</code> <pre><code>def remove(self, container):\n    # type: (dict) -&gt; None\n    \"\"\"Remove loaded container.\"\"\"\n    # Delete container and its contents\n    if cmds.objExists(container['objectName']):\n        members = cmds.sets(container['objectName'], query=True) or []\n        cmds.delete([container['objectName']] + members)\n\n    # Remove the namespace, if empty\n    namespace = container['namespace']\n    if cmds.namespace(exists=namespace):\n        members = cmds.namespaceInfo(namespace, listNamespace=True)\n        if not members:\n            cmds.namespace(removeNamespace=namespace)\n        else:\n            self.log.warning(\"Namespace not deleted because it \"\n                             \"still has members: %s\", namespace)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_maya_usd.html#client.ayon_maya.plugins.load.load_maya_usd.MayaUsdLoader.update","title":"<code>update(container, context)</code>","text":"<p>Update container with specified representation.</p> Source code in <code>client/ayon_maya/plugins/load/load_maya_usd.py</code> <pre><code>def update(self, container, context):\n    # type: (dict, dict) -&gt; None\n    \"\"\"Update container with specified representation.\"\"\"\n    node = container['objectName']\n    assert cmds.objExists(node), \"Missing container\"\n\n    members = cmds.sets(node, query=True) or []\n    shapes = cmds.ls(members, type=\"mayaUsdProxyShape\")\n\n    path = self.filepath_from_context(context)\n    for shape in shapes:\n        cmds.setAttr(\"{}.filePath\".format(shape), path, type=\"string\")\n\n    cmds.setAttr(\"{}.representation\".format(node),\n                 context[\"representation\"][\"id\"],\n                 type=\"string\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_multiverse_usd.html","title":"load_multiverse_usd","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_multiverse_usd.html#client.ayon_maya.plugins.load.load_multiverse_usd.MultiverseUsdLoader","title":"<code>MultiverseUsdLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Read USD data in a Multiverse Compound</p> Source code in <code>client/ayon_maya/plugins/load/load_multiverse_usd.py</code> <pre><code>class MultiverseUsdLoader(plugin.Loader):\n    \"\"\"Read USD data in a Multiverse Compound\"\"\"\n\n    product_types = {\n        \"model\",\n        \"usd\",\n        \"mvUsdComposition\",\n        \"mvUsdOverride\",\n        \"pointcache\",\n        \"animation\",\n    }\n    representations = {\"usd\", \"usda\", \"usdc\", \"usdz\", \"abc\"}\n\n    label = \"Load USD to Multiverse\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name=None, namespace=None, options=None):\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = namespace or unique_namespace(\n            folder_name + \"_\",\n            prefix=\"_\" if folder_name[0].isdigit() else \"\",\n            suffix=\"_\",\n        )\n\n        path = self.filepath_from_context(context)\n\n        # Make sure we can load the plugin\n        cmds.loadPlugin(\"MultiverseForMaya\", quiet=True)\n        import multiverse\n\n        # Create the shape\n        with maintained_selection():\n            cmds.namespace(addNamespace=namespace)\n            with namespaced(namespace, new=False):\n                shape = multiverse.CreateUsdCompound(path)\n                transform = cmds.listRelatives(\n                    shape, parent=True, fullPath=True)[0]\n\n        nodes = [transform, shape]\n        self[:] = nodes\n\n        return containerise(\n            name=name,\n            namespace=namespace,\n            nodes=nodes,\n            context=context,\n            loader=self.__class__.__name__)\n\n    def update(self, container, context):\n        # type: (dict, dict) -&gt; None\n        \"\"\"Update container with specified representation.\"\"\"\n        node = container['objectName']\n        assert cmds.objExists(node), \"Missing container\"\n\n        members = cmds.sets(node, query=True) or []\n        shapes = cmds.ls(members, type=\"mvUsdCompoundShape\")\n        assert shapes, \"Cannot find mvUsdCompoundShape in container\"\n\n        project_name = context[\"project\"][\"name\"]\n        repre_entity = context[\"representation\"]\n        path = self.filepath_from_context(context)\n        prev_representation_id = cmds.getAttr(\"{}.representation\".format(node))\n        prev_representation = get_representation_by_id(project_name,\n                                                       prev_representation_id)\n        prev_path = os.path.normpath(prev_representation[\"attrib\"][\"path\"])\n\n        # Make sure we can load the plugin\n        cmds.loadPlugin(\"MultiverseForMaya\", quiet=True)\n        import multiverse\n\n        for shape in shapes:\n\n            asset_paths = multiverse.GetUsdCompoundAssetPaths(shape)\n            asset_paths = [os.path.normpath(p) for p in asset_paths]\n\n            assert asset_paths.count(prev_path) == 1, \\\n                \"Couldn't find matching path (or too many)\"\n            prev_path_idx = asset_paths.index(prev_path)\n\n            asset_paths[prev_path_idx] = path\n\n            multiverse.SetUsdCompoundAssetPaths(shape, asset_paths)\n\n        cmds.setAttr(\"{}.representation\".format(node),\n                     repre_entity[\"id\"],\n                     type=\"string\")\n        mel.eval('refreshEditorTemplates;')\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        # type: (dict) -&gt; None\n        \"\"\"Remove loaded container.\"\"\"\n        # Delete container and its contents\n        if cmds.objExists(container['objectName']):\n            members = cmds.sets(container['objectName'], query=True) or []\n            cmds.delete([container['objectName']] + members)\n\n        # Remove the namespace, if empty\n        namespace = container['namespace']\n        if cmds.namespace(exists=namespace):\n            members = cmds.namespaceInfo(namespace, listNamespace=True)\n            if not members:\n                cmds.namespace(removeNamespace=namespace)\n            else:\n                self.log.warning(\"Namespace not deleted because it \"\n                                 \"still has members: %s\", namespace)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_multiverse_usd.html#client.ayon_maya.plugins.load.load_multiverse_usd.MultiverseUsdLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove loaded container.</p> Source code in <code>client/ayon_maya/plugins/load/load_multiverse_usd.py</code> <pre><code>def remove(self, container):\n    # type: (dict) -&gt; None\n    \"\"\"Remove loaded container.\"\"\"\n    # Delete container and its contents\n    if cmds.objExists(container['objectName']):\n        members = cmds.sets(container['objectName'], query=True) or []\n        cmds.delete([container['objectName']] + members)\n\n    # Remove the namespace, if empty\n    namespace = container['namespace']\n    if cmds.namespace(exists=namespace):\n        members = cmds.namespaceInfo(namespace, listNamespace=True)\n        if not members:\n            cmds.namespace(removeNamespace=namespace)\n        else:\n            self.log.warning(\"Namespace not deleted because it \"\n                             \"still has members: %s\", namespace)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_multiverse_usd.html#client.ayon_maya.plugins.load.load_multiverse_usd.MultiverseUsdLoader.update","title":"<code>update(container, context)</code>","text":"<p>Update container with specified representation.</p> Source code in <code>client/ayon_maya/plugins/load/load_multiverse_usd.py</code> <pre><code>def update(self, container, context):\n    # type: (dict, dict) -&gt; None\n    \"\"\"Update container with specified representation.\"\"\"\n    node = container['objectName']\n    assert cmds.objExists(node), \"Missing container\"\n\n    members = cmds.sets(node, query=True) or []\n    shapes = cmds.ls(members, type=\"mvUsdCompoundShape\")\n    assert shapes, \"Cannot find mvUsdCompoundShape in container\"\n\n    project_name = context[\"project\"][\"name\"]\n    repre_entity = context[\"representation\"]\n    path = self.filepath_from_context(context)\n    prev_representation_id = cmds.getAttr(\"{}.representation\".format(node))\n    prev_representation = get_representation_by_id(project_name,\n                                                   prev_representation_id)\n    prev_path = os.path.normpath(prev_representation[\"attrib\"][\"path\"])\n\n    # Make sure we can load the plugin\n    cmds.loadPlugin(\"MultiverseForMaya\", quiet=True)\n    import multiverse\n\n    for shape in shapes:\n\n        asset_paths = multiverse.GetUsdCompoundAssetPaths(shape)\n        asset_paths = [os.path.normpath(p) for p in asset_paths]\n\n        assert asset_paths.count(prev_path) == 1, \\\n            \"Couldn't find matching path (or too many)\"\n        prev_path_idx = asset_paths.index(prev_path)\n\n        asset_paths[prev_path_idx] = path\n\n        multiverse.SetUsdCompoundAssetPaths(shape, asset_paths)\n\n    cmds.setAttr(\"{}.representation\".format(node),\n                 repre_entity[\"id\"],\n                 type=\"string\")\n    mel.eval('refreshEditorTemplates;')\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_multiverse_usd_over.html","title":"load_multiverse_usd_over","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_multiverse_usd_over.html#client.ayon_maya.plugins.load.load_multiverse_usd_over.MultiverseUsdOverLoader","title":"<code>MultiverseUsdOverLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Reference file</p> Source code in <code>client/ayon_maya/plugins/load/load_multiverse_usd_over.py</code> <pre><code>class MultiverseUsdOverLoader(plugin.Loader):\n    \"\"\"Reference file\"\"\"\n\n    product_types = {\"mvUsdOverride\"}\n    representations = {\"usda\", \"usd\", \"udsz\"}\n\n    label = \"Load Usd Override into Compound\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    options = [\n        qargparse.String(\n            \"Which Compound\",\n            label=\"Compound\",\n            help=\"Select which compound to add this as a layer to.\"\n        )\n    ]\n\n    def load(self, context, name=None, namespace=None, options=None):\n        current_usd = cmds.ls(selection=True,\n                              type=\"mvUsdCompoundShape\",\n                              dag=True,\n                              long=True)\n        if len(current_usd) != 1:\n            self.log.error(\"Current selection invalid: '{}', \"\n                           \"must contain exactly 1 mvUsdCompoundShape.\"\n                           \"\".format(current_usd))\n            return\n\n        # Make sure we can load the plugin\n        cmds.loadPlugin(\"MultiverseForMaya\", quiet=True)\n        import multiverse\n\n        path = self.filepath_from_context(context)\n        nodes = current_usd\n        with maintained_selection():\n            multiverse.AddUsdCompoundAssetPath(current_usd[0], path)\n\n        namespace = current_usd[0].split(\"|\")[1].split(\":\")[0]\n\n        container = containerise(\n            name=name,\n            namespace=namespace,\n            nodes=nodes,\n            context=context,\n            loader=self.__class__.__name__)\n\n        cmds.addAttr(container, longName=\"mvUsdCompoundShape\",\n                     niceName=\"mvUsdCompoundShape\", dataType=\"string\")\n        cmds.setAttr(container + \".mvUsdCompoundShape\",\n                     current_usd[0], type=\"string\")\n\n        return container\n\n    def update(self, container, context):\n        # type: (dict, dict) -&gt; None\n        \"\"\"Update container with specified representation.\"\"\"\n\n        cmds.loadPlugin(\"MultiverseForMaya\", quiet=True)\n        import multiverse\n\n        node = container['objectName']\n        assert cmds.objExists(node), \"Missing container\"\n\n        members = cmds.sets(node, query=True) or []\n        shapes = cmds.ls(members, type=\"mvUsdCompoundShape\")\n        assert shapes, \"Cannot find mvUsdCompoundShape in container\"\n\n        mvShape = container['mvUsdCompoundShape']\n        assert mvShape, \"Missing mv source\"\n\n        project_name = context[\"project\"][\"name\"]\n        repre_entity = context[\"representation\"]\n        prev_representation_id = cmds.getAttr(\"{}.representation\".format(node))\n        prev_representation = get_representation_by_id(project_name,\n                                                       prev_representation_id)\n        prev_path = os.path.normpath(prev_representation[\"attrib\"][\"path\"])\n\n        path = self.filepath_from_context(context)\n\n        for shape in shapes:\n            asset_paths = multiverse.GetUsdCompoundAssetPaths(shape)\n            asset_paths = [os.path.normpath(p) for p in asset_paths]\n\n            assert asset_paths.count(prev_path) == 1, \\\n                \"Couldn't find matching path (or too many)\"\n            prev_path_idx = asset_paths.index(prev_path)\n            asset_paths[prev_path_idx] = path\n            multiverse.SetUsdCompoundAssetPaths(shape, asset_paths)\n\n        cmds.setAttr(\"{}.representation\".format(node),\n                     repre_entity[\"id\"],\n                     type=\"string\")\n        mel.eval('refreshEditorTemplates;')\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        # type: (dict) -&gt; None\n        \"\"\"Remove loaded container.\"\"\"\n        # Delete container and its contents\n        if cmds.objExists(container['objectName']):\n            members = cmds.sets(container['objectName'], query=True) or []\n            cmds.delete([container['objectName']] + members)\n\n        # Remove the namespace, if empty\n        namespace = container['namespace']\n        if cmds.namespace(exists=namespace):\n            members = cmds.namespaceInfo(namespace, listNamespace=True)\n            if not members:\n                cmds.namespace(removeNamespace=namespace)\n            else:\n                self.log.warning(\"Namespace not deleted because it \"\n                                 \"still has members: %s\", namespace)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_multiverse_usd_over.html#client.ayon_maya.plugins.load.load_multiverse_usd_over.MultiverseUsdOverLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove loaded container.</p> Source code in <code>client/ayon_maya/plugins/load/load_multiverse_usd_over.py</code> <pre><code>def remove(self, container):\n    # type: (dict) -&gt; None\n    \"\"\"Remove loaded container.\"\"\"\n    # Delete container and its contents\n    if cmds.objExists(container['objectName']):\n        members = cmds.sets(container['objectName'], query=True) or []\n        cmds.delete([container['objectName']] + members)\n\n    # Remove the namespace, if empty\n    namespace = container['namespace']\n    if cmds.namespace(exists=namespace):\n        members = cmds.namespaceInfo(namespace, listNamespace=True)\n        if not members:\n            cmds.namespace(removeNamespace=namespace)\n        else:\n            self.log.warning(\"Namespace not deleted because it \"\n                             \"still has members: %s\", namespace)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_multiverse_usd_over.html#client.ayon_maya.plugins.load.load_multiverse_usd_over.MultiverseUsdOverLoader.update","title":"<code>update(container, context)</code>","text":"<p>Update container with specified representation.</p> Source code in <code>client/ayon_maya/plugins/load/load_multiverse_usd_over.py</code> <pre><code>def update(self, container, context):\n    # type: (dict, dict) -&gt; None\n    \"\"\"Update container with specified representation.\"\"\"\n\n    cmds.loadPlugin(\"MultiverseForMaya\", quiet=True)\n    import multiverse\n\n    node = container['objectName']\n    assert cmds.objExists(node), \"Missing container\"\n\n    members = cmds.sets(node, query=True) or []\n    shapes = cmds.ls(members, type=\"mvUsdCompoundShape\")\n    assert shapes, \"Cannot find mvUsdCompoundShape in container\"\n\n    mvShape = container['mvUsdCompoundShape']\n    assert mvShape, \"Missing mv source\"\n\n    project_name = context[\"project\"][\"name\"]\n    repre_entity = context[\"representation\"]\n    prev_representation_id = cmds.getAttr(\"{}.representation\".format(node))\n    prev_representation = get_representation_by_id(project_name,\n                                                   prev_representation_id)\n    prev_path = os.path.normpath(prev_representation[\"attrib\"][\"path\"])\n\n    path = self.filepath_from_context(context)\n\n    for shape in shapes:\n        asset_paths = multiverse.GetUsdCompoundAssetPaths(shape)\n        asset_paths = [os.path.normpath(p) for p in asset_paths]\n\n        assert asset_paths.count(prev_path) == 1, \\\n            \"Couldn't find matching path (or too many)\"\n        prev_path_idx = asset_paths.index(prev_path)\n        asset_paths[prev_path_idx] = path\n        multiverse.SetUsdCompoundAssetPaths(shape, asset_paths)\n\n    cmds.setAttr(\"{}.representation\".format(node),\n                 repre_entity[\"id\"],\n                 type=\"string\")\n    mel.eval('refreshEditorTemplates;')\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_ornatrix_alembic.html","title":"load_ornatrix_alembic","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_ornatrix_alembic.html#client.ayon_maya.plugins.load.load_ornatrix_alembic.OxAlembicLoader","title":"<code>OxAlembicLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Ornatrix Alembic Loader</p> Source code in <code>client/ayon_maya/plugins/load/load_ornatrix_alembic.py</code> <pre><code>class OxAlembicLoader(plugin.Loader):\n    \"\"\"Ornatrix Alembic Loader\"\"\"\n\n    product_types = {\"oxcache\", \"oxrig\"}\n    representations = {\"abc\"}\n\n    label = \"Ornatrix Alembic Loader\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    @classmethod\n    def get_options(cls, contexts):\n        return [\n            EnumDef(\n                \"import_options\",\n                label=\"Import Options for Ornatrix Cache\",\n                items={\n                    0: \"Hair\",\n                    1: \"Guide\"\n                },\n                default=0\n            )\n        ]\n\n    def load(self, context, name, namespace, options):\n        cmds.loadPlugin(\"Ornatrix\", quiet=True)\n        # Build namespace\n        folder_name = context[\"folder\"][\"name\"]\n        if namespace is None:\n            namespace = self.create_namespace(folder_name)\n\n        path = self.filepath_from_context(context)\n        path = path.replace(\"\\\\\", \"/\")\n\n        ox_import_options = \"; importAs={}\".format(\n            options.get(\"import_options\"))\n        group_name = \"{}:{}\".format(namespace, name)\n        project_name = context[\"project\"][\"name\"]\n\n        with maintained_selection():\n            nodes = cmds.file(\n                path,\n                i=True,\n                type=\"Ornatrix Alembic Import\",\n                namespace=namespace,\n                returnNewNodes=True,\n                groupName=group_name,\n                options=ox_import_options\n            )\n            nodes = cmds.ls(nodes)\n        group_node = cmds.group(nodes, name=group_name)\n\n        settings = get_project_settings(project_name)\n        product_type = context[\"product\"][\"productType\"]\n        color = get_load_color_for_product_type(product_type, settings)\n        if color is not None:\n            red, green, blue = color\n            cmds.setAttr(group_node + \".useOutlinerColor\", 1)\n            cmds.setAttr(group_node + \".outlinerColor\", red, green, blue)\n\n        nodes.append(group_node)\n\n        self[:] = nodes\n\n        return containerise(\n            name=name,\n            namespace=namespace,\n            nodes=nodes,\n            context=context,\n            loader=self.__class__.__name__\n        )\n\n    def update(self, container, context):\n        path = self.filepath_from_context(context)\n        members = lib.get_container_members(container)\n        ox_nodes = cmds.ls(members, type=\"BakedHairNode\", long=True)\n        for node in ox_nodes:\n            cmds.setAttr(f\"{node}.sourceFilePath1\", path, type=\"string\")\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        self.log.info(\"Removing '%s' from Maya..\" % container[\"name\"])\n\n        nodes = lib.get_container_members(container)\n        cmds.delete(nodes)\n\n        namespace = container[\"namespace\"]\n        cmds.namespace(removeNamespace=namespace, deleteNamespaceContent=True)\n\n    def create_namespace(self, folder_name):\n        \"\"\"Create a unique namespace\n        Args:\n            folder_name (str): Folder name\n\n        Returns:\n            str: The unique namespace for the folder.\n        \"\"\"\n\n        asset_name = \"{}_\".format(folder_name)\n        prefix = \"_\" if asset_name[0].isdigit() else \"\"\n        namespace = unique_namespace(\n            asset_name,\n            prefix=prefix,\n            suffix=\"_\"\n        )\n\n        return namespace\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_ornatrix_alembic.html#client.ayon_maya.plugins.load.load_ornatrix_alembic.OxAlembicLoader.create_namespace","title":"<code>create_namespace(folder_name)</code>","text":"<p>Create a unique namespace Args:     folder_name (str): Folder name</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The unique namespace for the folder.</p> Source code in <code>client/ayon_maya/plugins/load/load_ornatrix_alembic.py</code> <pre><code>def create_namespace(self, folder_name):\n    \"\"\"Create a unique namespace\n    Args:\n        folder_name (str): Folder name\n\n    Returns:\n        str: The unique namespace for the folder.\n    \"\"\"\n\n    asset_name = \"{}_\".format(folder_name)\n    prefix = \"_\" if asset_name[0].isdigit() else \"\"\n    namespace = unique_namespace(\n        asset_name,\n        prefix=prefix,\n        suffix=\"_\"\n    )\n\n    return namespace\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_ornatrix_rig.html","title":"load_ornatrix_rig","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_ornatrix_rig.html#client.ayon_maya.plugins.load.load_ornatrix_rig.OxRigLoader","title":"<code>OxRigLoader</code>","text":"<p>               Bases: <code>ReferenceLoader</code></p> <p>This loader will load Ornatrix rig.</p> Source code in <code>client/ayon_maya/plugins/load/load_ornatrix_rig.py</code> <pre><code>class OxRigLoader(plugin.ReferenceLoader):\n    \"\"\"This loader will load Ornatrix rig.\"\"\"\n\n    product_types = {\"oxrig\"}\n    representations = {\"ma\"}\n\n    label = \"Load Ornatrix Rig\"\n    order = -11\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    # From settings\n    create_cache_instance_on_load = True\n\n    def process_reference(\n        self, context, name=None, namespace=None, options=None\n    ):\n        cmds.loadPlugin(\"Ornatrix\", quiet=True)\n\n        attach_to_root = options.get(\"attach_to_root\", True)\n        group_name = options[\"group_name\"]\n\n        # no group shall be created\n        if not attach_to_root:\n            group_name = namespace\n\n        path = self.filepath_from_context(context)\n        file_url = self.prepare_root_value(path, context[\"project\"][\"name\"])\n        with lib.maintained_selection():\n            nodes = cmds.file(\n                file_url,\n                namespace=namespace,\n                reference=True,\n                returnNewNodes=True,\n                groupReference=attach_to_root,\n                groupName=group_name\n            )\n\n        color = plugin.get_load_color_for_product_type(\"oxrig\")\n        if color is not None:\n            red, green, blue = color\n            cmds.setAttr(group_name + \".useOutlinerColor\", 1)\n            cmds.setAttr(\n                group_name + \".outlinerColor\", red, green, blue\n            )\n\n        self[:] = nodes\n\n        if self.create_cache_instance_on_load:\n            self._create_ox_cache_instance(nodes, variant=namespace)\n\n        return nodes\n\n    def _create_ox_cache_instance(self, nodes: List[str], variant: str):\n        \"\"\"Create an ornatrixcache product type instance to publish the output.\n\n        This is similar to how loading animation rig will automatically create\n        an animation instance for publishing any loaded character rigs, but\n        then for Ornatrix rigs.\n\n        Args:\n            nodes (List[str]): Nodes generated on load.\n            variant (str): Variant for the ornatrix cache instance to create.\n\n        \"\"\"\n\n        # Check of the nodes connect to the ornatrix-related nodes\n        ox_node_types = (\n            \"HairFromGuidesNode\", \"GuidesFromMeshNode\",\n            \"MeshFromStrandsNode\", \"SurfaceCombNode\"\n        )\n        # Check of the nodes connect to the ornatrix-related nodes\n        ox_nodes = cmds.ls(nodes, type=ox_node_types)\n        assert ox_nodes, \"No Ornatrix nodes in rig, this is a bug.\"\n\n        ox_geo_nodes = cmds.ls(nodes, assemblies=True, long=True)\n\n        self.log.info(\"Creating variant: {}\".format(variant))\n\n        creator_identifier = \"io.ayon.creators.maya.oxcache\"\n\n        host = registered_host()\n        create_context = CreateContext(host)\n\n        with lib.maintained_selection():\n            cmds.select(ox_geo_nodes, noExpand=True)\n            create_context.create(\n                creator_identifier=creator_identifier,\n                variant=variant,\n                pre_create_data={\"use_selection\": True}\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_redshift_proxy.html","title":"load_redshift_proxy","text":"<p>Loader for Redshift proxy.</p>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_redshift_proxy.html#client.ayon_maya.plugins.load.load_redshift_proxy.RedshiftProxyLoader","title":"<code>RedshiftProxyLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load Redshift proxy</p> Source code in <code>client/ayon_maya/plugins/load/load_redshift_proxy.py</code> <pre><code>class RedshiftProxyLoader(plugin.Loader):\n    \"\"\"Load Redshift proxy\"\"\"\n\n    product_types = {\"*\"}\n    representations = {\"*\"}\n    extensions = {\"rs\", \"usd\", \"usda\", \"usdc\", \"abc\"}\n\n    label = \"Import Redshift Proxy\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name=None, namespace=None, options=None):\n        \"\"\"Plugin entry point.\"\"\"\n        product_type = context[\"product\"][\"productType\"]\n\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = namespace or unique_namespace(\n            folder_name + \"_\",\n            prefix=\"_\" if folder_name[0].isdigit() else \"\",\n            suffix=\"_\",\n        )\n\n        # Ensure Redshift for Maya is loaded.\n        cmds.loadPlugin(\"redshift4maya\", quiet=True)\n\n        path = self.filepath_from_context(context)\n        with maintained_selection():\n            cmds.namespace(addNamespace=namespace)\n            with namespaced(namespace, new=False):\n                nodes, group_node = self.create_rs_proxy(name, path)\n\n        proxy = nodes[0]  # RedshiftProxyMesh\n        self._set_rs_proxy_file_type(proxy, path)\n\n        self[:] = nodes\n        if not nodes:\n            return\n\n        # colour the group node\n        project_name = context[\"project\"][\"name\"]\n        settings = get_project_settings(project_name)\n        color = get_load_color_for_product_type(product_type, settings)\n        if color is not None:\n            red, green, blue = color\n            cmds.setAttr(\"{0}.useOutlinerColor\".format(group_node), 1)\n            cmds.setAttr(\n                \"{0}.outlinerColor\".format(group_node), red, green, blue\n            )\n\n        return containerise(\n            name=name,\n            namespace=namespace,\n            nodes=nodes,\n            context=context,\n            loader=self.__class__.__name__)\n\n    def update(self, container, context):\n\n        node = container['objectName']\n        assert cmds.objExists(node), \"Missing container\"\n\n        members = cmds.sets(node, query=True) or []\n        rs_meshes = cmds.ls(members, type=\"RedshiftProxyMesh\")\n        assert rs_meshes, \"Cannot find RedshiftProxyMesh in container\"\n        repre_entity = context[\"representation\"]\n        filename = self.filepath_from_context(context)\n\n        for rs_mesh in rs_meshes:\n            cmds.setAttr(\"{}.fileName\".format(rs_mesh),\n                         filename,\n                         type=\"string\")\n            self._set_rs_proxy_file_type(rs_mesh, filename)\n\n        # Update metadata\n        cmds.setAttr(\"{}.representation\".format(node),\n                     repre_entity[\"id\"],\n                     type=\"string\")\n\n    def remove(self, container):\n\n        # Delete container and its contents\n        if cmds.objExists(container['objectName']):\n            members = cmds.sets(container['objectName'], query=True) or []\n            cmds.delete([container['objectName']] + members)\n\n        # Remove the namespace, if empty\n        namespace = container['namespace']\n        if cmds.namespace(exists=namespace):\n            members = cmds.namespaceInfo(namespace, listNamespace=True)\n            if not members:\n                cmds.namespace(removeNamespace=namespace)\n            else:\n                self.log.warning(\"Namespace not deleted because it \"\n                                 \"still has members: %s\", namespace)\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def create_rs_proxy(self, name, path):\n        \"\"\"Creates Redshift Proxies showing a proxy object.\n\n        Args:\n            name (str): Proxy name.\n            path (str): Path to proxy file.\n\n        Returns:\n            (str, str): Name of mesh with Redshift proxy and its parent\n                transform.\n\n        \"\"\"\n        rs_mesh = cmds.createNode(\n            'RedshiftProxyMesh', name=\"{}_RS\".format(name))\n        mesh_shape = cmds.createNode(\"mesh\", name=\"{}_GEOShape\".format(name))\n\n        cmds.setAttr(\"{}.fileName\".format(rs_mesh),\n                     path,\n                     type=\"string\")\n\n        cmds.connectAttr(\"{}.outMesh\".format(rs_mesh),\n                         \"{}.inMesh\".format(mesh_shape))\n\n        # TODO: use the assigned shading group as shaders if existed\n        # assign default shader to redshift proxy\n        if cmds.ls(\"initialShadingGroup\", type=\"shadingEngine\"):\n            cmds.sets(mesh_shape, forceElement=\"initialShadingGroup\")\n\n        group_node = cmds.group(empty=True, name=\"{}_GRP\".format(name))\n        mesh_transform = cmds.listRelatives(mesh_shape,\n                                            parent=True, fullPath=True)\n        cmds.parent(mesh_transform, group_node)\n        nodes = [rs_mesh, mesh_shape, group_node]\n\n        # determine if we need to enable animation support\n        files_in_folder = os.listdir(os.path.dirname(path))\n        collections, remainder = clique.assemble(files_in_folder)\n\n        if collections:\n            cmds.setAttr(\"{}.useFrameExtension\".format(rs_mesh), 1)\n\n        return nodes, group_node\n\n    def _set_rs_proxy_file_type(self, proxy: str, path: str):\n        \"\"\"Set Redshift Proxy file type attribute based on input file.\"\"\"\n\n        extension = os.path.splitext(path)[1].lower()\n        file_type = {\n            \".rs\": 0,\n            \".usd\": 1,\n            \".abc\": 2\n        }.get(extension, None)\n\n        # If file type is not recognized, log a warning\n        if file_type is None:\n            self.log.warning(\"Unknown file type: %s. \"\n                             \"File Type may be set incorrectly\", extension)\n            return\n\n        # If this redshift release (prior to 2025.4.0+) does not have the\n        # `proxyFileType` attribute and the file type is not 0 (rsproxy), then\n        # log a warning\n        if not cmds.attributeQuery(\"proxyFileType\", node=proxy, exists=True):\n            if file_type != 0:\n                self.log.warning(\n                    \"Redshift Proxy file type attribute not found. File Type\"\n                    \" may be set incorrectly. You may need a newer Redshift\"\n                    \" release (2025.4.0+) to support USD and Alembic in\"\n                    \" Redshift Proxies. \")\n            return\n\n        cmds.setAttr(proxy + \".proxyFileType\", file_type)\n\n    @classmethod\n    def get_representation_name_aliases(cls, representation_name):\n        # Allow switching between the different supported representations\n        # automatically if a newer version does not have the currently used\n        # representation\n        return [\"rs\", \"usd\", \"abc\"]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_redshift_proxy.html#client.ayon_maya.plugins.load.load_redshift_proxy.RedshiftProxyLoader.create_rs_proxy","title":"<code>create_rs_proxy(name, path)</code>","text":"<p>Creates Redshift Proxies showing a proxy object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Proxy name.</p> required <code>path</code> <code>str</code> <p>Path to proxy file.</p> required <p>Returns:</p> Type Description <code>(str, str)</code> <p>Name of mesh with Redshift proxy and its parent transform.</p> Source code in <code>client/ayon_maya/plugins/load/load_redshift_proxy.py</code> <pre><code>def create_rs_proxy(self, name, path):\n    \"\"\"Creates Redshift Proxies showing a proxy object.\n\n    Args:\n        name (str): Proxy name.\n        path (str): Path to proxy file.\n\n    Returns:\n        (str, str): Name of mesh with Redshift proxy and its parent\n            transform.\n\n    \"\"\"\n    rs_mesh = cmds.createNode(\n        'RedshiftProxyMesh', name=\"{}_RS\".format(name))\n    mesh_shape = cmds.createNode(\"mesh\", name=\"{}_GEOShape\".format(name))\n\n    cmds.setAttr(\"{}.fileName\".format(rs_mesh),\n                 path,\n                 type=\"string\")\n\n    cmds.connectAttr(\"{}.outMesh\".format(rs_mesh),\n                     \"{}.inMesh\".format(mesh_shape))\n\n    # TODO: use the assigned shading group as shaders if existed\n    # assign default shader to redshift proxy\n    if cmds.ls(\"initialShadingGroup\", type=\"shadingEngine\"):\n        cmds.sets(mesh_shape, forceElement=\"initialShadingGroup\")\n\n    group_node = cmds.group(empty=True, name=\"{}_GRP\".format(name))\n    mesh_transform = cmds.listRelatives(mesh_shape,\n                                        parent=True, fullPath=True)\n    cmds.parent(mesh_transform, group_node)\n    nodes = [rs_mesh, mesh_shape, group_node]\n\n    # determine if we need to enable animation support\n    files_in_folder = os.listdir(os.path.dirname(path))\n    collections, remainder = clique.assemble(files_in_folder)\n\n    if collections:\n        cmds.setAttr(\"{}.useFrameExtension\".format(rs_mesh), 1)\n\n    return nodes, group_node\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_redshift_proxy.html#client.ayon_maya.plugins.load.load_redshift_proxy.RedshiftProxyLoader.load","title":"<code>load(context, name=None, namespace=None, options=None)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_maya/plugins/load/load_redshift_proxy.py</code> <pre><code>def load(self, context, name=None, namespace=None, options=None):\n    \"\"\"Plugin entry point.\"\"\"\n    product_type = context[\"product\"][\"productType\"]\n\n    folder_name = context[\"folder\"][\"name\"]\n    namespace = namespace or unique_namespace(\n        folder_name + \"_\",\n        prefix=\"_\" if folder_name[0].isdigit() else \"\",\n        suffix=\"_\",\n    )\n\n    # Ensure Redshift for Maya is loaded.\n    cmds.loadPlugin(\"redshift4maya\", quiet=True)\n\n    path = self.filepath_from_context(context)\n    with maintained_selection():\n        cmds.namespace(addNamespace=namespace)\n        with namespaced(namespace, new=False):\n            nodes, group_node = self.create_rs_proxy(name, path)\n\n    proxy = nodes[0]  # RedshiftProxyMesh\n    self._set_rs_proxy_file_type(proxy, path)\n\n    self[:] = nodes\n    if not nodes:\n        return\n\n    # colour the group node\n    project_name = context[\"project\"][\"name\"]\n    settings = get_project_settings(project_name)\n    color = get_load_color_for_product_type(product_type, settings)\n    if color is not None:\n        red, green, blue = color\n        cmds.setAttr(\"{0}.useOutlinerColor\".format(group_node), 1)\n        cmds.setAttr(\n            \"{0}.outlinerColor\".format(group_node), red, green, blue\n        )\n\n    return containerise(\n        name=name,\n        namespace=namespace,\n        nodes=nodes,\n        context=context,\n        loader=self.__class__.__name__)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_reference.html","title":"load_reference","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_reference.html#client.ayon_maya.plugins.load.load_reference.MayaUSDReferenceLoader","title":"<code>MayaUSDReferenceLoader</code>","text":"<p>               Bases: <code>ReferenceLoader</code></p> <p>Reference USD file to native Maya nodes using MayaUSDImport reference</p> Source code in <code>client/ayon_maya/plugins/load/load_reference.py</code> <pre><code>class MayaUSDReferenceLoader(ReferenceLoader):\n    \"\"\"Reference USD file to native Maya nodes using MayaUSDImport reference\"\"\"\n\n    label = \"Reference Maya USD\"\n    product_types = {\"usd\"}\n    representations = {\"usd\"}\n    extensions = {\"usd\", \"usda\", \"usdc\"}\n\n    options = ReferenceLoader.options + [\n        qargparse.Boolean(\n            \"readAnimData\",\n            label=\"Load anim data\",\n            default=True,\n            help=\"Load animation data from USD file\"\n        ),\n        qargparse.Boolean(\n            \"useAsAnimationCache\",\n            label=\"Use as animation cache\",\n            default=True,\n            help=(\n                \"Imports geometry prims with time-sampled point data using a \"\n                \"point-based deformer that references the imported \"\n                \"USD file.\\n\"\n                \"This provides better import and playback performance when \"\n                \"importing time-sampled geometry from USD, and should \"\n                \"reduce the weight of the resulting Maya scene.\"\n            )\n        ),\n        qargparse.Boolean(\n            \"importInstances\",\n            label=\"Import instances\",\n            default=True,\n            help=(\n                \"Import USD instanced geometries as Maya instanced shapes. \"\n                \"Will flatten the scene otherwise.\"\n            )\n        ),\n        qargparse.String(\n            \"primPath\",\n            label=\"Prim Path\",\n            default=\"/\",\n            help=(\n                \"Name of the USD scope where traversing will begin.\\n\"\n                \"The prim at the specified primPath (including the prim) will \"\n                \"be imported.\\n\"\n                \"Specifying the pseudo-root (/) means you want \"\n                \"to import everything in the file.\\n\"\n                \"If the passed prim path is empty, it will first try to \"\n                \"import the defaultPrim for the rootLayer if it exists.\\n\"\n                \"Otherwise, it will behave as if the pseudo-root was passed \"\n                \"in.\"\n            )\n        )\n    ]\n\n    file_type = \"USD Import\"\n\n    def process_reference(self, context, name, namespace, options):\n        cmds.loadPlugin(\"mayaUsdPlugin\", quiet=True)\n\n        def bool_option(key, default):\n            # Shorthand for getting optional boolean file option from options\n            value = int(bool(options.get(key, default)))\n            return \"{}={}\".format(key, value)\n\n        def string_option(key, default):\n            # Shorthand for getting optional string file option from options\n            value = str(options.get(key, default))\n            return \"{}={}\".format(key, value)\n\n        options[\"file_options\"] = \";\".join([\n            string_option(\"primPath\", default=\"/\"),\n            bool_option(\"importInstances\", default=True),\n            bool_option(\"useAsAnimationCache\", default=True),\n            bool_option(\"readAnimData\", default=True),\n            # TODO: Expose more parameters\n            # \"preferredMaterial=none\",\n            # \"importRelativeTextures=Automatic\",\n            # \"useCustomFrameRange=0\",\n            # \"startTime=0\",\n            # \"endTime=0\",\n            # \"importUSDZTextures=0\"\n            # Avoid any automatic up-axis and unit conversions\n            # TODO: Expose as optional options\n            \"upAxis=0\",\n            \"unit=0\"\n        ])\n        options[\"file_type\"] = self.file_type\n\n        # Maya USD import reference has the tendency to change the time slider\n        # range and current frame, so we force revert it after\n        with preserve_time_units():\n            return super(MayaUSDReferenceLoader, self).process_reference(\n                context, name, namespace, options\n            )\n\n    def update(self, container, context):\n        # Maya USD import reference has the tendency to change the time slider\n        # range and current frame, so we force revert it after\n        with preserve_time_units():\n            super(MayaUSDReferenceLoader, self).update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_reference.html#client.ayon_maya.plugins.load.load_reference.ReferenceLoader","title":"<code>ReferenceLoader</code>","text":"<p>               Bases: <code>ReferenceLoader</code></p> <p>Reference file</p> Source code in <code>client/ayon_maya/plugins/load/load_reference.py</code> <pre><code>class ReferenceLoader(plugin.ReferenceLoader):\n    \"\"\"Reference file\"\"\"\n\n    product_types = {\n        \"model\",\n        \"pointcache\",\n        \"proxyAbc\",\n        \"animation\",\n        \"mayaAscii\",\n        \"mayaScene\",\n        \"setdress\",\n        \"layout\",\n        \"camera\",\n        \"rig\",\n        \"camerarig\",\n        \"staticMesh\",\n        \"skeletalMesh\",\n        \"mvLook\",\n        \"matchmove\",\n    }\n\n    representations = {\"ma\", \"abc\", \"fbx\", \"mb\"}\n\n    label = \"Reference\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def process_reference(self, context, name, namespace, options):\n        import maya.cmds as cmds\n        product_type = context[\"product\"][\"productType\"]\n        project_name = context[\"project\"][\"name\"]\n        # True by default to keep legacy behaviours\n        attach_to_root = options.get(\"attach_to_root\", True)\n        group_name = options[\"group_name\"]\n\n        # no group shall be created\n        if not attach_to_root:\n            group_name = namespace\n\n        kwargs = {}\n        if \"file_options\" in options:\n            kwargs[\"options\"] = options[\"file_options\"]\n        if \"file_type\" in options:\n            kwargs[\"type\"] = options[\"file_type\"]\n\n        path = self.filepath_from_context(context)\n        with maintained_selection():\n            cmds.loadPlugin(\"AbcImport.mll\", quiet=True)\n\n            file_url = self.prepare_root_value(path, project_name)\n            nodes = cmds.file(file_url,\n                              namespace=namespace,\n                              sharedReferenceFile=False,\n                              reference=True,\n                              returnNewNodes=True,\n                              groupReference=attach_to_root,\n                              groupName=group_name,\n                              **kwargs)\n\n            shapes = cmds.ls(nodes, shapes=True, long=True)\n\n            new_nodes = (list(set(nodes) - set(shapes)))\n\n            # if there are cameras, try to lock their transforms\n            self._lock_camera_transforms(new_nodes)\n\n            current_namespace = cmds.namespaceInfo(currentNamespace=True)\n\n            if current_namespace != \":\":\n                group_name = current_namespace + \":\" + group_name\n\n            self[:] = new_nodes\n\n            settings = get_project_settings(project_name)\n            if attach_to_root:\n                group_name = \"|\" + group_name\n                roots = cmds.listRelatives(group_name,\n                                           children=True,\n                                           fullPath=True) or []\n\n                if product_type not in {\n                    \"layout\", \"setdress\", \"mayaAscii\", \"mayaScene\"\n                }:\n                    # QUESTION Why do we need to exclude these families?\n                    with parent_nodes(roots, parent=None):\n                        cmds.xform(group_name, zeroTransformPivots=True)\n\n                color = plugin.get_load_color_for_product_type(\n                    product_type, settings\n                )\n                if color is not None:\n                    red, green, blue = color\n                    cmds.setAttr(\"{}.useOutlinerColor\".format(group_name), 1)\n                    cmds.setAttr(\n                        \"{}.outlinerColor\".format(group_name),\n                        red,\n                        green,\n                        blue\n                    )\n\n                display_handle = settings['maya']['load'].get(\n                    'reference_loader', {}\n                ).get('display_handle', True)\n                if display_handle:\n                    self._set_display_handle(group_name)\n\n            if product_type == \"rig\":\n                options[\"lock_instance\"] = (\n                    settings\n                    [\"maya\"]\n                    [\"load\"]\n                    [\"reference_loader\"]\n                    [\"lock_animation_instance_on_load\"]\n                )\n                self._post_process_rig(namespace, context, options)\n            else:\n                if \"translate\" in options:\n                    if not attach_to_root and new_nodes:\n                        root_nodes = cmds.ls(new_nodes, assemblies=True,\n                                             long=True)\n                        # we assume only a single root is ever loaded\n                        group_name = root_nodes[0]\n                    cmds.setAttr(\"{}.translate\".format(group_name),\n                                 *options[\"translate\"])\n            return new_nodes\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def update(self, container, context):\n        with preserve_modelpanel_cameras(container, log=self.log):\n            super(ReferenceLoader, self).update(container, context)\n\n        # We also want to lock camera transforms on any new cameras in the\n        # reference or for a camera which might have changed names.\n        members = get_container_members(container)\n        self._lock_camera_transforms(members)\n\n    def remove(self, container):\n        representation_id: str = container[\"representation\"]\n        project_name: str = container.get(\n            \"project_name\", get_current_project_name()\n        )\n        product_type = None\n        if representation_id:\n            context: dict = get_representation_context(\n                project_name, representation_id\n            )\n            product_type: str = context[\"product\"][\"productType\"]\n\n        if product_type == \"rig\":\n            # Special handling needed for rig containers\n            self._remove_rig(container)\n            return\n\n        super().remove(container)\n\n    def _remove_rig(self, container):\n        \"\"\"Remove linked animation instance no matter if it\n        is locked or not.\n\n        Args:\n            container (dict): The container to remove.\n        \"\"\"\n        members = get_container_members(container)\n        object_sets = set()\n        for member in members:\n            object_sets.update(\n                cmds.listSets(object=member, extendToShape=False) or []\n            )\n\n        super().remove(container)\n        # After the deletion, we check which object sets are still existing\n        # because maya may auto-delete empty object sets if they are not locked\n        # This way we can clean up remaining animation instances that were\n        # locked\n        object_sets = cmds.ls(object_sets, type=\"objectSet\")\n        for object_set in object_sets:\n            # Only consider empty object sets\n            members = cmds.sets(object_set, query=True)\n            if members:\n                continue\n\n            # Only consider locked object sets\n            locked = cmds.lockNode(object_set, query=True)\n            if not locked:\n                continue\n\n            # Ignore referenced object sets\n            if cmds.referenceQuery(isNodeReferenced=object_set):\n                continue\n\n            # Then only here confirm whether this is an animation instance, if so\n            # then we will want to auto-remove the instance\n            if get_creator_identifier(object_set) == \"io.openpype.creators.maya.animation\":\n                cmds.lockNode(object_set, lock=False)\n                cmds.delete(object_set)\n\n    def _post_process_rig(self, namespace, context, options):\n\n        nodes = self[:]\n        try:\n            create_rig_animation_instance(\n                nodes, context, namespace, options=options, log=self.log,\n            )\n        except RigSetsNotExistError as exc:\n            self.log.warning(\n                \"Missing rig sets for animation instance creation: %s\", exc)\n\n    def _lock_camera_transforms(self, nodes):\n        cameras = cmds.ls(nodes, type=\"camera\")\n        if not cameras:\n            return\n\n        # Check the Maya version, lockTransform has been introduced since\n        # Maya 2016.5 Ext 2\n        version = int(cmds.about(version=True))\n        if version &gt;= 2016:\n            for camera in cameras:\n                cmds.camera(camera, edit=True, lockTransform=True)\n        else:\n            self.log.warning(\"This version of Maya does not support locking of\"\n                             \" transforms of cameras.\")\n\n    def _set_display_handle(self, group_name: str):\n        \"\"\"Enable display handle and move select handle to object center\"\"\"\n        cmds.setAttr(f\"{group_name}.displayHandle\", True)\n        # get bounding box\n        # Bugfix: We force a refresh here because there is a reproducable case\n        # with Advanced Skeleton rig where the call to `exactWorldBoundingBox`\n        # directly after the reference without it breaks the behavior of the\n        # rigs making it appear as if parts of the mesh are static.\n        # TODO: Preferably we have a better fix than requiring refresh on loads\n        cmds.refresh()\n        bbox = cmds.exactWorldBoundingBox(group_name)\n        # get pivot position on world space\n        pivot = cmds.xform(group_name, q=True, sp=True, ws=True)\n        # center of bounding box\n        cx = (bbox[0] + bbox[3]) / 2\n        cy = (bbox[1] + bbox[4]) / 2\n        cz = (bbox[2] + bbox[5]) / 2\n        # add pivot position to calculate offset\n        cx += pivot[0]\n        cy += pivot[1]\n        cz += pivot[2]\n        # set selection handle offset to center of bounding box\n        cmds.setAttr(f\"{group_name}.selectHandleX\", cx)\n        cmds.setAttr(f\"{group_name}.selectHandleY\", cy)\n        cmds.setAttr(f\"{group_name}.selectHandleZ\", cz)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_reference.html#client.ayon_maya.plugins.load.load_reference.preserve_modelpanel_cameras","title":"<code>preserve_modelpanel_cameras(container, log=None)</code>","text":"<p>Preserve camera members of container in the modelPanels.</p> <p>This is used to ensure a camera remains in the modelPanels after updating to a new version.</p> Source code in <code>client/ayon_maya/plugins/load/load_reference.py</code> <pre><code>@contextlib.contextmanager\ndef preserve_modelpanel_cameras(container, log=None):\n    \"\"\"Preserve camera members of container in the modelPanels.\n\n    This is used to ensure a camera remains in the modelPanels after updating\n    to a new version.\n\n    \"\"\"\n\n    # Get the modelPanels that used the old camera\n    members = get_container_members(container)\n    old_cameras = set(cmds.ls(members, type=\"camera\", long=True))\n    if not old_cameras:\n        # No need to manage anything\n        yield\n        return\n\n    panel_cameras = {}\n    for panel in cmds.getPanel(type=\"modelPanel\"):\n        cam = cmds.ls(cmds.modelPanel(panel, query=True, camera=True),\n                      long=True)[0]\n\n        # Often but not always maya returns the transform from the\n        # modelPanel as opposed to the camera shape, so we convert it\n        # to explicitly be the camera shape\n        if cmds.nodeType(cam) != \"camera\":\n            cam = cmds.listRelatives(cam,\n                                     children=True,\n                                     fullPath=True,\n                                     type=\"camera\")[0]\n        if cam in old_cameras:\n            panel_cameras[panel] = cam\n\n    if not panel_cameras:\n        # No need to manage anything\n        yield\n        return\n\n    try:\n        yield\n    finally:\n        new_members = get_container_members(container)\n        new_cameras = set(cmds.ls(new_members, type=\"camera\", long=True))\n        if not new_cameras:\n            return\n\n        for panel, cam_name in panel_cameras.items():\n            new_camera = None\n            if cam_name in new_cameras:\n                new_camera = cam_name\n            elif len(new_cameras) == 1:\n                new_camera = next(iter(new_cameras))\n            else:\n                # Multiple cameras in the updated container but not an exact\n                # match detected by name. Find the closest match\n                matches = difflib.get_close_matches(word=cam_name,\n                                                    possibilities=new_cameras,\n                                                    n=1)\n                if matches:\n                    new_camera = matches[0]  # best match\n                    if log:\n                        log.info(\"Camera in '{}' restored with \"\n                                 \"closest match camera: {} (before: {})\"\n                                 .format(panel, new_camera, cam_name))\n\n            if not new_camera:\n                # Unable to find the camera to re-apply in the modelpanel\n                continue\n\n            cmds.modelPanel(panel, edit=True, camera=new_camera)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_reference.html#client.ayon_maya.plugins.load.load_reference.preserve_time_units","title":"<code>preserve_time_units()</code>","text":"<p>Preserve current frame, frame range and fps</p> Source code in <code>client/ayon_maya/plugins/load/load_reference.py</code> <pre><code>@contextlib.contextmanager\ndef preserve_time_units():\n    \"\"\"Preserve current frame, frame range and fps\"\"\"\n    frame = cmds.currentTime(query=True)\n    fps = cmds.currentUnit(query=True, time=True)\n    start = cmds.playbackOptions(query=True, minTime=True)\n    end = cmds.playbackOptions(query=True, maxTime=True)\n    anim_start = cmds.playbackOptions(query=True, animationStartTime=True)\n    anim_end = cmds.playbackOptions(query=True, animationEndTime=True)\n    try:\n        yield\n    finally:\n        cmds.currentUnit(time=fps, updateAnimation=False)\n        cmds.currentTime(frame)\n        cmds.playbackOptions(minTime=start,\n                             maxTime=end,\n                             animationStartTime=anim_start,\n                             animationEndTime=anim_end)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_rendersetup.html","title":"load_rendersetup","text":"<p>Load and update RenderSetup settings.</p> <p>Working with RenderSetup setting is Maya is done utilizing json files. When this json is loaded, it will overwrite all settings on RenderSetup instance.</p>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_rendersetup.html#client.ayon_maya.plugins.load.load_rendersetup.RenderSetupLoader","title":"<code>RenderSetupLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load json preset for RenderSetup overwriting current one.</p> Source code in <code>client/ayon_maya/plugins/load/load_rendersetup.py</code> <pre><code>class RenderSetupLoader(plugin.Loader):\n    \"\"\"Load json preset for RenderSetup overwriting current one.\"\"\"\n\n    product_types = {\"rendersetup\"}\n    representations = {\"json\"}\n    defaults = ['Main']\n\n    label = \"Load RenderSetup template\"\n    icon = \"tablet\"\n    color = \"orange\"\n\n    options = [\n        BoolDef(\"accept_import\",\n                label=\"Accept import on load\",\n                tooltip=(\n                  \"By default importing or pasting Render Setup collections \"\n                  \"will display them italic in the Render Setup list.\\nWith \"\n                  \"this enabled the load will directly mark the import \"\n                  \"'accepted' and remove the italic view.\"\n                ),\n                default=True),\n        BoolDef(\"load_managed\",\n                label=\"Load Managed\",\n                tooltip=(\n                  \"Containerize the rendersetup on load so it can be \"\n                  \"'updated' later.\"\n                ),\n                default=True),\n        EnumDef(\"import_mode\",\n                label=\"Import mode\",\n                items={\n                    renderSetup.DECODE_AND_OVERWRITE: (\n                        \"Flush existing render setup and \"\n                        \"add without any namespace\"\n                    ),\n                    renderSetup.DECODE_AND_MERGE: (\n                        \"Merge with the existing render setup objects and \"\n                        \"rename the unexpected objects\"\n                    ),\n                    renderSetup.DECODE_AND_RENAME: (\n                        \"Renaming all decoded render setup objects to not \"\n                        \"conflict with the existing render setup\"\n                    ),\n                },\n                default=renderSetup.DECODE_AND_OVERWRITE)\n    ]\n\n    def load(self, context, name, namespace, data):\n        \"\"\"Load RenderSetup settings.\"\"\"\n\n        path = self.filepath_from_context(context)\n\n        accept_import = data.get(\"accept_import\", True)\n        import_mode = data.get(\"import_mode\", renderSetup.DECODE_AND_OVERWRITE)\n\n        self.log.info(\"&gt;&gt;&gt; loading json [ {} ]\".format(path))\n        with mark_all_imported(accept_import):\n            with open(path, \"r\") as file:\n                renderSetup.instance().decode(\n                    json.load(file), import_mode, None)\n\n        if data.get(\"load_managed\", True):\n            self.log.info(\"&gt;&gt;&gt; containerising [ {} ]\".format(name))\n            folder_name = context[\"folder\"][\"name\"]\n            namespace = namespace or lib.unique_namespace(\n                folder_name + \"_\",\n                prefix=\"_\" if folder_name[0].isdigit() else \"\",\n                suffix=\"_\",\n            )\n\n            return containerise(\n                name=name,\n                namespace=namespace,\n                nodes=[],\n                context=context,\n                loader=self.__class__.__name__)\n\n    def remove(self, container):\n        \"\"\"Remove RenderSetup settings instance.\"\"\"\n        container_name = container[\"objectName\"]\n\n        self.log.info(\"Removing '%s' from Maya..\" % container[\"name\"])\n\n        container_content = cmds.sets(container_name, query=True) or []\n        nodes = cmds.ls(container_content, long=True)\n\n        nodes.append(container_name)\n\n        try:\n            cmds.delete(nodes)\n        except ValueError:\n            # Already implicitly deleted by Maya upon removing reference\n            pass\n\n    def update(self, container, context):\n        \"\"\"Update RenderSetup setting by overwriting existing settings.\"\"\"\n        lib.show_message(\n            \"Render setup update\",\n            \"Render setup setting will be overwritten by new version. All \"\n            \"setting specified by user not included in loaded version \"\n            \"will be lost.\")\n        repre_entity = context[\"representation\"]\n        path = self.filepath_from_context(context)\n        with open(path, \"r\") as file:\n            try:\n                renderSetup.instance().decode(\n                    json.load(file), renderSetup.DECODE_AND_OVERWRITE, None)\n            except Exception:\n                self.log.error(\"There were errors during loading\")\n                raise\n\n        # Update metadata\n        node = container[\"objectName\"]\n        cmds.setAttr(\"{}.representation\".format(node),\n                     repre_entity[\"id\"],\n                     type=\"string\")\n        self.log.info(\"... updated\")\n\n    def switch(self, container, context):\n        \"\"\"Switch representations.\"\"\"\n        self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_rendersetup.html#client.ayon_maya.plugins.load.load_rendersetup.RenderSetupLoader.load","title":"<code>load(context, name, namespace, data)</code>","text":"<p>Load RenderSetup settings.</p> Source code in <code>client/ayon_maya/plugins/load/load_rendersetup.py</code> <pre><code>def load(self, context, name, namespace, data):\n    \"\"\"Load RenderSetup settings.\"\"\"\n\n    path = self.filepath_from_context(context)\n\n    accept_import = data.get(\"accept_import\", True)\n    import_mode = data.get(\"import_mode\", renderSetup.DECODE_AND_OVERWRITE)\n\n    self.log.info(\"&gt;&gt;&gt; loading json [ {} ]\".format(path))\n    with mark_all_imported(accept_import):\n        with open(path, \"r\") as file:\n            renderSetup.instance().decode(\n                json.load(file), import_mode, None)\n\n    if data.get(\"load_managed\", True):\n        self.log.info(\"&gt;&gt;&gt; containerising [ {} ]\".format(name))\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = namespace or lib.unique_namespace(\n            folder_name + \"_\",\n            prefix=\"_\" if folder_name[0].isdigit() else \"\",\n            suffix=\"_\",\n        )\n\n        return containerise(\n            name=name,\n            namespace=namespace,\n            nodes=[],\n            context=context,\n            loader=self.__class__.__name__)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_rendersetup.html#client.ayon_maya.plugins.load.load_rendersetup.RenderSetupLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove RenderSetup settings instance.</p> Source code in <code>client/ayon_maya/plugins/load/load_rendersetup.py</code> <pre><code>def remove(self, container):\n    \"\"\"Remove RenderSetup settings instance.\"\"\"\n    container_name = container[\"objectName\"]\n\n    self.log.info(\"Removing '%s' from Maya..\" % container[\"name\"])\n\n    container_content = cmds.sets(container_name, query=True) or []\n    nodes = cmds.ls(container_content, long=True)\n\n    nodes.append(container_name)\n\n    try:\n        cmds.delete(nodes)\n    except ValueError:\n        # Already implicitly deleted by Maya upon removing reference\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_rendersetup.html#client.ayon_maya.plugins.load.load_rendersetup.RenderSetupLoader.switch","title":"<code>switch(container, context)</code>","text":"<p>Switch representations.</p> Source code in <code>client/ayon_maya/plugins/load/load_rendersetup.py</code> <pre><code>def switch(self, container, context):\n    \"\"\"Switch representations.\"\"\"\n    self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_rendersetup.html#client.ayon_maya.plugins.load.load_rendersetup.RenderSetupLoader.update","title":"<code>update(container, context)</code>","text":"<p>Update RenderSetup setting by overwriting existing settings.</p> Source code in <code>client/ayon_maya/plugins/load/load_rendersetup.py</code> <pre><code>def update(self, container, context):\n    \"\"\"Update RenderSetup setting by overwriting existing settings.\"\"\"\n    lib.show_message(\n        \"Render setup update\",\n        \"Render setup setting will be overwritten by new version. All \"\n        \"setting specified by user not included in loaded version \"\n        \"will be lost.\")\n    repre_entity = context[\"representation\"]\n    path = self.filepath_from_context(context)\n    with open(path, \"r\") as file:\n        try:\n            renderSetup.instance().decode(\n                json.load(file), renderSetup.DECODE_AND_OVERWRITE, None)\n        except Exception:\n            self.log.error(\"There were errors during loading\")\n            raise\n\n    # Update metadata\n    node = container[\"objectName\"]\n    cmds.setAttr(\"{}.representation\".format(node),\n                 repre_entity[\"id\"],\n                 type=\"string\")\n    self.log.info(\"... updated\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_rendersetup.html#client.ayon_maya.plugins.load.load_rendersetup.mark_all_imported","title":"<code>mark_all_imported(enabled)</code>","text":"<p>Mark all imported nodes accepted by removing the <code>imported</code> attribute</p> Source code in <code>client/ayon_maya/plugins/load/load_rendersetup.py</code> <pre><code>@contextlib.contextmanager\ndef mark_all_imported(enabled):\n    \"\"\"Mark all imported nodes accepted by removing the `imported` attribute\"\"\"\n    if not enabled:\n        yield\n        return\n\n    node_types = cmds.pluginInfo(\"renderSetup\", query=True, dependNode=True)\n\n    # Get node before load, then we can disable `imported`\n    # attribute on all new render setup layers after import\n    before = cmds.ls(type=node_types, long=True)\n    try:\n        yield\n    finally:\n        after = cmds.ls(type=node_types, long=True)\n        for node in (node for node in after if node not in before):\n            if cmds.attributeQuery(\"imported\",\n                                   node=node,\n                                   exists=True):\n                plug = \"{}.imported\".format(node)\n                if cmds.getAttr(plug):\n                    cmds.deleteAttr(plug)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_vdb_to_arnold.html","title":"load_vdb_to_arnold","text":"<p>Load OpenVDB for Arnold in aiVolume.</p> TODO <p><code>aiVolume</code> doesn't automatically set velocity fps correctly, set manual?</p>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_vdb_to_arnold.html#client.ayon_maya.plugins.load.load_vdb_to_arnold.LoadVDBtoArnold","title":"<code>LoadVDBtoArnold</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load OpenVDB for Arnold in aiVolume</p> Source code in <code>client/ayon_maya/plugins/load/load_vdb_to_arnold.py</code> <pre><code>class LoadVDBtoArnold(plugin.Loader):\n    \"\"\"Load OpenVDB for Arnold in aiVolume\"\"\"\n\n    product_types = {\"vdbcache\"}\n    representations = {\"vdb\"}\n\n    label = \"Load VDB to Arnold\"\n    icon = \"cloud\"\n    color = \"orange\"\n\n    def load(self, context, name, namespace, data):\n\n        from ayon_maya.api.lib import unique_namespace\n        from ayon_maya.api.pipeline import containerise\n        from maya import cmds\n\n        product_type = context[\"product\"][\"productType\"]\n\n        # Check if the plugin for arnold is available on the pc\n        try:\n            cmds.loadPlugin(\"mtoa\", quiet=True)\n        except Exception as exc:\n            self.log.error(\"Encountered exception:\\n%s\" % exc)\n            return\n\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = namespace or unique_namespace(\n            folder_name + \"_\",\n            prefix=\"_\" if folder_name[0].isdigit() else \"\",\n            suffix=\"_\",\n        )\n\n        # Root group\n        label = \"{}:{}\".format(namespace, name)\n        root = cmds.group(name=label, empty=True)\n\n        project_name = context[\"project\"][\"name\"]\n        settings = get_project_settings(project_name)\n        color = get_load_color_for_product_type(product_type, settings)\n        if color is not None:\n            red, green, blue = color\n            cmds.setAttr(root + \".useOutlinerColor\", 1)\n            cmds.setAttr(root + \".outlinerColor\", red, green, blue)\n\n        # Create VRayVolumeGrid\n        grid_node = cmds.createNode(\"aiVolume\",\n                                    name=\"{}Shape\".format(root),\n                                    parent=root)\n\n        path = self.filepath_from_context(context)\n        self._set_path(grid_node,\n                       path=path,\n                       repre_entity=context[\"representation\"])\n\n        # Lock the shape node so the user can't delete the transform/shape\n        # as if it was referenced\n        cmds.lockNode(grid_node, lock=True)\n\n        nodes = [root, grid_node]\n        self[:] = nodes\n\n        return containerise(\n            name=name,\n            namespace=namespace,\n            nodes=nodes,\n            context=context,\n            loader=self.__class__.__name__)\n\n    def update(self, container, context):\n\n        from maya import cmds\n\n        repre_entity = context[\"representation\"]\n\n        path = self.filepath_from_context(context)\n\n        # Find VRayVolumeGrid\n        members = cmds.sets(container['objectName'], query=True)\n        grid_nodes = cmds.ls(members, type=\"aiVolume\", long=True)\n        assert len(grid_nodes) == 1, \"This is a bug\"\n\n        # Update the VRayVolumeGrid\n        self._set_path(grid_nodes[0], path=path, repre_entity=repre_entity)\n\n        # Update container representation\n        cmds.setAttr(container[\"objectName\"] + \".representation\",\n                     repre_entity[\"id\"],\n                     type=\"string\")\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n\n        from maya import cmds\n\n        # Get all members of the AYON container, ensure they are unlocked\n        # and delete everything\n        members = cmds.sets(container['objectName'], query=True)\n        cmds.lockNode(members, lock=False)\n        cmds.delete([container['objectName']] + members)\n\n        # Clean up the namespace\n        try:\n            cmds.namespace(removeNamespace=container['namespace'],\n                           deleteNamespaceContent=True)\n        except RuntimeError:\n            pass\n\n    @staticmethod\n    def _set_path(grid_node,\n                  path,\n                  repre_entity):\n        \"\"\"Apply the settings for the VDB path to the aiVolume node\"\"\"\n        from maya import cmds\n\n        if not os.path.exists(path):\n            raise RuntimeError(\"Path does not exist: %s\" % path)\n\n        is_sequence = \"frame\" in repre_entity[\"context\"]\n        cmds.setAttr(grid_node + \".useFrameExtension\", is_sequence)\n\n        # Set file path\n        cmds.setAttr(grid_node + \".filename\", path, type=\"string\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_vdb_to_redshift.html","title":"load_vdb_to_redshift","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_vdb_to_redshift.html#client.ayon_maya.plugins.load.load_vdb_to_redshift.LoadVDBtoRedShift","title":"<code>LoadVDBtoRedShift</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load OpenVDB in a Redshift Volume Shape</p> <p>Note that the RedshiftVolumeShape is created without a RedshiftVolume shader assigned. To get the Redshift volume to render correctly assign a RedshiftVolume shader (in the Hypershade) and set the density, scatter and emission channels to the channel names of the volumes in the VDB file.</p> Source code in <code>client/ayon_maya/plugins/load/load_vdb_to_redshift.py</code> <pre><code>class LoadVDBtoRedShift(plugin.Loader):\n    \"\"\"Load OpenVDB in a Redshift Volume Shape\n\n    Note that the RedshiftVolumeShape is created without a RedshiftVolume\n    shader assigned. To get the Redshift volume to render correctly assign\n    a RedshiftVolume shader (in the Hypershade) and set the density, scatter\n    and emission channels to the channel names of the volumes in the VDB file.\n\n    \"\"\"\n\n    product_types = {\"vdbcache\"}\n    representations = {\"vdb\"}\n\n    label = \"Load VDB to RedShift\"\n    icon = \"cloud\"\n    color = \"orange\"\n\n    options = [\n        BoolDef(\"create_shader\",\n                label=\"Create Redshift Volume Shader\",\n                tooltip=\"When enabled create a Redshift Volume Shader and \"\n                        \"assign it to the volume shape. Without a volume \"\n                        \"shader assigned Redshift may not render the volume \"\n                        \"at all.\",\n                default=True)\n    ]\n\n    def load(self, context, name=None, namespace=None, options=None):\n\n        product_type = context[\"product\"][\"productType\"]\n\n        # Check if the plugin for redshift is available on the pc\n        try:\n            cmds.loadPlugin(\"redshift4maya\", quiet=True)\n        except Exception as exc:\n            self.log.error(\"Encountered exception:\\n%s\" % exc)\n            return\n\n        # Check if viewport drawing engine is Open GL Core (compat)\n        render_engine = None\n        compatible = \"OpenGL\"\n        if cmds.optionVar(exists=\"vp2RenderingEngine\"):\n            render_engine = cmds.optionVar(query=\"vp2RenderingEngine\")\n\n        if not render_engine or not render_engine.startswith(compatible):\n            raise RuntimeError(\"Current scene's settings are incompatible.\"\n                               \"See Preferences &gt; Display &gt; Viewport 2.0 to \"\n                               \"set the render engine to '%s&lt;type&gt;'\"\n                               % compatible)\n\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = namespace or lib.unique_namespace(\n            folder_name + \"_\",\n            prefix=\"_\" if folder_name[0].isdigit() else \"\",\n            suffix=\"_\",\n        )\n\n        # Root group\n        label = \"{}:{}\".format(namespace, name)\n        root = cmds.createNode(\"transform\", name=label)\n\n        project_name = context[\"project\"][\"name\"]\n        settings = get_project_settings(project_name)\n        color = get_load_color_for_product_type(product_type, settings)\n        if color is not None:\n            red, green, blue = color\n            cmds.setAttr(root + \".useOutlinerColor\", 1)\n            cmds.setAttr(root + \".outlinerColor\", red, green, blue)\n\n        # Create VR\n        volume_node = cmds.createNode(\"RedshiftVolumeShape\",\n                                      name=\"{}RVSShape\".format(label),\n                                      parent=root)\n\n        self._set_path(volume_node,\n                       path=self.filepath_from_context(context),\n                       representation=context[\"representation\"])\n\n        if options.get(\"create_shader\", True):\n            self._create_default_redshift_volume_shader(volume_node)\n\n        nodes = [root, volume_node]\n        self[:] = nodes\n\n        return containerise(\n            name=name,\n            namespace=namespace,\n            nodes=nodes,\n            context=context,\n            loader=self.__class__.__name__)\n\n    def update(self, container, context):\n\n        repre_entity = context[\"representation\"]\n        path = self.filepath_from_context(context)\n\n        # Find VRayVolumeGrid\n        members = cmds.sets(container['objectName'], query=True)\n        grid_nodes = cmds.ls(members, type=\"RedshiftVolumeShape\", long=True)\n        assert len(grid_nodes) == 1, \"This is a bug\"\n\n        # Update the VRayVolumeGrid\n        self._set_path(grid_nodes[0], path=path, representation=repre_entity)\n\n        # Update container representation\n        cmds.setAttr(container[\"objectName\"] + \".representation\",\n                     repre_entity[\"id\"],\n                     type=\"string\")\n\n    def remove(self, container):\n\n        # Get all members of the AYON container, ensure they are unlocked\n        # and delete everything\n        members = cmds.sets(container['objectName'], query=True)\n        cmds.lockNode(members, lock=False)\n        cmds.delete([container['objectName']] + members)\n\n        # Clean up the namespace\n        try:\n            cmds.namespace(removeNamespace=container['namespace'],\n                           deleteNamespaceContent=True)\n        except RuntimeError:\n            pass\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    @staticmethod\n    def _set_path(grid_node,\n                  path,\n                  representation):\n        \"\"\"Apply the settings for the VDB path to the RedshiftVolumeShape\"\"\"\n\n        if not os.path.exists(path):\n            raise RuntimeError(\"Path does not exist: %s\" % path)\n\n        is_sequence = \"frame\" in representation[\"context\"]\n        cmds.setAttr(grid_node + \".useFrameExtension\", is_sequence)\n\n        # Set file path\n        cmds.setAttr(grid_node + \".fileName\", path, type=\"string\")\n\n        # Force refresh with the use frame extension\n        # This makes sure we can directly retrieve the `.gridNames` attribute\n        # and avoids potential 'Failed to find volume file' warnings that\n        # appear once on load when Maya has not yet initialized use frame\n        # extension behavior correctly on load yet.\n        mel.eval(f'checkUseFrameExtension(\"{grid_node}\")')\n\n    def _create_default_redshift_volume_shader(\n            self, volume_shape: str) -&gt; List[str]:\n        \"\"\"Create RedshiftStandardVolume shader and assign it to the volume\"\"\"\n        # TODO: Should this material become \"managed\" and get removed on\n        #  removing the Redshift Volume itself? Currently it is not and it\n        #  will linger in the scene as dangling unused material.\n\n        # Create shading engine with RedshiftStandardVolume\n        material = cmds.shadingNode(\"RedshiftStandardVolume\", asShader=True)\n        sg = cmds.shadingNode(\n            \"shadingEngine\", asShader=True, name=f\"{material}SG\")\n        cmds.connectAttr(f\"{material}.outColor\",\n                         f\"{sg}.volumeShader\",\n                         force=True)\n\n        # Set default density name\n        channel = \"density\"\n        grid_names: List[str] = cmds.getAttr(f\"{volume_shape}.gridNames\")\n        if grid_names and channel not in grid_names:\n            channel = grid_names[0]\n        cmds.setAttr(\"{}.density_name\".format(material),\n                     channel, type=\"string\")\n\n        # Assign shader to the volume shape\n        cmds.sets(volume_shape, forceElement=sg)\n\n        self.log.info(\n            f\"Created RedshiftStandardVolume: '{material}'\"\n            f\" using channel '{channel}'\")\n        return [material, sg]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_vdb_to_vray.html","title":"load_vdb_to_vray","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_vdb_to_vray.html#client.ayon_maya.plugins.load.load_vdb_to_vray.LoadVDBtoVRay","title":"<code>LoadVDBtoVRay</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load OpenVDB in a V-Ray Volume Grid</p> Source code in <code>client/ayon_maya/plugins/load/load_vdb_to_vray.py</code> <pre><code>class LoadVDBtoVRay(plugin.Loader):\n    \"\"\"Load OpenVDB in a V-Ray Volume Grid\"\"\"\n\n    product_types = {\"vdbcache\"}\n    representations = {\"vdb\"}\n\n    label = \"Load VDB to VRay\"\n    icon = \"cloud\"\n    color = \"orange\"\n\n    def load(self, context, name, namespace, data):\n\n        from ayon_maya.api.lib import unique_namespace\n        from ayon_maya.api.pipeline import containerise\n\n        path = self.filepath_from_context(context)\n        assert os.path.exists(path), (\n            \"Path does not exist: %s\" % path\n        )\n\n        product_type = context[\"product\"][\"productType\"]\n\n        # Ensure V-ray is loaded with the vrayvolumegrid\n        if not cmds.pluginInfo(\"vrayformaya\", query=True, loaded=True):\n            cmds.loadPlugin(\"vrayformaya\")\n        if not cmds.pluginInfo(\"vrayvolumegrid\", query=True, loaded=True):\n            cmds.loadPlugin(\"vrayvolumegrid\")\n\n        # Check if viewport drawing engine is Open GL Core (compat)\n        render_engine = None\n        compatible = \"OpenGLCoreProfileCompat\"\n        if cmds.optionVar(exists=\"vp2RenderingEngine\"):\n            render_engine = cmds.optionVar(query=\"vp2RenderingEngine\")\n\n        if not render_engine or render_engine != compatible:\n            self.log.warning(\"Current scene's settings are incompatible.\"\n                             \"See Preferences &gt; Display &gt; Viewport 2.0 to \"\n                             \"set the render engine to '%s'\" % compatible)\n\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = namespace or unique_namespace(\n            folder_name + \"_\",\n            prefix=\"_\" if folder_name[0].isdigit() else \"\",\n            suffix=\"_\",\n        )\n\n        # Root group\n        label = \"{}:{}_VDB\".format(namespace, name)\n        root = cmds.group(name=label, empty=True)\n\n        project_name = context[\"project\"][\"name\"]\n        settings = get_project_settings(project_name)\n        color = get_load_color_for_product_type(product_type, settings)\n        if color is not None:\n            red, green, blue = color\n            cmds.setAttr(root + \".useOutlinerColor\", 1)\n            cmds.setAttr(root + \".outlinerColor\", red, green, blue)\n\n        # Create VRayVolumeGrid\n        grid_node = cmds.createNode(\"VRayVolumeGrid\",\n                                    name=\"{}Shape\".format(label),\n                                    parent=root)\n\n        # Ensure .currentTime is connected to time1.outTime\n        cmds.connectAttr(\"time1.outTime\", grid_node + \".currentTime\")\n\n        # Set path\n        self._set_path(grid_node, path, show_preset_popup=True)\n\n        # Lock the shape node so the user can't delete the transform/shape\n        # as if it was referenced\n        cmds.lockNode(grid_node, lock=True)\n\n        nodes = [root, grid_node]\n        self[:] = nodes\n\n        return containerise(\n            name=name,\n            namespace=namespace,\n            nodes=nodes,\n            context=context,\n            loader=self.__class__.__name__)\n\n    def _set_path(self, grid_node, path, show_preset_popup=True):\n\n        from ayon_maya.api.lib import attribute_values\n        from maya import cmds\n\n        def _get_filename_from_folder(path):\n            # Using the sequence of .vdb files we check the frame range, etc.\n            # to set the filename with #### padding.\n            files = sorted(x for x in os.listdir(path) if x.endswith(\".vdb\"))\n            if not files:\n                raise RuntimeError(\"Couldn't find .vdb files in: %s\" % path)\n\n            if len(files) == 1:\n                # Ensure check for single file is also done in folder\n                fname = files[0]\n            else:\n                # Sequence\n                import clique\n\n                # todo: check support for negative frames as input\n                collections, remainder = clique.assemble(files)\n                assert len(collections) == 1, (\n                    \"Must find a single image sequence, \"\n                    \"found: %s\" % (collections,)\n                )\n                collection = collections[0]\n\n                fname = collection.format('{head}{{padding}}{tail}')\n                padding = collection.padding\n                if padding == 0:\n                    # Clique doesn't provide padding if the frame number never\n                    # starts with a zero and thus has never any visual padding.\n                    # So we fall back to the smallest frame number as padding.\n                    padding = min(len(str(i)) for i in collection.indexes)\n\n                # Supply frame/padding with # signs\n                padding_str = \"#\" * padding\n                fname = fname.format(padding=padding_str)\n\n            return os.path.join(path, fname)\n\n        # The path is either a single file or sequence in a folder so\n        # we do a quick lookup for our files\n        if os.path.isfile(path):\n            path = os.path.dirname(path)\n        path = _get_filename_from_folder(path)\n\n        # Even when not applying a preset V-Ray will reset the 3rd Party\n        # Channels Mapping of the VRayVolumeGrid when setting the .inPath\n        # value. As such we try and preserve the values ourselves.\n        # Reported as ChaosGroup bug ticket: 154-011-2909\u2009\n        # todo(roy): Remove when new V-Ray release preserves values\n        original_user_mapping = cmds.getAttr(grid_node + \".usrchmap\") or \"\"\n\n        # Workaround for V-Ray bug: fix lag on path change, see function\n        _fix_duplicate_vvg_callbacks()\n\n        # Suppress preset pop-up if we want.\n        popup_attr = \"{0}.inDontOfferPresets\".format(grid_node)\n        popup = {popup_attr: not show_preset_popup}\n        with attribute_values(popup):\n            cmds.setAttr(grid_node + \".inPath\", path, type=\"string\")\n\n        # Reapply the 3rd Party channels user mapping when no preset popup\n        # was shown to the user\n        if not show_preset_popup:\n            channels = cmds.getAttr(grid_node + \".usrchmapallch\").split(\";\")\n            channels = set(channels)  # optimize lookup\n            restored_mapping = \"\"\n            for entry in original_user_mapping.split(\";\"):\n                if not entry:\n                    # Ignore empty entries\n                    continue\n\n                # If 3rd Party Channels selection channel still exists then\n                # add it again.\n                index, channel = entry.split(\",\")\n                attr = THIRD_PARTY_CHANNELS.get(int(index),\n                                                # Fallback for when a mapping\n                                                # was set that is not in the\n                                                # documentation\n                                                \"???\")\n                if channel in channels:\n                    restored_mapping += entry + \";\"\n                else:\n                    self.log.warning(\"Can't preserve '%s' mapping due to \"\n                                     \"missing channel '%s' on node: \"\n                                     \"%s\" % (attr, channel, grid_node))\n\n            if restored_mapping:\n                cmds.setAttr(grid_node + \".usrchmap\",\n                             restored_mapping,\n                             type=\"string\")\n\n    def update(self, container, context):\n        repre_entity = context[\"representation\"]\n\n        path = self.filepath_from_context(context)\n\n        # Find VRayVolumeGrid\n        members = cmds.sets(container['objectName'], query=True)\n        grid_nodes = cmds.ls(members, type=\"VRayVolumeGrid\", long=True)\n        assert len(grid_nodes) &gt; 0, \"This is a bug\"\n\n        # Update the VRayVolumeGrid\n        for grid_node in grid_nodes:\n            self._set_path(grid_node, path=path, show_preset_popup=False)\n\n        # Update container representation\n        cmds.setAttr(container[\"objectName\"] + \".representation\",\n                     repre_entity[\"id\"],\n                     type=\"string\")\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n\n        # Get all members of the AYON container, ensure they are unlocked\n        # and delete everything\n        members = cmds.sets(container['objectName'], query=True)\n        cmds.lockNode(members, lock=False)\n        cmds.delete([container['objectName']] + members)\n\n        # Clean up the namespace\n        try:\n            cmds.namespace(removeNamespace=container['namespace'],\n                           deleteNamespaceContent=True)\n        except RuntimeError:\n            pass\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_vrayproxy.html","title":"load_vrayproxy","text":"<p>Loader for Vray Proxy files.</p> <p>If there are Alembics published along vray proxy (in the same version), loader will use them instead of native vray vrmesh format.</p>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_vrayproxy.html#client.ayon_maya.plugins.load.load_vrayproxy.VRayProxyLoader","title":"<code>VRayProxyLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load VRay Proxy with Alembic or VrayMesh.</p> Source code in <code>client/ayon_maya/plugins/load/load_vrayproxy.py</code> <pre><code>class VRayProxyLoader(plugin.Loader):\n    \"\"\"Load VRay Proxy with Alembic or VrayMesh.\"\"\"\n\n    product_types = {\"vrayproxy\", \"model\", \"pointcache\", \"animation\", \"oxcache\"}\n    representations = {\"vrmesh\", \"abc\"}\n\n    label = \"Import VRay Proxy\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name=None, namespace=None, options=None):\n        # type: (dict, str, str, dict) -&gt; None\n        \"\"\"Loader entry point.\n\n        Args:\n            context (dict): Loaded representation context.\n            name (str): Name of container.\n            namespace (str): Optional namespace name.\n            options (dict): Optional loader options.\n\n        \"\"\"\n\n        product_type = context[\"product\"][\"productType\"]\n\n        #  get all representations for this version\n        filename = self._get_abc(\n            context[\"project\"][\"name\"], context[\"version\"][\"id\"]\n        )\n        if not filename:\n            filename = self.filepath_from_context(context)\n\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = namespace or unique_namespace(\n            folder_name + \"_\",\n            prefix=\"_\" if folder_name[0].isdigit() else \"\",\n            suffix=\"_\",\n        )\n\n        # Ensure V-Ray for Maya is loaded.\n        cmds.loadPlugin(\"vrayformaya\", quiet=True)\n\n        with maintained_selection():\n            cmds.namespace(addNamespace=namespace)\n            with namespaced(namespace, new=False):\n                nodes, group_node = self.create_vray_proxy(\n                    name, filename=filename)\n\n        self[:] = nodes\n        if not nodes:\n            return\n\n        # colour the group node\n        project_name = context[\"project\"][\"name\"]\n        settings = get_project_settings(project_name)\n        color = get_load_color_for_product_type(product_type, settings)\n        if color is not None:\n            red, green, blue = color\n            cmds.setAttr(\"{0}.useOutlinerColor\".format(group_node), 1)\n            cmds.setAttr(\n                \"{0}.outlinerColor\".format(group_node), red, green, blue\n            )\n\n        return containerise(\n            name=name,\n            namespace=namespace,\n            nodes=nodes,\n            context=context,\n            loader=self.__class__.__name__)\n\n    def update(self, container, context):\n        # type: (dict, dict) -&gt; None\n        \"\"\"Update container with specified representation.\"\"\"\n        node = container['objectName']\n        assert cmds.objExists(node), \"Missing container\"\n\n        members = cmds.sets(node, query=True) or []\n        vraymeshes = cmds.ls(members, type=\"VRayProxy\")\n        assert vraymeshes, \"Cannot find VRayMesh in container\"\n\n        #  get all representations for this version\n        repre_entity = context[\"representation\"]\n        filename = self._get_abc(\n            context[\"project\"][\"name\"], context[\"version\"][\"id\"]\n        )\n        if not filename:\n            filename = self.filepath_from_context(context)\n\n        for vray_mesh in vraymeshes:\n            cmds.setAttr(\"{}.fileName\".format(vray_mesh),\n                         filename,\n                         type=\"string\")\n\n        # Update metadata\n        cmds.setAttr(\"{}.representation\".format(node),\n                     repre_entity[\"id\"],\n                     type=\"string\")\n\n    def remove(self, container):\n        # type: (dict) -&gt; None\n        \"\"\"Remove loaded container.\"\"\"\n        # Delete container and its contents\n        if cmds.objExists(container['objectName']):\n            members = cmds.sets(container['objectName'], query=True) or []\n            cmds.delete([container['objectName']] + members)\n\n        # Remove the namespace, if empty\n        namespace = container['namespace']\n        if cmds.namespace(exists=namespace):\n            members = cmds.namespaceInfo(namespace, listNamespace=True)\n            if not members:\n                cmds.namespace(removeNamespace=namespace)\n            else:\n                self.log.warning(\"Namespace not deleted because it \"\n                                 \"still has members: %s\", namespace)\n\n    def switch(self, container, context):\n        # type: (dict, dict) -&gt; None\n        \"\"\"Switch loaded representation.\"\"\"\n        self.update(container, context)\n\n    def create_vray_proxy(self, name, filename):\n        # type: (str, str) -&gt; (list, str)\n        \"\"\"Re-create the structure created by VRay to support vrmeshes\n\n        Args:\n            name (str): Name of the asset.\n            filename (str): File name of vrmesh.\n\n        Returns:\n            nodes(list)\n\n        \"\"\"\n\n        if name is None:\n            name = os.path.splitext(os.path.basename(filename))[0]\n\n        parent = cmds.createNode(\"transform\", name=name)\n        proxy = cmds.createNode(\n            \"VRayProxy\", name=\"{}Shape\".format(name), parent=parent)\n        cmds.setAttr(proxy + \".fileName\", filename, type=\"string\")\n        cmds.connectAttr(\"time1.outTime\", proxy + \".currentFrame\")\n\n        return [parent, proxy], parent\n\n    def _get_abc(self, project_name, version_id):\n        # type: (str) -&gt; str\n        \"\"\"Get abc representation file path if present.\n\n        If here is published Alembic (abc) representation published along\n        vray proxy, get is file path.\n\n        Args:\n            project_name (str): Project name.\n            version_id (str): Version hash id.\n\n        Returns:\n            str: Path to file.\n            None: If abc not found.\n\n        \"\"\"\n        self.log.debug(\n            \"Looking for abc in published representations of this version.\")\n        abc_rep = ayon_api.get_representation_by_name(\n            project_name, \"abc\", version_id\n        )\n        if abc_rep:\n            self.log.debug(\"Found, we'll link alembic to vray proxy.\")\n            file_name = get_representation_path_by_project(project_name, abc_rep)\n            self.log.debug(\"File: {}\".format(file_name))\n            return file_name\n\n        return \"\"\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_vrayproxy.html#client.ayon_maya.plugins.load.load_vrayproxy.VRayProxyLoader.create_vray_proxy","title":"<code>create_vray_proxy(name, filename)</code>","text":"<p>Re-create the structure created by VRay to support vrmeshes</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the asset.</p> required <code>filename</code> <code>str</code> <p>File name of vrmesh.</p> required <p>Returns:</p> Type Description <p>nodes(list)</p> Source code in <code>client/ayon_maya/plugins/load/load_vrayproxy.py</code> <pre><code>def create_vray_proxy(self, name, filename):\n    # type: (str, str) -&gt; (list, str)\n    \"\"\"Re-create the structure created by VRay to support vrmeshes\n\n    Args:\n        name (str): Name of the asset.\n        filename (str): File name of vrmesh.\n\n    Returns:\n        nodes(list)\n\n    \"\"\"\n\n    if name is None:\n        name = os.path.splitext(os.path.basename(filename))[0]\n\n    parent = cmds.createNode(\"transform\", name=name)\n    proxy = cmds.createNode(\n        \"VRayProxy\", name=\"{}Shape\".format(name), parent=parent)\n    cmds.setAttr(proxy + \".fileName\", filename, type=\"string\")\n    cmds.connectAttr(\"time1.outTime\", proxy + \".currentFrame\")\n\n    return [parent, proxy], parent\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_vrayproxy.html#client.ayon_maya.plugins.load.load_vrayproxy.VRayProxyLoader.load","title":"<code>load(context, name=None, namespace=None, options=None)</code>","text":"<p>Loader entry point.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>Loaded representation context.</p> required <code>name</code> <code>str</code> <p>Name of container.</p> <code>None</code> <code>namespace</code> <code>str</code> <p>Optional namespace name.</p> <code>None</code> <code>options</code> <code>dict</code> <p>Optional loader options.</p> <code>None</code> Source code in <code>client/ayon_maya/plugins/load/load_vrayproxy.py</code> <pre><code>def load(self, context, name=None, namespace=None, options=None):\n    # type: (dict, str, str, dict) -&gt; None\n    \"\"\"Loader entry point.\n\n    Args:\n        context (dict): Loaded representation context.\n        name (str): Name of container.\n        namespace (str): Optional namespace name.\n        options (dict): Optional loader options.\n\n    \"\"\"\n\n    product_type = context[\"product\"][\"productType\"]\n\n    #  get all representations for this version\n    filename = self._get_abc(\n        context[\"project\"][\"name\"], context[\"version\"][\"id\"]\n    )\n    if not filename:\n        filename = self.filepath_from_context(context)\n\n    folder_name = context[\"folder\"][\"name\"]\n    namespace = namespace or unique_namespace(\n        folder_name + \"_\",\n        prefix=\"_\" if folder_name[0].isdigit() else \"\",\n        suffix=\"_\",\n    )\n\n    # Ensure V-Ray for Maya is loaded.\n    cmds.loadPlugin(\"vrayformaya\", quiet=True)\n\n    with maintained_selection():\n        cmds.namespace(addNamespace=namespace)\n        with namespaced(namespace, new=False):\n            nodes, group_node = self.create_vray_proxy(\n                name, filename=filename)\n\n    self[:] = nodes\n    if not nodes:\n        return\n\n    # colour the group node\n    project_name = context[\"project\"][\"name\"]\n    settings = get_project_settings(project_name)\n    color = get_load_color_for_product_type(product_type, settings)\n    if color is not None:\n        red, green, blue = color\n        cmds.setAttr(\"{0}.useOutlinerColor\".format(group_node), 1)\n        cmds.setAttr(\n            \"{0}.outlinerColor\".format(group_node), red, green, blue\n        )\n\n    return containerise(\n        name=name,\n        namespace=namespace,\n        nodes=nodes,\n        context=context,\n        loader=self.__class__.__name__)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_vrayproxy.html#client.ayon_maya.plugins.load.load_vrayproxy.VRayProxyLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove loaded container.</p> Source code in <code>client/ayon_maya/plugins/load/load_vrayproxy.py</code> <pre><code>def remove(self, container):\n    # type: (dict) -&gt; None\n    \"\"\"Remove loaded container.\"\"\"\n    # Delete container and its contents\n    if cmds.objExists(container['objectName']):\n        members = cmds.sets(container['objectName'], query=True) or []\n        cmds.delete([container['objectName']] + members)\n\n    # Remove the namespace, if empty\n    namespace = container['namespace']\n    if cmds.namespace(exists=namespace):\n        members = cmds.namespaceInfo(namespace, listNamespace=True)\n        if not members:\n            cmds.namespace(removeNamespace=namespace)\n        else:\n            self.log.warning(\"Namespace not deleted because it \"\n                             \"still has members: %s\", namespace)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_vrayproxy.html#client.ayon_maya.plugins.load.load_vrayproxy.VRayProxyLoader.switch","title":"<code>switch(container, context)</code>","text":"<p>Switch loaded representation.</p> Source code in <code>client/ayon_maya/plugins/load/load_vrayproxy.py</code> <pre><code>def switch(self, container, context):\n    # type: (dict, dict) -&gt; None\n    \"\"\"Switch loaded representation.\"\"\"\n    self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_vrayproxy.html#client.ayon_maya.plugins.load.load_vrayproxy.VRayProxyLoader.update","title":"<code>update(container, context)</code>","text":"<p>Update container with specified representation.</p> Source code in <code>client/ayon_maya/plugins/load/load_vrayproxy.py</code> <pre><code>def update(self, container, context):\n    # type: (dict, dict) -&gt; None\n    \"\"\"Update container with specified representation.\"\"\"\n    node = container['objectName']\n    assert cmds.objExists(node), \"Missing container\"\n\n    members = cmds.sets(node, query=True) or []\n    vraymeshes = cmds.ls(members, type=\"VRayProxy\")\n    assert vraymeshes, \"Cannot find VRayMesh in container\"\n\n    #  get all representations for this version\n    repre_entity = context[\"representation\"]\n    filename = self._get_abc(\n        context[\"project\"][\"name\"], context[\"version\"][\"id\"]\n    )\n    if not filename:\n        filename = self.filepath_from_context(context)\n\n    for vray_mesh in vraymeshes:\n        cmds.setAttr(\"{}.fileName\".format(vray_mesh),\n                     filename,\n                     type=\"string\")\n\n    # Update metadata\n    cmds.setAttr(\"{}.representation\".format(node),\n                 repre_entity[\"id\"],\n                 type=\"string\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_vrayscene.html","title":"load_vrayscene","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_vrayscene.html#client.ayon_maya.plugins.load.load_vrayscene.VRaySceneLoader","title":"<code>VRaySceneLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load Vray scene</p> Source code in <code>client/ayon_maya/plugins/load/load_vrayscene.py</code> <pre><code>class VRaySceneLoader(plugin.Loader):\n    \"\"\"Load Vray scene\"\"\"\n\n    product_types = {\"vrayscene_layer\"}\n    representations = {\"vrscene\"}\n\n    label = \"Import VRay Scene\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name, namespace, data):\n        product_type = context[\"product\"][\"productType\"]\n\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = namespace or unique_namespace(\n            folder_name + \"_\",\n            prefix=\"_\" if folder_name[0].isdigit() else \"\",\n            suffix=\"_\",\n        )\n\n        # Ensure V-Ray for Maya is loaded.\n        cmds.loadPlugin(\"vrayformaya\", quiet=True)\n\n        with maintained_selection():\n            cmds.namespace(addNamespace=namespace)\n            with namespaced(namespace, new=False):\n                nodes, root_node = self.create_vray_scene(\n                    name,\n                    filename=self.filepath_from_context(context)\n                )\n\n        self[:] = nodes\n        if not nodes:\n            return\n\n        # colour the group node\n        project_name = context[\"project\"][\"name\"]\n        settings = get_project_settings(project_name)\n        color = get_load_color_for_product_type(product_type, settings)\n        if color is not None:\n            red, green, blue = color\n            cmds.setAttr(\"{0}.useOutlinerColor\".format(root_node), 1)\n            cmds.setAttr(\n                \"{0}.outlinerColor\".format(root_node), red, green, blue\n            )\n\n        return containerise(\n            name=name,\n            namespace=namespace,\n            nodes=nodes,\n            context=context,\n            loader=self.__class__.__name__)\n\n    def update(self, container, context):\n\n        node = container['objectName']\n        assert cmds.objExists(node), \"Missing container\"\n\n        members = cmds.sets(node, query=True) or []\n        vraymeshes = cmds.ls(members, type=\"VRayScene\")\n        assert vraymeshes, \"Cannot find VRayScene in container\"\n\n        repre_entity = context[\"representation\"]\n        filename = self.filepath_from_context(context)\n\n        for vray_mesh in vraymeshes:\n            cmds.setAttr(\"{}.FilePath\".format(vray_mesh),\n                         filename,\n                         type=\"string\")\n\n        # Update metadata\n        cmds.setAttr(\"{}.representation\".format(node),\n                     repre_entity[\"id\"],\n                     type=\"string\")\n\n    def remove(self, container):\n\n        # Delete container and its contents\n        if cmds.objExists(container['objectName']):\n            members = cmds.sets(container['objectName'], query=True) or []\n            cmds.delete([container['objectName']] + members)\n\n        # Remove the namespace, if empty\n        namespace = container['namespace']\n        if cmds.namespace(exists=namespace):\n            members = cmds.namespaceInfo(namespace, listNamespace=True)\n            if not members:\n                cmds.namespace(removeNamespace=namespace)\n            else:\n                self.log.warning(\"Namespace not deleted because it \"\n                                 \"still has members: %s\", namespace)\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def create_vray_scene(self, name, filename):\n        \"\"\"Re-create the structure created by VRay to support vrscenes\n\n        Args:\n            name(str): name of the asset\n\n        Returns:\n            nodes(list)\n        \"\"\"\n\n        # Create nodes\n        mesh_node_name = \"VRayScene_{}\".format(name)\n\n        trans = cmds.createNode(\n            \"transform\", name=mesh_node_name)\n        vray_scene = cmds.createNode(\n            \"VRayScene\", name=\"{}_VRSCN\".format(mesh_node_name), parent=trans)\n        mesh = cmds.createNode(\n            \"mesh\", name=\"{}_Shape\".format(mesh_node_name), parent=trans)\n\n        cmds.connectAttr(\n            \"{}.outMesh\".format(vray_scene), \"{}.inMesh\".format(mesh))\n\n        cmds.setAttr(\"{}.FilePath\".format(vray_scene), filename, type=\"string\")\n\n        # Lock the shape nodes so the user cannot delete these\n        cmds.lockNode(mesh, lock=True)\n        cmds.lockNode(vray_scene, lock=True)\n\n        # Create important connections\n        cmds.connectAttr(\"time1.outTime\",\n                         \"{0}.inputTime\".format(trans))\n\n        # Connect mesh to initialShadingGroup\n        cmds.sets([mesh], forceElement=\"initialShadingGroup\")\n\n        nodes = [trans, vray_scene, mesh]\n\n        # Fix: Force refresh so the mesh shows correctly after creation\n        cmds.refresh()\n\n        return nodes, trans\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_vrayscene.html#client.ayon_maya.plugins.load.load_vrayscene.VRaySceneLoader.create_vray_scene","title":"<code>create_vray_scene(name, filename)</code>","text":"<p>Re-create the structure created by VRay to support vrscenes</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the asset</p> required <p>Returns:</p> Type Description <p>nodes(list)</p> Source code in <code>client/ayon_maya/plugins/load/load_vrayscene.py</code> <pre><code>def create_vray_scene(self, name, filename):\n    \"\"\"Re-create the structure created by VRay to support vrscenes\n\n    Args:\n        name(str): name of the asset\n\n    Returns:\n        nodes(list)\n    \"\"\"\n\n    # Create nodes\n    mesh_node_name = \"VRayScene_{}\".format(name)\n\n    trans = cmds.createNode(\n        \"transform\", name=mesh_node_name)\n    vray_scene = cmds.createNode(\n        \"VRayScene\", name=\"{}_VRSCN\".format(mesh_node_name), parent=trans)\n    mesh = cmds.createNode(\n        \"mesh\", name=\"{}_Shape\".format(mesh_node_name), parent=trans)\n\n    cmds.connectAttr(\n        \"{}.outMesh\".format(vray_scene), \"{}.inMesh\".format(mesh))\n\n    cmds.setAttr(\"{}.FilePath\".format(vray_scene), filename, type=\"string\")\n\n    # Lock the shape nodes so the user cannot delete these\n    cmds.lockNode(mesh, lock=True)\n    cmds.lockNode(vray_scene, lock=True)\n\n    # Create important connections\n    cmds.connectAttr(\"time1.outTime\",\n                     \"{0}.inputTime\".format(trans))\n\n    # Connect mesh to initialShadingGroup\n    cmds.sets([mesh], forceElement=\"initialShadingGroup\")\n\n    nodes = [trans, vray_scene, mesh]\n\n    # Fix: Force refresh so the mesh shows correctly after creation\n    cmds.refresh()\n\n    return nodes, trans\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_xgen.html","title":"load_xgen","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_xgen.html#client.ayon_maya.plugins.load.load_xgen.XgenLoader","title":"<code>XgenLoader</code>","text":"<p>               Bases: <code>ReferenceLoader</code></p> <p>Load Xgen as reference</p> Source code in <code>client/ayon_maya/plugins/load/load_xgen.py</code> <pre><code>class XgenLoader(plugin.ReferenceLoader):\n    \"\"\"Load Xgen as reference\"\"\"\n\n    product_types = {\"xgen\"}\n    representations = {\"ma\", \"mb\"}\n\n    label = \"Reference Xgen\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def get_xgen_xgd_paths(self, palette):\n        _, maya_extension = os.path.splitext(current_file())\n        xgen_file = current_file().replace(\n            maya_extension,\n            \"__{}.xgen\".format(palette.replace(\"|\", \"\").replace(\":\", \"__\"))\n        )\n        xgd_file = xgen_file.replace(\".xgen\", \".xgd\")\n        return xgen_file, xgd_file\n\n    def process_reference(self, context, name, namespace, options):\n        # Validate workfile has a path.\n        if current_file() is None:\n            QtWidgets.QMessageBox.warning(\n                None,\n                \"\",\n                \"Current workfile has not been saved. Please save the workfile\"\n                \" before loading an Xgen.\"\n            )\n            return\n\n        maya_filepath = self.prepare_root_value(\n            file_url=self.filepath_from_context(context),\n            project_name=context[\"project\"][\"name\"]\n        )\n\n        # Reference xgen. Xgen does not like being referenced in under a group.\n        with maintained_selection():\n            nodes = cmds.file(\n                maya_filepath,\n                namespace=namespace,\n                sharedReferenceFile=False,\n                reference=True,\n                returnNewNodes=True\n            )\n\n            xgen_palette = cmds.ls(\n                nodes, type=\"xgmPalette\", long=True\n            )[0].replace(\"|\", \"\")\n\n            xgen_file, xgd_file = self.get_xgen_xgd_paths(xgen_palette)\n            self.set_palette_attributes(xgen_palette, xgen_file, xgd_file)\n\n            # Change the cache and disk values of xgDataPath and xgProjectPath\n            # to ensure paths are setup correctly.\n            project_path = os.path.dirname(current_file()).replace(\"\\\\\", \"/\")\n            xgenm.setAttr(\"xgProjectPath\", project_path, xgen_palette)\n            data_path = \"${{PROJECT}}xgen/collections/{};{}\".format(\n                xgen_palette.replace(\":\", \"__ns__\"),\n                xgenm.getAttr(\"xgDataPath\", xgen_palette)\n            )\n            xgenm.setAttr(\"xgDataPath\", data_path, xgen_palette)\n\n            data = {\"xgProjectPath\": project_path, \"xgDataPath\": data_path}\n            write_xgen_file(data, xgen_file)\n\n            # This create an expression attribute of float. If we did not add\n            # any changes to collection, then Xgen does not create an xgd file\n            # on save. This gives errors when launching the workfile again due\n            # to trying to find the xgd file.\n            name = \"custom_float_ignore\"\n            if name not in xgenm.customAttrs(xgen_palette):\n                xgenm.addCustomAttr(\n                    \"custom_float_ignore\", xgen_palette\n                )\n\n            shapes = cmds.ls(nodes, shapes=True, long=True)\n\n            new_nodes = (list(set(nodes) - set(shapes)))\n\n            self[:] = new_nodes\n\n        return new_nodes\n\n    def set_palette_attributes(self, xgen_palette, xgen_file, xgd_file):\n        cmds.setAttr(\n            \"{}.xgBaseFile\".format(xgen_palette),\n            os.path.basename(xgen_file),\n            type=\"string\"\n        )\n        cmds.setAttr(\n            \"{}.xgFileName\".format(xgen_palette),\n            os.path.basename(xgd_file),\n            type=\"string\"\n        )\n        cmds.setAttr(\"{}.xgExportAsDelta\".format(xgen_palette), True)\n\n    def update(self, container, context):\n        \"\"\"Workflow for updating Xgen.\n\n        - Export changes to delta file.\n        - Copy and overwrite the workspace .xgen file.\n        - Set collection attributes to not include delta files.\n        - Update xgen maya file reference.\n        - Apply the delta file changes.\n        - Reset collection attributes to include delta files.\n\n        We have to do this workflow because when using referencing of the xgen\n        collection, Maya implicitly imports the Xgen data from the xgen file so\n        we dont have any control over when adding the delta file changes.\n\n        There is an implicit increment of the xgen and delta files, due to\n        using the workfile basename.\n        \"\"\"\n        # Storing current description to try and maintain later.\n        current_description = (\n            xgenm.xgGlobal.DescriptionEditor.currentDescription()\n        )\n\n        container_node = container[\"objectName\"]\n        members = get_container_members(container_node)\n        xgen_palette = cmds.ls(\n            members, type=\"xgmPalette\", long=True\n        )[0].replace(\"|\", \"\")\n        xgen_file, xgd_file = self.get_xgen_xgd_paths(xgen_palette)\n\n        # Export current changes to apply later.\n        xgenm.createDelta(xgen_palette.replace(\"|\", \"\"), xgd_file)\n\n        self.set_palette_attributes(xgen_palette, xgen_file, xgd_file)\n\n        maya_file = self.filepath_from_context(context)\n        _, extension = os.path.splitext(maya_file)\n        new_xgen_file = maya_file.replace(extension, \".xgen\")\n        data_path = \"\"\n        with open(new_xgen_file, \"r\") as f:\n            for line in f:\n                if line.startswith(\"\\txgDataPath\"):\n                    line = line.rstrip()\n                    data_path = line.split(\"\\t\")[-1]\n                    break\n\n        project_path = os.path.dirname(current_file()).replace(\"\\\\\", \"/\")\n        data_path = \"${{PROJECT}}xgen/collections/{};{}\".format(\n            xgen_palette.replace(\":\", \"__ns__\"),\n            data_path\n        )\n        data = {\"xgProjectPath\": project_path, \"xgDataPath\": data_path}\n        shutil.copy(new_xgen_file, xgen_file)\n        write_xgen_file(data, xgen_file)\n\n        attribute_data = {\n            \"{}.xgFileName\".format(xgen_palette): os.path.basename(xgen_file),\n            \"{}.xgBaseFile\".format(xgen_palette): \"\",\n            \"{}.xgExportAsDelta\".format(xgen_palette): False\n        }\n        with attribute_values(attribute_data):\n            super().update(container, context)\n\n            xgenm.applyDelta(xgen_palette.replace(\"|\", \"\"), xgd_file)\n\n        # Restore current selected description if it exists.\n        if cmds.objExists(current_description):\n            xgenm.xgGlobal.DescriptionEditor.setCurrentDescription(\n                current_description\n            )\n        # Full UI refresh.\n        xgenm.xgGlobal.DescriptionEditor.refresh(\"Full\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_xgen.html#client.ayon_maya.plugins.load.load_xgen.XgenLoader.update","title":"<code>update(container, context)</code>","text":"<p>Workflow for updating Xgen.</p> <ul> <li>Export changes to delta file.</li> <li>Copy and overwrite the workspace .xgen file.</li> <li>Set collection attributes to not include delta files.</li> <li>Update xgen maya file reference.</li> <li>Apply the delta file changes.</li> <li>Reset collection attributes to include delta files.</li> </ul> <p>We have to do this workflow because when using referencing of the xgen collection, Maya implicitly imports the Xgen data from the xgen file so we dont have any control over when adding the delta file changes.</p> <p>There is an implicit increment of the xgen and delta files, due to using the workfile basename.</p> Source code in <code>client/ayon_maya/plugins/load/load_xgen.py</code> <pre><code>def update(self, container, context):\n    \"\"\"Workflow for updating Xgen.\n\n    - Export changes to delta file.\n    - Copy and overwrite the workspace .xgen file.\n    - Set collection attributes to not include delta files.\n    - Update xgen maya file reference.\n    - Apply the delta file changes.\n    - Reset collection attributes to include delta files.\n\n    We have to do this workflow because when using referencing of the xgen\n    collection, Maya implicitly imports the Xgen data from the xgen file so\n    we dont have any control over when adding the delta file changes.\n\n    There is an implicit increment of the xgen and delta files, due to\n    using the workfile basename.\n    \"\"\"\n    # Storing current description to try and maintain later.\n    current_description = (\n        xgenm.xgGlobal.DescriptionEditor.currentDescription()\n    )\n\n    container_node = container[\"objectName\"]\n    members = get_container_members(container_node)\n    xgen_palette = cmds.ls(\n        members, type=\"xgmPalette\", long=True\n    )[0].replace(\"|\", \"\")\n    xgen_file, xgd_file = self.get_xgen_xgd_paths(xgen_palette)\n\n    # Export current changes to apply later.\n    xgenm.createDelta(xgen_palette.replace(\"|\", \"\"), xgd_file)\n\n    self.set_palette_attributes(xgen_palette, xgen_file, xgd_file)\n\n    maya_file = self.filepath_from_context(context)\n    _, extension = os.path.splitext(maya_file)\n    new_xgen_file = maya_file.replace(extension, \".xgen\")\n    data_path = \"\"\n    with open(new_xgen_file, \"r\") as f:\n        for line in f:\n            if line.startswith(\"\\txgDataPath\"):\n                line = line.rstrip()\n                data_path = line.split(\"\\t\")[-1]\n                break\n\n    project_path = os.path.dirname(current_file()).replace(\"\\\\\", \"/\")\n    data_path = \"${{PROJECT}}xgen/collections/{};{}\".format(\n        xgen_palette.replace(\":\", \"__ns__\"),\n        data_path\n    )\n    data = {\"xgProjectPath\": project_path, \"xgDataPath\": data_path}\n    shutil.copy(new_xgen_file, xgen_file)\n    write_xgen_file(data, xgen_file)\n\n    attribute_data = {\n        \"{}.xgFileName\".format(xgen_palette): os.path.basename(xgen_file),\n        \"{}.xgBaseFile\".format(xgen_palette): \"\",\n        \"{}.xgExportAsDelta\".format(xgen_palette): False\n    }\n    with attribute_values(attribute_data):\n        super().update(container, context)\n\n        xgenm.applyDelta(xgen_palette.replace(\"|\", \"\"), xgd_file)\n\n    # Restore current selected description if it exists.\n    if cmds.objExists(current_description):\n        xgenm.xgGlobal.DescriptionEditor.setCurrentDescription(\n            current_description\n        )\n    # Full UI refresh.\n    xgenm.xgGlobal.DescriptionEditor.refresh(\"Full\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_yeti_cache.html","title":"load_yeti_cache","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_yeti_cache.html#client.ayon_maya.plugins.load.load_yeti_cache.YetiCacheLoader","title":"<code>YetiCacheLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load Yeti Cache with one or more Yeti nodes</p> Source code in <code>client/ayon_maya/plugins/load/load_yeti_cache.py</code> <pre><code>class YetiCacheLoader(plugin.Loader):\n    \"\"\"Load Yeti Cache with one or more Yeti nodes\"\"\"\n\n    product_types = {\"yeticache\", \"yetiRig\"}\n    representations = {\"fur\"}\n\n    label = \"Load Yeti Cache\"\n    order = -9\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        \"\"\"Loads a .fursettings file defining how to load .fur sequences\n\n        A single yeticache or yetiRig can have more than a single pgYetiMaya\n        nodes and thus load more than a single yeti.fur sequence.\n\n        The .fursettings file defines what the node names should be and also\n        what \"cbId\" attribute they should receive to match the original source\n        and allow published looks to also work for Yeti rigs and its caches.\n\n        \"\"\"\n\n        product_type = context[\"product\"][\"productType\"]\n\n        # Build namespace\n        folder_name = context[\"folder\"][\"name\"]\n        if namespace is None:\n            namespace = self.create_namespace(folder_name)\n\n        # Ensure Yeti is loaded\n        if not cmds.pluginInfo(\"pgYetiMaya\", query=True, loaded=True):\n            cmds.loadPlugin(\"pgYetiMaya\", quiet=True)\n\n        # Create Yeti cache nodes according to settings\n        path = self.filepath_from_context(context)\n        settings = self.read_settings(path)\n        nodes = []\n        for node in settings[\"nodes\"]:\n            nodes.extend(self.create_node(namespace, node))\n\n        group_name = \"{}:{}\".format(namespace, name)\n        group_node = cmds.group(nodes, name=group_name)\n        project_name = context[\"project\"][\"name\"]\n\n        settings = get_project_settings(project_name)\n        color = get_load_color_for_product_type(product_type, settings)\n        if color is not None:\n            red, green, blue = color\n            cmds.setAttr(group_node + \".useOutlinerColor\", 1)\n            cmds.setAttr(group_node + \".outlinerColor\", red, green, blue)\n\n        nodes.append(group_node)\n\n        self[:] = nodes\n\n        return containerise(\n            name=name,\n            namespace=namespace,\n            nodes=nodes,\n            context=context,\n            loader=self.__class__.__name__\n        )\n\n    def remove(self, container):\n\n        from maya import cmds\n\n        namespace = container[\"namespace\"]\n        container_name = container[\"objectName\"]\n\n        self.log.info(\"Removing '%s' from Maya..\" % container[\"name\"])\n\n        container_content = cmds.sets(container_name, query=True)\n        nodes = cmds.ls(container_content, long=True)\n\n        nodes.append(container_name)\n\n        try:\n            cmds.delete(nodes)\n        except ValueError:\n            # Already implicitly deleted by Maya upon removing reference\n            pass\n\n        cmds.namespace(removeNamespace=namespace, deleteNamespaceContent=True)\n\n    def update(self, container, context):\n        repre_entity = context[\"representation\"]\n        namespace = container[\"namespace\"]\n        container_node = container[\"objectName\"]\n\n        path = self.filepath_from_context(context)\n        settings = self.read_settings(path)\n\n        # Collect scene information of asset\n        set_members = lib.get_container_members(container)\n        container_root = lib.get_container_transforms(container,\n                                                      members=set_members,\n                                                      root=True)\n        scene_nodes = cmds.ls(set_members, type=\"pgYetiMaya\", long=True)\n\n        # Build lookup with cbId as keys\n        scene_lookup = defaultdict(list)\n        for node in scene_nodes:\n            cb_id = lib.get_id(node)\n            scene_lookup[cb_id].append(node)\n\n        # Re-assemble metadata with cbId as keys\n        meta_data_lookup = {n[\"cbId\"]: n for n in settings[\"nodes\"]}\n\n        # Delete nodes by \"cbId\" that are not in the updated version\n        to_delete_lookup = {cb_id for cb_id in scene_lookup.keys() if\n                            cb_id not in meta_data_lookup}\n        if to_delete_lookup:\n\n            # Get nodes and remove entry from lookup\n            to_remove = []\n            for _id in to_delete_lookup:\n                # Get all related nodes\n                shapes = scene_lookup[_id]\n                # Get the parents of all shapes under the ID\n                transforms = cmds.listRelatives(shapes,\n                                                parent=True,\n                                                fullPath=True) or []\n                to_remove.extend(shapes + transforms)\n\n                # Remove id from lookup\n                scene_lookup.pop(_id, None)\n\n            cmds.delete(to_remove)\n\n        for cb_id, node_settings in meta_data_lookup.items():\n\n            if cb_id not in scene_lookup:\n                # Create new nodes\n                self.log.info(\"Creating new nodes ..\")\n\n                new_nodes = self.create_node(namespace, node_settings)\n                cmds.sets(new_nodes, addElement=container_node)\n                cmds.parent(new_nodes, container_root)\n\n            else:\n                # Update the matching nodes\n                scene_nodes = scene_lookup[cb_id]\n                lookup_result = meta_data_lookup[cb_id][\"name\"]\n\n                # Remove namespace if any (e.g.: \"character_01_:head_YNShape\")\n                node_name = lookup_result.rsplit(\":\", 1)[-1]\n\n                for scene_node in scene_nodes:\n\n                    # Get transform node, this makes renaming easier\n                    transforms = cmds.listRelatives(scene_node,\n                                                    parent=True,\n                                                    fullPath=True) or []\n                    assert len(transforms) == 1, \"This is a bug!\"\n\n                    # Get scene node's namespace and rename the transform node\n                    lead = scene_node.rsplit(\":\", 1)[0]\n                    namespace = \":{}\".format(lead.rsplit(\"|\")[-1])\n\n                    new_shape_name = \"{}:{}\".format(namespace, node_name)\n                    new_trans_name = new_shape_name.rsplit(\"Shape\", 1)[0]\n\n                    transform_node = transforms[0]\n                    cmds.rename(transform_node,\n                                new_trans_name,\n                                ignoreShape=False)\n\n                    # Get the newly named shape node\n                    yeti_nodes = cmds.listRelatives(new_trans_name,\n                                                    children=True)\n                    yeti_node = yeti_nodes[0]\n\n                    for attr, value in node_settings[\"attrs\"].items():\n                        if attr in SKIP_UPDATE_ATTRS:\n                            self.log.info(\n                                SKIP_ATTR_MESSAGE, yeti_node, attr, value\n                            )\n                            continue\n                        set_attribute(attr, value, yeti_node)\n\n                    # Set up user defined attributes\n                    user_variables = node_settings.get(\"user_variables\", {})\n                    for attr, value in user_variables.items():\n                        was_value_set = create_yeti_variable(\n                            yeti_shape_node=yeti_node,\n                            attr_name=attr,\n                            value=value,\n                            # We do not want to update the\n                            # value if it already exists so\n                            # that any local overrides that\n                            # may have been applied still\n                            # persist\n                            force_value=False\n                        )\n                        if not was_value_set:\n                            self.log.info(\n                                SKIP_ATTR_MESSAGE, yeti_node, attr, value\n                            )\n\n        cmds.setAttr(\"{}.representation\".format(container_node),\n                     repre_entity[\"id\"],\n                     typ=\"string\")\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    # helper functions\n    def create_namespace(self, folder_name):\n        \"\"\"Create a unique namespace\n        Args:\n            asset (dict): asset information\n\n        \"\"\"\n\n        asset_name = \"{}_\".format(folder_name)\n        prefix = \"_\" if asset_name[0].isdigit() else \"\"\n        namespace = lib.unique_namespace(\n            asset_name,\n            prefix=prefix,\n            suffix=\"_\"\n        )\n\n        return namespace\n\n    def get_cache_node_filepath(self, root, node_name):\n        \"\"\"Get the cache file path for one of the yeti nodes.\n\n        All caches with more than 1 frame need cache file name set with `%04d`\n        If the cache has only one frame we return the file name as we assume\n        it is a snapshot.\n\n        This expects the files to be named after the \"node name\" through\n        exports with &lt;Name&gt; in Yeti.\n\n        Args:\n            root(str): Folder containing cache files to search in.\n            node_name(str): Node name to search cache files for\n\n        Returns:\n            str: Cache file path value needed for cacheFileName attribute\n\n        \"\"\"\n\n        name = node_name.replace(\":\", \"_\")\n        pattern = r\"^({name})(\\.[0-9]+)?(\\.fur)$\".format(name=re.escape(name))\n\n        files = [fname for fname in os.listdir(root) if re.match(pattern,\n                                                                 fname)]\n        if not files:\n            self.log.error(\"Could not find cache files for '{}' \"\n                           \"with pattern {}\".format(node_name, pattern))\n            return\n\n        if len(files) == 1:\n            # Single file\n            return os.path.join(root, files[0])\n\n        # Get filename for the sequence with padding\n        collections, remainder = clique.assemble(files)\n        assert not remainder, \"This is a bug\"\n        assert len(collections) == 1, \"This is a bug\"\n        collection = collections[0]\n\n        # Formats name as {head}%d{tail} like cache.%04d.fur\n        fname = collection.format(\"{head}{padding}{tail}\")\n        return os.path.join(root, fname)\n\n    def create_node(self, namespace, node_settings):\n        \"\"\"Create nodes with the correct namespace and settings\n\n        Args:\n            namespace(str): namespace\n            node_settings(dict): Single \"nodes\" entry from .fursettings file.\n\n        Returns:\n             list: Created nodes\n\n        \"\"\"\n        nodes = []\n\n        # Get original names and ids\n        orig_transform_name = node_settings[\"transform\"][\"name\"]\n        orig_shape_name = node_settings[\"name\"]\n\n        # Add namespace\n        transform_name = \"{}:{}\".format(namespace, orig_transform_name)\n        shape_name = \"{}:{}\".format(namespace, orig_shape_name)\n\n        # Create pgYetiMaya node\n        transform_node = cmds.createNode(\"transform\",\n                                         name=transform_name)\n        yeti_node = cmds.createNode(\"pgYetiMaya\",\n                                    name=shape_name,\n                                    parent=transform_node)\n\n        lib.set_id(transform_node, node_settings[\"transform\"][\"cbId\"])\n        lib.set_id(yeti_node, node_settings[\"cbId\"])\n\n        nodes.extend([transform_node, yeti_node])\n\n        # Update attributes with defaults\n        attributes = node_settings[\"attrs\"]\n        attributes.update({\n            \"verbosity\": 2,\n            \"fileMode\": 1,\n\n            # Fix render stats, like Yeti's own\n            # ../scripts/pgYetiNode.mel script\n            \"visibleInReflections\": True,\n            \"visibleInRefractions\": True\n        })\n\n        if \"viewportDensity\" not in attributes:\n            attributes[\"viewportDensity\"] = 0.1\n\n        # Apply attributes to pgYetiMaya node\n        for attr, value in attributes.items():\n            set_attribute(attr, value, yeti_node)\n\n        # Set up user defined attributes\n        user_variables = node_settings.get(\"user_variables\", {})\n        for attr, value in user_variables.items():\n            create_yeti_variable(yeti_shape_node=yeti_node,\n                                 attr_name=attr,\n                                 value=value)\n\n        # Connect to the time node\n        cmds.connectAttr(\"time1.outTime\", \"%s.currentTime\" % yeti_node)\n\n        return nodes\n\n    def read_settings(self, path):\n        \"\"\"Read .fursettings file and compute some additional attributes\"\"\"\n\n        with open(path, \"r\") as fp:\n            fur_settings = json.load(fp)\n\n        if \"nodes\" not in fur_settings:\n            raise RuntimeError(\"Encountered invalid data, \"\n                               \"expected 'nodes' in fursettings.\")\n\n        # Compute the cache file name values we want to set for the nodes\n        root = os.path.dirname(path)\n        for node in fur_settings[\"nodes\"]:\n            cache_filename = self.get_cache_node_filepath(\n                root=root, node_name=node[\"name\"])\n\n            attrs = node.get(\"attrs\", {})       # allow 'attrs' to not exist\n            attrs[\"cacheFileName\"] = cache_filename\n            node[\"attrs\"] = attrs\n\n        return fur_settings\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_yeti_cache.html#client.ayon_maya.plugins.load.load_yeti_cache.YetiCacheLoader.create_namespace","title":"<code>create_namespace(folder_name)</code>","text":"<p>Create a unique namespace Args:     asset (dict): asset information</p> Source code in <code>client/ayon_maya/plugins/load/load_yeti_cache.py</code> <pre><code>def create_namespace(self, folder_name):\n    \"\"\"Create a unique namespace\n    Args:\n        asset (dict): asset information\n\n    \"\"\"\n\n    asset_name = \"{}_\".format(folder_name)\n    prefix = \"_\" if asset_name[0].isdigit() else \"\"\n    namespace = lib.unique_namespace(\n        asset_name,\n        prefix=prefix,\n        suffix=\"_\"\n    )\n\n    return namespace\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_yeti_cache.html#client.ayon_maya.plugins.load.load_yeti_cache.YetiCacheLoader.create_node","title":"<code>create_node(namespace, node_settings)</code>","text":"<p>Create nodes with the correct namespace and settings</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str</code> <p>namespace</p> required <code>node_settings</code> <code>dict</code> <p>Single \"nodes\" entry from .fursettings file.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Created nodes</p> Source code in <code>client/ayon_maya/plugins/load/load_yeti_cache.py</code> <pre><code>def create_node(self, namespace, node_settings):\n    \"\"\"Create nodes with the correct namespace and settings\n\n    Args:\n        namespace(str): namespace\n        node_settings(dict): Single \"nodes\" entry from .fursettings file.\n\n    Returns:\n         list: Created nodes\n\n    \"\"\"\n    nodes = []\n\n    # Get original names and ids\n    orig_transform_name = node_settings[\"transform\"][\"name\"]\n    orig_shape_name = node_settings[\"name\"]\n\n    # Add namespace\n    transform_name = \"{}:{}\".format(namespace, orig_transform_name)\n    shape_name = \"{}:{}\".format(namespace, orig_shape_name)\n\n    # Create pgYetiMaya node\n    transform_node = cmds.createNode(\"transform\",\n                                     name=transform_name)\n    yeti_node = cmds.createNode(\"pgYetiMaya\",\n                                name=shape_name,\n                                parent=transform_node)\n\n    lib.set_id(transform_node, node_settings[\"transform\"][\"cbId\"])\n    lib.set_id(yeti_node, node_settings[\"cbId\"])\n\n    nodes.extend([transform_node, yeti_node])\n\n    # Update attributes with defaults\n    attributes = node_settings[\"attrs\"]\n    attributes.update({\n        \"verbosity\": 2,\n        \"fileMode\": 1,\n\n        # Fix render stats, like Yeti's own\n        # ../scripts/pgYetiNode.mel script\n        \"visibleInReflections\": True,\n        \"visibleInRefractions\": True\n    })\n\n    if \"viewportDensity\" not in attributes:\n        attributes[\"viewportDensity\"] = 0.1\n\n    # Apply attributes to pgYetiMaya node\n    for attr, value in attributes.items():\n        set_attribute(attr, value, yeti_node)\n\n    # Set up user defined attributes\n    user_variables = node_settings.get(\"user_variables\", {})\n    for attr, value in user_variables.items():\n        create_yeti_variable(yeti_shape_node=yeti_node,\n                             attr_name=attr,\n                             value=value)\n\n    # Connect to the time node\n    cmds.connectAttr(\"time1.outTime\", \"%s.currentTime\" % yeti_node)\n\n    return nodes\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_yeti_cache.html#client.ayon_maya.plugins.load.load_yeti_cache.YetiCacheLoader.get_cache_node_filepath","title":"<code>get_cache_node_filepath(root, node_name)</code>","text":"<p>Get the cache file path for one of the yeti nodes.</p> <p>All caches with more than 1 frame need cache file name set with <code>%04d</code> If the cache has only one frame we return the file name as we assume it is a snapshot.</p> <p>This expects the files to be named after the \"node name\" through exports with  in Yeti. <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>Folder containing cache files to search in.</p> required <code>node_name</code> <code>str</code> <p>Node name to search cache files for</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Cache file path value needed for cacheFileName attribute</p> Source code in <code>client/ayon_maya/plugins/load/load_yeti_cache.py</code> <pre><code>def get_cache_node_filepath(self, root, node_name):\n    \"\"\"Get the cache file path for one of the yeti nodes.\n\n    All caches with more than 1 frame need cache file name set with `%04d`\n    If the cache has only one frame we return the file name as we assume\n    it is a snapshot.\n\n    This expects the files to be named after the \"node name\" through\n    exports with &lt;Name&gt; in Yeti.\n\n    Args:\n        root(str): Folder containing cache files to search in.\n        node_name(str): Node name to search cache files for\n\n    Returns:\n        str: Cache file path value needed for cacheFileName attribute\n\n    \"\"\"\n\n    name = node_name.replace(\":\", \"_\")\n    pattern = r\"^({name})(\\.[0-9]+)?(\\.fur)$\".format(name=re.escape(name))\n\n    files = [fname for fname in os.listdir(root) if re.match(pattern,\n                                                             fname)]\n    if not files:\n        self.log.error(\"Could not find cache files for '{}' \"\n                       \"with pattern {}\".format(node_name, pattern))\n        return\n\n    if len(files) == 1:\n        # Single file\n        return os.path.join(root, files[0])\n\n    # Get filename for the sequence with padding\n    collections, remainder = clique.assemble(files)\n    assert not remainder, \"This is a bug\"\n    assert len(collections) == 1, \"This is a bug\"\n    collection = collections[0]\n\n    # Formats name as {head}%d{tail} like cache.%04d.fur\n    fname = collection.format(\"{head}{padding}{tail}\")\n    return os.path.join(root, fname)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_yeti_cache.html#client.ayon_maya.plugins.load.load_yeti_cache.YetiCacheLoader.load","title":"<code>load(context, name=None, namespace=None, data=None)</code>","text":"<p>Loads a .fursettings file defining how to load .fur sequences</p> <p>A single yeticache or yetiRig can have more than a single pgYetiMaya nodes and thus load more than a single yeti.fur sequence.</p> <p>The .fursettings file defines what the node names should be and also what \"cbId\" attribute they should receive to match the original source and allow published looks to also work for Yeti rigs and its caches.</p> Source code in <code>client/ayon_maya/plugins/load/load_yeti_cache.py</code> <pre><code>def load(self, context, name=None, namespace=None, data=None):\n    \"\"\"Loads a .fursettings file defining how to load .fur sequences\n\n    A single yeticache or yetiRig can have more than a single pgYetiMaya\n    nodes and thus load more than a single yeti.fur sequence.\n\n    The .fursettings file defines what the node names should be and also\n    what \"cbId\" attribute they should receive to match the original source\n    and allow published looks to also work for Yeti rigs and its caches.\n\n    \"\"\"\n\n    product_type = context[\"product\"][\"productType\"]\n\n    # Build namespace\n    folder_name = context[\"folder\"][\"name\"]\n    if namespace is None:\n        namespace = self.create_namespace(folder_name)\n\n    # Ensure Yeti is loaded\n    if not cmds.pluginInfo(\"pgYetiMaya\", query=True, loaded=True):\n        cmds.loadPlugin(\"pgYetiMaya\", quiet=True)\n\n    # Create Yeti cache nodes according to settings\n    path = self.filepath_from_context(context)\n    settings = self.read_settings(path)\n    nodes = []\n    for node in settings[\"nodes\"]:\n        nodes.extend(self.create_node(namespace, node))\n\n    group_name = \"{}:{}\".format(namespace, name)\n    group_node = cmds.group(nodes, name=group_name)\n    project_name = context[\"project\"][\"name\"]\n\n    settings = get_project_settings(project_name)\n    color = get_load_color_for_product_type(product_type, settings)\n    if color is not None:\n        red, green, blue = color\n        cmds.setAttr(group_node + \".useOutlinerColor\", 1)\n        cmds.setAttr(group_node + \".outlinerColor\", red, green, blue)\n\n    nodes.append(group_node)\n\n    self[:] = nodes\n\n    return containerise(\n        name=name,\n        namespace=namespace,\n        nodes=nodes,\n        context=context,\n        loader=self.__class__.__name__\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_yeti_cache.html#client.ayon_maya.plugins.load.load_yeti_cache.YetiCacheLoader.read_settings","title":"<code>read_settings(path)</code>","text":"<p>Read .fursettings file and compute some additional attributes</p> Source code in <code>client/ayon_maya/plugins/load/load_yeti_cache.py</code> <pre><code>def read_settings(self, path):\n    \"\"\"Read .fursettings file and compute some additional attributes\"\"\"\n\n    with open(path, \"r\") as fp:\n        fur_settings = json.load(fp)\n\n    if \"nodes\" not in fur_settings:\n        raise RuntimeError(\"Encountered invalid data, \"\n                           \"expected 'nodes' in fursettings.\")\n\n    # Compute the cache file name values we want to set for the nodes\n    root = os.path.dirname(path)\n    for node in fur_settings[\"nodes\"]:\n        cache_filename = self.get_cache_node_filepath(\n            root=root, node_name=node[\"name\"])\n\n        attrs = node.get(\"attrs\", {})       # allow 'attrs' to not exist\n        attrs[\"cacheFileName\"] = cache_filename\n        node[\"attrs\"] = attrs\n\n    return fur_settings\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_yeti_cache.html#client.ayon_maya.plugins.load.load_yeti_cache.set_attribute","title":"<code>set_attribute(node, attr, value)</code>","text":"<p>Wrapper of set attribute which ignores None values</p> Source code in <code>client/ayon_maya/plugins/load/load_yeti_cache.py</code> <pre><code>def set_attribute(node, attr, value):\n    \"\"\"Wrapper of set attribute which ignores None values\"\"\"\n    if value is None:\n        return\n    lib.set_attribute(node, attr, value)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/load/load_yeti_rig.html","title":"load_yeti_rig","text":""},{"location":"autoapi/client/ayon_maya/plugins/load/load_yeti_rig.html#client.ayon_maya.plugins.load.load_yeti_rig.YetiRigLoader","title":"<code>YetiRigLoader</code>","text":"<p>               Bases: <code>ReferenceLoader</code></p> <p>This loader will load Yeti rig.</p> Source code in <code>client/ayon_maya/plugins/load/load_yeti_rig.py</code> <pre><code>class YetiRigLoader(plugin.ReferenceLoader):\n    \"\"\"This loader will load Yeti rig.\"\"\"\n\n    product_types = {\"yetiRig\"}\n    representations = {\"ma\"}\n\n    label = \"Load Yeti Rig\"\n    order = -9\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    # From settings\n    create_cache_instance_on_load = True\n\n    def process_reference(\n        self, context, name=None, namespace=None, options=None\n    ):\n        path = self.filepath_from_context(context)\n\n        attach_to_root = options.get(\"attach_to_root\", True)\n        group_name = options[\"group_name\"]\n\n        # no group shall be created\n        if not attach_to_root:\n            group_name = namespace\n\n        with lib.maintained_selection():\n            file_url = self.prepare_root_value(\n                path, context[\"project\"][\"name\"]\n            )\n            nodes = cmds.file(\n                file_url,\n                namespace=namespace,\n                reference=True,\n                returnNewNodes=True,\n                groupReference=attach_to_root,\n                groupName=group_name\n            )\n\n        color = plugin.get_load_color_for_product_type(\"yetiRig\")\n        if color is not None:\n            red, green, blue = color\n            cmds.setAttr(group_name + \".useOutlinerColor\", 1)\n            cmds.setAttr(\n                group_name + \".outlinerColor\", red, green, blue\n            )\n        self[:] = nodes\n\n        if self.create_cache_instance_on_load:\n            # Automatically create in instance to allow publishing the loaded\n            # yeti rig into a yeti cache\n            self._create_yeti_cache_instance(nodes, variant=namespace)\n\n        return nodes\n\n    def _create_yeti_cache_instance(self, nodes: List[str], variant: str):\n        \"\"\"Create a yeticache product type instance to publish the output.\n\n        This is similar to how loading animation rig will automatically create\n        an animation instance for publishing any loaded character rigs, but\n        then for yeti rigs.\n\n        Args:\n            nodes (List[str]): Nodes generated on load.\n            variant (str): Variant for the yeti cache instance to create.\n\n        \"\"\"\n\n        # Find the roots amongst the loaded nodes\n        yeti_nodes = cmds.ls(nodes, type=\"pgYetiMaya\", long=True)\n        assert yeti_nodes, \"No pgYetiMaya nodes in rig, this is a bug.\"\n\n        self.log.info(\"Creating variant: {}\".format(variant))\n\n        creator_identifier = \"io.openpype.creators.maya.yeticache\"\n\n        host = registered_host()\n        create_context = CreateContext(host)\n\n        with lib.maintained_selection():\n            cmds.select(yeti_nodes, noExpand=True)\n            create_context.create(\n                creator_identifier=creator_identifier,\n                variant=variant,\n                pre_create_data={\"use_selection\": True}\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_animation.html","title":"collect_animation","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_animation.html#client.ayon_maya.plugins.publish.collect_animation.CollectAnimationOutputGeometry","title":"<code>CollectAnimationOutputGeometry</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect out hierarchy data for instance.</p> <p>Collect all hierarchy nodes which reside in the out_SET of the animation instance or point cache instance. This is to unify the logic of retrieving that specific data. This eliminates the need to write two separate pieces of logic to fetch all hierarchy nodes.</p> <p>Results in a list of nodes from the content of the instances</p> Source code in <code>client/ayon_maya/plugins/publish/collect_animation.py</code> <pre><code>class CollectAnimationOutputGeometry(plugin.MayaInstancePlugin):\n    \"\"\"Collect out hierarchy data for instance.\n\n    Collect all hierarchy nodes which reside in the out_SET of the animation\n    instance or point cache instance. This is to unify the logic of retrieving\n    that specific data. This eliminates the need to write two separate pieces\n    of logic to fetch all hierarchy nodes.\n\n    Results in a list of nodes from the content of the instances\n\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.4\n    families = [\"animation\"]\n    label = \"Collect Animation Output Geometry\"\n\n    ignore_type = [\"constraints\"]\n\n    def process(self, instance):\n        \"\"\"Collect the hierarchy nodes\"\"\"\n\n        product_type = instance.data[\"productType\"]\n        out_set = next((i for i in instance.data[\"setMembers\"] if\n                        i.endswith(\"out_SET\")), None)\n\n        if out_set is None:\n            self.log.warning((\n                \"Expecting out_SET for instance of product type '{}'\"\n            ).format(product_type))\n            return\n\n        members = cmds.ls(cmds.sets(out_set, query=True), long=True)\n\n        # Get all the relatives of the members\n        descendants = cmds.listRelatives(members,\n                                         allDescendents=True,\n                                         fullPath=True) or []\n        descendants = cmds.ls(descendants, noIntermediate=True, long=True)\n\n        # Add members and descendants together for a complete overview\n\n        hierarchy = members + descendants\n\n        # Ignore certain node types (e.g. constraints)\n        ignore = cmds.ls(hierarchy, type=self.ignore_type, long=True)\n        if ignore:\n            ignore = set(ignore)\n            hierarchy = [node for node in hierarchy if node not in ignore]\n\n        # Store data in the instance for the validator\n        instance.data[\"out_hierarchy\"] = hierarchy\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_animation.html#client.ayon_maya.plugins.publish.collect_animation.CollectAnimationOutputGeometry.process","title":"<code>process(instance)</code>","text":"<p>Collect the hierarchy nodes</p> Source code in <code>client/ayon_maya/plugins/publish/collect_animation.py</code> <pre><code>def process(self, instance):\n    \"\"\"Collect the hierarchy nodes\"\"\"\n\n    product_type = instance.data[\"productType\"]\n    out_set = next((i for i in instance.data[\"setMembers\"] if\n                    i.endswith(\"out_SET\")), None)\n\n    if out_set is None:\n        self.log.warning((\n            \"Expecting out_SET for instance of product type '{}'\"\n        ).format(product_type))\n        return\n\n    members = cmds.ls(cmds.sets(out_set, query=True), long=True)\n\n    # Get all the relatives of the members\n    descendants = cmds.listRelatives(members,\n                                     allDescendents=True,\n                                     fullPath=True) or []\n    descendants = cmds.ls(descendants, noIntermediate=True, long=True)\n\n    # Add members and descendants together for a complete overview\n\n    hierarchy = members + descendants\n\n    # Ignore certain node types (e.g. constraints)\n    ignore = cmds.ls(hierarchy, type=self.ignore_type, long=True)\n    if ignore:\n        ignore = set(ignore)\n        hierarchy = [node for node in hierarchy if node not in ignore]\n\n    # Store data in the instance for the validator\n    instance.data[\"out_hierarchy\"] = hierarchy\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_arnold_scene_source.html","title":"collect_arnold_scene_source","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_arnold_scene_source.html#client.ayon_maya.plugins.publish.collect_arnold_scene_source.CollectArnoldSceneSource","title":"<code>CollectArnoldSceneSource</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect Arnold Scene Source data.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_arnold_scene_source.py</code> <pre><code>class CollectArnoldSceneSource(plugin.MayaInstancePlugin):\n    \"\"\"Collect Arnold Scene Source data.\"\"\"\n\n    # Offset to be after renderable camera collection.\n    order = pyblish.api.CollectorOrder + 0.2\n    label = \"Collect Arnold Scene Source\"\n    families = [\"ass\", \"assProxy\"]\n\n    def process(self, instance):\n        instance.data[\"members\"] = []\n        for set_member in instance.data[\"setMembers\"]:\n            if cmds.nodeType(set_member) != \"objectSet\":\n                instance.data[\"members\"].extend(self.get_hierarchy(set_member))\n                continue\n\n            members = cmds.sets(set_member, query=True)\n            members = cmds.ls(members, long=True)\n            if members is None:\n                self.log.warning(\n                    \"Skipped empty instance: \\\"%s\\\" \" % set_member\n                )\n                continue\n            if set_member.endswith(\"proxy_SET\"):\n                instance.data[\"proxy\"] = self.get_hierarchy(members)\n\n        # Use camera in object set if present else default to render globals\n        # camera.\n        cameras = cmds.ls(type=\"camera\", long=True)\n        renderable = [c for c in cameras if cmds.getAttr(\"%s.renderable\" % c)]\n        if renderable:\n            camera = renderable[0]\n            for node in instance.data[\"members\"]:\n                camera_shapes = cmds.listRelatives(\n                    node, shapes=True, type=\"camera\"\n                )\n                if camera_shapes:\n                    camera = node\n            instance.data[\"camera\"] = camera\n        else:\n            self.log.debug(\"No renderable cameras found.\")\n\n        self.log.debug(\"data: {}\".format(instance.data))\n\n    def get_hierarchy(self, nodes):\n        \"\"\"Return nodes with all their children\"\"\"\n        nodes = cmds.ls(nodes, long=True)\n        if not nodes:\n            return []\n        children = get_all_children(nodes)\n        # Make sure nodes merged with children only\n        # contains unique entries\n        return list(set(nodes + list(children)))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_arnold_scene_source.html#client.ayon_maya.plugins.publish.collect_arnold_scene_source.CollectArnoldSceneSource.get_hierarchy","title":"<code>get_hierarchy(nodes)</code>","text":"<p>Return nodes with all their children</p> Source code in <code>client/ayon_maya/plugins/publish/collect_arnold_scene_source.py</code> <pre><code>def get_hierarchy(self, nodes):\n    \"\"\"Return nodes with all their children\"\"\"\n    nodes = cmds.ls(nodes, long=True)\n    if not nodes:\n        return []\n    children = get_all_children(nodes)\n    # Make sure nodes merged with children only\n    # contains unique entries\n    return list(set(nodes + list(children)))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_assembly.html","title":"collect_assembly","text":"<p>Collect all relevant assembly items.</p> Todo <p>Publish of assembly need unique namespace for all assets, we should create validator for this.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_assembly.html#client.ayon_maya.plugins.publish.collect_assembly.CollectAssembly","title":"<code>CollectAssembly</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect all relevant assembly items</p> <p>Collected data:</p> <pre><code>* File name\n* Compatible loader\n* Matrix per instance\n* Namespace\n</code></pre> <p>Note: GPU caches are currently not supported in the pipeline. There is no logic yet which supports the swapping of GPU cache to renderable objects.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_assembly.py</code> <pre><code>class CollectAssembly(plugin.MayaInstancePlugin):\n    \"\"\"Collect all relevant assembly items\n\n    Collected data:\n\n        * File name\n        * Compatible loader\n        * Matrix per instance\n        * Namespace\n\n    Note: GPU caches are currently not supported in the pipeline. There is no\n    logic yet which supports the swapping of GPU cache to renderable objects.\n\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.49\n    label = \"Assembly\"\n    families = [\"assembly\"]\n\n    def process(self, instance):\n\n        # Find containers\n        containers = api.ls()\n\n        # Get all content from the instance\n        instance_lookup = set(cmds.ls(instance, type=\"transform\", long=True))\n        data = defaultdict(list)\n\n        hierarchy_nodes = []\n        for container in containers:\n\n            root = lib.get_container_transforms(container, root=True)\n            if not root or root not in instance_lookup:\n                continue\n\n            # Retrieve the hierarchy\n            parent = cmds.listRelatives(root, parent=True, fullPath=True)[0]\n            hierarchy_nodes.append(parent)\n\n            # Temporary warning for GPU cache which are not supported yet\n            loader = container[\"loader\"]\n            if loader == \"GpuCacheLoader\":\n                self.log.warning(\"GPU Cache Loader is currently not supported\"\n                                 \"in the pipeline, we will export it tho\")\n\n            # Gather info for new data entry\n            representation_id = container[\"representation\"]\n            instance_data = {\"loader\": loader,\n                             \"parent\": parent,\n                             \"namespace\": container[\"namespace\"]}\n\n            # Check if matrix differs from default and store changes\n            matrix_data = self.get_matrix_data(root)\n            if matrix_data:\n                instance_data[\"matrix\"] = matrix_data\n\n            data[representation_id].append(instance_data)\n\n        instance.data[\"scenedata\"] = dict(data)\n        instance.data[\"nodesHierarchy\"] = list(set(hierarchy_nodes))\n\n    def get_file_rule(self, rule):\n        return mel.eval('workspace -query -fileRuleEntry \"{}\"'.format(rule))\n\n    def get_matrix_data(self, node):\n        \"\"\"Get the matrix of all members when they are not default\n\n        Each matrix which differs from the default will be stored in a\n        dictionary\n\n        Args:\n            members (list): list of transform nmodes\n        Returns:\n            dict\n        \"\"\"\n\n        matrix = cmds.xform(node, query=True, matrix=True)\n        if matrix == lib.DEFAULT_MATRIX:\n            return\n\n        return matrix\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_assembly.html#client.ayon_maya.plugins.publish.collect_assembly.CollectAssembly.get_matrix_data","title":"<code>get_matrix_data(node)</code>","text":"<p>Get the matrix of all members when they are not default</p> <p>Each matrix which differs from the default will be stored in a dictionary</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>list</code> <p>list of transform nmodes</p> required <p>Returns:     dict</p> Source code in <code>client/ayon_maya/plugins/publish/collect_assembly.py</code> <pre><code>def get_matrix_data(self, node):\n    \"\"\"Get the matrix of all members when they are not default\n\n    Each matrix which differs from the default will be stored in a\n    dictionary\n\n    Args:\n        members (list): list of transform nmodes\n    Returns:\n        dict\n    \"\"\"\n\n    matrix = cmds.xform(node, query=True, matrix=True)\n    if matrix == lib.DEFAULT_MATRIX:\n        return\n\n    return matrix\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_current_file.html","title":"collect_current_file","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_current_file.html#client.ayon_maya.plugins.publish.collect_current_file.CollectCurrentFile","title":"<code>CollectCurrentFile</code>","text":"<p>               Bases: <code>MayaContextPlugin</code></p> <p>Inject the current working file.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_current_file.py</code> <pre><code>class CollectCurrentFile(plugin.MayaContextPlugin):\n    \"\"\"Inject the current working file.\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.4\n    label = \"Maya Current File\"\n\n    def process(self, context):\n        \"\"\"Inject the current working file\"\"\"\n        context.data['currentFile'] = cmds.file(query=True, sceneName=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_current_file.html#client.ayon_maya.plugins.publish.collect_current_file.CollectCurrentFile.process","title":"<code>process(context)</code>","text":"<p>Inject the current working file</p> Source code in <code>client/ayon_maya/plugins/publish/collect_current_file.py</code> <pre><code>def process(self, context):\n    \"\"\"Inject the current working file\"\"\"\n    context.data['currentFile'] = cmds.file(query=True, sceneName=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_farm_instances.html","title":"collect_farm_instances","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_farm_instances.html#client.ayon_maya.plugins.publish.collect_farm_instances.CollectFarmInstances","title":"<code>CollectFarmInstances</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect Farm Instances for remote publish</p> Source code in <code>client/ayon_maya/plugins/publish/collect_farm_instances.py</code> <pre><code>class CollectFarmInstances(plugin.MayaInstancePlugin):\n    \"\"\"Collect Farm Instances for remote publish\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.223\n    label = \"Collect Farm Instances\"\n    families = [\"ass\", \"animation\", \"pointcache\",\n                \"oxcache\", \"proxyAbc\", \"redshiftproxy\",\n                \"vrayproxy\", \"xgen\", \"yeticache\"]\n    targets = [\"local\"]\n\n    def process(self, instance):\n        if instance.data.get(\"farm\"):\n            instance.data[\"families\"].append(\"remote_publish_on_farm\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_farm_instances.html#client.ayon_maya.plugins.publish.collect_farm_instances.CollectRemoteCacheInstances","title":"<code>CollectRemoteCacheInstances</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect Cache instances for publish, only works for headless mode</p> Source code in <code>client/ayon_maya/plugins/publish/collect_farm_instances.py</code> <pre><code>class CollectRemoteCacheInstances(plugin.MayaInstancePlugin):\n    \"\"\"Collect Cache instances for publish, only works for headless mode\n\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.223\n    label = \"Collect Remote Cache Instances\"\n    targets = [\"remote\"]\n\n    def process(self, instance):\n        self.log.debug(\"Processing Cache Farm Instances.\")\n        instance.data[\"farm\"] = False\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_fbx_animation.html","title":"collect_fbx_animation","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_fbx_animation.html#client.ayon_maya.plugins.publish.collect_fbx_animation.CollectFbxAnimation","title":"<code>CollectFbxAnimation</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Collect Animated Rig Data for FBX Extractor.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_fbx_animation.py</code> <pre><code>class CollectFbxAnimation(plugin.MayaInstancePlugin,\n                          OptionalPyblishPluginMixin):\n    \"\"\"Collect Animated Rig Data for FBX Extractor.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.2\n    label = \"Collect Fbx Animation\"\n    families = [\"animation\"]\n    optional = True\n    input_connections = True\n    up_axis = \"y\"\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        skeleton_sets = [\n            i for i in instance\n            if i.endswith(\"skeletonAnim_SET\")\n        ]\n        if not skeleton_sets:\n            return\n\n        instance.data[\"families\"].append(\"animation.fbx\")\n        instance.data[\"animated_skeleton\"] = []\n        for skeleton_set in skeleton_sets:\n            skeleton_content = cmds.sets(skeleton_set, query=True)\n            self.log.debug(\n                \"Collected animated skeleton data: {}\".format(\n                    skeleton_content\n                ))\n            if skeleton_content:\n                instance.data[\"animated_skeleton\"] = skeleton_content\n\n        attribute_values = self.get_attr_values_from_data(\n            instance.data\n        )\n\n        instance.data[\"upAxis\"] = attribute_values.get(\n            \"upAxis\", self.up_axis)\n        instance.data[\"inputConnections\"] = attribute_values.get(\n            \"inputConnections\", self.input_connections)\n\n    @classmethod\n    def get_attribute_defs(cls):\n        defs = [\n            UISeparatorDef(\"sep_fbx_options\"),\n            UILabelDef(\"Fbx Options\"),\n        ]\n        defs.extend(\n            super().get_attribute_defs() + [\n            EnumDef(\"upAxis\",\n                    items=[\"y\", \"z\"],\n                    label=\"Up Axis\",\n                    default=cls.up_axis,\n                    tooltip=\"Convert the scene's orientation in your FBX file\"),\n            BoolDef(\"inputConnections\",\n                    label=\"Input Connections\",\n                    default=cls.input_connections,\n                    tooltip=(\n                        \"Whether input connections to \"\n                        \"selected objects are to be exported.\"\n                        ),\n                    ),\n            UISeparatorDef(\"sep_fbx_options_end\")\n        ])\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_fbx_camera.html","title":"collect_fbx_camera","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_fbx_camera.html#client.ayon_maya.plugins.publish.collect_fbx_camera.CollectFbxCamera","title":"<code>CollectFbxCamera</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Collect Camera for FBX export.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_fbx_camera.py</code> <pre><code>class CollectFbxCamera(plugin.MayaInstancePlugin,\n                       OptionalPyblishPluginMixin):\n    \"\"\"Collect Camera for FBX export.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.2\n    label = \"Collect Camera for FBX export\"\n    families = [\"camera\"]\n    optional = False\n    input_connections = True\n    up_axis = \"y\"\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        if not instance.data.get(\"families\"):\n            instance.data[\"families\"] = []\n\n        if \"fbx\" not in instance.data[\"families\"]:\n            instance.data[\"families\"].append(\"fbx\")\n\n        instance.data[\"cameras\"] = True\n\n        attribute_values = self.get_attr_values_from_data(\n            instance.data\n        )\n\n        instance.data[\"upAxis\"] = attribute_values.get(\n            \"upAxis\", self.up_axis)\n        instance.data[\"inputConnections\"] = attribute_values.get(\n            \"inputConnections\", self.input_connections)\n\n    @classmethod\n    def get_attribute_defs(cls):\n        defs = [\n            UISeparatorDef(\"sep_fbx_options\"),\n            UILabelDef(\"Fbx Options\"),\n        ]\n        defs.extend(\n            super().get_attribute_defs() + [\n            EnumDef(\"upAxis\",\n                    items=[\"y\", \"z\"],\n                    label=\"Up Axis\",\n                    default=cls.up_axis,\n                    tooltip=\"Convert the scene's orientation in your FBX file\"),\n            BoolDef(\"inputConnections\",\n                    label=\"Input Connections\",\n                    default=cls.input_connections,\n                    tooltip=(\n                        \"Whether input connections to \"\n                        \"selected objects are to be exported.\"\n                        ),\n                    ),\n            UISeparatorDef(\"sep_fbx_options_end\")\n        ])\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_fbx_model.html","title":"collect_fbx_model","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_fbx_model.html#client.ayon_maya.plugins.publish.collect_fbx_model.CollectFbxModel","title":"<code>CollectFbxModel</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Collect Camera for FBX export.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_fbx_model.py</code> <pre><code>class CollectFbxModel(plugin.MayaInstancePlugin,\n                      OptionalPyblishPluginMixin):\n    \"\"\"Collect Camera for FBX export.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.2\n    label = \"Collect Fbx Model\"\n    families = [\"model\"]\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        if not instance.data.get(\"families\"):\n            instance.data[\"families\"] = []\n\n        if \"fbx\" not in instance.data[\"families\"]:\n            instance.data[\"families\"].append(\"fbx\")\n\n        for key in {\n            \"bakeComplexAnimation\", \"bakeResampleAnimation\",\n            \"skins\", \"constraints\", \"lights\"}:\n                instance.data[key] = False\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_file_dependencies.html","title":"collect_file_dependencies","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_file_dependencies.html#client.ayon_maya.plugins.publish.collect_file_dependencies.CollectFileDependencies","title":"<code>CollectFileDependencies</code>","text":"<p>               Bases: <code>MayaContextPlugin</code></p> <p>Gather all files referenced in this scene.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_file_dependencies.py</code> <pre><code>class CollectFileDependencies(plugin.MayaContextPlugin):\n    \"\"\"Gather all files referenced in this scene.\"\"\"\n\n    label = \"Collect File Dependencies\"\n    order = pyblish.api.CollectorOrder - 0.49\n    families = [\"renderlayer\"]\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        # Disable plug-in if not used for deadline submission anyway\n        if \"deadline\" not in project_settings:\n            cls.enabled = False\n            return\n        settings = (\n            project_settings\n            [\"deadline\"]\n            [\"publish\"]\n            [\"MayaSubmitDeadline\"]\n        )\n        cls.enabled = settings.get(\"asset_dependencies\", True)\n\n    def process(self, context):\n        dependencies = set()\n        for node in cmds.ls(type=\"file\"):\n            path = cmds.getAttr(\"{}.{}\".format(node, \"fileTextureName\"))\n            if path not in dependencies:\n                dependencies.add(path)\n\n        for node in cmds.ls(type=\"AlembicNode\"):\n            path = cmds.getAttr(\"{}.{}\".format(node, \"abc_File\"))\n            if path not in dependencies:\n                dependencies.add(path)\n\n        context.data[\"fileDependencies\"] = list(dependencies)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_gltf.html","title":"collect_gltf","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_gltf.html#client.ayon_maya.plugins.publish.collect_gltf.CollectGLTF","title":"<code>CollectGLTF</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect Assets for GLTF/GLB export.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_gltf.py</code> <pre><code>class CollectGLTF(plugin.MayaInstancePlugin):\n    \"\"\"Collect Assets for GLTF/GLB export.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.2\n    label = \"Collect Asset for GLTF/GLB export\"\n    families = [\"model\", \"animation\", \"pointcache\"]\n\n    def process(self, instance):\n        if not instance.data.get(\"families\"):\n            instance.data[\"families\"] = []\n\n        if \"gltf\" not in instance.data[\"families\"]:\n            instance.data[\"families\"].append(\"gltf\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_history.html","title":"collect_history","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_history.html#client.ayon_maya.plugins.publish.collect_history.CollectMayaHistory","title":"<code>CollectMayaHistory</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect history for instances from the Maya scene</p> Note <p>This removes render layers collected in the history</p> <p>This is separate from Collect Instances so we can target it towards only specific product types.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_history.py</code> <pre><code>class CollectMayaHistory(plugin.MayaInstancePlugin):\n    \"\"\"Collect history for instances from the Maya scene\n\n    Note:\n        This removes render layers collected in the history\n\n    This is separate from Collect Instances so we can target it towards only\n    specific product types.\n\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.1\n    hosts = [\"maya\"]\n    label = \"Maya History\"\n    families = [\"rig\"]\n\n    def process(self, instance):\n\n        kwargs = {}\n        if int(cmds.about(version=True)) &gt;= 2020:\n            # New flag since Maya 2020 which makes cmds.listHistory faster\n            kwargs = {\"fastIteration\": True}\n        else:\n            self.log.debug(\"Ignoring `fastIteration` flag before Maya 2020..\")\n\n        # Collect the history with long names\n        history = set(cmds.listHistory(instance, leaf=False, **kwargs) or [])\n        history = cmds.ls(list(history), long=True)\n\n        # Exclude invalid nodes (like renderlayers)\n        exclude = cmds.ls(type=\"renderLayer\", long=True)\n        if exclude:\n            exclude = set(exclude)  # optimize lookup\n            history = [x for x in history if x not in exclude]\n\n        # Combine members with history\n        members = instance[:] + history\n        members = list(set(members))    # ensure unique\n\n        # Update the instance\n        instance[:] = members\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_inputs.html","title":"collect_inputs","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_inputs.html#client.ayon_maya.plugins.publish.collect_inputs.CollectUpstreamInputs","title":"<code>CollectUpstreamInputs</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect input source inputs for this publish.</p> <p>This will include <code>inputs</code> data of which loaded publishes were used in the generation of this publish. This leaves an upstream trace to what was used as input.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_inputs.py</code> <pre><code>class CollectUpstreamInputs(plugin.MayaInstancePlugin):\n    \"\"\"Collect input source inputs for this publish.\n\n    This will include `inputs` data of which loaded publishes were used in the\n    generation of this publish. This leaves an upstream trace to what was used\n    as input.\n\n    \"\"\"\n\n    label = \"Collect Inputs\"\n    order = pyblish.api.CollectorOrder + 0.34\n\n    def process(self, instance):\n\n        # For large scenes the querying of \"host.ls()\" can be relatively slow\n        # e.g. up to a second. Many instances calling it easily slows this\n        # down. As such, we cache it so we trigger it only once.\n        # todo: Instead of hidden cache make \"CollectContainers\" plug-in\n        cache_key = \"__cache_containers\"\n        scene_containers = instance.context.data.get(cache_key, None)\n        if scene_containers is None:\n            # Query the scenes' containers if there's no cache yet\n            host = registered_host()\n            scene_containers = list(host.ls())\n            for container in scene_containers:\n                # Embed the members into the container dictionary\n                container_members = set(get_container_members(container))\n                container[\"_members\"] = container_members\n            instance.context.data[\"__cache_containers\"] = scene_containers\n\n        # Collect the relevant input containers for this instance\n        if \"renderlayer\" in set(instance.data.get(\"families\", [])):\n            # Special behavior for renderlayers\n            self.log.debug(\"Collecting renderlayer inputs....\")\n            containers = self._collect_renderlayer_inputs(scene_containers,\n                                                          instance)\n\n        else:\n            # Basic behavior\n            nodes = instance[:]\n\n            # Include any input connections of history with long names\n            # For optimization purposes only trace upstream from shape nodes\n            # looking for used dag nodes. This way having just a constraint\n            # on a transform is also ignored which tended to give irrelevant\n            # inputs for the majority of our use cases. We tend to care more\n            # about geometry inputs.\n            shapes = cmds.ls(nodes,\n                             type=(\"mesh\", \"nurbsSurface\", \"nurbsCurve\"),\n                             noIntermediate=True)\n            if shapes:\n                history = list(iter_history(shapes, filter=om.MFn.kShape))\n                history = cmds.ls(history, long=True)\n\n                # Include the transforms in the collected history as shapes\n                # are excluded from containers\n                transforms = cmds.listRelatives(cmds.ls(history, shapes=True),\n                                                parent=True,\n                                                fullPath=True,\n                                                type=\"transform\")\n                if transforms:\n                    history.extend(transforms)\n\n                if history:\n                    nodes = list(set(nodes + history))\n\n            # Collect containers for the given set of nodes\n            containers = collect_input_containers(scene_containers,\n                                                  nodes)\n\n        inputs = [c[\"representation\"] for c in containers]\n        instance.data[\"inputRepresentations\"] = inputs\n        self.log.debug(\"Collected inputs: %s\" % inputs)\n\n    def _collect_renderlayer_inputs(self, scene_containers, instance):\n        \"\"\"Collects inputs from nodes in renderlayer, incl. shaders + camera\"\"\"\n\n        # Get the renderlayer\n        renderlayer = instance.data.get(\"setMembers\")\n\n        if renderlayer == \"defaultRenderLayer\":\n            # Assume all loaded containers in the scene are inputs\n            # for the masterlayer\n            return copy.deepcopy(scene_containers)\n        else:\n            # Get the members of the layer\n            members = cmds.editRenderLayerMembers(renderlayer,\n                                                  query=True,\n                                                  fullNames=True) or []\n\n            # In some cases invalid objects are returned from\n            # `editRenderLayerMembers` so we filter them out\n            members = cmds.ls(members, long=True)\n\n            # Include all children\n            children = cmds.listRelatives(members,\n                                          allDescendents=True,\n                                          fullPath=True) or []\n            members.extend(children)\n\n            # Include assigned shaders in renderlayer\n            shapes = cmds.ls(members, shapes=True, long=True)\n            shaders = set()\n            for shape in shapes:\n                shape_shaders = get_shader_in_layer(shape, layer=renderlayer)\n                if not shape_shaders:\n                    continue\n                shaders.update(shape_shaders)\n            members.extend(shaders)\n\n            # Explicitly include the camera being rendered in renderlayer\n            cameras = instance.data.get(\"cameras\")\n            members.extend(cameras)\n\n            containers = collect_input_containers(scene_containers, members)\n\n        return containers\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_inputs.html#client.ayon_maya.plugins.publish.collect_inputs.collect_input_containers","title":"<code>collect_input_containers(containers, nodes)</code>","text":"<p>Collect containers that contain any of the node in <code>nodes</code>.</p> <p>This will return any loaded AYON container that contains at least one of the nodes. As such, the AYON container is an input for it. Or in short, there are member nodes of that container.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Input loaded containers</p> Source code in <code>client/ayon_maya/plugins/publish/collect_inputs.py</code> <pre><code>def collect_input_containers(containers, nodes):\n    \"\"\"Collect containers that contain any of the node in `nodes`.\n\n    This will return any loaded AYON container that contains at least one of\n    the nodes. As such, the AYON container is an input for it. Or in short,\n    there are member nodes of that container.\n\n    Returns:\n        list: Input loaded containers\n\n    \"\"\"\n    # Assume the containers have collected their cached '_members' data\n    # in the collector.\n    return [container for container in containers\n            if any(node in container[\"_members\"] for node in nodes)]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_inputs.html#client.ayon_maya.plugins.publish.collect_inputs.iter_history","title":"<code>iter_history(nodes, filter=om.MFn.kInvalid, direction=om.MItDependencyGraph.kUpstream)</code>","text":"<p>Iterate unique upstream history for list of nodes.</p> <p>This acts as a replacement to maya.cmds.listHistory. It's faster by about 2x-3x. It returns less than maya.cmds.listHistory as it excludes the input nodes from the output (unless an input node was history for another input node). It also excludes duplicates.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list</code> <p>Maya node names to start search from.</p> required <code>filter</code> <code>Type</code> <p>Filter to only specific types. e.g. to dag nodes using om.MFn.kDagNode</p> <code>kInvalid</code> <code>direction</code> <code>Direction</code> <p>Direction to traverse in. Defaults to upstream.</p> <code>kUpstream</code> <p>Yields:</p> Name Type Description <code>str</code> <p>Node names in upstream history.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_inputs.py</code> <pre><code>def iter_history(nodes,\n                 filter=om.MFn.kInvalid,\n                 direction=om.MItDependencyGraph.kUpstream):\n    \"\"\"Iterate unique upstream history for list of nodes.\n\n    This acts as a replacement to maya.cmds.listHistory.\n    It's faster by about 2x-3x. It returns less than\n    maya.cmds.listHistory as it excludes the input nodes\n    from the output (unless an input node was history\n    for another input node). It also excludes duplicates.\n\n    Args:\n        nodes (list): Maya node names to start search from.\n        filter (om.MFn.Type): Filter to only specific types.\n            e.g. to dag nodes using om.MFn.kDagNode\n        direction (om.MItDependencyGraph.Direction): Direction to traverse in.\n            Defaults to upstream.\n\n    Yields:\n        str: Node names in upstream history.\n\n    \"\"\"\n    if not nodes:\n        return\n\n    sel = om.MSelectionList()\n    for node in nodes:\n        sel.add(node)\n\n    it = om.MItDependencyGraph(sel.getDependNode(0))  # init iterator\n    handle = om.MObjectHandle\n\n    traversed = set()\n    fn_dep = om.MFnDependencyNode()\n    fn_dag = om.MFnDagNode()\n    for i in range(sel.length()):\n\n        start_node = sel.getDependNode(i)\n        start_node_hash = handle(start_node).hashCode()\n        if start_node_hash in traversed:\n            continue\n\n        it.resetTo(start_node,\n                   filter=filter,\n                   direction=direction)\n        while not it.isDone():\n\n            node = it.currentNode()\n            node_hash = handle(node).hashCode()\n\n            if node_hash in traversed:\n                it.prune()\n                it.next()  # noqa: B305\n                continue\n\n            traversed.add(node_hash)\n\n            if node.hasFn(om.MFn.kDagNode):\n                fn_dag.setObject(node)\n                yield fn_dag.fullPathName()\n            else:\n                fn_dep.setObject(node)\n                yield fn_dep.name()\n\n            it.next()  # noqa: B305\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_instances.html","title":"collect_instances","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_instances.html#client.ayon_maya.plugins.publish.collect_instances.CollectNewInstances","title":"<code>CollectNewInstances</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Gather members for instances and pre-defined attribute</p> <p>This collector takes into account assets that are associated with an objectSet and marked with a unique identifier;</p> Identifier <p>id (str): \"ayon.create.instance\"</p> Limitations <ul> <li>Does not take into account nodes connected to those     within an objectSet. Extractors are assumed to export     with history preserved, but this limits what they will     be able to achieve and the amount of data available     to validators. An additional collector could also     append this input data into the instance, as we do     for <code>pype.rig</code> with collect_history.</li> </ul> Source code in <code>client/ayon_maya/plugins/publish/collect_instances.py</code> <pre><code>class CollectNewInstances(plugin.MayaInstancePlugin):\n    \"\"\"Gather members for instances and pre-defined attribute\n\n    This collector takes into account assets that are associated with\n    an objectSet and marked with a unique identifier;\n\n    Identifier:\n        id (str): \"ayon.create.instance\"\n\n    Limitations:\n        - Does not take into account nodes connected to those\n            within an objectSet. Extractors are assumed to export\n            with history preserved, but this limits what they will\n            be able to achieve and the amount of data available\n            to validators. An additional collector could also\n            append this input data into the instance, as we do\n            for `pype.rig` with collect_history.\n\n    \"\"\"\n\n    label = \"Collect New Instance Data\"\n    order = pyblish.api.CollectorOrder\n    hosts = [\"maya\"]\n\n    valid_empty_product_types = {\"workfile\", \"renderlayer\"}\n\n    def process(self, instance):\n\n        objset = instance.data.get(\"instance_node\")\n        if not objset:\n            self.log.debug(\"Instance has no `instance_node` data\")\n\n        # TODO: We might not want to do this in the future\n        # Merge creator attributes into instance.data just backwards compatible\n        # code still runs as expected\n        creator_attributes = instance.data.get(\"creator_attributes\", {})\n        if creator_attributes:\n            instance.data.update(creator_attributes)\n\n        members = cmds.sets(objset, query=True) or []\n        if members:\n            # Collect members\n            members = cmds.ls(members, long=True) or []\n\n            # Collect full hierarchy\n            dag_members = cmds.ls(members, type=\"dagNode\", long=True)\n            children = get_all_children(dag_members,\n                                        ignore_intermediate_objects=True)\n\n            members_hierarchy = set(members)\n            members_hierarchy.update(children)\n            if creator_attributes.get(\"includeParentHierarchy\", True):\n                members_hierarchy.update(self.get_all_parents(dag_members))\n\n            instance[:] = members_hierarchy\n\n        elif (\n            instance.data[\"productType\"] not in self.valid_empty_product_types\n        ):\n            self.log.warning(\"Empty instance: \\\"%s\\\" \" % objset)\n        # Store the exact members of the object set\n        instance.data[\"setMembers\"] = members\n\n        # TODO: This might make more sense as a separate collector\n        # Convert frame values to integers\n        for attr_name in (\n            \"handleStart\", \"handleEnd\", \"frameStart\", \"frameEnd\",\n        ):\n            value = instance.data.get(attr_name)\n            if value is not None:\n                instance.data[attr_name] = int(value)\n\n        # Append start frame and end frame to label if present\n        if \"frameStart\" in instance.data and \"frameEnd\" in instance.data:\n            # Take handles from context if not set locally on the instance\n            for key in [\"handleStart\", \"handleEnd\"]:\n                if key not in instance.data:\n                    value = instance.context.data[key]\n                    if value is not None:\n                        value = int(value)\n                    instance.data[key] = value\n\n            instance.data[\"frameStartHandle\"] = int(\n                instance.data[\"frameStart\"] - instance.data[\"handleStart\"]\n            )\n            instance.data[\"frameEndHandle\"] = int(\n                instance.data[\"frameEnd\"] + instance.data[\"handleEnd\"]\n            )\n\n    def get_all_parents(self, nodes):\n        \"\"\"Get all parents by using string operations (optimization)\n\n        Args:\n            nodes (iterable): the nodes which are found in the objectSet\n\n        Returns:\n            set\n        \"\"\"\n\n        parents = set()\n        for node in nodes:\n            split_parts = node.split(\"|\")\n            items = [\n                \"|\".join(split_parts[:i]) for i in range(2, len(split_parts))\n            ]\n            parents.update(items)\n\n        return parents\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_instances.html#client.ayon_maya.plugins.publish.collect_instances.CollectNewInstances.get_all_parents","title":"<code>get_all_parents(nodes)</code>","text":"<p>Get all parents by using string operations (optimization)</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>iterable</code> <p>the nodes which are found in the objectSet</p> required <p>Returns:</p> Type Description <p>set</p> Source code in <code>client/ayon_maya/plugins/publish/collect_instances.py</code> <pre><code>def get_all_parents(self, nodes):\n    \"\"\"Get all parents by using string operations (optimization)\n\n    Args:\n        nodes (iterable): the nodes which are found in the objectSet\n\n    Returns:\n        set\n    \"\"\"\n\n    parents = set()\n    for node in nodes:\n        split_parts = node.split(\"|\")\n        items = [\n            \"|\".join(split_parts[:i]) for i in range(2, len(split_parts))\n        ]\n        parents.update(items)\n\n    return parents\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_look.html","title":"collect_look","text":"<p>Maya look collector.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_look.html#client.ayon_maya.plugins.publish.collect_look.CollectLook","title":"<code>CollectLook</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect look data for instance.</p> <p>For the shapes/transforms of the referenced object to collect look for retrieve the user-defined attributes (like V-ray attributes) and their values as they were created in the current scene.</p> <p>For the members of the instance collect the sets (shadingEngines and other sets, e.g. VRayDisplacement) they are in along with the exact membership relations.</p> Collects <p>lookAttributes (list): Nodes in instance with their altered attributes lookSetRelations (list): Sets and their memberships lookSets (list): List of set names included in the look</p> Source code in <code>client/ayon_maya/plugins/publish/collect_look.py</code> <pre><code>class CollectLook(plugin.MayaInstancePlugin):\n    \"\"\"Collect look data for instance.\n\n    For the shapes/transforms of the referenced object to collect look for\n    retrieve the user-defined attributes (like V-ray attributes) and their\n    values as they were created in the current scene.\n\n    For the members of the instance collect the sets (shadingEngines and\n    other sets, e.g. VRayDisplacement) they are in along with the exact\n    membership relations.\n\n    Collects:\n        lookAttributes (list): Nodes in instance with their altered attributes\n        lookSetRelations (list): Sets and their memberships\n        lookSets (list): List of set names included in the look\n\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.2\n    families = [\"look\"]\n    label = \"Collect Look\"\n\n    def process(self, instance):\n        \"\"\"Collect the Look in the instance with the correct layer settings\"\"\"\n        renderlayer = instance.data.get(\"renderlayer\", \"defaultRenderLayer\")\n        with lib.renderlayer(renderlayer):\n            self.collect(instance)\n\n    def collect(self, instance):\n        \"\"\"Collect looks.\n\n        Args:\n            instance (pyblish.api.Instance): Instance to collect.\n\n        \"\"\"\n        self.log.debug(\"Looking for look associations \"\n                       \"for %s\" % instance.data['name'])\n\n        # Discover related object sets\n        self.log.debug(\"Gathering sets ...\")\n        sets = self.collect_sets(instance)\n\n        # Lookup set (optimization)\n        instance_lookup = set(cmds.ls(instance, long=True))\n\n        self.log.debug(\"Gathering set relations ...\")\n        # Ensure iteration happen in a list to allow removing keys from the\n        # dict within the loop\n        for obj_set in list(sets):\n            self.log.debug(\"From {}\".format(obj_set))\n            # Get all nodes of the current objectSet (shadingEngine)\n            for member in cmds.ls(cmds.sets(obj_set, query=True), long=True):\n                member_data = self.collect_member_data(member,\n                                                       instance_lookup)\n                if member_data:\n                    # Add information of the node to the members list\n                    sets[obj_set][\"members\"].append(member_data)\n\n            # Remove sets that didn't have any members assigned in the end\n            # Thus the data will be limited to only what we need.\n            if not sets[obj_set][\"members\"]:\n                self.log.debug(\n                    \"Removing redundant set information: {}\".format(obj_set)\n                )\n                sets.pop(obj_set, None)\n\n        self.log.debug(\"Gathering attribute changes to instance members..\")\n        attributes = self.collect_attributes_changed(instance)\n\n        # Store data on the instance\n        instance.data[\"lookData\"] = {\n            \"attributes\": attributes,\n            \"relationships\": sets\n        }\n        if instance.data.get(\"includeTextureReferenceObjects\", False):\n            collections, texture_object_nodes = (\n                self.collect_texture_reference_object_inputs(instance)\n            )\n            instance.data[\"lookData\"][\"connections\"] = collections\n            instance.data[\"textureReferenceObjects\"] = texture_object_nodes\n        # Collect file nodes used by shading engines (if we have any)\n        files = []\n        look_sets = list(sets.keys())\n        if look_sets:\n            self.log.debug(\"Found look sets: {}\".format(look_sets))\n            files = self.collect_file_nodes(look_sets)\n\n        self.log.debug(\"Collected file nodes:\\n{}\".format(files))\n\n        # Collect texture resources if any file nodes are found\n        resources = []\n        for node in files:\n            resources.extend(self.collect_resources(node))\n        instance.data[\"resources\"] = resources\n        self.log.debug(\"Collected resources: {}\".format(resources))\n\n        # Log warning when no relevant sets were retrieved for the look.\n        if (\n            not instance.data[\"lookData\"][\"relationships\"]\n            and \"model\" not in self.families\n        ):\n            self.log.warning(\"No sets found for the nodes in the \"\n                             \"instance: %s\" % instance[:])\n\n        # Ensure unique shader sets\n        # Add shader sets to the instance for unify ID validation\n        instance.extend(shader for shader in look_sets if shader\n                        not in instance_lookup)\n\n        self.log.debug(\"Collected look for %s\" % instance)\n\n    def collect_file_nodes(self, look_sets):\n        \"\"\"Get the entire node chain of the look sets and return file nodes\n\n        Arguments:\n            look_sets (List[str]): List of sets and shading engines relevant\n                to the look.\n\n        Returns:\n            List[str]: List of file node names.\n\n        \"\"\"\n\n        shader_attrs = [\n            \"surfaceShader\",\n            \"volumeShader\",\n            \"displacementShader\",\n            \"aiSurfaceShader\",\n            \"aiVolumeShader\",\n            \"rman__surface\",\n            \"rman__displacement\"\n        ]\n\n        # Get all material attrs for all look sets to retrieve their inputs\n        existing_attrs = []\n        for look_set in look_sets:\n            for attr in shader_attrs:\n                if cmds.attributeQuery(attr, node=look_set, exists=True):\n                    existing_attrs.append(\"{}.{}\".format(look_set, attr))\n\n        materials = cmds.listConnections(existing_attrs,\n                                         source=True,\n                                         destination=False) or []\n\n        self.log.debug(\"Found materials:\\n{}\".format(materials))\n\n        # Get the entire node chain of the look sets\n        # history = cmds.listHistory(look_sets, allConnections=True)\n        # if materials list is empty, listHistory() will crash with\n        # RuntimeError\n        history = set()\n        if materials:\n            history.update(cmds.listHistory(materials, allConnections=True))\n\n        # Since we retrieved history only of the connected materials connected\n        # to the look sets above we now add direct history for some of the\n        # look sets directly handling render attribute sets\n\n        # Maya (at least 2024) crashes with Warning when render set type\n        # isn't available. cmds.ls() will return empty list\n        if RENDER_SET_TYPES:\n            render_sets = cmds.ls(look_sets, type=RENDER_SET_TYPES)\n            if render_sets:\n                history.update(\n                    cmds.listHistory(render_sets,\n                                     future=False,\n                                     pruneDagObjects=True)\n                    or []\n                )\n\n        # Get file nodes in the material history\n        files = cmds.ls(list(history),\n                        # It's important only node types are passed that\n                        # exist (e.g. for loaded plugins) because otherwise\n                        # the result will turn back empty\n                        type=list(FILE_NODES.keys()),\n                        long=True)\n\n        # Sort for log readability\n        files.sort()\n\n        return files\n\n    def collect_sets(self, instance):\n        \"\"\"Collect all objectSets which are of importance for publishing\n\n        It checks if all nodes in the instance are related to any objectSet\n        which need to be\n\n        Args:\n            instance (pyblish.api.Instance): publish instance containing all\n                nodes to be published.\n\n        Returns:\n            dict\n        \"\"\"\n\n        sets = {}\n        for node in instance:\n            related_sets = lib.get_related_sets(node)\n            if not related_sets:\n                continue\n\n            for objset in related_sets:\n                if objset in sets:\n                    continue\n\n                sets[objset] = {\"uuid\": lib.get_id(objset), \"members\": list()}\n\n        return sets\n\n    def collect_member_data(self, member, instance_members):\n        \"\"\"Get all information of the node\n        Args:\n            member (str): the name of the node to check\n            instance_members (set): the collected instance members\n\n        Returns:\n            dict\n\n        \"\"\"\n        node, components = (member.rsplit(\".\", 1) + [None])[:2]\n        if components and not cmds.objectType(node, isAType=\"shape\"):\n            # Components are always on shapes. When only a single shape is\n            # parented under a transform Maya returns it as e.g. `cube.f[0:4]`\n            # instead of `cubeShape.f[0:4]` so we expand that to the shape\n            node = cmds.listRelatives(node, shapes=True, fullPath=True)[0]\n\n        # Only include valid members of the instance\n        if node not in instance_members:\n            return\n\n        node_id = lib.get_id(node)\n        if not node_id:\n            self.log.error(\"Member '{}' has no attribute 'cbId'\".format(node))\n            return\n\n        member_data = {\"name\": node, \"uuid\": node_id}\n        if components:\n            member_data[\"components\"] = components\n\n        return member_data\n\n    def collect_attributes_changed(self, instance):\n        \"\"\"Collect all userDefined attributes which have changed\n\n        Each node gets checked for user defined attributes which have been\n        altered during development. Each changes gets logged in a dictionary\n\n        [{name: node,\n          uuid: uuid,\n          attributes: {attribute: value}}]\n\n        Args:\n            instance (list): all nodes which will be published\n\n        Returns:\n            list\n        \"\"\"\n\n        attributes = []\n        for node in instance:\n\n            # Collect changes to \"custom\" attributes\n            node_attrs = get_look_attrs(node)\n\n            # Only include if there are any properties we care about\n            if not node_attrs:\n                continue\n\n            self.log.debug(\n                \"Node \\\"{0}\\\" attributes: {1}\".format(node, node_attrs)\n            )\n\n            node_attributes = {}\n            for attr in node_attrs:\n                if not cmds.attributeQuery(attr, node=node, exists=True):\n                    continue\n                attribute = \"{}.{}\".format(node, attr)\n                # We don't support mixed-type attributes yet.\n                if cmds.attributeQuery(attr, node=node, multi=True):\n                    self.log.warning(\"Attribute '{}' is mixed-type and is \"\n                                     \"not supported yet.\".format(attribute))\n                    continue\n\n                attribute_type = cmds.getAttr(attribute, type=True)\n                if attribute_type == \"message\":\n                    continue\n\n                # Maya has a tendency to return string attribute values as\n                # `None` if it is an empty string and the attribute has never\n                # been set but is still at default value.\n                value = cmds.getAttr(attribute, asString=True)\n                if value is None:\n                    # If the attribute type is `string` we will convert it\n                    # to enforce an empty string value\n                    if attribute_type == \"string\":\n                        value = \"\"\n                    else:\n                        continue\n\n                node_attributes[attr] = value\n            # Only include if there are any properties we care about\n            if not node_attributes:\n                continue\n            attributes.append({\"name\": node,\n                               \"uuid\": lib.get_id(node),\n                               \"attributes\": node_attributes})\n\n        return attributes\n\n    def collect_resources(self, node):\n        \"\"\"Collect the link to the file(s) used (resource)\n        Args:\n            node (str): name of the node\n\n        Returns:\n            dict\n        \"\"\"\n        if cmds.nodeType(node) not in FILE_NODES:\n            self.log.error(\n                \"Unsupported file node: {}\".format(cmds.nodeType(node)))\n            raise AssertionError(\"Unsupported file node\")\n\n        self.log.debug(\n            \"Collecting resource: {} ({})\".format(node, cmds.nodeType(node))\n        )\n\n        attributes = get_attributes(FILE_NODES, cmds.nodeType(node), node)\n        for attribute in attributes:\n            source = cmds.getAttr(\"{}.{}\".format(\n                node,\n                attribute\n            ))\n\n            self.log.debug(\"  - file source: {}\".format(source))\n            color_space_attr = \"{}.colorSpace\".format(node)\n            try:\n                color_space = cmds.getAttr(color_space_attr)\n            except ValueError:\n                # node doesn't have colorspace attribute\n                color_space = \"Raw\"\n\n            # Compare with the computed file path, e.g. the one with\n            # the &lt;UDIM&gt; pattern in it, to generate some logging information\n            # about this difference\n            # Only for file nodes with `fileTextureName` attribute\n            if attribute == \"fileTextureName\":\n                computed_source = cmds.getAttr(\n                    \"{}.computedFileTextureNamePattern\".format(node)\n                )\n                if source != computed_source:\n                    self.log.debug(\"Detected computed file pattern difference \"\n                                   \"from original pattern: {0} \"\n                                   \"({1} -&gt; {2})\".format(node,\n                                                         source,\n                                                         computed_source))\n\n            # renderman allows nodes to have filename attribute empty while\n            # you can have another incoming connection from different node.\n            if not source and cmds.nodeType(node) in PXR_NODES:\n                self.log.debug(\"Renderman: source is empty, skipping...\")\n                continue\n            # We replace backslashes with forward slashes because V-Ray\n            # can't handle the UDIM files with the backslashes in the\n            # paths as the computed patterns\n            source = source.replace(\"\\\\\", \"/\")\n\n            files = get_file_node_files(node)\n            if len(files) == 0:\n                self.log.debug(\"No valid files found from node `%s`\" % node)\n\n            self.log.debug(\"collection of resource done:\")\n            self.log.debug(\"  - node: {}\".format(node))\n            self.log.debug(\"  - attribute: {}\".format(attribute))\n            self.log.debug(\"  - source: {}\".format(source))\n            self.log.debug(\"  - file: {}\".format(files))\n            self.log.debug(\"  - color space: {}\".format(color_space))\n\n            # Define the resource\n            yield {\n                \"node\": node,\n                # here we are passing not only attribute, but with node again\n                # this should be simplified and changed extractor.\n                \"attribute\": \"{}.{}\".format(node, attribute),\n                \"source\": source,  # required for resources\n                \"files\": files,\n                \"color_space\": color_space\n            }\n\n    def collect_texture_reference_object_inputs(self, instance):\n        \"\"\"Collect the inputs for all nodes in the input_SET\"\"\"\n\n        # Get the input meshes information\n        input_content = instance.data[\"setMembers\"]\n\n        # Include children\n        input_content += cmds.listRelatives(input_content,\n                                            allDescendents=True,\n                                            fullPath=True) or []\n\n        # Ignore intermediate objects\n        input_content = cmds.ls(\n            input_content, \n            long=True, \n            noIntermediate=True,\n            type=\"mesh\"\n        )\n        if not input_content:\n            return []\n\n        attrs = [f\"{mesh}.referenceObject\" for mesh in set(input_content)]\n        # Store all connections\n        connections = cmds.listConnections(attrs,\n                                           source=True,\n                                           destination=False,\n                                           connections=True,\n                                           # Only allow inputs from dagNodes\n                                           # (avoid display layers, etc.)\n                                           type=\"mesh\",\n                                           plugs=True) or []\n        connections = cmds.ls(connections, long=True)      # Ensure long names\n\n        inputs = []\n        texture_object_nodes = []\n        for dest, src in lib.pairwise(connections):\n            source_node, source_attr = src.split(\".\", 1)\n            dest_node, dest_attr = dest.split(\".\", 1)\n\n            inputs.append({\n                \"connections\": [source_attr, dest_attr],\n                \"sourceID\": lib.get_id(source_node),\n                \"destinationID\": lib.get_id(dest_node)\n            })\n            texture_object_nodes.append(source_node)\n\n        return inputs, texture_object_nodes\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_look.html#client.ayon_maya.plugins.publish.collect_look.CollectLook.collect","title":"<code>collect(instance)</code>","text":"<p>Collect looks.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>Instance to collect.</p> required Source code in <code>client/ayon_maya/plugins/publish/collect_look.py</code> <pre><code>def collect(self, instance):\n    \"\"\"Collect looks.\n\n    Args:\n        instance (pyblish.api.Instance): Instance to collect.\n\n    \"\"\"\n    self.log.debug(\"Looking for look associations \"\n                   \"for %s\" % instance.data['name'])\n\n    # Discover related object sets\n    self.log.debug(\"Gathering sets ...\")\n    sets = self.collect_sets(instance)\n\n    # Lookup set (optimization)\n    instance_lookup = set(cmds.ls(instance, long=True))\n\n    self.log.debug(\"Gathering set relations ...\")\n    # Ensure iteration happen in a list to allow removing keys from the\n    # dict within the loop\n    for obj_set in list(sets):\n        self.log.debug(\"From {}\".format(obj_set))\n        # Get all nodes of the current objectSet (shadingEngine)\n        for member in cmds.ls(cmds.sets(obj_set, query=True), long=True):\n            member_data = self.collect_member_data(member,\n                                                   instance_lookup)\n            if member_data:\n                # Add information of the node to the members list\n                sets[obj_set][\"members\"].append(member_data)\n\n        # Remove sets that didn't have any members assigned in the end\n        # Thus the data will be limited to only what we need.\n        if not sets[obj_set][\"members\"]:\n            self.log.debug(\n                \"Removing redundant set information: {}\".format(obj_set)\n            )\n            sets.pop(obj_set, None)\n\n    self.log.debug(\"Gathering attribute changes to instance members..\")\n    attributes = self.collect_attributes_changed(instance)\n\n    # Store data on the instance\n    instance.data[\"lookData\"] = {\n        \"attributes\": attributes,\n        \"relationships\": sets\n    }\n    if instance.data.get(\"includeTextureReferenceObjects\", False):\n        collections, texture_object_nodes = (\n            self.collect_texture_reference_object_inputs(instance)\n        )\n        instance.data[\"lookData\"][\"connections\"] = collections\n        instance.data[\"textureReferenceObjects\"] = texture_object_nodes\n    # Collect file nodes used by shading engines (if we have any)\n    files = []\n    look_sets = list(sets.keys())\n    if look_sets:\n        self.log.debug(\"Found look sets: {}\".format(look_sets))\n        files = self.collect_file_nodes(look_sets)\n\n    self.log.debug(\"Collected file nodes:\\n{}\".format(files))\n\n    # Collect texture resources if any file nodes are found\n    resources = []\n    for node in files:\n        resources.extend(self.collect_resources(node))\n    instance.data[\"resources\"] = resources\n    self.log.debug(\"Collected resources: {}\".format(resources))\n\n    # Log warning when no relevant sets were retrieved for the look.\n    if (\n        not instance.data[\"lookData\"][\"relationships\"]\n        and \"model\" not in self.families\n    ):\n        self.log.warning(\"No sets found for the nodes in the \"\n                         \"instance: %s\" % instance[:])\n\n    # Ensure unique shader sets\n    # Add shader sets to the instance for unify ID validation\n    instance.extend(shader for shader in look_sets if shader\n                    not in instance_lookup)\n\n    self.log.debug(\"Collected look for %s\" % instance)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_look.html#client.ayon_maya.plugins.publish.collect_look.CollectLook.collect_attributes_changed","title":"<code>collect_attributes_changed(instance)</code>","text":"<p>Collect all userDefined attributes which have changed</p> <p>Each node gets checked for user defined attributes which have been altered during development. Each changes gets logged in a dictionary</p> <p>[{name: node,   uuid: uuid,   attributes: {attribute: value}}]</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>list</code> <p>all nodes which will be published</p> required <p>Returns:</p> Type Description <p>list</p> Source code in <code>client/ayon_maya/plugins/publish/collect_look.py</code> <pre><code>def collect_attributes_changed(self, instance):\n    \"\"\"Collect all userDefined attributes which have changed\n\n    Each node gets checked for user defined attributes which have been\n    altered during development. Each changes gets logged in a dictionary\n\n    [{name: node,\n      uuid: uuid,\n      attributes: {attribute: value}}]\n\n    Args:\n        instance (list): all nodes which will be published\n\n    Returns:\n        list\n    \"\"\"\n\n    attributes = []\n    for node in instance:\n\n        # Collect changes to \"custom\" attributes\n        node_attrs = get_look_attrs(node)\n\n        # Only include if there are any properties we care about\n        if not node_attrs:\n            continue\n\n        self.log.debug(\n            \"Node \\\"{0}\\\" attributes: {1}\".format(node, node_attrs)\n        )\n\n        node_attributes = {}\n        for attr in node_attrs:\n            if not cmds.attributeQuery(attr, node=node, exists=True):\n                continue\n            attribute = \"{}.{}\".format(node, attr)\n            # We don't support mixed-type attributes yet.\n            if cmds.attributeQuery(attr, node=node, multi=True):\n                self.log.warning(\"Attribute '{}' is mixed-type and is \"\n                                 \"not supported yet.\".format(attribute))\n                continue\n\n            attribute_type = cmds.getAttr(attribute, type=True)\n            if attribute_type == \"message\":\n                continue\n\n            # Maya has a tendency to return string attribute values as\n            # `None` if it is an empty string and the attribute has never\n            # been set but is still at default value.\n            value = cmds.getAttr(attribute, asString=True)\n            if value is None:\n                # If the attribute type is `string` we will convert it\n                # to enforce an empty string value\n                if attribute_type == \"string\":\n                    value = \"\"\n                else:\n                    continue\n\n            node_attributes[attr] = value\n        # Only include if there are any properties we care about\n        if not node_attributes:\n            continue\n        attributes.append({\"name\": node,\n                           \"uuid\": lib.get_id(node),\n                           \"attributes\": node_attributes})\n\n    return attributes\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_look.html#client.ayon_maya.plugins.publish.collect_look.CollectLook.collect_file_nodes","title":"<code>collect_file_nodes(look_sets)</code>","text":"<p>Get the entire node chain of the look sets and return file nodes</p> <p>Parameters:</p> Name Type Description Default <code>look_sets</code> <code>List[str]</code> <p>List of sets and shading engines relevant to the look.</p> required <p>Returns:</p> Type Description <p>List[str]: List of file node names.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_look.py</code> <pre><code>def collect_file_nodes(self, look_sets):\n    \"\"\"Get the entire node chain of the look sets and return file nodes\n\n    Arguments:\n        look_sets (List[str]): List of sets and shading engines relevant\n            to the look.\n\n    Returns:\n        List[str]: List of file node names.\n\n    \"\"\"\n\n    shader_attrs = [\n        \"surfaceShader\",\n        \"volumeShader\",\n        \"displacementShader\",\n        \"aiSurfaceShader\",\n        \"aiVolumeShader\",\n        \"rman__surface\",\n        \"rman__displacement\"\n    ]\n\n    # Get all material attrs for all look sets to retrieve their inputs\n    existing_attrs = []\n    for look_set in look_sets:\n        for attr in shader_attrs:\n            if cmds.attributeQuery(attr, node=look_set, exists=True):\n                existing_attrs.append(\"{}.{}\".format(look_set, attr))\n\n    materials = cmds.listConnections(existing_attrs,\n                                     source=True,\n                                     destination=False) or []\n\n    self.log.debug(\"Found materials:\\n{}\".format(materials))\n\n    # Get the entire node chain of the look sets\n    # history = cmds.listHistory(look_sets, allConnections=True)\n    # if materials list is empty, listHistory() will crash with\n    # RuntimeError\n    history = set()\n    if materials:\n        history.update(cmds.listHistory(materials, allConnections=True))\n\n    # Since we retrieved history only of the connected materials connected\n    # to the look sets above we now add direct history for some of the\n    # look sets directly handling render attribute sets\n\n    # Maya (at least 2024) crashes with Warning when render set type\n    # isn't available. cmds.ls() will return empty list\n    if RENDER_SET_TYPES:\n        render_sets = cmds.ls(look_sets, type=RENDER_SET_TYPES)\n        if render_sets:\n            history.update(\n                cmds.listHistory(render_sets,\n                                 future=False,\n                                 pruneDagObjects=True)\n                or []\n            )\n\n    # Get file nodes in the material history\n    files = cmds.ls(list(history),\n                    # It's important only node types are passed that\n                    # exist (e.g. for loaded plugins) because otherwise\n                    # the result will turn back empty\n                    type=list(FILE_NODES.keys()),\n                    long=True)\n\n    # Sort for log readability\n    files.sort()\n\n    return files\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_look.html#client.ayon_maya.plugins.publish.collect_look.CollectLook.collect_member_data","title":"<code>collect_member_data(member, instance_members)</code>","text":"<p>Get all information of the node Args:     member (str): the name of the node to check     instance_members (set): the collected instance members</p> <p>Returns:</p> Type Description <p>dict</p> Source code in <code>client/ayon_maya/plugins/publish/collect_look.py</code> <pre><code>def collect_member_data(self, member, instance_members):\n    \"\"\"Get all information of the node\n    Args:\n        member (str): the name of the node to check\n        instance_members (set): the collected instance members\n\n    Returns:\n        dict\n\n    \"\"\"\n    node, components = (member.rsplit(\".\", 1) + [None])[:2]\n    if components and not cmds.objectType(node, isAType=\"shape\"):\n        # Components are always on shapes. When only a single shape is\n        # parented under a transform Maya returns it as e.g. `cube.f[0:4]`\n        # instead of `cubeShape.f[0:4]` so we expand that to the shape\n        node = cmds.listRelatives(node, shapes=True, fullPath=True)[0]\n\n    # Only include valid members of the instance\n    if node not in instance_members:\n        return\n\n    node_id = lib.get_id(node)\n    if not node_id:\n        self.log.error(\"Member '{}' has no attribute 'cbId'\".format(node))\n        return\n\n    member_data = {\"name\": node, \"uuid\": node_id}\n    if components:\n        member_data[\"components\"] = components\n\n    return member_data\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_look.html#client.ayon_maya.plugins.publish.collect_look.CollectLook.collect_resources","title":"<code>collect_resources(node)</code>","text":"<p>Collect the link to the file(s) used (resource) Args:     node (str): name of the node</p> <p>Returns:</p> Type Description <p>dict</p> Source code in <code>client/ayon_maya/plugins/publish/collect_look.py</code> <pre><code>def collect_resources(self, node):\n    \"\"\"Collect the link to the file(s) used (resource)\n    Args:\n        node (str): name of the node\n\n    Returns:\n        dict\n    \"\"\"\n    if cmds.nodeType(node) not in FILE_NODES:\n        self.log.error(\n            \"Unsupported file node: {}\".format(cmds.nodeType(node)))\n        raise AssertionError(\"Unsupported file node\")\n\n    self.log.debug(\n        \"Collecting resource: {} ({})\".format(node, cmds.nodeType(node))\n    )\n\n    attributes = get_attributes(FILE_NODES, cmds.nodeType(node), node)\n    for attribute in attributes:\n        source = cmds.getAttr(\"{}.{}\".format(\n            node,\n            attribute\n        ))\n\n        self.log.debug(\"  - file source: {}\".format(source))\n        color_space_attr = \"{}.colorSpace\".format(node)\n        try:\n            color_space = cmds.getAttr(color_space_attr)\n        except ValueError:\n            # node doesn't have colorspace attribute\n            color_space = \"Raw\"\n\n        # Compare with the computed file path, e.g. the one with\n        # the &lt;UDIM&gt; pattern in it, to generate some logging information\n        # about this difference\n        # Only for file nodes with `fileTextureName` attribute\n        if attribute == \"fileTextureName\":\n            computed_source = cmds.getAttr(\n                \"{}.computedFileTextureNamePattern\".format(node)\n            )\n            if source != computed_source:\n                self.log.debug(\"Detected computed file pattern difference \"\n                               \"from original pattern: {0} \"\n                               \"({1} -&gt; {2})\".format(node,\n                                                     source,\n                                                     computed_source))\n\n        # renderman allows nodes to have filename attribute empty while\n        # you can have another incoming connection from different node.\n        if not source and cmds.nodeType(node) in PXR_NODES:\n            self.log.debug(\"Renderman: source is empty, skipping...\")\n            continue\n        # We replace backslashes with forward slashes because V-Ray\n        # can't handle the UDIM files with the backslashes in the\n        # paths as the computed patterns\n        source = source.replace(\"\\\\\", \"/\")\n\n        files = get_file_node_files(node)\n        if len(files) == 0:\n            self.log.debug(\"No valid files found from node `%s`\" % node)\n\n        self.log.debug(\"collection of resource done:\")\n        self.log.debug(\"  - node: {}\".format(node))\n        self.log.debug(\"  - attribute: {}\".format(attribute))\n        self.log.debug(\"  - source: {}\".format(source))\n        self.log.debug(\"  - file: {}\".format(files))\n        self.log.debug(\"  - color space: {}\".format(color_space))\n\n        # Define the resource\n        yield {\n            \"node\": node,\n            # here we are passing not only attribute, but with node again\n            # this should be simplified and changed extractor.\n            \"attribute\": \"{}.{}\".format(node, attribute),\n            \"source\": source,  # required for resources\n            \"files\": files,\n            \"color_space\": color_space\n        }\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_look.html#client.ayon_maya.plugins.publish.collect_look.CollectLook.collect_sets","title":"<code>collect_sets(instance)</code>","text":"<p>Collect all objectSets which are of importance for publishing</p> <p>It checks if all nodes in the instance are related to any objectSet which need to be</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>publish instance containing all nodes to be published.</p> required <p>Returns:</p> Type Description <p>dict</p> Source code in <code>client/ayon_maya/plugins/publish/collect_look.py</code> <pre><code>def collect_sets(self, instance):\n    \"\"\"Collect all objectSets which are of importance for publishing\n\n    It checks if all nodes in the instance are related to any objectSet\n    which need to be\n\n    Args:\n        instance (pyblish.api.Instance): publish instance containing all\n            nodes to be published.\n\n    Returns:\n        dict\n    \"\"\"\n\n    sets = {}\n    for node in instance:\n        related_sets = lib.get_related_sets(node)\n        if not related_sets:\n            continue\n\n        for objset in related_sets:\n            if objset in sets:\n                continue\n\n            sets[objset] = {\"uuid\": lib.get_id(objset), \"members\": list()}\n\n    return sets\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_look.html#client.ayon_maya.plugins.publish.collect_look.CollectLook.collect_texture_reference_object_inputs","title":"<code>collect_texture_reference_object_inputs(instance)</code>","text":"<p>Collect the inputs for all nodes in the input_SET</p> Source code in <code>client/ayon_maya/plugins/publish/collect_look.py</code> <pre><code>def collect_texture_reference_object_inputs(self, instance):\n    \"\"\"Collect the inputs for all nodes in the input_SET\"\"\"\n\n    # Get the input meshes information\n    input_content = instance.data[\"setMembers\"]\n\n    # Include children\n    input_content += cmds.listRelatives(input_content,\n                                        allDescendents=True,\n                                        fullPath=True) or []\n\n    # Ignore intermediate objects\n    input_content = cmds.ls(\n        input_content, \n        long=True, \n        noIntermediate=True,\n        type=\"mesh\"\n    )\n    if not input_content:\n        return []\n\n    attrs = [f\"{mesh}.referenceObject\" for mesh in set(input_content)]\n    # Store all connections\n    connections = cmds.listConnections(attrs,\n                                       source=True,\n                                       destination=False,\n                                       connections=True,\n                                       # Only allow inputs from dagNodes\n                                       # (avoid display layers, etc.)\n                                       type=\"mesh\",\n                                       plugs=True) or []\n    connections = cmds.ls(connections, long=True)      # Ensure long names\n\n    inputs = []\n    texture_object_nodes = []\n    for dest, src in lib.pairwise(connections):\n        source_node, source_attr = src.split(\".\", 1)\n        dest_node, dest_attr = dest.split(\".\", 1)\n\n        inputs.append({\n            \"connections\": [source_attr, dest_attr],\n            \"sourceID\": lib.get_id(source_node),\n            \"destinationID\": lib.get_id(dest_node)\n        })\n        texture_object_nodes.append(source_node)\n\n    return inputs, texture_object_nodes\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_look.html#client.ayon_maya.plugins.publish.collect_look.CollectLook.process","title":"<code>process(instance)</code>","text":"<p>Collect the Look in the instance with the correct layer settings</p> Source code in <code>client/ayon_maya/plugins/publish/collect_look.py</code> <pre><code>def process(self, instance):\n    \"\"\"Collect the Look in the instance with the correct layer settings\"\"\"\n    renderlayer = instance.data.get(\"renderlayer\", \"defaultRenderLayer\")\n    with lib.renderlayer(renderlayer):\n        self.collect(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_look.html#client.ayon_maya.plugins.publish.collect_look.CollectModelRenderSets","title":"<code>CollectModelRenderSets</code>","text":"<p>               Bases: <code>CollectLook</code></p> <p>Collect render attribute sets for model instance.</p> <p>Collects additional render attribute sets so they can be published with model.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_look.py</code> <pre><code>class CollectModelRenderSets(CollectLook):\n    \"\"\"Collect render attribute sets for model instance.\n\n    Collects additional render attribute sets so they can be\n    published with model.\n\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.21\n    families = [\"model\"]\n    label = \"Collect Model Render Sets\"\n\n    def collect_sets(self, instance):\n        \"\"\"Collect all related objectSets except shadingEngines\n\n        Args:\n            instance (pyblish.api.Instance): publish instance containing all\n                nodes to be published.\n\n        Returns:\n            dict\n        \"\"\"\n\n        sets = {}\n        for node in instance:\n            related_sets = lib.get_related_sets(node)\n            if not related_sets:\n                continue\n\n            for objset in related_sets:\n                if objset in sets:\n                    continue\n\n                if cmds.objectType(objset, isAType=\"shadingEngine\"):\n                    continue\n\n                sets[objset] = {\"uuid\": lib.get_id(objset), \"members\": list()}\n\n        return sets\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_look.html#client.ayon_maya.plugins.publish.collect_look.CollectModelRenderSets.collect_sets","title":"<code>collect_sets(instance)</code>","text":"<p>Collect all related objectSets except shadingEngines</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>publish instance containing all nodes to be published.</p> required <p>Returns:</p> Type Description <p>dict</p> Source code in <code>client/ayon_maya/plugins/publish/collect_look.py</code> <pre><code>def collect_sets(self, instance):\n    \"\"\"Collect all related objectSets except shadingEngines\n\n    Args:\n        instance (pyblish.api.Instance): publish instance containing all\n            nodes to be published.\n\n    Returns:\n        dict\n    \"\"\"\n\n    sets = {}\n    for node in instance:\n        related_sets = lib.get_related_sets(node)\n        if not related_sets:\n            continue\n\n        for objset in related_sets:\n            if objset in sets:\n                continue\n\n            if cmds.objectType(objset, isAType=\"shadingEngine\"):\n                continue\n\n            sets[objset] = {\"uuid\": lib.get_id(objset), \"members\": list()}\n\n    return sets\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_look.html#client.ayon_maya.plugins.publish.collect_look.get_file_node_files","title":"<code>get_file_node_files(node)</code>","text":"<p>Return the file paths related to the file node</p> Note <p>Will only return existing files. Returns an empty list if not valid existing files are linked.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of full file paths.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_look.py</code> <pre><code>def get_file_node_files(node):\n    \"\"\"Return the file paths related to the file node\n\n    Note:\n        Will only return existing files. Returns an empty list\n        if not valid existing files are linked.\n\n    Returns:\n        list: List of full file paths.\n\n    \"\"\"\n    paths = get_file_node_paths(node)\n\n    # For sequences get all files and filter to only existing files\n    result = []\n    for path in paths:\n        if node_uses_image_sequence(node, path):\n            glob_pattern = seq_to_glob(path)\n            result.extend(glob.glob(glob_pattern))\n        elif os.path.exists(path):\n            result.append(path)\n\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_look.html#client.ayon_maya.plugins.publish.collect_look.get_file_node_paths","title":"<code>get_file_node_paths(node)</code>","text":"<p>Get the file path used by a Maya file node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>Name of the Maya file node</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>the file paths in use</p> Source code in <code>client/ayon_maya/plugins/publish/collect_look.py</code> <pre><code>def get_file_node_paths(node):\n    # type: (str) -&gt; list\n    \"\"\"Get the file path used by a Maya file node.\n\n    Args:\n        node (str): Name of the Maya file node\n\n    Returns:\n        list: the file paths in use\n\n    \"\"\"\n    # if the path appears to be sequence, use computedFileTextureNamePattern,\n    # this preserves the &lt;&gt; tag\n    if cmds.attributeQuery('computedFileTextureNamePattern',\n                           node=node,\n                           exists=True):\n        plug = '{0}.computedFileTextureNamePattern'.format(node)\n        texture_pattern = cmds.getAttr(plug)\n\n        patterns = [\"&lt;udim&gt;\",\n                    \"&lt;tile&gt;\",\n                    \"u&lt;u&gt;_v&lt;v&gt;\",\n                    \"&lt;f&gt;\",\n                    \"&lt;frame0\",\n                    \"&lt;uvtile&gt;\"]\n        lower = texture_pattern.lower()\n        if any(pattern in lower for pattern in patterns):\n            return [texture_pattern]\n\n    try:\n        file_attributes = get_attributes(\n            FILE_NODES, cmds.nodeType(node), node)\n    except AttributeError:\n        file_attributes = \"fileTextureName\"\n\n    files = []\n    for file_attr in file_attributes:\n        if cmds.attributeQuery(file_attr, node=node, exists=True):\n            files.append(cmds.getAttr(\"{}.{}\".format(node, file_attr)))\n\n    return files\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_look.html#client.ayon_maya.plugins.publish.collect_look.get_look_attrs","title":"<code>get_look_attrs(node)</code>","text":"<p>Returns attributes of a node that are important for the look.</p> <p>These are the \"changed\" attributes (those that have edits applied in the current scene).</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Attribute names to extract</p> Source code in <code>client/ayon_maya/plugins/publish/collect_look.py</code> <pre><code>def get_look_attrs(node):\n    \"\"\"Returns attributes of a node that are important for the look.\n\n    These are the \"changed\" attributes (those that have edits applied\n    in the current scene).\n\n    Returns:\n        list: Attribute names to extract\n\n    \"\"\"\n    # When referenced get only attributes that are \"changed since file open\"\n    # which includes any reference edits, otherwise take *all* user defined\n    # attributes\n    is_referenced = cmds.referenceQuery(node, isNodeReferenced=True)\n    result = cmds.listAttr(node, userDefined=True,\n                           changedSinceFileOpen=is_referenced) or []\n\n    # `cbId` is added when a scene is saved, ignore by default\n    if \"cbId\" in result:\n        result.remove(\"cbId\")\n\n    # For shapes allow render stat changes\n    if cmds.objectType(node, isAType=\"shape\"):\n        attrs = cmds.listAttr(node, changedSinceFileOpen=True) or []\n        for attr in attrs:\n            if (\n                    attr in SHAPE_ATTRS       # maya shape render stats\n                    or attr.startswith('ai')  # arnold\n                    or attr.startswith(\"rs\")  # redshift\n            ):\n                result.append(attr)\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_look.html#client.ayon_maya.plugins.publish.collect_look.node_uses_image_sequence","title":"<code>node_uses_image_sequence(node, node_path)</code>","text":"<p>Return whether file node uses an image sequence or single image.</p> <p>Determine if a node uses an image sequence or just a single image, not always obvious from its file path alone.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>Name of the Maya node</p> required <code>node_path</code> <code>str</code> <p>The file path of the node</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if node uses an image sequence</p> Source code in <code>client/ayon_maya/plugins/publish/collect_look.py</code> <pre><code>def node_uses_image_sequence(node, node_path):\n    # type: (str, str) -&gt; bool\n    \"\"\"Return whether file node uses an image sequence or single image.\n\n    Determine if a node uses an image sequence or just a single image,\n    not always obvious from its file path alone.\n\n    Args:\n        node (str): Name of the Maya node\n        node_path (str): The file path of the node\n\n    Returns:\n        bool: True if node uses an image sequence\n\n    \"\"\"\n\n    # useFrameExtension indicates an explicit image sequence\n    try:\n        use_frame_extension = cmds.getAttr('%s.useFrameExtension' % node)\n    except ValueError:\n        use_frame_extension = False\n    if use_frame_extension:\n        return True\n\n    # The following tokens imply a sequence\n    patterns = [\"&lt;udim&gt;\", \"&lt;tile&gt;\", \"&lt;uvtile&gt;\",\n                \"u&lt;u&gt;_v&lt;v&gt;\", \"&lt;frame0\", \"&lt;f4&gt;\"]\n    node_path_lowered = node_path.lower()\n    return any(pattern in node_path_lowered for pattern in patterns)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_look.html#client.ayon_maya.plugins.publish.collect_look.seq_to_glob","title":"<code>seq_to_glob(path)</code>","text":"<p>Takes an image sequence path and returns it in glob format, with the frame number replaced by a '*'.</p> <p>Image sequences may be numerical sequences, e.g. /path/to/file.1001.exr will return as /path/to/file.*.exr.</p> <p>Image sequences may also use tokens to denote sequences, e.g. /path/to/texture..tif will return as /path/to/texture.*.tif. <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>the image sequence path</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Return glob string that matches the filename pattern.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_look.py</code> <pre><code>def seq_to_glob(path):\n    \"\"\"Takes an image sequence path and returns it in glob format,\n    with the frame number replaced by a '*'.\n\n    Image sequences may be numerical sequences, e.g. /path/to/file.1001.exr\n    will return as /path/to/file.*.exr.\n\n    Image sequences may also use tokens to denote sequences, e.g.\n    /path/to/texture.&lt;UDIM&gt;.tif will return as /path/to/texture.*.tif.\n\n    Args:\n        path (str): the image sequence path\n\n    Returns:\n        str: Return glob string that matches the filename pattern.\n\n    \"\"\"\n\n    if path is None:\n        return path\n\n    # If any of the patterns, convert the pattern\n    patterns = {\n        \"&lt;udim&gt;\": \"&lt;udim&gt;\",\n        \"&lt;tile&gt;\": \"&lt;tile&gt;\",\n        \"&lt;uvtile&gt;\": \"&lt;uvtile&gt;\",\n        \"#\": \"#\",\n        \"u&lt;u&gt;_v&lt;v&gt;\": \"&lt;u&gt;|&lt;v&gt;\",\n        \"&lt;frame0\": \"&lt;frame0\\d+&gt;\",\n        \"&lt;f&gt;\": \"&lt;f&gt;\"\n    }\n\n    lower = path.lower()\n    has_pattern = False\n    for pattern, regex_pattern in patterns.items():\n        if pattern in lower:\n            path = re.sub(regex_pattern, \"*\", path, flags=re.IGNORECASE)\n            has_pattern = True\n\n    if has_pattern:\n        return path\n\n    base = os.path.basename(path)\n    matches = list(re.finditer(r'\\d+', base))\n    if matches:\n        match = matches[-1]\n        new_base = '{0}*{1}'.format(base[:match.start()],\n                                    base[match.end():])\n        head = os.path.dirname(path)\n        return os.path.join(head, new_base)\n    else:\n        return path\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_maya_scene_time.html","title":"collect_maya_scene_time","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_maya_scene_time.html#client.ayon_maya.plugins.publish.collect_maya_scene_time.CollectMayaSceneTime","title":"<code>CollectMayaSceneTime</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect Maya Scene playback range</p> <p>This allows to reproduce the playback range for the content to be loaded. It does not limit the extracted data to only data inside that time range.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_maya_scene_time.py</code> <pre><code>class CollectMayaSceneTime(plugin.MayaInstancePlugin):\n    \"\"\"Collect Maya Scene playback range\n\n    This allows to reproduce the playback range for the content to be loaded.\n    It does *not* limit the extracted data to only data inside that time range.\n\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.2\n    label = 'Collect Maya Scene Time'\n    families = [\"mayaScene\"]\n\n    def process(self, instance):\n        instance.data.update({\n            \"frameStart\": int(\n                cmds.playbackOptions(query=True, minTime=True)),\n            \"frameEnd\": int(\n                cmds.playbackOptions(query=True, maxTime=True)),\n            \"frameStartHandle\": int(\n                cmds.playbackOptions(query=True, animationStartTime=True)),\n            \"frameEndHandle\": int(\n                cmds.playbackOptions(query=True, animationEndTime=True))\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_maya_units.html","title":"collect_maya_units","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_maya_units.html#client.ayon_maya.plugins.publish.collect_maya_units.CollectMayaUnits","title":"<code>CollectMayaUnits</code>","text":"<p>               Bases: <code>MayaContextPlugin</code></p> <p>Collect Maya's scene units.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_maya_units.py</code> <pre><code>class CollectMayaUnits(plugin.MayaContextPlugin):\n    \"\"\"Collect Maya's scene units.\"\"\"\n\n    label = \"Maya Units\"\n    order = pyblish.api.CollectorOrder\n\n    def process(self, context):\n\n        # Get the current linear units\n        units = cmds.currentUnit(query=True, linear=True)\n\n        # Get the current angular units ('deg' or 'rad')\n        units_angle = cmds.currentUnit(query=True, angle=True)\n\n        # Get the current time units\n        # Using the mel command is simpler than using\n        # `cmds.currentUnit(q=1, time=1)`. Otherwise we\n        # have to parse the returned string value to FPS\n        fps = mel.eval('currentTimeUnitToFPS()')\n\n        context.data['linearUnits'] = units\n        context.data['angularUnits'] = units_angle\n        context.data['fps'] = fps\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_maya_usd_export_filter_properties.html","title":"collect_maya_usd_export_filter_properties","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_maya_workspace.html","title":"collect_maya_workspace","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_maya_workspace.html#client.ayon_maya.plugins.publish.collect_maya_workspace.CollectMayaWorkspace","title":"<code>CollectMayaWorkspace</code>","text":"<p>               Bases: <code>MayaContextPlugin</code></p> <p>Inject the current workspace into context</p> Source code in <code>client/ayon_maya/plugins/publish/collect_maya_workspace.py</code> <pre><code>class CollectMayaWorkspace(plugin.MayaContextPlugin):\n    \"\"\"Inject the current workspace into context\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.5\n    label = \"Maya Workspace\"\n\n\n    def process(self, context):\n        workspace = cmds.workspace(rootDirectory=True, query=True)\n        if not workspace:\n            # Project has not been set. Files will\n            # instead end up next to the working file.\n            workspace = cmds.workspace(dir=True, query=True)\n\n        # Maya returns forward-slashes by default\n        normalised = os.path.normpath(workspace)\n\n        context.set_data('workspaceDir', value=normalised)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_model.html","title":"collect_model","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_model.html#client.ayon_maya.plugins.publish.collect_model.CollectModelData","title":"<code>CollectModelData</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect model data</p> <p>Ensures always only a single frame is extracted (current frame).</p> Todo <p>Validate if is this plugin still useful.</p> Note <p>This is a workaround so that the <code>model</code> product type can use the same pointcache extractor implementation as animation and pointcaches. This always enforces the \"current\" frame to be published.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_model.py</code> <pre><code>class CollectModelData(plugin.MayaInstancePlugin):\n    \"\"\"Collect model data\n\n    Ensures always only a single frame is extracted (current frame).\n\n    Todo:\n        Validate if is this plugin still useful.\n\n    Note:\n        This is a workaround so that the `model` product type can use the\n        same pointcache extractor implementation as animation and pointcaches.\n        This always enforces the \"current\" frame to be published.\n\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.2\n    label = 'Collect Model Data'\n    families = [\"model\"]\n\n    def process(self, instance):\n        # Extract only current frame (override)\n        frame = cmds.currentTime(query=True)\n        instance.data[\"frameStart\"] = frame\n        instance.data[\"frameEnd\"] = frame\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_multiverse_look.html","title":"collect_multiverse_look","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_multiverse_look.html#client.ayon_maya.plugins.publish.collect_multiverse_look.CollectMultiverseLookData","title":"<code>CollectMultiverseLookData</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect Multiverse Look</p> <p>Searches through the overrides finding all material overrides. From there it extracts the shading group and then finds all texture files in the shading group network. It also checks for mipmap versions of texture files and adds them to the resources to get published.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_multiverse_look.py</code> <pre><code>class CollectMultiverseLookData(plugin.MayaInstancePlugin):\n    \"\"\"Collect Multiverse Look\n\n    Searches through the overrides finding all material overrides. From there\n    it extracts the shading group and then finds all texture files in the\n    shading group network. It also checks for mipmap versions of texture files\n    and adds them to the resources to get published.\n\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.2\n    label = 'Collect Multiverse Look'\n    families = [\"mvLook\"]\n\n    def process(self, instance):\n        # Load plugin first\n        cmds.loadPlugin(\"MultiverseForMaya\", quiet=True)\n        import multiverse\n\n        self.log.debug(\"Processing mvLook for '{}'\".format(instance))\n\n        nodes = set()\n        for node in instance:\n            # We want only mvUsdCompoundShape nodes.\n            nodes_of_interest = cmds.ls(node,\n                                        dag=True,\n                                        shapes=False,\n                                        type=\"mvUsdCompoundShape\",\n                                        noIntermediate=True,\n                                        long=True)\n            nodes.update(nodes_of_interest)\n\n        sets = {}\n        instance.data[\"resources\"] = []\n        publishMipMap = instance.data[\"publishMipMap\"]\n\n        for node in nodes:\n            self.log.debug(\"Getting resources for '{}'\".format(node))\n\n            # We know what nodes need to be collected, now we need to\n            # extract the materials overrides.\n            overrides = multiverse.ListMaterialOverridePrims(node)\n            for override in overrides:\n                matOver = multiverse.GetMaterialOverride(node, override)\n\n                if isinstance(matOver, multiverse.MaterialSourceShadingGroup):\n                    # We now need to grab the shadingGroup so add it to the\n                    # sets we pass down the pipe.\n                    shadingGroup = matOver.shadingGroupName\n                    self.log.debug(\"ShadingGroup = '{}'\".format(shadingGroup))\n                    sets[shadingGroup] = {\"uuid\": lib.get_id(\n                        shadingGroup), \"members\": list()}\n\n                    # The SG may reference files, add those too!\n                    history = cmds.listHistory(\n                        shadingGroup, allConnections=True)\n\n                    # We need to iterate over node_types since `cmds.ls` may\n                    # error out if we don't have the appropriate plugin loaded.\n                    files = []\n                    for node_type in NODETYPES.keys():\n                        files += cmds.ls(history,\n                                         type=node_type,\n                                         long=True)\n\n                    for f in files:\n                        resources = self.collect_resource(f, publishMipMap)\n                        instance.data[\"resources\"] += resources\n\n                elif isinstance(matOver, multiverse.MaterialSourceUsdPath):\n                    # TODO: Handle this later.\n                    pass\n\n        # Store data on the instance for validators, extractos, etc.\n        instance.data[\"lookData\"] = {\n            \"attributes\": [],\n            \"relationships\": sets\n        }\n\n    def collect_resource(self, node, publishMipMap):\n        \"\"\"Collect the link to the file(s) used (resource)\n        Args:\n            node (str): name of the node\n\n        Returns:\n            dict\n        \"\"\"\n\n        node_type = cmds.nodeType(node)\n        self.log.debug(\"processing: {}/{}\".format(node, node_type))\n\n        if node_type not in NODETYPES:\n            self.log.error(\"Unsupported file node: {}\".format(node_type))\n            raise AssertionError(\"Unsupported file node\")\n\n        resources = []\n        for node_type_attr in NODETYPES[node_type]:\n            fname_attrib = node_type_attr.get_fname(node)\n            computed_fname_attrib = node_type_attr.get_computed_fname(node)\n            colour_space_attrib = node_type_attr.get_colour_space(node)\n\n            source = cmds.getAttr(fname_attrib)\n            color_space = \"Raw\"\n            try:\n                color_space = cmds.getAttr(colour_space_attrib)\n            except ValueError:\n                # node doesn't have colorspace attribute, use \"Raw\" from before\n                pass\n            # Compare with the computed file path, e.g. the one with the &lt;UDIM&gt;\n            # pattern in it, to generate some logging information about this\n            # difference\n            # computed_attribute = \"{}.computedFileTextureNamePattern\".format(node)  # noqa\n            computed_source = cmds.getAttr(computed_fname_attrib)\n            if source != computed_source:\n                self.log.debug(\"Detected computed file pattern difference \"\n                               \"from original pattern: {0} \"\n                               \"({1} -&gt; {2})\".format(node,\n                                                     source,\n                                                     computed_source))\n\n            # We replace backslashes with forward slashes because V-Ray\n            # can't handle the UDIM files with the backslashes in the\n            # paths as the computed patterns\n            source = source.replace(\"\\\\\", \"/\")\n\n            files = get_file_node_files(node)\n            files = self.handle_files(files, publishMipMap)\n            if len(files) == 0:\n                self.log.error(\"No valid files found from node `%s`\" % node)\n\n            self.log.debug(\"collection of resource done:\")\n            self.log.debug(\"  - node: {}\".format(node))\n            self.log.debug(\"  - attribute: {}\".format(fname_attrib))\n            self.log.debug(\"  - source: {}\".format(source))\n            self.log.debug(\"  - file: {}\".format(files))\n            self.log.debug(\"  - color space: {}\".format(color_space))\n\n            # Define the resource\n            resource = {\"node\": node,\n                        \"attribute\": fname_attrib,\n                        \"source\": source,  # required for resources\n                        \"files\": files,\n                        \"color_space\": color_space}  # required for resources\n            resources.append(resource)\n        return resources\n\n    def handle_files(self, files, publishMipMap):\n        \"\"\"This will go through all the files and make sure that they are\n        either already mipmapped or have a corresponding mipmap sidecar and\n        add that to the list.\"\"\"\n        if not publishMipMap:\n            return files\n\n        extra_files = []\n        self.log.debug(\"Expecting MipMaps, going to look for them.\")\n        for fname in files:\n            self.log.debug(\"Checking '{}' for mipmaps\".format(fname))\n            if is_mipmap(fname):\n                self.log.debug(\" - file is already MipMap, skipping.\")\n                continue\n\n            mipmap = get_mipmap(fname)\n            if mipmap:\n                self.log.debug(\" mipmap found for '{}'\".format(fname))\n                extra_files.append(mipmap)\n            else:\n                self.log.warning(\" no mipmap found for '{}'\".format(fname))\n        return files + extra_files\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_multiverse_look.html#client.ayon_maya.plugins.publish.collect_multiverse_look.CollectMultiverseLookData.collect_resource","title":"<code>collect_resource(node, publishMipMap)</code>","text":"<p>Collect the link to the file(s) used (resource) Args:     node (str): name of the node</p> <p>Returns:</p> Type Description <p>dict</p> Source code in <code>client/ayon_maya/plugins/publish/collect_multiverse_look.py</code> <pre><code>def collect_resource(self, node, publishMipMap):\n    \"\"\"Collect the link to the file(s) used (resource)\n    Args:\n        node (str): name of the node\n\n    Returns:\n        dict\n    \"\"\"\n\n    node_type = cmds.nodeType(node)\n    self.log.debug(\"processing: {}/{}\".format(node, node_type))\n\n    if node_type not in NODETYPES:\n        self.log.error(\"Unsupported file node: {}\".format(node_type))\n        raise AssertionError(\"Unsupported file node\")\n\n    resources = []\n    for node_type_attr in NODETYPES[node_type]:\n        fname_attrib = node_type_attr.get_fname(node)\n        computed_fname_attrib = node_type_attr.get_computed_fname(node)\n        colour_space_attrib = node_type_attr.get_colour_space(node)\n\n        source = cmds.getAttr(fname_attrib)\n        color_space = \"Raw\"\n        try:\n            color_space = cmds.getAttr(colour_space_attrib)\n        except ValueError:\n            # node doesn't have colorspace attribute, use \"Raw\" from before\n            pass\n        # Compare with the computed file path, e.g. the one with the &lt;UDIM&gt;\n        # pattern in it, to generate some logging information about this\n        # difference\n        # computed_attribute = \"{}.computedFileTextureNamePattern\".format(node)  # noqa\n        computed_source = cmds.getAttr(computed_fname_attrib)\n        if source != computed_source:\n            self.log.debug(\"Detected computed file pattern difference \"\n                           \"from original pattern: {0} \"\n                           \"({1} -&gt; {2})\".format(node,\n                                                 source,\n                                                 computed_source))\n\n        # We replace backslashes with forward slashes because V-Ray\n        # can't handle the UDIM files with the backslashes in the\n        # paths as the computed patterns\n        source = source.replace(\"\\\\\", \"/\")\n\n        files = get_file_node_files(node)\n        files = self.handle_files(files, publishMipMap)\n        if len(files) == 0:\n            self.log.error(\"No valid files found from node `%s`\" % node)\n\n        self.log.debug(\"collection of resource done:\")\n        self.log.debug(\"  - node: {}\".format(node))\n        self.log.debug(\"  - attribute: {}\".format(fname_attrib))\n        self.log.debug(\"  - source: {}\".format(source))\n        self.log.debug(\"  - file: {}\".format(files))\n        self.log.debug(\"  - color space: {}\".format(color_space))\n\n        # Define the resource\n        resource = {\"node\": node,\n                    \"attribute\": fname_attrib,\n                    \"source\": source,  # required for resources\n                    \"files\": files,\n                    \"color_space\": color_space}  # required for resources\n        resources.append(resource)\n    return resources\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_multiverse_look.html#client.ayon_maya.plugins.publish.collect_multiverse_look.CollectMultiverseLookData.handle_files","title":"<code>handle_files(files, publishMipMap)</code>","text":"<p>This will go through all the files and make sure that they are either already mipmapped or have a corresponding mipmap sidecar and add that to the list.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_multiverse_look.py</code> <pre><code>def handle_files(self, files, publishMipMap):\n    \"\"\"This will go through all the files and make sure that they are\n    either already mipmapped or have a corresponding mipmap sidecar and\n    add that to the list.\"\"\"\n    if not publishMipMap:\n        return files\n\n    extra_files = []\n    self.log.debug(\"Expecting MipMaps, going to look for them.\")\n    for fname in files:\n        self.log.debug(\"Checking '{}' for mipmaps\".format(fname))\n        if is_mipmap(fname):\n            self.log.debug(\" - file is already MipMap, skipping.\")\n            continue\n\n        mipmap = get_mipmap(fname)\n        if mipmap:\n            self.log.debug(\" mipmap found for '{}'\".format(fname))\n            extra_files.append(mipmap)\n        else:\n            self.log.warning(\" no mipmap found for '{}'\".format(fname))\n    return files + extra_files\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_multiverse_look.html#client.ayon_maya.plugins.publish.collect_multiverse_look.get_file_node_files","title":"<code>get_file_node_files(node)</code>","text":"<p>Return the file paths related to the file node</p> Note <p>Will only return existing files. Returns an empty list if not valid existing files are linked.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of full file paths.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_multiverse_look.py</code> <pre><code>def get_file_node_files(node):\n    \"\"\"Return the file paths related to the file node\n\n    Note:\n        Will only return existing files. Returns an empty list\n        if not valid existing files are linked.\n\n    Returns:\n        list: List of full file paths.\n\n    \"\"\"\n\n    paths = get_file_node_paths(node)\n    paths = [cmds.workspace(expandName=path) for path in paths]\n    if node_uses_image_sequence(node):\n        globs = []\n        for path in paths:\n            globs += glob.glob(seq_to_glob(path))\n        return globs\n    else:\n        return list(filter(lambda x: os.path.exists(x), paths))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_multiverse_look.html#client.ayon_maya.plugins.publish.collect_multiverse_look.get_file_node_paths","title":"<code>get_file_node_paths(node)</code>","text":"<p>Get the file path used by a Maya file node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>Name of the Maya file node</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the file path in use</p> Source code in <code>client/ayon_maya/plugins/publish/collect_multiverse_look.py</code> <pre><code>def get_file_node_paths(node):\n    \"\"\"Get the file path used by a Maya file node.\n\n    Args:\n        node (str): Name of the Maya file node\n\n    Returns:\n        str: the file path in use\n\n    \"\"\"\n    # if the path appears to be sequence, use computedFileTextureNamePattern,\n    # this preserves the &lt;&gt; tag\n    if cmds.attributeQuery('computedFileTextureNamePattern',\n                           node=node,\n                           exists=True):\n        plug = '{0}.computedFileTextureNamePattern'.format(node)\n        texture_pattern = cmds.getAttr(plug)\n\n        patterns = [\"&lt;udim&gt;\",\n                    \"&lt;tile&gt;\",\n                    \"u&lt;u&gt;_v&lt;v&gt;\",\n                    \"&lt;f&gt;\",\n                    \"&lt;frame0\",\n                    \"&lt;uvtile&gt;\"]\n        lower = texture_pattern.lower()\n        if any(pattern in lower for pattern in patterns):\n            return [texture_pattern]\n\n    return get_file_paths_for_node(node)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_multiverse_look.html#client.ayon_maya.plugins.publish.collect_multiverse_look.get_file_paths_for_node","title":"<code>get_file_paths_for_node(node)</code>","text":"<p>Gets all the file paths in this node.</p> <p>Returns all filepaths that this node references. Some node types only reference one, but others, like dlTriplanar, can reference 3.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>Name of the Maya node</p> required <p>Returns     list(str): A list with all evaluated maya attributes for filepaths.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_multiverse_look.py</code> <pre><code>def get_file_paths_for_node(node):\n    \"\"\"Gets all the file paths in this node.\n\n    Returns all filepaths that this node references. Some node types only\n    reference one, but others, like dlTriplanar, can reference 3.\n\n    Args:\n        node (str): Name of the Maya node\n\n    Returns\n        list(str): A list with all evaluated maya attributes for filepaths.\n    \"\"\"\n\n    node_type = cmds.nodeType(node)\n    if node_type not in NODETYPES:\n        return []\n\n    paths = []\n    for node_type_attr in NODETYPES[node_type]:\n        fname = cmds.getAttr(\"{}.{}\".format(node, node_type_attr.fname))\n        paths.append(fname)\n    return paths\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_multiverse_look.html#client.ayon_maya.plugins.publish.collect_multiverse_look.node_uses_image_sequence","title":"<code>node_uses_image_sequence(node)</code>","text":"<p>Return whether file node uses an image sequence or single image.</p> <p>Determine if a node uses an image sequence or just a single image, not always obvious from its file path alone.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>Name of the Maya node</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if node uses an image sequence</p> Source code in <code>client/ayon_maya/plugins/publish/collect_multiverse_look.py</code> <pre><code>def node_uses_image_sequence(node):\n    \"\"\"Return whether file node uses an image sequence or single image.\n\n    Determine if a node uses an image sequence or just a single image,\n    not always obvious from its file path alone.\n\n    Args:\n        node (str): Name of the Maya node\n\n    Returns:\n        bool: True if node uses an image sequence\n\n    \"\"\"\n\n    # useFrameExtension indicates an explicit image sequence\n    paths = get_file_node_paths(node)\n    paths = [path.lower() for path in paths]\n\n    # The following tokens imply a sequence\n    patterns = [\"&lt;udim&gt;\", \"&lt;tile&gt;\", \"&lt;uvtile&gt;\", \"u&lt;u&gt;_v&lt;v&gt;\", \"&lt;frame0\"]\n\n    def pattern_in_paths(patterns, paths):\n        \"\"\"Helper function for checking to see if a pattern is contained\n        in the list of paths\"\"\"\n        for pattern in patterns:\n            for path in paths:\n                if pattern in path:\n                    return True\n        return False\n\n    node_type = cmds.nodeType(node)\n    if node_type == 'dlTexture':\n        return (cmds.getAttr('{}.useImageSequence'.format(node)) or\n                pattern_in_paths(patterns, paths))\n    elif node_type == \"file\":\n        return (cmds.getAttr('{}.useFrameExtension'.format(node)) or\n                pattern_in_paths(patterns, paths))\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_multiverse_look.html#client.ayon_maya.plugins.publish.collect_multiverse_look.seq_to_glob","title":"<code>seq_to_glob(path)</code>","text":"<p>Takes an image sequence path and returns it in glob format, with the frame number replaced by a '*'.</p> <p>Image sequences may be numerical sequences, e.g. /path/to/file.1001.exr will return as /path/to/file.*.exr.</p> <p>Image sequences may also use tokens to denote sequences, e.g. /path/to/texture..tif will return as /path/to/texture.*.tif. <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>the image sequence path</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Return glob string that matches the filename pattern.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_multiverse_look.py</code> <pre><code>def seq_to_glob(path):\n    \"\"\"Takes an image sequence path and returns it in glob format,\n    with the frame number replaced by a '*'.\n\n    Image sequences may be numerical sequences, e.g. /path/to/file.1001.exr\n    will return as /path/to/file.*.exr.\n\n    Image sequences may also use tokens to denote sequences, e.g.\n    /path/to/texture.&lt;UDIM&gt;.tif will return as /path/to/texture.*.tif.\n\n    Args:\n        path (str): the image sequence path\n\n    Returns:\n        str: Return glob string that matches the filename pattern.\n\n    \"\"\"\n\n    if path is None:\n        return path\n\n    # If any of the patterns, convert the pattern\n    patterns = {\n        \"&lt;udim&gt;\": \"&lt;udim&gt;\",\n        \"&lt;tile&gt;\": \"&lt;tile&gt;\",\n        \"&lt;uvtile&gt;\": \"&lt;uvtile&gt;\",\n        \"#\": \"#\",\n        \"u&lt;u&gt;_v&lt;v&gt;\": \"&lt;u&gt;|&lt;v&gt;\",\n        \"&lt;frame0\": \"&lt;frame0\\d+&gt;\",  # noqa - copied from collect_look.py\n        \"&lt;f&gt;\": \"&lt;f&gt;\"\n    }\n\n    lower = path.lower()\n    has_pattern = False\n    for pattern, regex_pattern in patterns.items():\n        if pattern in lower:\n            path = re.sub(regex_pattern, \"*\", path, flags=re.IGNORECASE)\n            has_pattern = True\n\n    if has_pattern:\n        return path\n\n    base = os.path.basename(path)\n    matches = list(re.finditer(r'\\d+', base))\n    if matches:\n        match = matches[-1]\n        new_base = '{0}*{1}'.format(base[:match.start()],\n                                    base[match.end():])\n        head = os.path.dirname(path)\n        return os.path.join(head, new_base)\n    else:\n        return path\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_ornatrix_cache.html","title":"collect_ornatrix_cache","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_ornatrix_cache.html#client.ayon_maya.plugins.publish.collect_ornatrix_cache.CollectOxCache","title":"<code>CollectOxCache</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect all information of the Ornatrix caches</p> Source code in <code>client/ayon_maya/plugins/publish/collect_ornatrix_cache.py</code> <pre><code>class CollectOxCache(plugin.MayaInstancePlugin):\n    \"\"\"Collect all information of the Ornatrix caches\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.45\n    label = \"Collect Ornatrix Cache\"\n    families = [\"oxrig\", \"oxcache\"]\n\n    def process(self, instance):\n\n        nodes = []\n        ox_shapes = cmds.ls(instance[:], shapes=True)\n        for ox_shape in ox_shapes:\n            ox_shape_id = lib.get_id(ox_shape)\n            if not ox_shape_id:\n                continue\n            ox_cache_nodes = cmds.listConnections(\n                ox_shape, destination=True, type=\"HairFromGuidesNode\") or []\n\n            if not ox_cache_nodes:\n                continue\n            # transfer cache file\n            if instance.data[\"productType\"] == \"oxcache\":\n                # strip the namespace\n                namespace = get_namespace(ox_shape)\n                ox_shape = strip_namespace(ox_shape, namespace)\n                self.log.debug(ox_shape)\n            nodes.append({\n                \"name\": ox_shape,\n                \"cbId\": ox_shape_id,\n                \"ox_nodes\": ox_cache_nodes,\n                \"cache_file_attributes\": [\"{}.cacheFilePath\".format(ox_node)\n                                          for ox_node in ox_cache_nodes]\n            })\n        instance.data[\"cachesettings\"] = {\"nodes\": nodes}\n        self.log.debug(f\"Found Ornatrix HairFromGuidesNodes: {nodes}\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_ornatrix_rig.html","title":"collect_ornatrix_rig","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_ornatrix_rig.html#client.ayon_maya.plugins.publish.collect_ornatrix_rig.CollectOxRig","title":"<code>CollectOxRig</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect all information of the Ornatrix Rig</p> Source code in <code>client/ayon_maya/plugins/publish/collect_ornatrix_rig.py</code> <pre><code>class CollectOxRig(plugin.MayaInstancePlugin):\n    \"\"\"Collect all information of the Ornatrix Rig\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.4\n    label = \"Collect Ornatrix Rig\"\n    families = [\"oxrig\"]\n\n    def process(self, instance):\n        ornatrix_nodes = cmds.ls(instance.data[\"setMembers\"], long=True)\n        self.log.debug(f\"Getting ornatrix nodes: {ornatrix_nodes}\")\n\n        # Use `set` to avoid duplicate resource data\n        ornatrix_resources = []\n        for node in set(ornatrix_nodes):\n            # Get Yeti resources (textures)\n            resources = self.get_texture_resources(node)\n            ornatrix_resources.extend(resources)\n\n        instance.data[\"resources\"] = ornatrix_resources\n        self.log.debug(\"Collected Ornatrix resources: \"\n                       \"{}\".format(instance.data[\"resources\"]))\n\n    def get_texture_resources(self, node: str) -&gt; List[Dict[str, Any]]:\n        resources = []\n        node_shape = cmds.listRelatives(node, shapes=True)\n        if not node_shape:\n            return []\n\n        ox_nodes = cmds.ls(\n            cmds.listConnections(node_shape, destination=True) or [],\n            type=ORNATRIX_NODES)\n\n        ox_file_nodes = cmds.listConnections(ox_nodes,\n                                             destination=False,\n                                             type=\"file\") or []\n        if not ox_file_nodes:\n            return []\n        for file_node in ox_file_nodes:\n            texture_attr = \"{}.fileTextureName\".format(file_node)\n            texture = cmds.getAttr(\"{}.fileTextureName\".format(file_node))\n            files = []\n            if os.path.isabs(texture):\n                self.log.debug(\"Texture is absolute path, ignoring \"\n                               \"image search paths for: %s\" % texture)\n                files = lib.search_textures(texture)\n            else:\n                root = cmds.workspace(query=True, rootDirectory=True)\n                filepath = os.path.join(root, texture)\n                files = lib.search_textures(filepath)\n                if files:\n                    continue\n\n            if not files:\n                self.log.warning(f\"No texture found for: {texture}\")\n                continue\n\n            item = {\n                \"node\": node,\n                \"files\": files,\n                \"source\": texture,\n                \"texture_attribute\": texture_attr\n            }\n\n            resources.append(item)\n\n        return resources\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_pointcache.html","title":"collect_pointcache","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_pointcache.html#client.ayon_maya.plugins.publish.collect_pointcache.CollectPointcache","title":"<code>CollectPointcache</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect pointcache data for instance.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_pointcache.py</code> <pre><code>class CollectPointcache(plugin.MayaInstancePlugin):\n    \"\"\"Collect pointcache data for instance.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.4\n    families = [\"pointcache\"]\n    label = \"Collect Pointcache\"\n\n    def process(self, instance):\n        proxy_set = None\n        for node in cmds.ls(instance.data[\"setMembers\"],\n                            exactType=\"objectSet\"):\n            # Find proxy_SET objectSet in the instance for proxy meshes\n            if node.endswith(\"proxy_SET\"):\n                members = cmds.sets(node, query=True)\n                if members is None:\n                    self.log.debug(\"Skipped empty proxy_SET: \\\"%s\\\" \" % node)\n                    continue\n                self.log.debug(\"Found proxy set: {}\".format(node))\n\n                proxy_set = node\n                instance.data[\"proxy\"] = []\n                instance.data[\"proxyRoots\"] = []\n                for member in members:\n                    instance.data[\"proxy\"].extend(cmds.ls(member, long=True))\n                    instance.data[\"proxyRoots\"].extend(\n                        cmds.ls(member, long=True)\n                    )\n                    instance.data[\"proxy\"].extend(\n                        cmds.listRelatives(member, shapes=True, fullPath=True)\n                    )\n                self.log.debug(\n                    \"Found proxy members: {}\".format(instance.data[\"proxy\"])\n                )\n                break\n\n        if proxy_set:\n            instance.remove(proxy_set)\n            instance.data[\"setMembers\"].remove(proxy_set)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_pointcache_visible_only.html","title":"collect_pointcache_visible_only","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_pointcache_visible_only.html#client.ayon_maya.plugins.publish.collect_pointcache_visible_only.CollectPointcacheVisibleOnly","title":"<code>CollectPointcacheVisibleOnly</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect pointcache visible only data for instance.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_pointcache_visible_only.py</code> <pre><code>class CollectPointcacheVisibleOnly(plugin.MayaInstancePlugin):\n    \"\"\"Collect pointcache visible only data for instance.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.4\n    families = [\"pointcache\", \"animation\", \"model\", \"vrayproxy.alembic\"]\n    label = \"Collect Pointcache Visible Only\"\n\n    def process(self, instance):\n\n        if instance.data[\"productType\"] == \"animation\":\n            plugin_name = \"ExtractAnimation\"\n        else:\n            plugin_name = \"ExtractAlembic\"\n\n        publish_attributes = instance.data.get(\"publish_attributes\", {})\n        plugin_attr_values = publish_attributes.get(plugin_name, {})\n\n        if \"visibleOnly\" in plugin_attr_values:\n            value = plugin_attr_values[\"visibleOnly\"]\n            instance.data[\"visibleOnly\"] = value\n            self.log.debug(\n                f\"Transferring visibleOnly to instance.data: {value}\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_remove_marked.html","title":"collect_remove_marked","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_remove_marked.html#client.ayon_maya.plugins.publish.collect_remove_marked.CollectRemoveMarked","title":"<code>CollectRemoveMarked</code>","text":"<p>               Bases: <code>MayaContextPlugin</code></p> <p>Remove marked data</p> <p>Remove instances that have 'remove' in their instance.data</p> Source code in <code>client/ayon_maya/plugins/publish/collect_remove_marked.py</code> <pre><code>class CollectRemoveMarked(plugin.MayaContextPlugin):\n    \"\"\"Remove marked data\n\n    Remove instances that have 'remove' in their instance.data\n\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.499\n    label = 'Remove Marked Instances'\n\n    def process(self, context):\n\n        self.log.debug(context)\n        instances_to_remove = []\n        for instance in context:\n            if instance.data.get('remove'):\n                instances_to_remove.append(instance)\n\n        for instance in instances_to_remove:\n            context.remove(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_render.html","title":"collect_render","text":"<p>Collect render data.</p> <p>This collector will go through renderlayer instances and prepare all data needed to detect the expected rendered files for a layer, with resolution, frame ranges and collects the data needed for publishing on the farm.</p> Requires <p>instance    -&gt; families</p> <p>context     -&gt; currentFile context     -&gt; user</p> Provides <p>instance    -&gt; label instance    -&gt; subset instance    -&gt; attachTo instance    -&gt; setMembers instance    -&gt; publish instance    -&gt; frameStart instance    -&gt; frameEnd instance    -&gt; byFrameStep instance    -&gt; renderer instance    -&gt; family instance    -&gt; asset instance    -&gt; time instance    -&gt; author instance    -&gt; source instance    -&gt; expectedFiles instance    -&gt; resolutionWidth instance    -&gt; resolutionHeight instance    -&gt; pixelAspect</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_render.html#client.ayon_maya.plugins.publish.collect_render.CollectMayaRender","title":"<code>CollectMayaRender</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Gather all publishable render layers from renderSetup.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_render.py</code> <pre><code>class CollectMayaRender(plugin.MayaInstancePlugin):\n    \"\"\"Gather all publishable render layers from renderSetup.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.01\n    hosts = [\"maya\"]\n    families = [\"renderlayer\"]\n    label = \"Collect Render Layers\"\n    sync_workfile_version = False\n\n    _aov_chars = {\n        \"dot\": \".\",\n        \"dash\": \"-\",\n        \"underscore\": \"_\"\n    }\n\n    def process(self, instance):\n\n        # TODO: Re-add force enable of workfile instance?\n        # TODO: Re-add legacy layer support with LAYER_ prefix but in Creator\n        context = instance.context\n\n        layer = instance.data[\"transientData\"][\"layer\"]\n        objset = instance.data.get(\"instance_node\")\n        filepath = context.data[\"currentFile\"].replace(\"\\\\\", \"/\")\n\n        # check if layer is renderable\n        if not layer.isRenderable():\n            msg = \"Render layer [ {} ] is not \" \"renderable\".format(\n                layer.name()\n            )\n            self.log.warning(msg)\n\n        # detect if there are sets (products) to attach render to\n        sets = cmds.sets(objset, query=True) or []\n        attach_to = []\n        for s in sets:\n            if not cmds.attributeQuery(\"productType\", node=s, exists=True):\n                continue\n\n            attach_to.append(\n                {\n                    \"version\": None,  # we need integrator for that\n                    \"productName\": s,\n                    \"productType\": cmds.getAttr(\"{}.productType\".format(s)),\n                }\n            )\n            self.log.debug(\" -&gt; attach render to: {}\".format(s))\n\n        layer_name = layer.name()\n\n        # collect all frames we are expecting to be rendered\n        # return all expected files for all cameras and aovs in given\n        # frame range\n        try:\n            layer_render_products = get_layer_render_products(layer.name())\n        except UnsupportedRendererException as exc:\n            raise KnownPublishError(exc)\n        render_products = layer_render_products.layer_data.products\n        if not render_products:\n            self.log.error(\n                \"No render products generated for '%s'. You might not have \"\n                \"any render camera in the renderlayer or render end frame is \"\n                \"lower than start frame.\",\n                instance.name\n            )\n        expected_files = []\n        multipart = False\n        for product in render_products:\n            self.log.debug(f\"Getting render product: {product}\")\n            if product.multipart:\n                multipart = True\n            product_name = product.productName\n            if product.camera and layer_render_products.has_camera_token():\n                product_name = \"{}{}\".format(\n                    product.camera,\n                    \"_{}\".format(product_name) if product_name else \"\")\n            expected_files.append(\n                {\n                    product_name: layer_render_products.get_files(\n                        product)\n                })\n\n        has_cameras = any(product.camera for product in render_products)\n        if render_products and not has_cameras:\n            self.log.error(\n                \"No render cameras found for: %s\",\n                instance\n            )\n        if not expected_files:\n            self.log.warning(\n                \"No file names were generated, this is a bug.\")\n\n        for render_product in render_products:\n            self.log.debug(render_product)\n        self.log.debug(\"multipart: {}\".format(multipart))\n        self.log.debug(\"expected files: {}\".format(\n            json.dumps(expected_files, indent=4, sort_keys=True)\n        ))\n\n        # if we want to attach render to product, check if we have AOV's\n        # in expectedFiles. If so, raise error as we cannot attach AOV\n        # (considered to be product on its own) to another product\n        if attach_to:\n            assert isinstance(expected_files, list), (\n                \"attaching multiple AOVs or renderable cameras to \"\n                \"product is not supported\"\n            )\n\n        # append full path\n        image_directory = os.path.join(\n            cmds.workspace(query=True, rootDirectory=True),\n            cmds.workspace(fileRuleEntry=\"images\")\n        )\n        # replace relative paths with absolute. Render products are\n        # returned as list of dictionaries.\n        publish_meta_path = \"NOT-SET\"\n        aov_dict = {}\n        for aov in expected_files:\n            full_paths = []\n            aov_first_key = list(aov.keys())[0]\n            for file in aov[aov_first_key]:\n                full_path = os.path.join(image_directory, file)\n                full_path = full_path.replace(\"\\\\\", \"/\")\n                full_paths.append(full_path)\n                publish_meta_path = os.path.dirname(full_path)\n            aov_dict[aov_first_key] = full_paths\n        full_exp_files = [aov_dict]\n\n        frame_start_render = int(self.get_render_attribute(\n            \"startFrame\", layer=layer_name))\n        frame_end_render = int(self.get_render_attribute(\n            \"endFrame\", layer=layer_name))\n\n        if (int(context.data[\"frameStartHandle\"]) == frame_start_render\n                and int(context.data[\"frameEndHandle\"]) == frame_end_render):  # noqa: W503, E501\n\n            handle_start = context.data[\"handleStart\"]\n            handle_end = context.data[\"handleEnd\"]\n            frame_start = context.data[\"frameStart\"]\n            frame_end = context.data[\"frameEnd\"]\n            frame_start_handle = context.data[\"frameStartHandle\"]\n            frame_end_handle = context.data[\"frameEndHandle\"]\n        else:\n            handle_start = 0\n            handle_end = 0\n            frame_start = frame_start_render\n            frame_end = frame_end_render\n            frame_start_handle = frame_start_render\n            frame_end_handle = frame_end_render\n\n        # find common path to store metadata\n        # so if image prefix is branching to many directories\n        # metadata file will be located in top-most common\n        # directory.\n        # TODO: use `os.path.commonpath()` after switch to Python 3\n        publish_meta_path = os.path.normpath(publish_meta_path)\n        common_publish_meta_path = os.path.splitdrive(\n            publish_meta_path)[0]\n        if common_publish_meta_path:\n            common_publish_meta_path += os.path.sep\n        for part in publish_meta_path.replace(\n                common_publish_meta_path, \"\").split(os.path.sep):\n            common_publish_meta_path = os.path.join(\n                common_publish_meta_path, part)\n            if part == layer_name:\n                break\n\n        # TODO: replace this terrible linux hotfix with real solution :)\n        if platform.system().lower() in [\"linux\", \"darwin\"]:\n            common_publish_meta_path = \"/\" + common_publish_meta_path\n\n        self.log.debug(\n            \"Publish meta path: {}\".format(common_publish_meta_path)\n        )\n\n        # Get layer specific settings, might be overrides\n        colorspace_data = lib.get_color_management_preferences()\n        data = {\n            \"farm\": True,\n            \"attachTo\": attach_to,\n\n            \"multipartExr\": multipart,\n            \"review\": instance.data.get(\"review\") or False,\n\n            # Frame range\n            \"handleStart\": handle_start,\n            \"handleEnd\": handle_end,\n            \"frameStart\": frame_start,\n            \"frameEnd\": frame_end,\n            \"frameStartHandle\": frame_start_handle,\n            \"frameEndHandle\": frame_end_handle,\n            \"byFrameStep\": int(\n                self.get_render_attribute(\"byFrameStep\",\n                                          layer=layer_name)),\n\n            # Renderlayer\n            \"renderer\": self.get_render_attribute(\n                \"currentRenderer\", layer=layer_name).lower(),\n            \"setMembers\": layer._getLegacyNodeName(),  # legacy renderlayer\n            \"renderlayer\": layer_name,\n\n            # todo: is `time` and `author` still needed?\n            \"time\": get_formatted_current_time(),\n            \"author\": context.data[\"user\"],\n\n            # Add source to allow tracing back to the scene from\n            # which was submitted originally\n            \"source\": filepath,\n            \"expectedFiles\": full_exp_files,\n            \"publishRenderMetadataFolder\": common_publish_meta_path,\n            \"renderProducts\": layer_render_products,\n            \"resolutionWidth\": lib.get_attr_in_layer(\n                \"defaultResolution.width\", layer=layer_name\n            ),\n            \"resolutionHeight\": lib.get_attr_in_layer(\n                \"defaultResolution.height\", layer=layer_name\n            ),\n            \"pixelAspect\": lib.get_attr_in_layer(\n                \"defaultResolution.pixelAspect\", layer=layer_name\n            ),\n\n            # todo: Following are likely not needed due to collecting from the\n            #       instance itself if they are attribute definitions\n            \"tileRendering\": instance.data.get(\"tileRendering\") or False,  # noqa: E501\n            \"tilesX\": instance.data.get(\"tilesX\") or 2,\n            \"tilesY\": instance.data.get(\"tilesY\") or 2,\n            \"convertToScanline\": instance.data.get(\n                \"convertToScanline\") or False,\n            \"useReferencedAovs\": instance.data.get(\n                \"useReferencedAovs\") or instance.data.get(\n                    \"vrayUseReferencedAovs\") or False,\n            \"aovSeparator\": layer_render_products.layer_data.aov_separator,  # noqa: E501\n            \"renderSetupIncludeLights\": instance.data.get(\n                \"renderSetupIncludeLights\"\n            ),\n            \"colorspaceConfig\": colorspace_data[\"config\"],\n            \"colorspaceDisplay\": colorspace_data[\"display\"],\n            \"colorspaceView\": colorspace_data[\"view\"],\n        }\n\n        manager = context.data[\"ayonAddonsManager\"]\n        if manager.get_enabled_addon(\"royalrender\") is not None:\n            data[\"rrPathName\"] = instance.data.get(\"rrPathName\")\n            self.log.debug(data[\"rrPathName\"])\n\n        if self.sync_workfile_version:\n            data[\"version\"] = context.data[\"version\"]\n            for _instance in context:\n                if _instance.data[\"productType\"] == \"workfile\":\n                    _instance.data[\"version\"] = context.data[\"version\"]\n\n        # Define nice label\n        label = \"{0} ({1})\".format(layer_name, instance.data[\"folderPath\"])\n        label += \"  [{0}-{1}]\".format(\n            int(data[\"frameStartHandle\"]), int(data[\"frameEndHandle\"])\n        )\n        data[\"label\"] = label\n\n        # Override frames should be False if extendFrames is False. This is\n        # to ensure it doesn't go off doing crazy unpredictable things\n        extend_frames = instance.data.get(\"extendFrames\", False)\n        if not extend_frames:\n            instance.data[\"overrideExistingFrame\"] = False\n\n        # Update the instance\n        instance.data.update(data)\n\n    @staticmethod\n    def get_render_attribute(attr, layer):\n        \"\"\"Get attribute from render options.\n\n        Args:\n            attr (str): name of attribute to be looked up\n            layer (str): name of render layer\n\n        Returns:\n            Attribute value\n\n        \"\"\"\n        return lib.get_attr_in_layer(\n            \"defaultRenderGlobals.{}\".format(attr), layer=layer\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_render.html#client.ayon_maya.plugins.publish.collect_render.CollectMayaRender.get_render_attribute","title":"<code>get_render_attribute(attr, layer)</code>  <code>staticmethod</code>","text":"<p>Get attribute from render options.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>name of attribute to be looked up</p> required <code>layer</code> <code>str</code> <p>name of render layer</p> required <p>Returns:</p> Type Description <p>Attribute value</p> Source code in <code>client/ayon_maya/plugins/publish/collect_render.py</code> <pre><code>@staticmethod\ndef get_render_attribute(attr, layer):\n    \"\"\"Get attribute from render options.\n\n    Args:\n        attr (str): name of attribute to be looked up\n        layer (str): name of render layer\n\n    Returns:\n        Attribute value\n\n    \"\"\"\n    return lib.get_attr_in_layer(\n        \"defaultRenderGlobals.{}\".format(attr), layer=layer\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_render_layer_aovs.html","title":"collect_render_layer_aovs","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_render_layer_aovs.html#client.ayon_maya.plugins.publish.collect_render_layer_aovs.CollectRenderLayerAOVS","title":"<code>CollectRenderLayerAOVS</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect all render layer's AOVs / Render Elements that will render.</p> <p>This collector is important to be able to Extend Frames.</p> <p>Technical information: Each renderer uses different logic to work with render passes. VRay - RenderElement     Simple node connection to the actual renderLayer node</p> Arnold - AOV <p>Uses its own render settings node and connects an aiOAV to it</p> Redshift - AOV <p>Uses its own render settings node and RedshiftAOV node. It is not connected but all AOVs are enabled for all render layers by default.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_render_layer_aovs.py</code> <pre><code>class CollectRenderLayerAOVS(plugin.MayaInstancePlugin):\n    \"\"\"Collect all render layer's AOVs / Render Elements that will render.\n\n    This collector is important to be able to Extend Frames.\n\n    Technical information:\n    Each renderer uses different logic to work with render passes.\n    VRay - RenderElement\n        Simple node connection to the actual renderLayer node\n\n    Arnold - AOV:\n        Uses its own render settings node and connects an aiOAV to it\n\n    Redshift - AOV:\n        Uses its own render settings node and RedshiftAOV node. It is not\n        connected but all AOVs are enabled for all render layers by default.\n\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.02\n    label = \"Render Elements / AOVs\"\n    families = [\"renderlayer\"]\n\n    def process(self, instance):\n\n        # Check if Extend Frames is toggled\n        if not instance.data(\"extendFrames\", False):\n            return\n\n        # Get renderer\n        renderer = instance.data[\"renderer\"]\n        self.log.debug(\"Renderer found: {}\".format(renderer))\n\n        rp_node_types = {\"vray\": [\"VRayRenderElement\", \"VRayRenderElementSet\"],\n                         \"arnold\": [\"aiAOV\"],\n                         \"redshift\": [\"RedshiftAOV\"]}\n\n        if renderer not in rp_node_types.keys():\n            self.log.error(\"Unsupported renderer found: '{}'\".format(renderer))\n            return\n\n        result = []\n\n        # Collect all AOVs / Render Elements\n        layer = instance.data[\"renderlayer\"]\n        node_type = rp_node_types[renderer]\n        render_elements = cmds.ls(type=node_type)\n\n        # Check if AOVs / Render Elements are enabled\n        for element in render_elements:\n            enabled = lib.get_attr_in_layer(\"{}.enabled\".format(element),\n                                            layer=layer)\n            if not enabled:\n                continue\n\n            pass_name = self.get_pass_name(renderer, element)\n            render_pass = \"%s.%s\" % (instance.data[\"productName\"], pass_name)\n\n            result.append(render_pass)\n\n        self.log.debug(\"Found {} render elements / AOVs for \"\n                       \"'{}'\".format(len(result), instance.data[\"productName\"]))\n\n        instance.data[\"renderPasses\"] = result\n\n    def get_pass_name(self, renderer, node):\n\n        if renderer == \"vray\":\n\n            # Get render element pass type\n            vray_node_attr = next(attr for attr in cmds.listAttr(node)\n                                  if attr.startswith(\"vray_name\"))\n            pass_type = vray_node_attr.rsplit(\"_\", 1)[-1]\n\n            # Support V-Ray extratex explicit name (if set by user)\n            if pass_type == \"extratex\":\n                explicit_attr = \"{}.vray_explicit_name_extratex\".format(node)\n                explicit_name = cmds.getAttr(explicit_attr)\n                if explicit_name:\n                    return explicit_name\n\n            # Node type is in the attribute name but we need to check if value\n            # of the attribute as it can be changed\n            return cmds.getAttr(\"{}.{}\".format(node, vray_node_attr))\n\n        elif renderer in [\"arnold\", \"redshift\"]:\n            return cmds.getAttr(\"{}.name\".format(node))\n        else:\n            raise RuntimeError(\"Unsupported renderer: '{}'\".format(renderer))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_renderable_camera.html","title":"collect_renderable_camera","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_renderable_camera.html#client.ayon_maya.plugins.publish.collect_renderable_camera.CollectRenderableCamera","title":"<code>CollectRenderableCamera</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect the renderable camera(s) for the render layer</p> Source code in <code>client/ayon_maya/plugins/publish/collect_renderable_camera.py</code> <pre><code>class CollectRenderableCamera(plugin.MayaInstancePlugin):\n    \"\"\"Collect the renderable camera(s) for the render layer\"\"\"\n\n    # Offset to be after renderlayer collection.\n    order = pyblish.api.CollectorOrder + 0.02\n    label = \"Collect Renderable Camera(s)\"\n    hosts = [\"maya\"]\n    families = [\"vrayscene_layer\",\n                \"renderlayer\"]\n\n    def process(self, instance):\n        if \"vrayscene_layer\" in instance.data.get(\"families\", []):\n            layer = instance.data.get(\"layer\")\n        else:\n            layer = instance.data[\"renderlayer\"]\n\n        cameras = cmds.ls(type=\"camera\", long=True)\n        renderable = [cam for cam in cameras if\n                      get_attr_in_layer(\"{}.renderable\".format(cam), layer)]\n\n        self.log.debug(\n            \"Found renderable cameras %s: %s\", len(renderable), renderable\n        )\n\n        instance.data[\"cameras\"] = renderable\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_review.html","title":"collect_review","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_review.html#client.ayon_maya.plugins.publish.collect_review.CollectReview","title":"<code>CollectReview</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect Review data</p> Source code in <code>client/ayon_maya/plugins/publish/collect_review.py</code> <pre><code>class CollectReview(plugin.MayaInstancePlugin):\n    \"\"\"Collect Review data\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.3\n    label = 'Collect Review Data'\n    families = [\"review\"]\n\n    def process(self, instance):\n\n        # Get panel.\n        instance.data[\"panel\"] = cmds.playblast(\n            activeEditor=True\n        ).rsplit(\"|\", 1)[-1]\n\n        # get cameras\n        members = instance.data['setMembers']\n        self.log.debug('members: {}'.format(members))\n        cameras = cmds.ls(members, long=True, dag=True, cameras=True)\n        camera = cameras[0] if cameras else None\n\n        context = instance.context\n        objectset = {\n            i.data.get(\"instance_node\") for i in context\n        }\n\n        # Collect display lights.\n        display_lights = instance.data.get(\"displayLights\", \"default\")\n\n        # Collect camera focal length.\n        burninDataMembers = instance.data.get(\"burninDataMembers\", {})\n        if camera is not None:\n            attr = camera + \".focalLength\"\n            if lib.get_attribute_input(attr):\n                start = instance.data[\"frameStart\"]\n                end = instance.data[\"frameEnd\"] + 1\n                time_range = range(int(start), int(end))\n                focal_length = [cmds.getAttr(attr, time=t) for t in time_range]\n            else:\n                focal_length = cmds.getAttr(attr)\n\n            burninDataMembers[\"focalLength\"] = focal_length\n\n        # Account for nested instances like model.\n        reviewable_products = list(set(members) &amp; objectset)\n        if reviewable_products:\n            if len(reviewable_products) &gt; 1:\n                raise KnownPublishError(\n                    \"Multiple attached products for review are not supported. \"\n                    \"Attached: {}\".format(\", \".join(reviewable_products))\n                )\n\n            reviewable_product = reviewable_products[0]\n            self.log.debug(\n                \"Product attached to review: {}\".format(reviewable_product)\n            )\n\n            # Find the relevant publishing instance in the current context\n            reviewable_inst = next(inst for inst in context\n                                   if inst.name == reviewable_product)\n            data = reviewable_inst.data\n\n            self.log.debug(\n                'Adding review family to {}'.format(reviewable_product)\n            )\n            if data.get('families'):\n                data['families'].append('review')\n            else:\n                data['families'] = ['review']\n\n            data[\"cameras\"] = cameras\n            data['review_camera'] = camera\n            data['frameStartFtrack'] = instance.data[\"frameStartHandle\"]\n            data['frameEndFtrack'] = instance.data[\"frameEndHandle\"]\n            data['frameStartHandle'] = instance.data[\"frameStartHandle\"]\n            data['frameEndHandle'] = instance.data[\"frameEndHandle\"]\n            data['handleStart'] = instance.data[\"handleStart\"]\n            data['handleEnd'] = instance.data[\"handleEnd\"]\n            data[\"frameStart\"] = instance.data[\"frameStart\"]\n            data[\"frameEnd\"] = instance.data[\"frameEnd\"]\n            data['step'] = instance.data['step']\n            # this (with other time related data) should be set on\n            # representations. Once plugins like Extract Review start\n            # using representations, this should be removed from here\n            # as Extract Playblast is already adding fps to representation.\n            data['fps'] = context.data['fps']\n            data['review_width'] = instance.data['review_width']\n            data['review_height'] = instance.data['review_height']\n            data[\"isolate\"] = instance.data[\"isolate\"]\n            data[\"panZoom\"] = instance.data.get(\"panZoom\", False)\n            data[\"panel\"] = instance.data[\"panel\"]\n            data[\"displayLights\"] = display_lights\n            data[\"burninDataMembers\"] = burninDataMembers\n\n            for key, value in instance.data[\"publish_attributes\"].items():\n                data[\"publish_attributes\"][key] = value\n\n            instance.data['remove'] = True\n\n        else:\n            project_name = instance.context.data[\"projectName\"]\n            folder_entity = instance.context.data[\"folderEntity\"]\n            task = instance.context.data[\"task\"]\n            legacy_product_name = task + 'Review'\n            product_entity = ayon_api.get_product_by_name(\n                project_name,\n                legacy_product_name,\n                folder_entity[\"id\"],\n                fields={\"id\"}\n            )\n            if product_entity:\n                self.log.debug(\"Existing products found, keep legacy name.\")\n                instance.data[\"productName\"] = legacy_product_name\n\n            instance.data[\"cameras\"] = cameras\n            instance.data['review_camera'] = camera\n            instance.data['frameStartFtrack'] = \\\n                instance.data[\"frameStartHandle\"]\n            instance.data['frameEndFtrack'] = \\\n                instance.data[\"frameEndHandle\"]\n            instance.data[\"displayLights\"] = display_lights\n            instance.data[\"burninDataMembers\"] = burninDataMembers\n            # this (with other time related data) should be set on\n            # representations. Once plugins like Extract Review start\n            # using representations, this should be removed from here\n            # as Extract Playblast is already adding fps to representation.\n            instance.data[\"fps\"] = instance.context.data[\"fps\"]\n\n            # Collect audio\n            playback_slider = mel.eval('$tmpVar=$gPlayBackSlider')\n            audio_name = cmds.timeControl(playback_slider,\n                                          query=True,\n                                          sound=True)\n            display_sounds = cmds.timeControl(\n                playback_slider, query=True, displaySound=True\n            )\n\n            def get_audio_node_data(node):\n                return {\n                    \"offset\": cmds.getAttr(\"{}.offset\".format(node)),\n                    \"filename\": cmds.getAttr(\"{}.filename\".format(node))\n                }\n\n            audio_data = []\n\n            if audio_name:\n                audio_data.append(get_audio_node_data(audio_name))\n\n            elif display_sounds:\n                start_frame = int(cmds.playbackOptions(query=True, min=True))\n                end_frame = int(cmds.playbackOptions(query=True, max=True))\n\n                for node in cmds.ls(type=\"audio\"):\n                    # Check if frame range and audio range intersections,\n                    # for whether to include this audio node or not.\n                    duration = cmds.getAttr(\"{}.duration\".format(node))\n                    start_audio = cmds.getAttr(\"{}.offset\".format(node))\n                    end_audio = start_audio + duration\n\n                    if start_audio &lt;= end_frame and end_audio &gt; start_frame:\n                        audio_data.append(get_audio_node_data(node))\n\n            # Exclude audio data with filenames that can't be found with a\n            # warning to avoid a harder error on e.g. Extract Review\n            valid_audio_data = []\n            for audio in audio_data:\n                if not os.path.exists(audio[\"filename\"]):\n                    self.log.warning(\n                        \"Timeline audio file not found on disk: '{}'. \"\n                        \"Ignoring audio.\".format(audio[\"filename\"])\n                    )\n                    continue\n                valid_audio_data.append(audio)\n            audio_data = valid_audio_data\n\n            instance.data[\"audio\"] = audio_data\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_rig_sets.html","title":"collect_rig_sets","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_rig_sets.html#client.ayon_maya.plugins.publish.collect_rig_sets.CollectRigSets","title":"<code>CollectRigSets</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Ensure rig contains pipeline-critical content</p> Every rig must contain at least two object sets <p>\"controls_SET\" - Set of all animatable controls \"out_SET\" - Set of all cacheable meshes</p> Source code in <code>client/ayon_maya/plugins/publish/collect_rig_sets.py</code> <pre><code>class CollectRigSets(plugin.MayaInstancePlugin):\n    \"\"\"Ensure rig contains pipeline-critical content\n\n    Every rig must contain at least two object sets:\n        \"controls_SET\" - Set of all animatable controls\n        \"out_SET\" - Set of all cacheable meshes\n\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.05\n    label = \"Collect Rig Sets\"\n    families = [\"rig\"]\n\n    accepted_output = [\"mesh\", \"transform\"]\n    accepted_controllers = [\"transform\"]\n\n    def process(self, instance):\n\n        # Find required sets by suffix\n        searching = {\"controls_SET\", \"out_SET\",\n                     \"skeletonAnim_SET\", \"skeletonMesh_SET\"}\n        found = {}\n        for node in cmds.ls(instance, exactType=\"objectSet\"):\n            for suffix in searching:\n                if node.endswith(suffix):\n                    found[suffix] = node\n                    searching.remove(suffix)\n                    break\n            if not searching:\n                break\n\n        self.log.debug(\"Found sets: {}\".format(found))\n        rig_sets = instance.data.setdefault(\"rig_sets\", {})\n        for name, objset in found.items():\n            rig_sets[name] = objset\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_skeleton_mesh.html","title":"collect_skeleton_mesh","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_skeleton_mesh.html#client.ayon_maya.plugins.publish.collect_skeleton_mesh.CollectSkeletonMesh","title":"<code>CollectSkeletonMesh</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect Static Rig Data for FBX Extractor.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_skeleton_mesh.py</code> <pre><code>class CollectSkeletonMesh(plugin.MayaInstancePlugin):\n    \"\"\"Collect Static Rig Data for FBX Extractor.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.2\n    label = \"Collect Skeleton Mesh\"\n    families = [\"rig\"]\n\n    def process(self, instance):\n        skeleton_mesh_set = instance.data[\"rig_sets\"].get(\n            \"skeletonMesh_SET\")\n        if not skeleton_mesh_set:\n            self.log.debug(\n                \"No skeletonMesh_SET found. \"\n                \"Skipping collecting of skeleton mesh...\"\n            )\n            return\n\n        # Store current frame to ensure single frame export\n        frame = cmds.currentTime(query=True)\n        instance.data[\"frameStart\"] = frame\n        instance.data[\"frameEnd\"] = frame\n\n        instance.data[\"skeleton_mesh\"] = []\n\n        skeleton_mesh_content = cmds.sets(\n            skeleton_mesh_set, query=True) or []\n        if not skeleton_mesh_content:\n            self.log.debug(\n                \"No object nodes in skeletonMesh_SET. \"\n                \"Skipping collecting of skeleton mesh...\"\n            )\n            return\n        instance.data[\"families\"] += [\"rig.fbx\"]\n        instance.data[\"skeleton_mesh\"] = skeleton_mesh_content\n        self.log.debug(\n            \"Collected skeletonMesh_SET members: {}\".format(\n                skeleton_mesh_content\n            ))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_unreal_skeletalmesh.html","title":"collect_unreal_skeletalmesh","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_unreal_skeletalmesh.html#client.ayon_maya.plugins.publish.collect_unreal_skeletalmesh.CollectUnrealSkeletalMesh","title":"<code>CollectUnrealSkeletalMesh</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect Unreal Skeletal Mesh.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_unreal_skeletalmesh.py</code> <pre><code>class CollectUnrealSkeletalMesh(plugin.MayaInstancePlugin):\n    \"\"\"Collect Unreal Skeletal Mesh.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.2\n    label = \"Collect Unreal Skeletal Meshes\"\n    families = [\"skeletalMesh\"]\n\n    def process(self, instance):\n        frame = cmds.currentTime(query=True)\n        instance.data[\"frameStart\"] = frame\n        instance.data[\"frameEnd\"] = frame\n\n        geo_sets = [\n            i for i in instance[:]\n            if i.lower().startswith(\"geometry_set\")\n        ]\n\n        joint_sets = [\n            i for i in instance[:]\n            if i.lower().startswith(\"joints_set\")\n        ]\n\n        instance.data[\"geometry\"] = []\n        instance.data[\"joints\"] = []\n\n        for geo_set in geo_sets:\n            geo_content = cmds.ls(cmds.sets(geo_set, query=True), long=True)\n            if geo_content:\n                instance.data[\"geometry\"] += geo_content\n\n        for join_set in joint_sets:\n            join_content = cmds.ls(cmds.sets(join_set, query=True), long=True)\n            if join_content:\n                instance.data[\"joints\"] += join_content\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_unreal_staticmesh.html","title":"collect_unreal_staticmesh","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_unreal_staticmesh.html#client.ayon_maya.plugins.publish.collect_unreal_staticmesh.CollectUnrealStaticMesh","title":"<code>CollectUnrealStaticMesh</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect Unreal Static Mesh.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_unreal_staticmesh.py</code> <pre><code>class CollectUnrealStaticMesh(plugin.MayaInstancePlugin):\n    \"\"\"Collect Unreal Static Mesh.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.2\n    label = \"Collect Unreal Static Meshes\"\n    families = [\"staticMesh\"]\n\n    def process(self, instance):\n        geometry_set = [\n            i for i in instance\n            if i.startswith(\"geometry_SET\")\n        ]\n        instance.data[\"geometryMembers\"] = cmds.sets(\n            geometry_set, query=True)\n\n        self.log.debug(\"geometry: {}\".format(\n            pformat(instance.data.get(\"geometryMembers\"))))\n\n        collision_set = [\n            i for i in instance\n            if i.startswith(\"collisions_SET\")\n        ]\n        instance.data[\"collisionMembers\"] = cmds.sets(\n            collision_set, query=True)\n\n        self.log.debug(\"collisions: {}\".format(\n            pformat(instance.data.get(\"collisionMembers\"))))\n\n        frame = cmds.currentTime(query=True)\n        instance.data[\"frameStart\"] = frame\n        instance.data[\"frameEnd\"] = frame\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_user_defined_attributes.html","title":"collect_user_defined_attributes","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_user_defined_attributes.html#client.ayon_maya.plugins.publish.collect_user_defined_attributes.CollectUserDefinedAttributes","title":"<code>CollectUserDefinedAttributes</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect user defined attributes for nodes in instance.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_user_defined_attributes.py</code> <pre><code>class CollectUserDefinedAttributes(plugin.MayaInstancePlugin):\n    \"\"\"Collect user defined attributes for nodes in instance.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.45\n    families = [\"pointcache\", \"animation\", \"usd\"]\n    label = \"Collect User Defined Attributes\"\n\n    def process(self, instance):\n\n        # Collect user defined attributes.\n        if not instance.data.get(\"creator_attributes\", {}).get(\n            \"includeUserDefinedAttributes\"\n        ):\n            return\n\n        if \"out_hierarchy\" in instance.data:\n            # animation family\n            nodes = instance.data[\"out_hierarchy\"]\n        else:\n            nodes = instance[:]\n        if not nodes:\n            return\n\n        shapes = cmds.listRelatives(nodes, shapes=True, fullPath=True) or []\n        nodes = set(nodes).union(shapes)\n\n        attrs = cmds.listAttr(list(nodes), userDefined=True) or []\n        user_defined_attributes = list(sorted(set(attrs)))\n        instance.data[\"userDefinedAttributes\"] = user_defined_attributes\n\n        self.log.debug(\n            \"Collected user defined attributes: {}\".format(\n                \", \".join(user_defined_attributes)\n            )\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_vrayproxy.html","title":"collect_vrayproxy","text":"<p>Collect Vray Proxy.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_vrayproxy.html#client.ayon_maya.plugins.publish.collect_vrayproxy.CollectVrayProxy","title":"<code>CollectVrayProxy</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect Vray Proxy instance.</p> <p>Add <code>pointcache</code> family for it.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_vrayproxy.py</code> <pre><code>class CollectVrayProxy(plugin.MayaInstancePlugin):\n    \"\"\"Collect Vray Proxy instance.\n\n    Add `pointcache` family for it.\n    \"\"\"\n    order = pyblish.api.CollectorOrder + 0.01\n    label = \"Collect Vray Proxy\"\n    families = [\"vrayproxy\"]\n\n    def process(self, instance):\n        \"\"\"Collector entry point.\"\"\"\n        if not instance.data.get(\"families\"):\n            instance.data[\"families\"] = []\n\n        if instance.data.get(\"vrmesh\"):\n            instance.data[\"families\"].append(\"vrayproxy.vrmesh\")\n\n        if instance.data.get(\"alembic\"):\n            instance.data[\"families\"].append(\"vrayproxy.alembic\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_vrayproxy.html#client.ayon_maya.plugins.publish.collect_vrayproxy.CollectVrayProxy.process","title":"<code>process(instance)</code>","text":"<p>Collector entry point.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_vrayproxy.py</code> <pre><code>def process(self, instance):\n    \"\"\"Collector entry point.\"\"\"\n    if not instance.data.get(\"families\"):\n        instance.data[\"families\"] = []\n\n    if instance.data.get(\"vrmesh\"):\n        instance.data[\"families\"].append(\"vrayproxy.vrmesh\")\n\n    if instance.data.get(\"alembic\"):\n        instance.data[\"families\"].append(\"vrayproxy.alembic\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_vrayscene.html","title":"collect_vrayscene","text":"<p>Collect Vray Scene and prepare it for extraction and publishing.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_vrayscene.html#client.ayon_maya.plugins.publish.collect_vrayscene.CollectVrayScene","title":"<code>CollectVrayScene</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect Vray Scene.</p> <p>If export on farm is checked, job is created to export it.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_vrayscene.py</code> <pre><code>class CollectVrayScene(plugin.MayaInstancePlugin):\n    \"\"\"Collect Vray Scene.\n\n    If export on farm is checked, job is created to export it.\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.01\n    label = \"Collect Vray Scene\"\n    families = [\"vrayscene\"]\n\n    def process(self, instance):\n        \"\"\"Collector entry point.\"\"\"\n\n        context = instance.context\n\n        layer = instance.data[\"transientData\"][\"layer\"]\n        layer_name = layer.name()\n\n        renderer = self.get_render_attribute(\"currentRenderer\",\n                                             layer=layer_name)\n        if renderer != \"vray\":\n            self.log.warning(\"Layer '{}' renderer is not set to V-Ray\".format(\n                layer_name\n            ))\n\n        # collect all frames we are expecting to be rendered\n        frame_start_render = int(self.get_render_attribute(\n            \"startFrame\", layer=layer_name))\n        frame_end_render = int(self.get_render_attribute(\n            \"endFrame\", layer=layer_name))\n\n        if (int(context.data['frameStartHandle']) == frame_start_render\n                and int(context.data['frameEndHandle']) == frame_end_render):  # noqa: W503, E501\n\n            handle_start = context.data['handleStart']\n            handle_end = context.data['handleEnd']\n            frame_start = context.data['frameStart']\n            frame_end = context.data['frameEnd']\n            frame_start_handle = context.data['frameStartHandle']\n            frame_end_handle = context.data['frameEndHandle']\n        else:\n            handle_start = 0\n            handle_end = 0\n            frame_start = frame_start_render\n            frame_end = frame_end_render\n            frame_start_handle = frame_start_render\n            frame_end_handle = frame_end_render\n\n        # Get layer specific settings, might be overrides\n        product_type = \"vrayscene_layer\"\n        data = {\n            \"productName\": layer_name,\n            \"layer\": layer_name,\n            # TODO: This likely needs fixing now\n            # Before refactor: cmds.sets(layer, q=True) or [\"*\"]\n            \"setMembers\": [\"*\"],\n            \"review\": False,\n            \"publish\": True,\n            \"handleStart\": handle_start,\n            \"handleEnd\": handle_end,\n            \"frameStart\": frame_start,\n            \"frameEnd\": frame_end,\n            \"frameStartHandle\": frame_start_handle,\n            \"frameEndHandle\": frame_end_handle,\n            \"byFrameStep\": int(\n                self.get_render_attribute(\"byFrameStep\",\n                                          layer=layer_name)),\n            \"renderer\": renderer,\n            # instance product type\n            \"productType\": product_type,\n            \"family\": product_type,\n            \"families\": [product_type],\n            \"time\": get_formatted_current_time(),\n            \"author\": context.data[\"user\"],\n            # Add source to allow tracing back to the scene from\n            # which was submitted originally\n            \"source\": context.data[\"currentFile\"].replace(\"\\\\\", \"/\"),\n            \"resolutionWidth\": lib.get_attr_in_layer(\n                \"defaultResolution.height\", layer=layer_name\n            ),\n            \"resolutionHeight\": lib.get_attr_in_layer(\n                \"defaultResolution.width\", layer=layer_name\n            ),\n            \"pixelAspect\": lib.get_attr_in_layer(\n                \"defaultResolution.pixelAspect\", layer=layer_name\n            ),\n            \"priority\": instance.data.get(\"priority\"),\n            \"useMultipleSceneFiles\": instance.data.get(\n                \"vraySceneMultipleFiles\")\n        }\n\n        instance.data.update(data)\n\n        # Define nice label\n        label = \"{0} ({1})\".format(layer_name, instance.data[\"folderPath\"])\n        label += \"  [{0}-{1}]\".format(\n            int(data[\"frameStartHandle\"]), int(data[\"frameEndHandle\"])\n        )\n        instance.data[\"label\"] = label\n\n    def get_render_attribute(self, attr, layer):\n        \"\"\"Get attribute from render options.\n\n        Args:\n            attr (str): name of attribute to be looked up.\n\n        Returns:\n            Attribute value\n\n        \"\"\"\n        return lib.get_attr_in_layer(\n            \"defaultRenderGlobals.{}\".format(attr), layer=layer\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_vrayscene.html#client.ayon_maya.plugins.publish.collect_vrayscene.CollectVrayScene.get_render_attribute","title":"<code>get_render_attribute(attr, layer)</code>","text":"<p>Get attribute from render options.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>name of attribute to be looked up.</p> required <p>Returns:</p> Type Description <p>Attribute value</p> Source code in <code>client/ayon_maya/plugins/publish/collect_vrayscene.py</code> <pre><code>def get_render_attribute(self, attr, layer):\n    \"\"\"Get attribute from render options.\n\n    Args:\n        attr (str): name of attribute to be looked up.\n\n    Returns:\n        Attribute value\n\n    \"\"\"\n    return lib.get_attr_in_layer(\n        \"defaultRenderGlobals.{}\".format(attr), layer=layer\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_vrayscene.html#client.ayon_maya.plugins.publish.collect_vrayscene.CollectVrayScene.process","title":"<code>process(instance)</code>","text":"<p>Collector entry point.</p> Source code in <code>client/ayon_maya/plugins/publish/collect_vrayscene.py</code> <pre><code>def process(self, instance):\n    \"\"\"Collector entry point.\"\"\"\n\n    context = instance.context\n\n    layer = instance.data[\"transientData\"][\"layer\"]\n    layer_name = layer.name()\n\n    renderer = self.get_render_attribute(\"currentRenderer\",\n                                         layer=layer_name)\n    if renderer != \"vray\":\n        self.log.warning(\"Layer '{}' renderer is not set to V-Ray\".format(\n            layer_name\n        ))\n\n    # collect all frames we are expecting to be rendered\n    frame_start_render = int(self.get_render_attribute(\n        \"startFrame\", layer=layer_name))\n    frame_end_render = int(self.get_render_attribute(\n        \"endFrame\", layer=layer_name))\n\n    if (int(context.data['frameStartHandle']) == frame_start_render\n            and int(context.data['frameEndHandle']) == frame_end_render):  # noqa: W503, E501\n\n        handle_start = context.data['handleStart']\n        handle_end = context.data['handleEnd']\n        frame_start = context.data['frameStart']\n        frame_end = context.data['frameEnd']\n        frame_start_handle = context.data['frameStartHandle']\n        frame_end_handle = context.data['frameEndHandle']\n    else:\n        handle_start = 0\n        handle_end = 0\n        frame_start = frame_start_render\n        frame_end = frame_end_render\n        frame_start_handle = frame_start_render\n        frame_end_handle = frame_end_render\n\n    # Get layer specific settings, might be overrides\n    product_type = \"vrayscene_layer\"\n    data = {\n        \"productName\": layer_name,\n        \"layer\": layer_name,\n        # TODO: This likely needs fixing now\n        # Before refactor: cmds.sets(layer, q=True) or [\"*\"]\n        \"setMembers\": [\"*\"],\n        \"review\": False,\n        \"publish\": True,\n        \"handleStart\": handle_start,\n        \"handleEnd\": handle_end,\n        \"frameStart\": frame_start,\n        \"frameEnd\": frame_end,\n        \"frameStartHandle\": frame_start_handle,\n        \"frameEndHandle\": frame_end_handle,\n        \"byFrameStep\": int(\n            self.get_render_attribute(\"byFrameStep\",\n                                      layer=layer_name)),\n        \"renderer\": renderer,\n        # instance product type\n        \"productType\": product_type,\n        \"family\": product_type,\n        \"families\": [product_type],\n        \"time\": get_formatted_current_time(),\n        \"author\": context.data[\"user\"],\n        # Add source to allow tracing back to the scene from\n        # which was submitted originally\n        \"source\": context.data[\"currentFile\"].replace(\"\\\\\", \"/\"),\n        \"resolutionWidth\": lib.get_attr_in_layer(\n            \"defaultResolution.height\", layer=layer_name\n        ),\n        \"resolutionHeight\": lib.get_attr_in_layer(\n            \"defaultResolution.width\", layer=layer_name\n        ),\n        \"pixelAspect\": lib.get_attr_in_layer(\n            \"defaultResolution.pixelAspect\", layer=layer_name\n        ),\n        \"priority\": instance.data.get(\"priority\"),\n        \"useMultipleSceneFiles\": instance.data.get(\n            \"vraySceneMultipleFiles\")\n    }\n\n    instance.data.update(data)\n\n    # Define nice label\n    label = \"{0} ({1})\".format(layer_name, instance.data[\"folderPath\"])\n    label += \"  [{0}-{1}]\".format(\n        int(data[\"frameStartHandle\"]), int(data[\"frameEndHandle\"])\n    )\n    instance.data[\"label\"] = label\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_workfile.html","title":"collect_workfile","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_workfile.html#client.ayon_maya.plugins.publish.collect_workfile.CollectWorkfileData","title":"<code>CollectWorkfileData</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Inject data into Workfile instance</p> Source code in <code>client/ayon_maya/plugins/publish/collect_workfile.py</code> <pre><code>class CollectWorkfileData(plugin.MayaInstancePlugin):\n    \"\"\"Inject data into Workfile instance\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.01\n    label = \"Maya Workfile\"\n    families = [\"workfile\"]\n\n    def process(self, instance):\n        \"\"\"Inject the current working file\"\"\"\n\n        context = instance.context\n        current_file = instance.context.data['currentFile']\n        folder, file = os.path.split(current_file)\n        filename, ext = os.path.splitext(file)\n\n        data = {  # noqa\n            \"setMembers\": [current_file],\n            \"frameStart\": context.data['frameStart'],\n            \"frameEnd\": context.data['frameEnd'],\n            \"handleStart\": context.data['handleStart'],\n            \"handleEnd\": context.data['handleEnd']\n        }\n\n        data['representations'] = [{\n            'name': ext.lstrip(\".\"),\n            'ext': ext.lstrip(\".\"),\n            'files': file,\n            \"stagingDir\": folder,\n        }]\n\n        instance.data.update(data)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_workfile.html#client.ayon_maya.plugins.publish.collect_workfile.CollectWorkfileData.process","title":"<code>process(instance)</code>","text":"<p>Inject the current working file</p> Source code in <code>client/ayon_maya/plugins/publish/collect_workfile.py</code> <pre><code>def process(self, instance):\n    \"\"\"Inject the current working file\"\"\"\n\n    context = instance.context\n    current_file = instance.context.data['currentFile']\n    folder, file = os.path.split(current_file)\n    filename, ext = os.path.splitext(file)\n\n    data = {  # noqa\n        \"setMembers\": [current_file],\n        \"frameStart\": context.data['frameStart'],\n        \"frameEnd\": context.data['frameEnd'],\n        \"handleStart\": context.data['handleStart'],\n        \"handleEnd\": context.data['handleEnd']\n    }\n\n    data['representations'] = [{\n        'name': ext.lstrip(\".\"),\n        'ext': ext.lstrip(\".\"),\n        'files': file,\n        \"stagingDir\": folder,\n    }]\n\n    instance.data.update(data)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_workscene_fps.html","title":"collect_workscene_fps","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_workscene_fps.html#client.ayon_maya.plugins.publish.collect_workscene_fps.CollectWorksceneFPS","title":"<code>CollectWorksceneFPS</code>","text":"<p>               Bases: <code>MayaContextPlugin</code></p> <p>Get the FPS of the work scene</p> Source code in <code>client/ayon_maya/plugins/publish/collect_workscene_fps.py</code> <pre><code>class CollectWorksceneFPS(plugin.MayaContextPlugin):\n    \"\"\"Get the FPS of the work scene\"\"\"\n\n    label = \"Workscene FPS\"\n    order = pyblish.api.CollectorOrder\n\n    def process(self, context):\n        fps = mel.eval('currentTimeUnitToFPS()')\n        self.log.info(\"Workscene FPS: %s\" % fps)\n        context.data.update({\"fps\": fps})\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_xgen.html","title":"collect_xgen","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_xgen.html#client.ayon_maya.plugins.publish.collect_xgen.CollectXgen","title":"<code>CollectXgen</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect Xgen</p> Source code in <code>client/ayon_maya/plugins/publish/collect_xgen.py</code> <pre><code>class CollectXgen(plugin.MayaInstancePlugin):\n    \"\"\"Collect Xgen\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.499999\n    label = \"Collect Xgen\"\n    families = [\"xgen\"]\n\n    def process(self, instance):\n        data = {\n            \"xgmPalettes\": cmds.ls(instance, type=\"xgmPalette\", long=True),\n            \"xgmDescriptions\": cmds.ls(\n                instance, type=\"xgmDescription\", long=True\n            ),\n            \"xgmSubdPatches\": cmds.ls(instance, type=\"xgmSubdPatch\", long=True)\n        }\n        data[\"xgenNodes\"] = (\n            data[\"xgmPalettes\"] +\n            data[\"xgmDescriptions\"] +\n            data[\"xgmSubdPatches\"]\n        )\n\n        if data[\"xgmPalettes\"]:\n            data[\"xgmPalette\"] = data[\"xgmPalettes\"][0]\n\n        data[\"xgenConnections\"] = set()\n        for node in data[\"xgmSubdPatches\"]:\n            connected_transform = get_attribute_input(\n                node + \".transform\"\n            ).split(\".\")[0]\n            data[\"xgenConnections\"].add(connected_transform)\n\n        # Collect all files under palette root as resources.\n        import xgenm\n\n        data_path = xgenm.getAttr(\n            \"xgDataPath\", data[\"xgmPalette\"].replace(\"|\", \"\")\n        ).split(os.pathsep)[0]\n        data_path = data_path.replace(\n            \"${PROJECT}\",\n            xgenm.getAttr(\"xgProjectPath\", data[\"xgmPalette\"].replace(\"|\", \"\"))\n        )\n        transfers = []\n\n        # Since we are duplicating this palette when extracting we predict that\n        # the name will be the basename without namespaces.\n        predicted_palette_name = data[\"xgmPalette\"].split(\":\")[-1]\n        predicted_palette_name = predicted_palette_name.replace(\"|\", \"\")\n\n        for root, _, files in os.walk(data_path):\n            for file in files:\n                source = os.path.join(root, file).replace(\"\\\\\", \"/\")\n                destination = os.path.join(\n                    instance.data[\"resourcesDir\"],\n                    \"collections\",\n                    predicted_palette_name,\n                    source.replace(data_path, \"\")[1:]\n                )\n                transfers.append((source, destination.replace(\"\\\\\", \"/\")))\n\n        data[\"transfers\"] = transfers\n\n        self.log.debug(data)\n        instance.data.update(data)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_yeti_cache.html","title":"collect_yeti_cache","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_yeti_cache.html#client.ayon_maya.plugins.publish.collect_yeti_cache.CollectYetiCache","title":"<code>CollectYetiCache</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect all information of the Yeti caches</p> <p>The information contains the following attributes per Yeti node</p> <ul> <li>\"renderDensity\"</li> <li>\"renderWidth\"</li> <li>\"renderLength\"</li> <li>\"increaseRenderBounds\"</li> <li>\"imageSearchPath\"</li> </ul> <p>Other information is the name of the transform and its <code>cbId</code></p> Source code in <code>client/ayon_maya/plugins/publish/collect_yeti_cache.py</code> <pre><code>class CollectYetiCache(plugin.MayaInstancePlugin):\n    \"\"\"Collect all information of the Yeti caches\n\n    The information contains the following attributes per Yeti node\n\n    - \"renderDensity\"\n    - \"renderWidth\"\n    - \"renderLength\"\n    - \"increaseRenderBounds\"\n    - \"imageSearchPath\"\n\n    Other information is the name of the transform and its `cbId`\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.45\n    label = \"Collect Yeti Cache\"\n    families = [\"yetiRig\", \"yeticache\", \"yeticacheUE\"]\n\n    def process(self, instance):\n\n        # Collect fur settings\n        settings = {\"nodes\": []}\n\n        # Get yeti nodes and their transforms\n        yeti_shapes = cmds.ls(instance, type=\"pgYetiMaya\")\n        for shape in yeti_shapes:\n\n            # Get specific node attributes\n            attr_data = {}\n            for attr in SETTINGS:\n                # Ignore non-existing attributes with a warning, e.g. cbId\n                # if they have not been generated yet\n                if not cmds.attributeQuery(attr, node=shape, exists=True):\n                    self.log.warning(\n                        \"Attribute '{}' not found on Yeti node: {}\".format(\n                            attr, shape\n                        )\n                    )\n                    continue\n\n                current = cmds.getAttr(\"%s.%s\" % (shape, attr))\n                # change None to empty string as Maya doesn't support\n                # NoneType in attributes\n                if current is None:\n                    current = \"\"\n                attr_data[attr] = current\n\n            # Get user variable attributes\n            user_variable_attrs = {\n                attr: lib.get_attribute(\"{}.{}\".format(shape, attr))\n                for attr in get_yeti_user_variables(shape)\n            }\n\n            # Get transform data\n            parent = cmds.listRelatives(shape, parent=True)[0]\n            transform_data = {\"name\": parent, \"cbId\": lib.get_id(parent)}\n\n            shape_data = {\n                \"transform\": transform_data,\n                \"name\": shape,\n                \"cbId\": lib.get_id(shape),\n                \"attrs\": attr_data,\n                \"user_variables\": user_variable_attrs\n            }\n\n            settings[\"nodes\"].append(shape_data)\n\n        instance.data[\"fursettings\"] = settings\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_yeti_rig.html","title":"collect_yeti_rig","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_yeti_rig.html#client.ayon_maya.plugins.publish.collect_yeti_rig.CollectYetiRig","title":"<code>CollectYetiRig</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Collect all information of the Yeti Rig</p> Source code in <code>client/ayon_maya/plugins/publish/collect_yeti_rig.py</code> <pre><code>class CollectYetiRig(plugin.MayaInstancePlugin):\n    \"\"\"Collect all information of the Yeti Rig\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.4\n    label = \"Collect Yeti Rig\"\n    families = [\"yetiRig\"]\n\n    def process(self, instance):\n\n        assert \"input_SET\" in instance.data[\"setMembers\"], (\n            \"Yeti Rig must have an input_SET\")\n\n        input_connections = self.collect_input_connections(instance)\n\n        # Collect any textures if used\n        yeti_resources = []\n        yeti_nodes = cmds.ls(instance[:], type=\"pgYetiMaya\", long=True)\n        for node in yeti_nodes:\n            # Get Yeti resources (textures)\n            resources = self.get_yeti_resources(node)\n            yeti_resources.extend(resources)\n\n        instance.data[\"rigsettings\"] = {\"inputs\": input_connections}\n\n        instance.data[\"resources\"] = yeti_resources\n\n        # Force frame range for yeti cache export for the rig\n        start = cmds.playbackOptions(query=True, animationStartTime=True)\n        for key in [\"frameStart\", \"frameEnd\",\n                    \"frameStartHandle\", \"frameEndHandle\"]:\n            instance.data[key] = start\n        instance.data[\"preroll\"] = 0\n\n    def collect_input_connections(self, instance):\n        \"\"\"Collect the inputs for all nodes in the input_SET\"\"\"\n\n        # Get the input meshes information\n        input_content = cmds.ls(cmds.sets(\"input_SET\", query=True), long=True)\n\n        # Include children\n        input_content += cmds.listRelatives(input_content,\n                                            allDescendents=True,\n                                            fullPath=True) or []\n\n        # Ignore intermediate objects\n        input_content = cmds.ls(input_content, long=True, noIntermediate=True)\n        if not input_content:\n            return []\n\n        # Store all connections\n        connections = cmds.listConnections(input_content,\n                                           source=True,\n                                           destination=False,\n                                           connections=True,\n                                           # Only allow inputs from dagNodes\n                                           # (avoid display layers, etc.)\n                                           type=\"dagNode\",\n                                           plugs=True) or []\n        connections = cmds.ls(connections, long=True)      # Ensure long names\n\n        inputs = []\n        for dest, src in lib.pairwise(connections):\n            source_node, source_attr = src.split(\".\", 1)\n            dest_node, dest_attr = dest.split(\".\", 1)\n\n            # Ensure the source of the connection is not included in the\n            # current instance's hierarchy. If so, we ignore that connection\n            # as we will want to preserve it even over a publish.\n            if source_node in instance:\n                self.log.debug(\"Ignoring input connection between nodes \"\n                               \"inside the instance: %s -&gt; %s\" % (src, dest))\n                continue\n\n            inputs.append({\"connections\": [source_attr, dest_attr],\n                           \"sourceID\": lib.get_id(source_node),\n                           \"destinationID\": lib.get_id(dest_node)})\n\n        return inputs\n\n    def get_yeti_resources(self, node):\n        \"\"\"Get all resource file paths\n\n        If a texture is a sequence it gathers all sibling files to ensure\n        the texture sequence is complete.\n\n        References can be used in the Yeti graph, this means that it is\n        possible to load previously caches files. The information will need\n        to be stored and, if the file not publish, copied to the resource\n        folder.\n\n        Args:\n            node (str): node name of the pgYetiMaya node\n\n        Returns:\n            list\n        \"\"\"\n        resources = []\n\n        image_search_paths = cmds.getAttr(\"{}.imageSearchPath\".format(node))\n        if image_search_paths:\n\n            # TODO: Somehow this uses OS environment path separator, `:` vs `;`\n            # Later on check whether this is pipeline OS cross-compatible.\n            image_search_paths = [p for p in\n                                  image_search_paths.split(os.path.pathsep) if p]\n\n            # find all ${TOKEN} tokens and replace them with $TOKEN env. variable\n            image_search_paths = self._replace_tokens(image_search_paths)\n\n        # List all related textures\n        texture_nodes = cmds.pgYetiGraph(\n            node, listNodes=True, type=\"texture\")\n        texture_filenames = [\n            cmds.pgYetiGraph(\n                node, node=texture_node,\n                param=\"file_name\", getParamValue=True)\n            for texture_node in texture_nodes\n        ]\n        self.log.debug(\"Found %i texture(s)\" % len(texture_filenames))\n\n        # Get all reference nodes\n        reference_nodes = cmds.pgYetiGraph(node,\n                                           listNodes=True,\n                                           type=\"reference\")\n        self.log.debug(\"Found %i reference node(s)\" % len(reference_nodes))\n\n        # Collect all texture files\n        # find all ${TOKEN} tokens and replace them with $TOKEN env. variable\n        texture_filenames = self._replace_tokens(texture_filenames)\n        for texture in texture_filenames:\n\n            files = []\n            if os.path.isabs(texture):\n                self.log.debug(\"Texture is absolute path, ignoring \"\n                               \"image search paths for: %s\" % texture)\n                files = lib.search_textures(texture)\n            else:\n                for root in image_search_paths:\n                    filepath = os.path.join(root, texture)\n                    files = lib.search_textures(filepath)\n                    if files:\n                        # Break out on first match in search paths..\n                        break\n\n            if not files:\n                raise KnownPublishError(\n                    \"No texture found for: %s \"\n                    \"(searched: %s)\" % (texture, image_search_paths))\n\n            item = {\n                \"files\": files,\n                \"source\": texture,\n                \"node\": node\n            }\n\n            resources.append(item)\n\n        # For now validate that every texture has at least a single file\n        # resolved. Since a 'resource' does not have the requirement of having\n        # a `files` explicitly mapped it's not explicitly validated.\n        # TODO: Validate this as a validator\n        invalid_resources = []\n        for resource in resources:\n            if not resource['files']:\n                invalid_resources.append(resource)\n        if invalid_resources:\n            raise RuntimeError(\"Invalid resources\")\n\n        # Collect all referenced files\n        for reference_node in reference_nodes:\n            ref_file = cmds.pgYetiGraph(node,\n                                        node=reference_node,\n                                        param=\"reference_file\",\n                                        getParamValue=True)\n\n            # Create resource dict\n            item = {\n                \"source\": ref_file,\n                \"node\": node,\n                \"graphnode\": reference_node,\n                \"param\": \"reference_file\",\n                \"files\": []\n            }\n\n            ref_file_name = os.path.basename(ref_file)\n            if \"%04d\" in ref_file_name:\n                item[\"files\"] = lib.get_sequence(ref_file)\n            else:\n                if os.path.exists(ref_file) and os.path.isfile(ref_file):\n                    item[\"files\"] = [ref_file]\n\n            if not item[\"files\"]:\n                self.log.warning(\"Reference node '%s' has no valid file \"\n                                 \"path set: %s\" % (reference_node, ref_file))\n                # TODO: This should allow to pass and fail in Validator instead\n                raise RuntimeError(\"Reference node  must be a full file path!\")\n\n            resources.append(item)\n\n        return resources\n\n    def _replace_tokens(self, strings):\n        env_re = re.compile(r\"\\$\\{(\\w+)\\}\")\n\n        replaced = []\n        for s in strings:\n            matches = re.finditer(env_re, s)\n            for m in matches:\n                try:\n                    s = s.replace(m.group(), os.environ[m.group(1)])\n                except KeyError:\n                    msg = \"Cannot find requested {} in environment\".format(\n                        m.group(1))\n                    self.log.error(msg)\n                    raise RuntimeError(msg)\n            replaced.append(s)\n        return replaced\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_yeti_rig.html#client.ayon_maya.plugins.publish.collect_yeti_rig.CollectYetiRig.collect_input_connections","title":"<code>collect_input_connections(instance)</code>","text":"<p>Collect the inputs for all nodes in the input_SET</p> Source code in <code>client/ayon_maya/plugins/publish/collect_yeti_rig.py</code> <pre><code>def collect_input_connections(self, instance):\n    \"\"\"Collect the inputs for all nodes in the input_SET\"\"\"\n\n    # Get the input meshes information\n    input_content = cmds.ls(cmds.sets(\"input_SET\", query=True), long=True)\n\n    # Include children\n    input_content += cmds.listRelatives(input_content,\n                                        allDescendents=True,\n                                        fullPath=True) or []\n\n    # Ignore intermediate objects\n    input_content = cmds.ls(input_content, long=True, noIntermediate=True)\n    if not input_content:\n        return []\n\n    # Store all connections\n    connections = cmds.listConnections(input_content,\n                                       source=True,\n                                       destination=False,\n                                       connections=True,\n                                       # Only allow inputs from dagNodes\n                                       # (avoid display layers, etc.)\n                                       type=\"dagNode\",\n                                       plugs=True) or []\n    connections = cmds.ls(connections, long=True)      # Ensure long names\n\n    inputs = []\n    for dest, src in lib.pairwise(connections):\n        source_node, source_attr = src.split(\".\", 1)\n        dest_node, dest_attr = dest.split(\".\", 1)\n\n        # Ensure the source of the connection is not included in the\n        # current instance's hierarchy. If so, we ignore that connection\n        # as we will want to preserve it even over a publish.\n        if source_node in instance:\n            self.log.debug(\"Ignoring input connection between nodes \"\n                           \"inside the instance: %s -&gt; %s\" % (src, dest))\n            continue\n\n        inputs.append({\"connections\": [source_attr, dest_attr],\n                       \"sourceID\": lib.get_id(source_node),\n                       \"destinationID\": lib.get_id(dest_node)})\n\n    return inputs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/collect_yeti_rig.html#client.ayon_maya.plugins.publish.collect_yeti_rig.CollectYetiRig.get_yeti_resources","title":"<code>get_yeti_resources(node)</code>","text":"<p>Get all resource file paths</p> <p>If a texture is a sequence it gathers all sibling files to ensure the texture sequence is complete.</p> <p>References can be used in the Yeti graph, this means that it is possible to load previously caches files. The information will need to be stored and, if the file not publish, copied to the resource folder.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>node name of the pgYetiMaya node</p> required <p>Returns:</p> Type Description <p>list</p> Source code in <code>client/ayon_maya/plugins/publish/collect_yeti_rig.py</code> <pre><code>def get_yeti_resources(self, node):\n    \"\"\"Get all resource file paths\n\n    If a texture is a sequence it gathers all sibling files to ensure\n    the texture sequence is complete.\n\n    References can be used in the Yeti graph, this means that it is\n    possible to load previously caches files. The information will need\n    to be stored and, if the file not publish, copied to the resource\n    folder.\n\n    Args:\n        node (str): node name of the pgYetiMaya node\n\n    Returns:\n        list\n    \"\"\"\n    resources = []\n\n    image_search_paths = cmds.getAttr(\"{}.imageSearchPath\".format(node))\n    if image_search_paths:\n\n        # TODO: Somehow this uses OS environment path separator, `:` vs `;`\n        # Later on check whether this is pipeline OS cross-compatible.\n        image_search_paths = [p for p in\n                              image_search_paths.split(os.path.pathsep) if p]\n\n        # find all ${TOKEN} tokens and replace them with $TOKEN env. variable\n        image_search_paths = self._replace_tokens(image_search_paths)\n\n    # List all related textures\n    texture_nodes = cmds.pgYetiGraph(\n        node, listNodes=True, type=\"texture\")\n    texture_filenames = [\n        cmds.pgYetiGraph(\n            node, node=texture_node,\n            param=\"file_name\", getParamValue=True)\n        for texture_node in texture_nodes\n    ]\n    self.log.debug(\"Found %i texture(s)\" % len(texture_filenames))\n\n    # Get all reference nodes\n    reference_nodes = cmds.pgYetiGraph(node,\n                                       listNodes=True,\n                                       type=\"reference\")\n    self.log.debug(\"Found %i reference node(s)\" % len(reference_nodes))\n\n    # Collect all texture files\n    # find all ${TOKEN} tokens and replace them with $TOKEN env. variable\n    texture_filenames = self._replace_tokens(texture_filenames)\n    for texture in texture_filenames:\n\n        files = []\n        if os.path.isabs(texture):\n            self.log.debug(\"Texture is absolute path, ignoring \"\n                           \"image search paths for: %s\" % texture)\n            files = lib.search_textures(texture)\n        else:\n            for root in image_search_paths:\n                filepath = os.path.join(root, texture)\n                files = lib.search_textures(filepath)\n                if files:\n                    # Break out on first match in search paths..\n                    break\n\n        if not files:\n            raise KnownPublishError(\n                \"No texture found for: %s \"\n                \"(searched: %s)\" % (texture, image_search_paths))\n\n        item = {\n            \"files\": files,\n            \"source\": texture,\n            \"node\": node\n        }\n\n        resources.append(item)\n\n    # For now validate that every texture has at least a single file\n    # resolved. Since a 'resource' does not have the requirement of having\n    # a `files` explicitly mapped it's not explicitly validated.\n    # TODO: Validate this as a validator\n    invalid_resources = []\n    for resource in resources:\n        if not resource['files']:\n            invalid_resources.append(resource)\n    if invalid_resources:\n        raise RuntimeError(\"Invalid resources\")\n\n    # Collect all referenced files\n    for reference_node in reference_nodes:\n        ref_file = cmds.pgYetiGraph(node,\n                                    node=reference_node,\n                                    param=\"reference_file\",\n                                    getParamValue=True)\n\n        # Create resource dict\n        item = {\n            \"source\": ref_file,\n            \"node\": node,\n            \"graphnode\": reference_node,\n            \"param\": \"reference_file\",\n            \"files\": []\n        }\n\n        ref_file_name = os.path.basename(ref_file)\n        if \"%04d\" in ref_file_name:\n            item[\"files\"] = lib.get_sequence(ref_file)\n        else:\n            if os.path.exists(ref_file) and os.path.isfile(ref_file):\n                item[\"files\"] = [ref_file]\n\n        if not item[\"files\"]:\n            self.log.warning(\"Reference node '%s' has no valid file \"\n                             \"path set: %s\" % (reference_node, ref_file))\n            # TODO: This should allow to pass and fail in Validator instead\n            raise RuntimeError(\"Reference node  must be a full file path!\")\n\n        resources.append(item)\n\n    return resources\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/determine_future_version.html","title":"determine_future_version","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/determine_future_version.html#client.ayon_maya.plugins.publish.determine_future_version.DetermineFutureVersion","title":"<code>DetermineFutureVersion</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>This will determine version of product if we want render to be attached to.</p> Source code in <code>client/ayon_maya/plugins/publish/determine_future_version.py</code> <pre><code>class DetermineFutureVersion(plugin.MayaInstancePlugin):\n    \"\"\"\n    This will determine version of product if we want render to be attached to.\n    \"\"\"\n    label = \"Determine Product Version\"\n    order = pyblish.api.IntegratorOrder\n    families = [\"renderlayer\"]\n\n    def process(self, instance):\n        context = instance.context\n        attatch_to_products = [\n            i[\"productName\"]\n            for i in instance.data[\"attachTo\"]\n        ]\n        if not attatch_to_products:\n            return\n\n        for i in context:\n            if i.data[\"productName\"] not in attatch_to_products:\n                continue\n            # # this will get corresponding product in attachTo list\n            # # so we can set version there\n            sub = next(\n                item\n                for item in instance.data[\"attachTo\"]\n                if item[\"productName\"] == i.data[\"productName\"]\n            )\n\n            sub[\"version\"] = i.data.get(\"version\", 1)\n            self.log.info(\"render will be attached to {} v{}\".format(\n                    sub[\"productName\"], sub[\"version\"]\n            ))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_active_view_thumbnail.html","title":"extract_active_view_thumbnail","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_active_view_thumbnail.html#client.ayon_maya.plugins.publish.extract_active_view_thumbnail.ExtractActiveViewThumbnail","title":"<code>ExtractActiveViewThumbnail</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Set instance thumbnail to a screengrab of current active viewport.</p> <p>This makes it so that if an instance does not have a thumbnail set yet that it will get a thumbnail of the currently active view at the time of publishing as a fallback.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_active_view_thumbnail.py</code> <pre><code>class ExtractActiveViewThumbnail(plugin.MayaInstancePlugin):\n    \"\"\"Set instance thumbnail to a screengrab of current active viewport.\n\n    This makes it so that if an instance does not have a thumbnail set yet that\n    it will get a thumbnail of the currently active view at the time of\n    publishing as a fallback.\n\n    \"\"\"\n    order = pyblish.api.ExtractorOrder + 0.49\n    label = \"Active View Thumbnail\"\n    families = [\"workfile\"]\n\n    def process(self, instance):\n        if IS_HEADLESS or is_in_tests():\n            self.log.debug(\n                \"Skip extraction of active view thumbnail, due to being in\"\n                \"headless mode.\"\n            )\n            return\n\n        thumbnail = instance.data.get(\"thumbnailPath\")\n        if not thumbnail:\n            view_thumbnail = self.get_view_thumbnail(instance)\n            if not view_thumbnail:\n                return\n\n            self.log.debug(\"Setting instance thumbnail path to: {}\".format(\n                view_thumbnail\n            ))\n            instance.data[\"thumbnailPath\"] = view_thumbnail\n\n    def get_view_thumbnail(self, instance):\n        cache_key = \"__maya_view_thumbnail\"\n        context = instance.context\n\n        if cache_key not in context.data:\n            # Generate only a single thumbnail, even for multiple instances\n            with tempfile.NamedTemporaryFile(suffix=\"_thumbnail.jpg\",\n                                             delete=False) as f:\n                path = f.name\n\n            view = omui.M3dView.active3dView()\n            image = om.MImage()\n            view.readColorBuffer(image, True)\n            image.writeToFile(path, \"jpg\")\n            self.log.debug(\"Generated thumbnail: {}\".format(path))\n\n            context.data[\"cleanupFullPaths\"].append(path)\n            context.data[cache_key] = path\n        return context.data[cache_key]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_arnold_scene_source.html","title":"extract_arnold_scene_source","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_arnold_scene_source.html#client.ayon_maya.plugins.publish.extract_arnold_scene_source.ExtractArnoldSceneSource","title":"<code>ExtractArnoldSceneSource</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extract the content of the instance to an Arnold Scene Source file.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_arnold_scene_source.py</code> <pre><code>class ExtractArnoldSceneSource(plugin.MayaExtractorPlugin):\n    \"\"\"Extract the content of the instance to an Arnold Scene Source file.\"\"\"\n\n    label = \"Extract Arnold Scene Source\"\n    families = [\"ass\"]\n    targets = [\"local\", \"remote\"]\n    asciiAss = False\n\n    def _pre_process(self, instance, staging_dir):\n        file_path = os.path.join(staging_dir, \"{}.ass\".format(instance.name))\n\n        # Mask\n        mask = arnold.AI_NODE_ALL\n\n        node_types = {\n            \"options\": arnold.AI_NODE_OPTIONS,\n            \"camera\": arnold.AI_NODE_CAMERA,\n            \"light\": arnold.AI_NODE_LIGHT,\n            \"shape\": arnold.AI_NODE_SHAPE,\n            \"shader\": arnold.AI_NODE_SHADER,\n            \"override\": arnold.AI_NODE_OVERRIDE,\n            \"driver\": arnold.AI_NODE_DRIVER,\n            \"filter\": arnold.AI_NODE_FILTER,\n            \"color_manager\": arnold.AI_NODE_COLOR_MANAGER,\n            \"operator\": arnold.AI_NODE_OPERATOR\n        }\n        if hasattr(arnold, \"AI_NODE_IMAGER\"):\n            # Added in Arnold 6.1.0.0 with MtoA 4.1.0 (Oct. 2020)\n            node_types[\"imager\"] = arnold.AI_NODE_IMAGER\n\n        for key in node_types.keys():\n            if instance.data.get(\"mask\" + key.title()):\n                mask = mask ^ node_types[key]\n\n        # Motion blur\n        attribute_data = {\n            \"defaultArnoldRenderOptions.motion_blur_enable\": instance.data.get(\n                \"motionBlur\", True\n            ),\n            \"defaultArnoldRenderOptions.motion_steps\": instance.data.get(\n                \"motionBlurKeys\", 2\n            ),\n            \"defaultArnoldRenderOptions.motion_frames\": instance.data.get(\n                \"motionBlurLength\", 0.5\n            )\n        }\n\n        # Write out .ass file\n        kwargs = {\n            \"filename\": file_path,\n            \"startFrame\": instance.data.get(\"frameStartHandle\", 1),\n            \"endFrame\": instance.data.get(\"frameEndHandle\", 1),\n            \"frameStep\": instance.data.get(\"step\", 1),\n            \"selected\": True,\n            \"asciiAss\": self.asciiAss,\n            \"shadowLinks\": True,\n            \"lightLinks\": True,\n            \"boundingBox\": instance.data.get(\"boundingBox\", True),\n            \"compressed\": instance.data.get(\"compressed\", False),\n            \"expandProcedurals\": instance.data.get(\"expandProcedurals\", False),\n            \"camera\": instance.data[\"camera\"],\n            \"mask\": mask\n        }\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        return attribute_data, kwargs\n\n    def process(self, instance):\n        staging_dir = self.staging_dir(instance)\n        attribute_data, kwargs = self._pre_process(instance, staging_dir)\n\n        filenames = self._extract(\n            instance.data[\"members\"], attribute_data, kwargs\n        )\n\n        self._post_process(\n            instance, filenames, staging_dir, kwargs[\"startFrame\"]\n        )\n\n    def _post_process(self, instance, filenames, staging_dir, frame_start):\n        nodes_by_id = self._nodes_by_id(instance[:])\n\n        ext = \"ass.gz\" if instance.data.get(\"compressed\") else \"ass\"\n\n        representation = {\n            \"name\": \"ass\",\n            \"ext\": ext,\n            \"files\": filenames if len(filenames) &gt; 1 else filenames[0],\n            \"stagingDir\": staging_dir,\n            \"frameStart\": frame_start\n        }\n\n        instance.data[\"representations\"].append(representation)\n\n        json_path = os.path.join(\n            staging_dir, \"{}.json\".format(instance.name)\n        )\n        with open(json_path, \"w\") as f:\n            json.dump(nodes_by_id, f)\n\n        representation = {\n            \"name\": \"json\",\n            \"ext\": \"json\",\n            \"files\": os.path.basename(json_path),\n            \"stagingDir\": staging_dir\n        }\n\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\n            \"Extracted instance {} to: {}\".format(instance.name, staging_dir)\n        )\n\n    def _nodes_by_id(self, nodes):\n        nodes_by_id = defaultdict(list)\n\n        for node in nodes:\n            id = lib.get_id(node)\n\n            if id is None:\n                continue\n\n            # Converting Maya hierarchy separator \"|\" to Arnold separator \"/\".\n            nodes_by_id[id].append(node.replace(\"|\", \"/\"))\n\n        return nodes_by_id\n\n    def _extract(self, nodes, attribute_data, kwargs):\n        filenames = []\n        with lib.attribute_values(attribute_data):\n            with lib.maintained_selection():\n                self.log.debug(\n                    \"Writing: {}\".format(nodes)\n                )\n                cmds.select(nodes, noExpand=True)\n\n                self.log.debug(\n                    \"Extracting ass sequence with: {}\".format(kwargs)\n                )\n\n                exported_files = cmds.arnoldExportAss(**kwargs)\n\n                for file in exported_files:\n                    filenames.append(os.path.split(file)[1])\n\n                self.log.debug(\"Exported: {}\".format(filenames))\n\n        return filenames\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_arnold_scene_source.html#client.ayon_maya.plugins.publish.extract_arnold_scene_source.ExtractArnoldSceneSourceProxy","title":"<code>ExtractArnoldSceneSourceProxy</code>","text":"<p>               Bases: <code>ExtractArnoldSceneSource</code></p> <p>Extract the content of the instance to an Arnold Scene Source file.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_arnold_scene_source.py</code> <pre><code>class ExtractArnoldSceneSourceProxy(ExtractArnoldSceneSource):\n    \"\"\"Extract the content of the instance to an Arnold Scene Source file.\"\"\"\n\n    label = \"Extract Arnold Scene Source Proxy\"\n    hosts = [\"maya\"]\n    families = [\"assProxy\"]\n    asciiAss = True\n\n    def process(self, instance):\n        staging_dir = self.staging_dir(instance)\n        attribute_data, kwargs = self._pre_process(instance, staging_dir)\n\n        filenames, _ = self._duplicate_extract(\n            instance.data[\"members\"], attribute_data, kwargs\n        )\n\n        self._post_process(\n            instance, filenames, staging_dir, kwargs[\"startFrame\"]\n        )\n\n        kwargs[\"filename\"] = os.path.join(\n            staging_dir, \"{}_proxy.ass\".format(instance.name)\n        )\n\n        filenames, _ = self._duplicate_extract(\n            instance.data[\"proxy\"], attribute_data, kwargs\n        )\n\n        representation = {\n            \"name\": \"proxy\",\n            \"ext\": \"ass\",\n            \"files\": filenames if len(filenames) &gt; 1 else filenames[0],\n            \"stagingDir\": staging_dir,\n            \"frameStart\": kwargs[\"startFrame\"],\n            \"outputName\": \"proxy\"\n        }\n\n        instance.data[\"representations\"].append(representation)\n\n    def _duplicate_extract(self, nodes, attribute_data, kwargs):\n        self.log.debug(\n            \"Writing {} with:\\n{}\".format(kwargs[\"filename\"], kwargs)\n        )\n        filenames = []\n        # Duplicating nodes so they are direct children of the world. This\n        # makes the hierarchy of any exported ass file the same.\n        with lib.delete_after() as delete_bin:\n            duplicate_nodes = []\n            for node in nodes:\n                # Only interested in transforms:\n                if cmds.nodeType(node) != \"transform\":\n                    continue\n\n                # Only interested in transforms with shapes.\n                shapes = cmds.listRelatives(\n                    node, shapes=True, noIntermediate=True\n                )\n                if not shapes:\n                    continue\n\n                basename = cmds.duplicate(node)[0]\n                parents = cmds.ls(node, long=True)[0].split(\"|\")[:-1]\n                duplicate_transform = \"|\".join(parents + [basename])\n\n                if cmds.listRelatives(duplicate_transform, parent=True):\n                    duplicate_transform = cmds.parent(\n                        duplicate_transform, world=True\n                    )[0]\n\n                basename = node.rsplit(\"|\", 1)[-1].rsplit(\":\", 1)[-1]\n                duplicate_transform = cmds.rename(\n                    duplicate_transform, basename\n                )\n\n                # Discard children nodes that are not shapes\n                shapes = cmds.listRelatives(\n                    duplicate_transform, shapes=True, fullPath=True\n                )\n                children = cmds.listRelatives(\n                    duplicate_transform, children=True, fullPath=True\n                )\n                cmds.delete(set(children) - set(shapes))\n\n                duplicate_nodes.append(duplicate_transform)\n                duplicate_nodes.extend(shapes)\n                delete_bin.append(duplicate_transform)\n\n            nodes_by_id = self._nodes_by_id(duplicate_nodes)\n            filenames = self._extract(duplicate_nodes, attribute_data, kwargs)\n\n        return filenames, nodes_by_id\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_assembly.html","title":"extract_assembly","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_assembly.html#client.ayon_maya.plugins.publish.extract_assembly.ExtractAssembly","title":"<code>ExtractAssembly</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Produce an alembic of just point positions and normals.</p> <p>Positions and normals are preserved, but nothing more, for plain and predictable point caches.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_assembly.py</code> <pre><code>class ExtractAssembly(plugin.MayaExtractorPlugin):\n    \"\"\"Produce an alembic of just point positions and normals.\n\n    Positions and normals are preserved, but nothing more,\n    for plain and predictable point caches.\n\n    \"\"\"\n\n    label = \"Extract Assembly\"\n    families = [\"assembly\"]\n\n    def process(self, instance):\n\n        staging_dir = self.staging_dir(instance)\n        hierarchy_filename = \"{}.abc\".format(instance.name)\n        hierarchy_path = os.path.join(staging_dir, hierarchy_filename)\n        json_filename = \"{}.json\".format(instance.name)\n        json_path = os.path.join(staging_dir, json_filename)\n\n        self.log.debug(\"Dumping scene data for debugging ..\")\n        with open(json_path, \"w\") as filepath:\n            json.dump(instance.data[\"scenedata\"], filepath, ensure_ascii=False)\n\n        self.log.debug(\"Extracting pointcache ..\")\n        cmds.select(instance.data[\"nodesHierarchy\"])\n\n        # Run basic alembic exporter\n        extract_alembic(file=hierarchy_path,\n                        startFrame=1.0,\n                        endFrame=1.0,\n                        **{\"step\": 1.0,\n                           \"attr\": [\"cbId\"],\n                           \"writeVisibility\": True,\n                           \"writeCreases\": True,\n                           \"uvWrite\": True,\n                           \"selection\": True})\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation_abc = {\n            'name': 'abc',\n            'ext': 'abc',\n            'files': hierarchy_filename,\n            \"stagingDir\": staging_dir\n        }\n        instance.data[\"representations\"].append(representation_abc)\n\n        representation_json = {\n            'name': 'json',\n            'ext': 'json',\n            'files': json_filename,\n            \"stagingDir\": staging_dir\n        }\n        instance.data[\"representations\"].append(representation_json)\n        # Remove data\n        instance.data.pop(\"scenedata\", None)\n\n        cmds.select(clear=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_camera_alembic.html","title":"extract_camera_alembic","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_camera_alembic.html#client.ayon_maya.plugins.publish.extract_camera_alembic.ExtractCameraAlembic","title":"<code>ExtractCameraAlembic</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract a Camera as Alembic.</p> <p>The camera gets baked to world space by default. Only when the instance's <code>bakeToWorldSpace</code> is set to False it will include its full hierarchy.</p> <p>'camera'  product type expects only single camera, if multiple cameras are needed, 'matchmove' is better choice.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_camera_alembic.py</code> <pre><code>class ExtractCameraAlembic(plugin.MayaExtractorPlugin,\n                           publish.OptionalPyblishPluginMixin):\n    \"\"\"Extract a Camera as Alembic.\n\n    The camera gets baked to world space by default. Only when the instance's\n    `bakeToWorldSpace` is set to False it will include its full hierarchy.\n\n    'camera'  product type expects only single camera, if multiple cameras\n    are needed, 'matchmove' is better choice.\n\n    \"\"\"\n\n    label = \"Extract Camera (Alembic)\"\n    hosts = [\"maya\"]\n    families = [\"camera\", \"matchmove\"]\n    bake_attributes = \"[]\"\n\n    def process(self, instance):\n\n        # Collect the start and end including handles\n        start = instance.data[\"frameStartHandle\"]\n        end = instance.data[\"frameEndHandle\"]\n\n        step = instance.data.get(\"step\", 1.0)\n        bake_to_worldspace = instance.data(\"bakeToWorldSpace\", True)\n\n        # get cameras\n        members = instance.data['setMembers']\n        cameras = cmds.ls(members, leaf=True, long=True,\n                          dag=True, type=\"camera\")\n\n        # validate required settings\n        assert isinstance(step, float), \"Step must be a float value\"\n\n        # Define extract output file path\n        dir_path = self.staging_dir(instance)\n        if not os.path.exists(dir_path):\n            os.makedirs(dir_path)\n        filename = \"{0}.abc\".format(instance.name)\n        path = os.path.join(dir_path, filename)\n\n        # Perform alembic extraction\n        member_shapes = cmds.ls(\n            members, leaf=True, shapes=True, long=True, dag=True)\n        with lib.maintained_selection():\n            cmds.select(\n                member_shapes,\n                replace=True, noExpand=True)\n\n            # Enforce forward slashes for AbcExport because we're\n            # embedding it into a job string\n            path = path.replace(\"\\\\\", \"/\")\n\n            job_str = ' -selection -dataFormat \"ogawa\" '\n            job_str += ' -attrPrefix cb'\n            job_str += ' -frameRange {0} {1} '.format(start, end)\n            job_str += ' -step {0} '.format(step)\n\n            if bake_to_worldspace:\n                job_str += ' -worldSpace'\n\n                # if baked, drop the camera hierarchy to maintain\n                # clean output and backwards compatibility\n                camera_roots = cmds.listRelatives(\n                    cameras, parent=True, fullPath=True)\n                for camera_root in camera_roots:\n                    job_str += ' -root {0}'.format(camera_root)\n\n                for member in members:\n                    descendants = cmds.listRelatives(member,\n                                                     allDescendents=True,\n                                                     fullPath=True) or []\n                    shapes = cmds.ls(descendants, shapes=True,\n                                     noIntermediate=True, long=True)\n                    cameras = cmds.ls(shapes, type=\"camera\", long=True)\n                    if cameras:\n                        if not set(shapes) - set(cameras):\n                            continue\n                        self.log.warning((\n                            \"Camera hierarchy contains additional geometry. \"\n                            \"Extraction will fail.\")\n                        )\n                    transform = cmds.listRelatives(\n                        member, parent=True, fullPath=True)\n                    transform = transform[0] if transform else member\n                    job_str += ' -root {0}'.format(transform)\n\n            job_str += ' -file \"{0}\"'.format(path)\n\n            bake_attributes = json.loads(self.bake_attributes)\n            # bake specified attributes in preset\n            assert isinstance(bake_attributes, list), (\n                \"Attributes to bake must be specified as a list\"\n            )\n            for attr in bake_attributes:\n                self.log.debug(\"Adding {} attribute\".format(attr))\n                job_str += \" -attr {0}\".format(attr)\n\n            with lib.evaluation(\"off\"):\n                with lib.suspended_refresh():\n                    cmds.AbcExport(j=job_str, verbose=False)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'abc',\n            'ext': 'abc',\n            'files': filename,\n            \"stagingDir\": dir_path,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance '{0}' to: {1}\".format(\n            instance.name, path))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_camera_mayaScene.html","title":"extract_camera_mayaScene","text":"<p>Extract camera as Maya Scene.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_camera_mayaScene.html#client.ayon_maya.plugins.publish.extract_camera_mayaScene.ExtractCameraMayaScene","title":"<code>ExtractCameraMayaScene</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract a Camera as Maya Scene.</p> <p>This will create a duplicate of the camera that will be baked with substeps and handles for the required frames. This temporary duplicate will be published.</p> <p>The cameras gets baked to world space by default. Only when the instance's <code>bakeToWorldSpace</code> is set to False it will include its full hierarchy.</p> <p>'camera' product type expects only single camera, if multiple cameras are needed, 'matchmove' is better choice.</p> Note <p>The extracted Maya ascii file gets \"massaged\" removing the uuid values so they are valid for older versions of Fusion (e.g. 6.4)</p> Source code in <code>client/ayon_maya/plugins/publish/extract_camera_mayaScene.py</code> <pre><code>class ExtractCameraMayaScene(plugin.MayaExtractorPlugin,\n                             publish.OptionalPyblishPluginMixin):\n    \"\"\"Extract a Camera as Maya Scene.\n\n    This will create a duplicate of the camera that will be baked *with*\n    substeps and handles for the required frames. This temporary duplicate\n    will be published.\n\n    The cameras gets baked to world space by default. Only when the instance's\n    `bakeToWorldSpace` is set to False it will include its full hierarchy.\n\n    'camera' product type expects only single camera, if multiple cameras are\n    needed, 'matchmove' is better choice.\n\n    Note:\n        The extracted Maya ascii file gets \"massaged\" removing the uuid values\n        so they are valid for older versions of Fusion (e.g. 6.4)\n\n    \"\"\"\n\n    label = \"Extract Camera (Maya Scene)\"\n    hosts = [\"maya\"]\n    families = [\"camera\", \"matchmove\"]\n    scene_type = \"ma\"\n\n    keep_image_planes = True\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\"\"\"\n        # get settings\n        maya_settings = instance.context.data[\"project_settings\"][\"maya\"]\n        ext_mapping = {\n            item[\"name\"]: item[\"value\"]\n            for item in maya_settings[\"ext_mapping\"]\n        }\n        if ext_mapping:\n            self.log.debug(\"Looking in settings for scene type ...\")\n            # use extension mapping for first family found\n            for family in self.families:\n                try:\n                    self.scene_type = ext_mapping[family]\n                    self.log.debug(\n                        \"Using {} as scene type\".format(self.scene_type))\n                    break\n                except KeyError:\n                    # no preset found\n                    pass\n\n        # Collect the start and end including handles\n        start = instance.data[\"frameStartHandle\"]\n        end = instance.data[\"frameEndHandle\"]\n\n        step = instance.data.get(\"step\", 1.0)\n        bake_to_worldspace = instance.data(\"bakeToWorldSpace\", True)\n\n        if not bake_to_worldspace:\n            self.log.warning(\"Camera (Maya Scene) export only supports world\"\n                             \"space baked camera extractions. The disabled \"\n                             \"bake to world space is ignored...\")\n\n        # get cameras\n        members = set(cmds.ls(instance.data['setMembers'], leaf=True,\n                      shapes=True, long=True, dag=True))\n        cameras = set(cmds.ls(members, leaf=True, shapes=True, long=True,\n                      dag=True, type=\"camera\"))\n\n        # validate required settings\n        assert isinstance(step, float), \"Step must be a float value\"\n        transforms = cmds.listRelatives(list(cameras),\n                                        parent=True, fullPath=True)\n\n        # Define extract output file path\n        dir_path = self.staging_dir(instance)\n        filename = \"{0}.{1}\".format(instance.name, self.scene_type)\n        path = os.path.join(dir_path, filename)\n\n        # Perform extraction\n        with lib.maintained_selection():\n            with lib.evaluation(\"off\"):\n                with lib.suspended_refresh():\n                    if bake_to_worldspace:\n                        baked = lib.bake_to_world_space(\n                            transforms,\n                            frame_range=[start, end],\n                            step=step\n                        )\n                        baked_camera_shapes = set(cmds.ls(baked,\n                                                  type=\"camera\",\n                                                  dag=True,\n                                                  shapes=True,\n                                                  long=True))\n\n                        members.update(baked_camera_shapes)\n                        members.difference_update(cameras)\n                    else:\n                        baked_camera_shapes = cmds.ls(list(cameras),\n                                                      type=\"camera\",\n                                                      dag=True,\n                                                      shapes=True,\n                                                      long=True)\n\n                    attrs = {\"backgroundColorR\": 0.0,\n                             \"backgroundColorG\": 0.0,\n                             \"backgroundColorB\": 0.0,\n                             \"overscan\": 1.0}\n\n                    # Fix PLN-178: Don't allow background color to be non-black\n                    for cam, (attr, value) in itertools.product(cmds.ls(\n                            baked_camera_shapes, type=\"camera\", dag=True,\n                            long=True), attrs.items()):\n                        plug = \"{0}.{1}\".format(cam, attr)\n                        unlock(plug)\n                        cmds.setAttr(plug, value)\n\n                    attr_values = self.get_attr_values_from_data(\n                        instance.data)\n                    keep_image_planes = attr_values.get(\"keep_image_planes\")\n\n                    with transfer_image_planes(sorted(cameras),\n                                               sorted(baked_camera_shapes),\n                                               keep_image_planes):\n\n                        self.log.info(\"Performing extraction..\")\n                        cmds.select(cmds.ls(list(members), dag=True,\n                                            shapes=True, long=True),\n                                    noExpand=True)\n                        cmds.file(path,\n                                  force=True,\n                                  typ=\"mayaAscii\" if self.scene_type == \"ma\" else \"mayaBinary\",  # noqa: E501\n                                  exportSelected=True,\n                                  preserveReferences=False,\n                                  constructionHistory=False,\n                                  channels=True,  # allow animation\n                                  constraints=False,\n                                  shader=False,\n                                  expressions=False)\n\n                    # Delete the baked hierarchy\n                    if bake_to_worldspace:\n                        cmds.delete(baked)\n                    if self.scene_type == \"ma\":\n                        massage_ma_file(path)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': self.scene_type,\n            'ext': self.scene_type,\n            'files': filename,\n            \"stagingDir\": dir_path,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance '{0}' to: {1}\".format(\n            instance.name, path))\n\n    @classmethod\n    def get_attribute_defs(cls):\n        defs = super(ExtractCameraMayaScene, cls).get_attribute_defs()\n\n        defs.extend([\n            BoolDef(\"keep_image_planes\",\n                    label=\"Keep Image Planes\",\n                    tooltip=\"Preserving connected image planes on camera\",\n                    default=cls.keep_image_planes),\n\n        ])\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_camera_mayaScene.html#client.ayon_maya.plugins.publish.extract_camera_mayaScene.ExtractCameraMayaScene.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_camera_mayaScene.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\"\"\"\n    # get settings\n    maya_settings = instance.context.data[\"project_settings\"][\"maya\"]\n    ext_mapping = {\n        item[\"name\"]: item[\"value\"]\n        for item in maya_settings[\"ext_mapping\"]\n    }\n    if ext_mapping:\n        self.log.debug(\"Looking in settings for scene type ...\")\n        # use extension mapping for first family found\n        for family in self.families:\n            try:\n                self.scene_type = ext_mapping[family]\n                self.log.debug(\n                    \"Using {} as scene type\".format(self.scene_type))\n                break\n            except KeyError:\n                # no preset found\n                pass\n\n    # Collect the start and end including handles\n    start = instance.data[\"frameStartHandle\"]\n    end = instance.data[\"frameEndHandle\"]\n\n    step = instance.data.get(\"step\", 1.0)\n    bake_to_worldspace = instance.data(\"bakeToWorldSpace\", True)\n\n    if not bake_to_worldspace:\n        self.log.warning(\"Camera (Maya Scene) export only supports world\"\n                         \"space baked camera extractions. The disabled \"\n                         \"bake to world space is ignored...\")\n\n    # get cameras\n    members = set(cmds.ls(instance.data['setMembers'], leaf=True,\n                  shapes=True, long=True, dag=True))\n    cameras = set(cmds.ls(members, leaf=True, shapes=True, long=True,\n                  dag=True, type=\"camera\"))\n\n    # validate required settings\n    assert isinstance(step, float), \"Step must be a float value\"\n    transforms = cmds.listRelatives(list(cameras),\n                                    parent=True, fullPath=True)\n\n    # Define extract output file path\n    dir_path = self.staging_dir(instance)\n    filename = \"{0}.{1}\".format(instance.name, self.scene_type)\n    path = os.path.join(dir_path, filename)\n\n    # Perform extraction\n    with lib.maintained_selection():\n        with lib.evaluation(\"off\"):\n            with lib.suspended_refresh():\n                if bake_to_worldspace:\n                    baked = lib.bake_to_world_space(\n                        transforms,\n                        frame_range=[start, end],\n                        step=step\n                    )\n                    baked_camera_shapes = set(cmds.ls(baked,\n                                              type=\"camera\",\n                                              dag=True,\n                                              shapes=True,\n                                              long=True))\n\n                    members.update(baked_camera_shapes)\n                    members.difference_update(cameras)\n                else:\n                    baked_camera_shapes = cmds.ls(list(cameras),\n                                                  type=\"camera\",\n                                                  dag=True,\n                                                  shapes=True,\n                                                  long=True)\n\n                attrs = {\"backgroundColorR\": 0.0,\n                         \"backgroundColorG\": 0.0,\n                         \"backgroundColorB\": 0.0,\n                         \"overscan\": 1.0}\n\n                # Fix PLN-178: Don't allow background color to be non-black\n                for cam, (attr, value) in itertools.product(cmds.ls(\n                        baked_camera_shapes, type=\"camera\", dag=True,\n                        long=True), attrs.items()):\n                    plug = \"{0}.{1}\".format(cam, attr)\n                    unlock(plug)\n                    cmds.setAttr(plug, value)\n\n                attr_values = self.get_attr_values_from_data(\n                    instance.data)\n                keep_image_planes = attr_values.get(\"keep_image_planes\")\n\n                with transfer_image_planes(sorted(cameras),\n                                           sorted(baked_camera_shapes),\n                                           keep_image_planes):\n\n                    self.log.info(\"Performing extraction..\")\n                    cmds.select(cmds.ls(list(members), dag=True,\n                                        shapes=True, long=True),\n                                noExpand=True)\n                    cmds.file(path,\n                              force=True,\n                              typ=\"mayaAscii\" if self.scene_type == \"ma\" else \"mayaBinary\",  # noqa: E501\n                              exportSelected=True,\n                              preserveReferences=False,\n                              constructionHistory=False,\n                              channels=True,  # allow animation\n                              constraints=False,\n                              shader=False,\n                              expressions=False)\n\n                # Delete the baked hierarchy\n                if bake_to_worldspace:\n                    cmds.delete(baked)\n                if self.scene_type == \"ma\":\n                    massage_ma_file(path)\n\n    if \"representations\" not in instance.data:\n        instance.data[\"representations\"] = []\n\n    representation = {\n        'name': self.scene_type,\n        'ext': self.scene_type,\n        'files': filename,\n        \"stagingDir\": dir_path,\n    }\n    instance.data[\"representations\"].append(representation)\n\n    self.log.debug(\"Extracted instance '{0}' to: {1}\".format(\n        instance.name, path))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_camera_mayaScene.html#client.ayon_maya.plugins.publish.extract_camera_mayaScene.grouper","title":"<code>grouper(iterable, n, fillvalue=None)</code>","text":"<p>Collect data into fixed-length chunks or blocks.</p> <p>Examples:</p> <p>grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx</p> Source code in <code>client/ayon_maya/plugins/publish/extract_camera_mayaScene.py</code> <pre><code>def grouper(iterable, n, fillvalue=None):\n    \"\"\"Collect data into fixed-length chunks or blocks.\n\n    Examples:\n        grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx\n\n    \"\"\"\n    args = [iter(iterable)] * n\n    return itertools.zip_longest(fillvalue=fillvalue, *args)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_camera_mayaScene.html#client.ayon_maya.plugins.publish.extract_camera_mayaScene.massage_ma_file","title":"<code>massage_ma_file(path)</code>","text":"<p>Clean up .ma file for backwards compatibility.</p> <p>Massage the .ma of baked camera to stay backwards compatible with older versions of Fusion (6.4)</p> Source code in <code>client/ayon_maya/plugins/publish/extract_camera_mayaScene.py</code> <pre><code>def massage_ma_file(path):\n    \"\"\"Clean up .ma file for backwards compatibility.\n\n    Massage the .ma of baked camera to stay\n    backwards compatible with older versions\n    of Fusion (6.4)\n\n    \"\"\"\n    # Get open file's lines\n    f = open(path, \"r+\")\n    lines = f.readlines()\n    f.seek(0)  # reset to start of file\n\n    # Rewrite the file\n    for line in lines:\n        # Skip all 'rename -uid' lines\n        stripped = line.strip()\n        if stripped.startswith(\"rename -uid \"):\n            continue\n\n        f.write(line)\n\n    f.truncate()  # remove remainder\n    f.close()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_camera_mayaScene.html#client.ayon_maya.plugins.publish.extract_camera_mayaScene.transfer_image_planes","title":"<code>transfer_image_planes(source_cameras, target_cameras, keep_input_connections)</code>","text":"<p>Reattaches image planes to baked or original cameras.</p> <p>Baked cameras are duplicates of original ones. This attaches it to duplicated camera properly and after export it reattaches it back to original to keep image plane in workfile.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_camera_mayaScene.py</code> <pre><code>@contextlib.contextmanager\ndef transfer_image_planes(source_cameras, target_cameras,\n                          keep_input_connections):\n    \"\"\"Reattaches image planes to baked or original cameras.\n\n    Baked cameras are duplicates of original ones.\n    This attaches it to duplicated camera properly and after\n    export it reattaches it back to original to keep image plane in workfile.\n    \"\"\"\n    originals = {}\n    try:\n        for source_camera, target_camera in zip(source_cameras,\n                                                target_cameras):\n            image_plane_plug = \"{}.imagePlane\".format(source_camera)\n            image_planes = cmds.listConnections(image_plane_plug,\n                                                source=True,\n                                                destination=False,\n                                                type=\"imagePlane\") or []\n\n            # Split of the parent path they are attached - we want\n            # the image plane node name if attached to a camera.\n            # TODO: Does this still mean the image plane name is unique?\n            image_planes = [x.split(\"-&gt;\", 1)[-1] for x in image_planes]\n\n            if not image_planes:\n                continue\n\n            originals[source_camera] = []\n            for image_plane in image_planes:\n                if keep_input_connections:\n                    if source_camera == target_camera:\n                        continue\n                    _attach_image_plane(target_camera, image_plane)\n                else:  # explicitly detach image planes\n                    cmds.imagePlane(image_plane, edit=True, detach=True)\n                originals[source_camera].append(image_plane)\n        yield\n    finally:\n        for camera, image_planes in originals.items():\n            for image_plane in image_planes:\n                _attach_image_plane(camera, image_plane)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_camera_mayaScene.html#client.ayon_maya.plugins.publish.extract_camera_mayaScene.unlock","title":"<code>unlock(plug)</code>","text":"<p>Unlocks attribute and disconnects inputs for a plug.</p> <p>This will also recursively unlock the attribute upwards to any parent attributes for compound attributes, to ensure it's fully unlocked and free to change the value.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_camera_mayaScene.py</code> <pre><code>def unlock(plug):\n    \"\"\"Unlocks attribute and disconnects inputs for a plug.\n\n    This will also recursively unlock the attribute\n    upwards to any parent attributes for compound\n    attributes, to ensure it's fully unlocked and free\n    to change the value.\n\n    \"\"\"\n    node, attr = plug.rsplit(\".\", 1)\n\n    # Unlock attribute\n    cmds.setAttr(plug, lock=False)\n\n    # Also unlock any parent attribute (if compound)\n    parents = cmds.attributeQuery(attr, node=node, listParent=True)\n    if parents:\n        for parent in parents:\n            unlock(\"{0}.{1}\".format(node, parent))\n\n    # Break incoming connections\n    connections = cmds.listConnections(plug,\n                                       source=True,\n                                       destination=False,\n                                       plugs=True,\n                                       connections=True)\n    if connections:\n        for destination, source in grouper(connections, 2):\n            cmds.disconnectAttr(source, destination)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_fbx.html","title":"extract_fbx","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_fbx.html#client.ayon_maya.plugins.publish.extract_fbx.ExtractFBX","title":"<code>ExtractFBX</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extract FBX from Maya.</p> <p>This extracts reproducible FBX exports ignoring any of the settings set on the local machine in the FBX export options window.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_fbx.py</code> <pre><code>class ExtractFBX(plugin.MayaExtractorPlugin):\n    \"\"\"Extract FBX from Maya.\n\n    This extracts reproducible FBX exports ignoring any of the\n    settings set on the local machine in the FBX export options window.\n\n    \"\"\"\n    order = pyblish.api.ExtractorOrder\n    label = \"Extract FBX\"\n    families = [\"fbx\"]\n\n    def process(self, instance):\n        fbx_exporter = fbx.FBXExtractor(log=self.log)\n\n        # Define output path\n        staging_dir = self.staging_dir(instance)\n        filename = \"{0}.fbx\".format(instance.name)\n        path = os.path.join(staging_dir, filename)\n\n        # The export requires forward slashes because we need\n        # to format it into a string in a mel expression\n        path = path.replace('\\\\', '/')\n\n        self.log.debug(\"Extracting FBX to: {0}\".format(path))\n\n        members = instance.data[\"setMembers\"]\n        self.log.debug(\"Members: {0}\".format(members))\n        self.log.debug(\"Instance: {0}\".format(instance[:]))\n\n        fbx_exporter.set_options_from_instance(instance)\n\n        # Export\n        with maintained_selection():\n            fbx_exporter.export(members, path)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'fbx',\n            'ext': 'fbx',\n            'files': filename,\n            \"stagingDir\": staging_dir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extract FBX successful to: {0}\".format(path))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_fbx_animation.html","title":"extract_fbx_animation","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_fbx_animation.html#client.ayon_maya.plugins.publish.extract_fbx_animation.ExtractFBXAnimation","title":"<code>ExtractFBXAnimation</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extract Rig in FBX format from Maya.</p> <p>This extracts the rig in fbx with the constraints and referenced asset content included. This also optionally extract animated rig in fbx with geometries included.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_fbx_animation.py</code> <pre><code>class ExtractFBXAnimation(plugin.MayaExtractorPlugin):\n    \"\"\"Extract Rig in FBX format from Maya.\n\n    This extracts the rig in fbx with the constraints\n    and referenced asset content included.\n    This also optionally extract animated rig in fbx with\n    geometries included.\n\n    \"\"\"\n    order = pyblish.api.ExtractorOrder\n    label = \"Extract Animation (FBX)\"\n    families = [\"animation.fbx\"]\n    targets = [\"local\", \"remote\"]\n\n    def process(self, instance):\n        # Define output path\n        staging_dir = self.staging_dir(instance)\n        filename = \"{0}.fbx\".format(instance.name)\n        path = os.path.join(staging_dir, filename)\n        path = path.replace(\"\\\\\", \"/\")\n\n        fbx_exporter = fbx.FBXExtractor(log=self.log)\n        out_members = instance.data.get(\"animated_skeleton\", [])\n        # Export\n        # TODO: need to set up the options for users to set up\n        # the flags they intended to export\n        instance.data[\"skeletonDefinitions\"] = True\n        instance.data[\"referencedAssetsContent\"] = True\n        fbx_exporter.set_options_from_instance(instance)\n\n        # Export relative only to the first level of the namespace,\n        # keeping any nested namespaces intact. Fix #147\n        # So `root:sublevel:mesh` becomes `sublevel:mesh`\n        namespace = get_namespace(out_members[0]).split(\":\", 1)[0]\n        relative_out_members = [\n            strip_namespace(node, namespace) for node in out_members\n        ]\n        with namespaced(\n            \":\" + namespace,\n            new=False,\n            relative_names=True\n        ) as _namespace:\n            fbx_exporter.export(relative_out_members, path)\n\n        representations = instance.data.setdefault(\"representations\", [])\n        representations.append({\n            'name': 'fbx',\n            'ext': 'fbx',\n            'files': filename,\n            \"stagingDir\": staging_dir\n        })\n\n        self.log.debug(\n            \"Extracted FBX animation to: {0}\".format(path))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_gltf.html","title":"extract_gltf","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_gpu_cache.html","title":"extract_gpu_cache","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_gpu_cache.html#client.ayon_maya.plugins.publish.extract_gpu_cache.ExtractGPUCache","title":"<code>ExtractGPUCache</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract the content of the instance to a GPU cache file.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_gpu_cache.py</code> <pre><code>class ExtractGPUCache(plugin.MayaExtractorPlugin,\n                      publish.OptionalPyblishPluginMixin):\n    \"\"\"Extract the content of the instance to a GPU cache file.\"\"\"\n\n    label = \"GPU Cache\"\n    families = [\"model\", \"animation\", \"pointcache\"]\n    targets = [\"local\", \"remote\"]\n    step = 1.0\n    stepSave = 1\n    optimize = True\n    optimizationThreshold = 40000\n    optimizeAnimationsForMotionBlur = True\n    writeMaterials = True\n    useBaseTessellation = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        if instance.data.get(\"farm\"):\n            self.log.debug(\"Should be processed on farm, skipping.\")\n            return\n\n        cmds.loadPlugin(\"gpuCache\", quiet=True)\n\n        staging_dir = self.staging_dir(instance)\n        filename = \"{}_gpu_cache\".format(instance.name)\n\n        # Write out GPU cache file.\n        kwargs = {\n            \"directory\": staging_dir,\n            \"fileName\": filename,\n            \"saveMultipleFiles\": False,\n            \"simulationRate\": self.step,\n            \"sampleMultiplier\": self.stepSave,\n            \"optimize\": self.optimize,\n            \"optimizationThreshold\": self.optimizationThreshold,\n            \"optimizeAnimationsForMotionBlur\": (\n                self.optimizeAnimationsForMotionBlur\n            ),\n            \"writeMaterials\": self.writeMaterials,\n            \"useBaseTessellation\": self.useBaseTessellation\n        }\n        self.log.debug(\n            \"Extract {} with:\\n{}\".format(\n                instance[:], json.dumps(kwargs, indent=4, sort_keys=True)\n            )\n        )\n        cmds.gpuCache(instance[:], **kwargs)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            \"name\": \"gpu_cache\",\n            \"ext\": \"abc\",\n            \"files\": filename + \".abc\",\n            \"stagingDir\": staging_dir,\n            \"outputName\": \"gpu_cache\"\n        }\n\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\n            \"Extracted instance {} to: {}\".format(instance.name, staging_dir)\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_import_reference.html","title":"extract_import_reference","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_import_reference.html#client.ayon_maya.plugins.publish.extract_import_reference.ExtractImportReference","title":"<code>ExtractImportReference</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract the scene with imported reference. The temp scene with imported reference is published for rendering if this extractor is activated</p> Source code in <code>client/ayon_maya/plugins/publish/extract_import_reference.py</code> <pre><code>class ExtractImportReference(plugin.MayaExtractorPlugin,\n                             OptionalPyblishPluginMixin):\n    \"\"\"\n\n        Extract the scene with imported reference.\n        The temp scene with imported reference is\n        published for rendering if this extractor is activated\n\n    \"\"\"\n\n    label = \"Extract Import Reference\"\n    order = pyblish.api.ExtractorOrder - 0.48\n    families = [\"renderlayer\", \"workfile\"]\n    optional = True\n    tmp_format = \"_tmp\"\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        if \"deadline\" not in project_settings:\n            cls.enabled = False\n            return\n        cls.active = (\n            project_settings\n            [\"deadline\"]\n            [\"publish\"]\n            [\"MayaSubmitDeadline\"]\n            [\"import_reference\"]\n        )\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        maya_settings = instance.context.data[\"project_settings\"][\"maya\"]\n        ext_mapping = {\n            item[\"name\"]: item[\"value\"]\n            for item in maya_settings[\"ext_mapping\"]\n        }\n        if ext_mapping:\n            self.log.debug(\"Looking in settings for scene type ...\")\n            # use extension mapping for first family found\n            for family in self.families:\n                try:\n                    self.scene_type = ext_mapping[family]\n                    self.log.debug(\n                        \"Using {} as scene type\".format(self.scene_type))\n                    break\n\n                except KeyError:\n                    # set scene type to ma\n                    self.scene_type = \"ma\"\n\n        _scene_type = (\"mayaAscii\"\n                       if self.scene_type == \"ma\"\n                       else \"mayaBinary\")\n\n        dir_path = self.staging_dir(instance)\n        # named the file with imported reference\n        if instance.name == \"Main\":\n            return\n        tmp_name = instance.name + self.tmp_format\n        current_name = cmds.file(query=True, sceneName=True)\n        ref_scene_name = \"{0}.{1}\".format(tmp_name, self.scene_type)\n\n        reference_path = os.path.join(dir_path, ref_scene_name)\n        tmp_path = os.path.dirname(current_name) + \"/\" + ref_scene_name\n\n        self.log.debug(\"Performing extraction..\")\n\n        # This generates script for mayapy to take care of reference\n        # importing outside current session. It is passing current scene\n        # name and destination scene name.\n        script = (\"\"\"\n# -*- coding: utf-8 -*-\n'''Script to import references to given scene.'''\nimport maya.standalone\nmaya.standalone.initialize()\n# scene names filled by caller\ncurrent_name = \"{current_name}\"\nref_scene_name = \"{ref_scene_name}\"\nprint(\"&gt;&gt;&gt; Opening {{}} ...\".format(current_name))\ncmds.file(current_name, open=True, force=True)\nprint(\"&gt;&gt;&gt; Processing references\")\nall_reference = cmds.file(q=True, reference=True) or []\nfor ref in all_reference:\n    if cmds.referenceQuery(ref, il=True):\n        cmds.file(ref, importReference=True)\n\n        nested_ref = cmds.file(q=True, reference=True)\n        if nested_ref:\n            for new_ref in nested_ref:\n                if new_ref not in all_reference:\n                    all_reference.append(new_ref)\n\nprint(\"&gt;&gt;&gt; Finish importing references\")\nprint(\"&gt;&gt;&gt; Saving scene as {{}}\".format(ref_scene_name))\n\ncmds.file(rename=ref_scene_name)\ncmds.file(save=True, force=True)\nprint(\"*** Done\")\n        \"\"\").format(current_name=current_name, ref_scene_name=tmp_path)\n        mayapy_exe = os.path.join(os.getenv(\"MAYA_LOCATION\"), \"bin\", \"mayapy\")\n        if sys.platform == \"windows\":\n            mayapy_exe += \".exe\"\n            mayapy_exe = os.path.normpath(mayapy_exe)\n        # can't use TemporaryNamedFile as that can't be opened in another\n        # process until handles are closed by context manager.\n        with tempfile.TemporaryDirectory() as tmp_dir_name:\n            tmp_script_path = os.path.join(tmp_dir_name, \"import_ref.py\")\n            self.log.debug(\"Using script file: {}\".format(tmp_script_path))\n            with open(tmp_script_path, \"wt\") as tmp:\n                tmp.write(script)\n\n            try:\n                run_subprocess([mayapy_exe, tmp_script_path])\n            except Exception:\n                self.log.error(\"Import reference failed\", exc_info=True)\n                raise\n\n        with lib.maintained_selection():\n            cmds.select(all=True, noExpand=True)\n            cmds.file(reference_path,\n                      force=True,\n                      typ=_scene_type,\n                      exportSelected=True,\n                      channels=True,\n                      constraints=True,\n                      shader=True,\n                      expressions=True,\n                      constructionHistory=True)\n\n        instance.context.data[\"currentFile\"] = tmp_path\n\n        if \"files\" not in instance.data:\n            instance.data[\"files\"] = []\n        instance.data[\"files\"].append(ref_scene_name)\n\n        if instance.data.get(\"representations\") is None:\n            instance.data[\"representations\"] = []\n\n        ref_representation = {\n            \"name\": self.scene_type,\n            \"ext\": self.scene_type,\n            \"files\": ref_scene_name,\n            \"stagingDir\": os.path.dirname(current_name),\n            \"outputName\": \"imported\"\n        }\n        self.log.debug(ref_representation)\n\n        instance.data[\"representations\"].append(ref_representation)\n\n        self.log.debug(\"Extracted instance '%s' to : '%s'\" % (ref_scene_name,\n                                                              reference_path))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_layout.html","title":"extract_layout","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_layout.html#client.ayon_maya.plugins.publish.extract_layout.ExtractLayout","title":"<code>ExtractLayout</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extract a layout.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_layout.py</code> <pre><code>class ExtractLayout(plugin.MayaExtractorPlugin):\n    \"\"\"Extract a layout.\"\"\"\n\n    label = \"Extract Layout\"\n    families = [\"layout\"]\n    project_container = \"AVALON_CONTAINERS\"\n\n    def process(self, instance):\n        # Define extract output file path\n        stagingdir = self.staging_dir(instance)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        json_data = []\n        container_order = 0\n        # TODO representation queries can be refactored to be faster\n        project_name = instance.context.data[\"projectName\"]\n        members = [member.lstrip('|') for member in instance.data[\"setMembers\"]]\n        for asset in members:\n            # Find the container\n            project_container = self.project_container\n            container_list = cmds.ls(project_container)\n            if len(container_list) == 0:\n                self.log.warning(\"Project container is not found!\")\n                self.log.warning(\"The asset(s) may not be properly loaded after published\") # noqa\n                continue\n\n            grp_loaded_ass = instance.data.get(\"groupLoadedAssets\", False)\n            if grp_loaded_ass:\n                asset_list = cmds.listRelatives(asset, children=True)\n                # WARNING This does override 'asset' variable from parent loop\n                #   is it correct?\n                for asset in asset_list:\n                    grp_name = asset.split(':')[0]\n            else:\n                grp_name = asset.split(':')[0]\n\n            containers = cmds.ls(\"{}*_CON\".format(grp_name))\n            containers = [\n                container for container in containers\n                # Make sure to include only valid containers\n                if pipeline.parse_container(container)\n            ]\n\n            if len(containers) == 0:\n                self.log.warning(\"{} isn't from the loader\".format(asset))\n                self.log.warning(\"It may not be properly loaded after published\") # noqa\n                continue\n\n            container_dict = self.process_containers(containers)\n            allow_obj_transforms = instance.data.get(\"allowObjectTransforms\", False)\n\n            for container, container_root in container_dict.items():\n                container_order += 1\n                representation_id = cmds.getAttr(\n                    \"{}.representation\".format(container))\n\n                # Ignore invalid UUID is the representation for whatever reason\n                # is invalid\n                if not is_valid_uuid(representation_id):\n                    self.log.warning(\n                        f\"Skipping container with invalid UUID: {container}\")\n                    continue\n\n                # TODO: Once we support managed products from another project\n                #  we should be querying here using the project name from the\n                #  container instead.\n                representation = get_representation_by_id(\n                    project_name,\n                    representation_id,\n                    fields={\"versionId\", \"context\", \"name\"}\n                )\n                if not representation:\n                    self.log.warning(\n                        \"Representation not found in current project \"\n                        \"for container: {}\".format(container))\n                    continue\n\n                version_id = representation[\"versionId\"]\n                # TODO use product entity to get product type rather than\n                #    data in representation 'context'\n                repre_context = representation[\"context\"]\n                product_type = repre_context.get(\"product\", {}).get(\"type\")\n                if not product_type:\n                    product_type = repre_context.get(\"family\")\n                json_element = {\n                    \"product_type\": product_type,\n                    \"instance_name\": cmds.getAttr(\n                        \"{}.namespace\".format(container)),\n                    \"representation\": str(representation_id),\n                    \"version\": str(version_id),\n                    \"extension\": repre_context[\"ext\"],\n                    \"host\": self.hosts\n                }\n                local_matrix = cmds.xform(\n                    container_root, query=True, matrix=True)\n                local_rotation = cmds.xform(\n                    container_root, query=True, rotation=True, euler=True)\n\n                t_matrix = self.create_transformation_matrix(local_matrix, local_rotation)\n\n                json_element[\"transform_matrix\"] = [\n                    list(row)\n                    for row in t_matrix\n                ]\n\n                basis_list = [\n                    1, 0, 0, 0,\n                    0, 1, 0, 0,\n                    0, 0, 1, 0,\n                    0, 0, 0, 1\n                ]\n\n                basis_mm = om.MMatrix(basis_list)\n                b_matrix = convert_matrix_to_4x4_list(basis_mm)\n\n                json_element[\"basis\"] = []\n                for row in b_matrix:\n                    json_element[\"basis\"].append(list(row))\n\n                json_element[\"rotation\"] = {\n                    \"x\": local_rotation[0],\n                    \"y\": local_rotation[1],\n                    \"z\": local_rotation[2]\n                }\n                if allow_obj_transforms:\n                    child_transforms = cmds.ls(\n                        get_all_children(\n                            [container_root],\n                            ignore_intermediate_objects=True\n                        ),\n                        type=\"transform\",\n                        long=True\n                    )\n                    if child_transforms:\n                        object_transforms = json_element.setdefault(\"object_transform\", [])\n                        for child_transform in child_transforms:\n                            object_transforms.append(\n                                self.parse_objects_transform_as_json_element(\n                                    child_transform\n                                )\n                            )\n                json_data.append(json_element)\n        json_data = sorted(json_data, key=lambda x: x[\"instance_name\"])\n        json_filename = \"{}.json\".format(instance.name)\n        json_path = os.path.join(stagingdir, json_filename)\n\n        with open(json_path, \"w+\") as file:\n            json.dump(json_data, fp=file, indent=2)\n\n        json_representation = {\n            'name': 'json',\n            'ext': 'json',\n            'files': json_filename,\n            \"stagingDir\": stagingdir,\n        }\n\n        instance.data[\"representations\"].append(json_representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\",\n                       instance.name, json_representation)\n\n    def process_containers(self, containers):\n        \"\"\"Allow to collect the asset containers through sub-assembly workflow if\n        there is a layout container.\n\n        Args:\n            containers (list[str]): Ayon asset containers\n\n        Returns:\n            dict[str, str]: container mapping to its related root transform node\n        \"\"\"\n        all_containers_set = {}\n        for container in containers:\n            if cmds.getAttr(f\"{container}.loader\") == \"LayoutLoader\":\n                # Flatten container layout loader products to their individual loaded containers\n                member_containers = get_container_members(container)\n                # Recursively process each member container\n                children_containers = self.process_containers(member_containers)\n                all_containers_set.update(children_containers)\n            else:\n                members = get_container_members(container)\n                transforms = cmds.ls(members, transforms=True, references=False)\n                roots = get_highest_in_hierarchy(transforms)\n                if roots:\n                    root = roots[0].split(\"|\")[1]\n                    # Assume just a single root node\n                    all_containers_set[container] = root\n\n        return all_containers_set\n\n    def create_transformation_matrix(self, local_matrix, local_rotation):\n        matrix = om.MMatrix(local_matrix)\n        matrix = self.convert_transformation_matrix(matrix, local_rotation)\n        t_matrix = convert_matrix_to_4x4_list(matrix)\n        return t_matrix\n\n    def convert_transformation_matrix(self, transform_mm: om.MMatrix, rotation: list) -&gt; om.MMatrix:\n        \"\"\"Convert matrix to list of transformation matrix for Unreal Engine fbx asset import.\n\n        Args:\n            transform_mm (om.MMatrix): Local Matrix for the asset\n            rotation (list): Rotations of the asset\n\n        Returns:\n            List[om.MMatrix]: List of transformation matrix of the asset\n        \"\"\"\n        convert_transform = om.MTransformationMatrix(transform_mm)\n\n        convert_translation = convert_transform.translation(om.MSpace.kWorld)\n        convert_translation = om.MVector(convert_translation.x, convert_translation.z, convert_translation.y)\n        convert_scale = convert_transform.scale(om.MSpace.kWorld)\n        convert_transform.setTranslation(convert_translation, om.MSpace.kWorld)\n        converted_rotation = om.MEulerRotation(\n            math.radians(rotation[0]), math.radians(rotation[2]), math.radians(rotation[1])\n        )\n        convert_transform.setRotation(converted_rotation)\n        convert_transform.setScale([convert_scale[0], convert_scale[2], convert_scale[1]], om.MSpace.kWorld)\n\n        return convert_transform.asMatrix()\n\n    def parse_objects_transform_as_json_element(self, child_transform):\n        \"\"\"Parse transform data of the container objects.\n        Args:\n            child_transform (str): transform node.\n        Returns:\n            dict: transform data of the transform object\n        \"\"\"\n        local_matrix = cmds.xform(child_transform, query=True, matrix=True)\n        local_rotation = cmds.xform(child_transform, query=True, rotation=True)\n        transform_matrix = self.create_transformation_matrix(local_matrix, local_rotation)\n        child_transform_name = child_transform.rsplit(\":\", 1)[-1]\n        return {\n            child_transform_name: transform_matrix\n        }\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_layout.html#client.ayon_maya.plugins.publish.extract_layout.ExtractLayout.convert_transformation_matrix","title":"<code>convert_transformation_matrix(transform_mm, rotation)</code>","text":"<p>Convert matrix to list of transformation matrix for Unreal Engine fbx asset import.</p> <p>Parameters:</p> Name Type Description Default <code>transform_mm</code> <code>MMatrix</code> <p>Local Matrix for the asset</p> required <code>rotation</code> <code>list</code> <p>Rotations of the asset</p> required <p>Returns:</p> Type Description <code>MMatrix</code> <p>List[om.MMatrix]: List of transformation matrix of the asset</p> Source code in <code>client/ayon_maya/plugins/publish/extract_layout.py</code> <pre><code>def convert_transformation_matrix(self, transform_mm: om.MMatrix, rotation: list) -&gt; om.MMatrix:\n    \"\"\"Convert matrix to list of transformation matrix for Unreal Engine fbx asset import.\n\n    Args:\n        transform_mm (om.MMatrix): Local Matrix for the asset\n        rotation (list): Rotations of the asset\n\n    Returns:\n        List[om.MMatrix]: List of transformation matrix of the asset\n    \"\"\"\n    convert_transform = om.MTransformationMatrix(transform_mm)\n\n    convert_translation = convert_transform.translation(om.MSpace.kWorld)\n    convert_translation = om.MVector(convert_translation.x, convert_translation.z, convert_translation.y)\n    convert_scale = convert_transform.scale(om.MSpace.kWorld)\n    convert_transform.setTranslation(convert_translation, om.MSpace.kWorld)\n    converted_rotation = om.MEulerRotation(\n        math.radians(rotation[0]), math.radians(rotation[2]), math.radians(rotation[1])\n    )\n    convert_transform.setRotation(converted_rotation)\n    convert_transform.setScale([convert_scale[0], convert_scale[2], convert_scale[1]], om.MSpace.kWorld)\n\n    return convert_transform.asMatrix()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_layout.html#client.ayon_maya.plugins.publish.extract_layout.ExtractLayout.parse_objects_transform_as_json_element","title":"<code>parse_objects_transform_as_json_element(child_transform)</code>","text":"<p>Parse transform data of the container objects. Args:     child_transform (str): transform node. Returns:     dict: transform data of the transform object</p> Source code in <code>client/ayon_maya/plugins/publish/extract_layout.py</code> <pre><code>def parse_objects_transform_as_json_element(self, child_transform):\n    \"\"\"Parse transform data of the container objects.\n    Args:\n        child_transform (str): transform node.\n    Returns:\n        dict: transform data of the transform object\n    \"\"\"\n    local_matrix = cmds.xform(child_transform, query=True, matrix=True)\n    local_rotation = cmds.xform(child_transform, query=True, rotation=True)\n    transform_matrix = self.create_transformation_matrix(local_matrix, local_rotation)\n    child_transform_name = child_transform.rsplit(\":\", 1)[-1]\n    return {\n        child_transform_name: transform_matrix\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_layout.html#client.ayon_maya.plugins.publish.extract_layout.ExtractLayout.process_containers","title":"<code>process_containers(containers)</code>","text":"<p>Allow to collect the asset containers through sub-assembly workflow if there is a layout container.</p> <p>Parameters:</p> Name Type Description Default <code>containers</code> <code>list[str]</code> <p>Ayon asset containers</p> required <p>Returns:</p> Type Description <p>dict[str, str]: container mapping to its related root transform node</p> Source code in <code>client/ayon_maya/plugins/publish/extract_layout.py</code> <pre><code>def process_containers(self, containers):\n    \"\"\"Allow to collect the asset containers through sub-assembly workflow if\n    there is a layout container.\n\n    Args:\n        containers (list[str]): Ayon asset containers\n\n    Returns:\n        dict[str, str]: container mapping to its related root transform node\n    \"\"\"\n    all_containers_set = {}\n    for container in containers:\n        if cmds.getAttr(f\"{container}.loader\") == \"LayoutLoader\":\n            # Flatten container layout loader products to their individual loaded containers\n            member_containers = get_container_members(container)\n            # Recursively process each member container\n            children_containers = self.process_containers(member_containers)\n            all_containers_set.update(children_containers)\n        else:\n            members = get_container_members(container)\n            transforms = cmds.ls(members, transforms=True, references=False)\n            roots = get_highest_in_hierarchy(transforms)\n            if roots:\n                root = roots[0].split(\"|\")[1]\n                # Assume just a single root node\n                all_containers_set[container] = root\n\n    return all_containers_set\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_layout.html#client.ayon_maya.plugins.publish.extract_layout.convert_matrix_to_4x4_list","title":"<code>convert_matrix_to_4x4_list(value)</code>","text":"<p>Convert matrix or flat list to 4x4 matrix list Example:     &gt;&gt;&gt; convert_matrix_to_4x4_list(om.MMatrix())     [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]     &gt;&gt;&gt; convert_matrix_to_4x4_list(     ... [1, 0, 0, 0,     ...  0, 1, 0, 0,     ...  0, 0, 1, 0,     ...  0, 0, 0, 1]     ... )     [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]</p> Source code in <code>client/ayon_maya/plugins/publish/extract_layout.py</code> <pre><code>def convert_matrix_to_4x4_list(\n        value) -&gt; List[List[float]]:\n    \"\"\"Convert matrix or flat list to 4x4 matrix list\n    Example:\n        &gt;&gt;&gt; convert_matrix_to_4x4_list(om.MMatrix())\n        [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]\n        &gt;&gt;&gt; convert_matrix_to_4x4_list(\n        ... [1, 0, 0, 0,\n        ...  0, 1, 0, 0,\n        ...  0, 0, 1, 0,\n        ...  0, 0, 0, 1]\n        ... )\n        [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]\n    \"\"\"\n    result = []\n    value = list(value)\n    for i in range(0, len(value), 4):\n        result.append(list(value[i:i + 4]))\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_layout.html#client.ayon_maya.plugins.publish.extract_layout.extract_number_from_namespace","title":"<code>extract_number_from_namespace(namespace)</code>","text":"<p>Extracts a number from the namespace.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str</code> <p>namespace</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>namespace number</p> Source code in <code>client/ayon_maya/plugins/publish/extract_layout.py</code> <pre><code>def extract_number_from_namespace(namespace):\n    \"\"\"Extracts a number from the namespace.\n\n    Args:\n        namespace (str): namespace\n\n    Returns:\n        int: namespace number\n    \"\"\"\n    matches = re.findall(r'(\\d+)', namespace)\n    return int(matches[-1]) if matches else 0\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_layout.html#client.ayon_maya.plugins.publish.extract_layout.is_valid_uuid","title":"<code>is_valid_uuid(value)</code>","text":"<p>Return whether value is a valid UUID</p> Source code in <code>client/ayon_maya/plugins/publish/extract_layout.py</code> <pre><code>def is_valid_uuid(value) -&gt; bool:\n    \"\"\"Return whether value is a valid UUID\"\"\"\n    try:\n        uuid.UUID(value)\n    except ValueError:\n        return False\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_look.html","title":"extract_look","text":"<p>Maya look extractor.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_look.html#client.ayon_maya.plugins.publish.extract_look.ExtractLook","title":"<code>ExtractLook</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extract Look (Maya Scene + JSON)</p> <p>Only extracts the sets (shadingEngines and alike) alongside a .json file that stores it relationships for the sets and \"attribute\" data for the instance members.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_look.py</code> <pre><code>class ExtractLook(plugin.MayaExtractorPlugin):\n    \"\"\"Extract Look (Maya Scene + JSON)\n\n    Only extracts the sets (shadingEngines and alike) alongside a .json file\n    that stores it relationships for the sets and \"attribute\" data for the\n    instance members.\n\n    \"\"\"\n\n    label = \"Extract Look (Maya Scene + JSON)\"\n    hosts = [\"maya\"]\n    families = [\"look\", \"mvLook\"]\n    order = pyblish.api.ExtractorOrder + 0.2\n    scene_type = \"ma\"\n    look_data_type = \"json\"\n\n    def get_maya_scene_type(self, instance):\n        \"\"\"Get Maya scene type from settings.\n\n        Args:\n            instance (pyblish.api.Instance): Instance with collected\n                project settings.\n\n        \"\"\"\n        maya_settings = instance.context.data[\"project_settings\"][\"maya\"]\n        ext_mapping = {\n            item[\"name\"]: item[\"value\"]\n            for item in maya_settings[\"ext_mapping\"]\n        }\n        if ext_mapping:\n            self.log.debug(\"Looking in settings for scene type ...\")\n            # use extension mapping for first family found\n            for family in self.families:\n                try:\n                    self.scene_type = ext_mapping[family]\n                    self.log.debug(\n                        \"Using {} as scene type\".format(self.scene_type))\n                    break\n                except KeyError:\n                    # no preset found\n                    pass\n\n        return \"mayaAscii\" if self.scene_type == \"ma\" else \"mayaBinary\"\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\n\n        Args:\n            instance: Instance to process.\n\n        \"\"\"\n        _scene_type = self.get_maya_scene_type(instance)\n\n        # Define extract output file path\n        dir_path = self.staging_dir(instance)\n        maya_fname = \"{0}.{1}\".format(instance.name, self.scene_type)\n        json_fname = \"{0}.{1}\".format(instance.name, self.look_data_type)\n        maya_path = os.path.join(dir_path, maya_fname)\n        json_path = os.path.join(dir_path, json_fname)\n\n        # Remove all members of the sets so they are not included in the\n        # exported file by accident\n        self.log.debug(\"Processing sets..\")\n        lookdata = instance.data[\"lookData\"]\n        relationships = lookdata[\"relationships\"]\n        sets = list(relationships.keys())\n        if not sets:\n            self.log.debug(\"No sets found for the look\")\n            return\n\n        texture_objs = instance.data.get(\"textureReferenceObjects\", [])\n        # Specify texture processing executables to activate\n        # TODO: Load these more dynamically once we support more processors\n        processors = []\n        context = instance.context\n        for key, Processor in {\n            # Instance data key to texture processor mapping\n            \"maketx\": MakeTX,\n            \"rstex\": MakeRSTexBin\n        }.items():\n            if instance.data.get(key, False):\n                processor = Processor(log=self.log)\n                processor.apply_settings(context.data[\"project_settings\"])\n                processors.append(processor)\n\n        if processors:\n            self.log.debug(\"Collected texture processors: \"\n                           \"{}\".format(processors))\n\n        self.log.debug(\"Processing resources..\")\n        results = self.process_resources(instance,\n                                         staging_dir=dir_path,\n                                         processors=processors)\n        transfers = results[\"fileTransfers\"]\n        hardlinks = results[\"fileHardlinks\"]\n        hashes = results[\"fileHashes\"]\n        remap = results[\"attrRemap\"]\n\n        # Extract in correct render layer\n        self.log.debug(\"Extracting look maya scene file: {}\".format(maya_path))\n        layer = instance.data.get(\"renderlayer\", \"defaultRenderLayer\")\n        with lib.renderlayer(layer):\n            # TODO: Ensure membership edits don't become renderlayer overrides\n            with lib.empty_sets(sets, force=True):\n                # To avoid Maya trying to automatically remap the file\n                # textures relative to the `workspace -directory` we force\n                # it to a fake temporary workspace. This fixes textures\n                # getting incorrectly remapped.\n                with no_workspace_dir():\n                    with lib.attribute_values(remap):\n                        with lib.maintained_selection():\n                            # texture reference objects would publish along with\n                            # construction history and constraints\n                            cmds.select(sets + texture_objs, noExpand=True)\n                            cmds.file(\n                                maya_path,\n                                force=True,\n                                typ=_scene_type,\n                                exportSelected=True,\n                                preserveReferences=False,\n                                channels=True,\n                                constraints=True,\n                                expressions=True,\n                                constructionHistory=True,\n                            )\n\n        # Write the JSON data\n        data = {\n            \"attributes\": lookdata[\"attributes\"],\n            \"relationships\": relationships\n        }\n        if instance.data.get(\"includeTextureReferenceObjects\"):\n            data[\"connections\"] = lookdata[\"connections\"]\n\n        self.log.debug(\"Extracting json file: {}\".format(json_path))\n        with open(json_path, \"w\") as f:\n            json.dump(data, f)\n\n        if \"files\" not in instance.data:\n            instance.data[\"files\"] = []\n        if \"hardlinks\" not in instance.data:\n            instance.data[\"hardlinks\"] = []\n        if \"transfers\" not in instance.data:\n            instance.data[\"transfers\"] = []\n\n        instance.data[\"files\"].append(maya_fname)\n        instance.data[\"files\"].append(json_fname)\n\n        if instance.data.get(\"representations\") is None:\n            instance.data[\"representations\"] = []\n\n        instance.data[\"representations\"].append(\n            {\n                \"name\": self.scene_type,\n                \"ext\": self.scene_type,\n                \"files\": os.path.basename(maya_fname),\n                \"stagingDir\": os.path.dirname(maya_fname),\n            }\n        )\n        instance.data[\"representations\"].append(\n            {\n                \"name\": self.look_data_type,\n                \"ext\": self.look_data_type,\n                \"files\": os.path.basename(json_fname),\n                \"stagingDir\": os.path.dirname(json_fname),\n            }\n        )\n\n        # Set up the resources transfers/links for the integrator\n        instance.data[\"transfers\"].extend(transfers)\n        instance.data[\"hardlinks\"].extend(hardlinks)\n\n        # Source hash for the textures\n        instance.data[\"sourceHashes\"] = hashes\n\n        self.log.debug(\"Extracted instance '%s' to: %s\" % (instance.name,\n                                                           maya_path))\n\n    def _set_resource_result_colorspace(self, resource, colorspace):\n        \"\"\"Update resource resulting colorspace after texture processing\"\"\"\n        if \"result_color_space\" in resource:\n            if resource[\"result_color_space\"] == colorspace:\n                return\n\n            self.log.warning(\n                \"Resource already has a resulting colorspace but is now \"\n                \"being overridden to a new one: {} -&gt; {}\".format(\n                    resource[\"result_color_space\"], colorspace\n                )\n            )\n        resource[\"result_color_space\"] = colorspace\n\n    def process_resources(self, instance, staging_dir, processors):\n        \"\"\"Process all resources in the instance.\n\n        It is assumed that all resources are nodes using file textures.\n\n        Extract the textures to transfer, possibly convert with maketx and\n        remap the node paths to the destination path. Note that a source\n        might be included more than once amongst the resources as they could\n        be the input file to multiple nodes.\n\n        \"\"\"\n\n        resources = instance.data[\"resources\"]\n        color_management = lib.get_color_management_preferences()\n\n        # TODO: Temporary disable all hardlinking, due to the feature not being\n        # used or properly working.\n        self.log.info(\n            \"Forcing copy instead of hardlink.\"\n        )\n        force_copy = True\n\n        if not force_copy and platform.system().lower() == \"windows\":\n            # Temporary fix to NOT create hardlinks on windows machines\n            self.log.warning(\n                \"Forcing copy instead of hardlink due to issues on Windows...\"\n            )\n            force_copy = True\n\n        destinations_cache = {}\n\n        def get_resource_destination_cached(path):\n            \"\"\"Get resource destination with cached result per filepath\"\"\"\n            if path not in destinations_cache:\n                destination = self.get_resource_destination(\n                    path, instance.data[\"resourcesDir\"], processors)\n                destinations_cache[path] = destination\n            return destinations_cache[path]\n\n        # Process all resource's individual files\n        processed_files = {}\n        transfers = []\n        hardlinks = []\n        hashes = {}\n        remap = OrderedDict()\n        for resource in resources:\n            colorspace = resource[\"color_space\"]\n\n            for filepath in resource[\"files\"]:\n                filepath = os.path.normpath(filepath)\n\n                if filepath in processed_files:\n                    # The file was already processed, likely due to usage by\n                    # another resource in the scene. We confirm here it\n                    # didn't do color spaces different than the current\n                    # resource.\n                    processed_file = processed_files[filepath]\n                    self.log.debug(\n                        \"File was already processed. Likely used by another \"\n                        \"resource too: {}\".format(filepath)\n                    )\n\n                    if colorspace != processed_file[\"color_space\"]:\n                        self.log.warning(\n                            \"File '{}' was already processed using colorspace \"\n                            \"'{}' instead of the current resource's \"\n                            \"colorspace '{}'. The already processed texture \"\n                            \"result's colorspace '{}' will be used.\"\n                            \"\".format(filepath,\n                                      colorspace,\n                                      processed_file[\"color_space\"],\n                                      processed_file[\"result_color_space\"]))\n\n                    self._set_resource_result_colorspace(\n                        resource,\n                        colorspace=processed_file[\"result_color_space\"]\n                    )\n                    continue\n\n                texture_result = self._process_texture(\n                    filepath,\n                    processors=processors,\n                    staging_dir=staging_dir,\n                    force_copy=force_copy,\n                    color_management=color_management,\n                    colorspace=colorspace\n                )\n\n                # Set the resulting color space on the resource\n                self._set_resource_result_colorspace(\n                    resource, colorspace=texture_result.colorspace\n                )\n\n                processed_files[filepath] = {\n                    \"color_space\": colorspace,\n                    \"result_color_space\": texture_result.colorspace,\n                }\n\n                source = texture_result.path\n                destination = get_resource_destination_cached(source)\n                if force_copy or texture_result.transfer_mode == COPY:\n                    transfers.append((source, destination))\n                    self.log.debug('file will be copied {} -&gt; {}'.format(\n                        source, destination))\n                elif texture_result.transfer_mode == HARDLINK:\n                    hardlinks.append((source, destination))\n                    self.log.debug('file will be hardlinked {} -&gt; {}'.format(\n                        source, destination))\n\n                # Store the hashes from hash to destination to include in the\n                # database\n                hashes[texture_result.file_hash] = destination\n\n            # Set up remapping attributes for the node during the publish\n            # The order of these can be important if one attribute directly\n            # affects another, e.g. we set colorspace after filepath because\n            # maya sometimes tries to guess the colorspace when changing\n            # filepaths (which is avoidable, but we don't want to have those\n            # attributes changed in the resulting publish)\n            # Remap filepath to publish destination\n            # TODO It would be much better if we could use the destination path\n            #   from the actual processed texture results, but since the\n            #   attribute will need to preserve tokens like &lt;f&gt;, &lt;udim&gt; etc for\n            #   now we will define the output path from the attribute value\n            #   including the tokens to persist them.\n            filepath_attr = resource[\"attribute\"]\n            remap[filepath_attr] = get_resource_destination_cached(\n                resource[\"source\"]\n            )\n\n            # Preserve color space values (force value after filepath change)\n            # This will also trigger in the same order at end of context to\n            # ensure after context it's still the original value.\n            node = resource[\"node\"]\n            if cmds.attributeQuery(\"colorSpace\", node=node, exists=True):\n                color_space_attr = \"{}.colorSpace\".format(node)\n                remap[color_space_attr] = resource[\"result_color_space\"]\n\n        self.log.debug(\"Finished remapping destinations ...\")\n\n        return {\n            \"fileTransfers\": transfers,\n            \"fileHardlinks\": hardlinks,\n            \"fileHashes\": hashes,\n            \"attrRemap\": remap,\n        }\n\n    def get_resource_destination(self, filepath, resources_dir, processors):\n        \"\"\"Get resource destination path.\n\n        This is utility function to change path if resource file name is\n        changed by some external tool like `maketx`.\n\n        Args:\n            filepath (str): Resource source path\n            resources_dir (str): Destination dir for resources in publish.\n            processors (list): Texture processors converting resource.\n\n        Returns:\n            str: Path to resource file\n\n        \"\"\"\n        # Compute destination location\n        basename, ext = os.path.splitext(os.path.basename(filepath))\n\n        # Get extension from the last processor\n        for processor in reversed(processors):\n            processor_ext = processor.extension\n            if processor_ext and ext != processor_ext:\n                self.log.debug(\"Processor {} overrides extension to '{}' \"\n                               \"for path: {}\".format(processor,\n                                                     processor_ext,\n                                                     filepath))\n                ext = processor_ext\n            break\n\n        return os.path.join(\n            resources_dir, basename + ext\n        )\n\n    def _get_existing_hashed_texture(self, texture_hash):\n        \"\"\"Return the first found filepath from a texture hash\"\"\"\n\n        # If source has been published before with the same settings,\n        # then don't reprocess but hardlink from the original\n        existing = find_paths_by_hash(texture_hash)\n        if existing:\n            source = next((p for p in existing if os.path.exists(p)), None)\n            if source:\n                return source\n            else:\n                self.log.warning(\n                    \"Paths not found on disk, \"\n                    \"skipping hardlink: {}\".format(existing)\n                )\n\n    def _process_texture(self,\n                         filepath,\n                         processors,\n                         staging_dir,\n                         force_copy,\n                         color_management,\n                         colorspace):\n        \"\"\"Process a single texture file on disk for publishing.\n\n        This will:\n            1. Check whether it's already published, if so it will do hardlink\n                (if the texture hash is found and force copy is not enabled)\n            2. It will process the texture using the supplied texture\n                processors like MakeTX and MakeRSTexBin if enabled.\n            3. Compute the destination path for the source file.\n\n        Args:\n            filepath (str): The source file path to process.\n            processors (list): List of TextureProcessor processing the texture\n            staging_dir (str): The staging directory to write to.\n            force_copy (bool): Whether to force a copy even if a file hash\n                might have existed already in the project, otherwise\n                hardlinking the existing file is allowed.\n            color_management (dict): Maya's Color Management settings from\n                `lib.get_color_management_preferences`\n            colorspace (str): The source colorspace of the resources this\n                texture belongs to.\n\n        Returns:\n            TextureResult: The texture result information.\n        \"\"\"\n\n        if len(processors) &gt; 1:\n            raise KnownPublishError(\n                \"More than one texture processor not supported. \"\n                \"Current processors enabled: {}\".format(processors)\n            )\n\n        for processor in processors:\n            self.log.debug(\"Processing texture {} with processor {}\".format(\n                filepath, processor\n            ))\n\n            processed_result = processor.process(filepath,\n                                                 colorspace,\n                                                 color_management,\n                                                 staging_dir)\n            if not processed_result:\n                raise RuntimeError(\"Texture Processor {} returned \"\n                                   \"no result.\".format(processor))\n            self.log.debug(\"Generated processed \"\n                           \"texture: {}\".format(processed_result.path))\n\n            # TODO: Currently all processors force copy instead of allowing\n            #       hardlinks using source hashes. This should be refactored\n            return processed_result\n\n        # No texture processing for this file\n        texture_hash = source_hash(filepath)\n        if not force_copy:\n            existing = self._get_existing_hashed_texture(filepath)\n            if existing:\n                self.log.debug(\"Found hash in database, preparing hardlink..\")\n                return TextureResult(\n                    path=filepath,\n                    file_hash=texture_hash,\n                    colorspace=colorspace,\n                    transfer_mode=HARDLINK\n                )\n\n        return TextureResult(\n            path=filepath,\n            file_hash=texture_hash,\n            colorspace=colorspace,\n            transfer_mode=COPY\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_look.html#client.ayon_maya.plugins.publish.extract_look.ExtractLook.get_maya_scene_type","title":"<code>get_maya_scene_type(instance)</code>","text":"<p>Get Maya scene type from settings.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>Instance with collected project settings.</p> required Source code in <code>client/ayon_maya/plugins/publish/extract_look.py</code> <pre><code>def get_maya_scene_type(self, instance):\n    \"\"\"Get Maya scene type from settings.\n\n    Args:\n        instance (pyblish.api.Instance): Instance with collected\n            project settings.\n\n    \"\"\"\n    maya_settings = instance.context.data[\"project_settings\"][\"maya\"]\n    ext_mapping = {\n        item[\"name\"]: item[\"value\"]\n        for item in maya_settings[\"ext_mapping\"]\n    }\n    if ext_mapping:\n        self.log.debug(\"Looking in settings for scene type ...\")\n        # use extension mapping for first family found\n        for family in self.families:\n            try:\n                self.scene_type = ext_mapping[family]\n                self.log.debug(\n                    \"Using {} as scene type\".format(self.scene_type))\n                break\n            except KeyError:\n                # no preset found\n                pass\n\n    return \"mayaAscii\" if self.scene_type == \"ma\" else \"mayaBinary\"\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_look.html#client.ayon_maya.plugins.publish.extract_look.ExtractLook.get_resource_destination","title":"<code>get_resource_destination(filepath, resources_dir, processors)</code>","text":"<p>Get resource destination path.</p> <p>This is utility function to change path if resource file name is changed by some external tool like <code>maketx</code>.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Resource source path</p> required <code>resources_dir</code> <code>str</code> <p>Destination dir for resources in publish.</p> required <code>processors</code> <code>list</code> <p>Texture processors converting resource.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Path to resource file</p> Source code in <code>client/ayon_maya/plugins/publish/extract_look.py</code> <pre><code>def get_resource_destination(self, filepath, resources_dir, processors):\n    \"\"\"Get resource destination path.\n\n    This is utility function to change path if resource file name is\n    changed by some external tool like `maketx`.\n\n    Args:\n        filepath (str): Resource source path\n        resources_dir (str): Destination dir for resources in publish.\n        processors (list): Texture processors converting resource.\n\n    Returns:\n        str: Path to resource file\n\n    \"\"\"\n    # Compute destination location\n    basename, ext = os.path.splitext(os.path.basename(filepath))\n\n    # Get extension from the last processor\n    for processor in reversed(processors):\n        processor_ext = processor.extension\n        if processor_ext and ext != processor_ext:\n            self.log.debug(\"Processor {} overrides extension to '{}' \"\n                           \"for path: {}\".format(processor,\n                                                 processor_ext,\n                                                 filepath))\n            ext = processor_ext\n        break\n\n    return os.path.join(\n        resources_dir, basename + ext\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_look.html#client.ayon_maya.plugins.publish.extract_look.ExtractLook.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <p>Instance to process.</p> required Source code in <code>client/ayon_maya/plugins/publish/extract_look.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\n\n    Args:\n        instance: Instance to process.\n\n    \"\"\"\n    _scene_type = self.get_maya_scene_type(instance)\n\n    # Define extract output file path\n    dir_path = self.staging_dir(instance)\n    maya_fname = \"{0}.{1}\".format(instance.name, self.scene_type)\n    json_fname = \"{0}.{1}\".format(instance.name, self.look_data_type)\n    maya_path = os.path.join(dir_path, maya_fname)\n    json_path = os.path.join(dir_path, json_fname)\n\n    # Remove all members of the sets so they are not included in the\n    # exported file by accident\n    self.log.debug(\"Processing sets..\")\n    lookdata = instance.data[\"lookData\"]\n    relationships = lookdata[\"relationships\"]\n    sets = list(relationships.keys())\n    if not sets:\n        self.log.debug(\"No sets found for the look\")\n        return\n\n    texture_objs = instance.data.get(\"textureReferenceObjects\", [])\n    # Specify texture processing executables to activate\n    # TODO: Load these more dynamically once we support more processors\n    processors = []\n    context = instance.context\n    for key, Processor in {\n        # Instance data key to texture processor mapping\n        \"maketx\": MakeTX,\n        \"rstex\": MakeRSTexBin\n    }.items():\n        if instance.data.get(key, False):\n            processor = Processor(log=self.log)\n            processor.apply_settings(context.data[\"project_settings\"])\n            processors.append(processor)\n\n    if processors:\n        self.log.debug(\"Collected texture processors: \"\n                       \"{}\".format(processors))\n\n    self.log.debug(\"Processing resources..\")\n    results = self.process_resources(instance,\n                                     staging_dir=dir_path,\n                                     processors=processors)\n    transfers = results[\"fileTransfers\"]\n    hardlinks = results[\"fileHardlinks\"]\n    hashes = results[\"fileHashes\"]\n    remap = results[\"attrRemap\"]\n\n    # Extract in correct render layer\n    self.log.debug(\"Extracting look maya scene file: {}\".format(maya_path))\n    layer = instance.data.get(\"renderlayer\", \"defaultRenderLayer\")\n    with lib.renderlayer(layer):\n        # TODO: Ensure membership edits don't become renderlayer overrides\n        with lib.empty_sets(sets, force=True):\n            # To avoid Maya trying to automatically remap the file\n            # textures relative to the `workspace -directory` we force\n            # it to a fake temporary workspace. This fixes textures\n            # getting incorrectly remapped.\n            with no_workspace_dir():\n                with lib.attribute_values(remap):\n                    with lib.maintained_selection():\n                        # texture reference objects would publish along with\n                        # construction history and constraints\n                        cmds.select(sets + texture_objs, noExpand=True)\n                        cmds.file(\n                            maya_path,\n                            force=True,\n                            typ=_scene_type,\n                            exportSelected=True,\n                            preserveReferences=False,\n                            channels=True,\n                            constraints=True,\n                            expressions=True,\n                            constructionHistory=True,\n                        )\n\n    # Write the JSON data\n    data = {\n        \"attributes\": lookdata[\"attributes\"],\n        \"relationships\": relationships\n    }\n    if instance.data.get(\"includeTextureReferenceObjects\"):\n        data[\"connections\"] = lookdata[\"connections\"]\n\n    self.log.debug(\"Extracting json file: {}\".format(json_path))\n    with open(json_path, \"w\") as f:\n        json.dump(data, f)\n\n    if \"files\" not in instance.data:\n        instance.data[\"files\"] = []\n    if \"hardlinks\" not in instance.data:\n        instance.data[\"hardlinks\"] = []\n    if \"transfers\" not in instance.data:\n        instance.data[\"transfers\"] = []\n\n    instance.data[\"files\"].append(maya_fname)\n    instance.data[\"files\"].append(json_fname)\n\n    if instance.data.get(\"representations\") is None:\n        instance.data[\"representations\"] = []\n\n    instance.data[\"representations\"].append(\n        {\n            \"name\": self.scene_type,\n            \"ext\": self.scene_type,\n            \"files\": os.path.basename(maya_fname),\n            \"stagingDir\": os.path.dirname(maya_fname),\n        }\n    )\n    instance.data[\"representations\"].append(\n        {\n            \"name\": self.look_data_type,\n            \"ext\": self.look_data_type,\n            \"files\": os.path.basename(json_fname),\n            \"stagingDir\": os.path.dirname(json_fname),\n        }\n    )\n\n    # Set up the resources transfers/links for the integrator\n    instance.data[\"transfers\"].extend(transfers)\n    instance.data[\"hardlinks\"].extend(hardlinks)\n\n    # Source hash for the textures\n    instance.data[\"sourceHashes\"] = hashes\n\n    self.log.debug(\"Extracted instance '%s' to: %s\" % (instance.name,\n                                                       maya_path))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_look.html#client.ayon_maya.plugins.publish.extract_look.ExtractLook.process_resources","title":"<code>process_resources(instance, staging_dir, processors)</code>","text":"<p>Process all resources in the instance.</p> <p>It is assumed that all resources are nodes using file textures.</p> <p>Extract the textures to transfer, possibly convert with maketx and remap the node paths to the destination path. Note that a source might be included more than once amongst the resources as they could be the input file to multiple nodes.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_look.py</code> <pre><code>def process_resources(self, instance, staging_dir, processors):\n    \"\"\"Process all resources in the instance.\n\n    It is assumed that all resources are nodes using file textures.\n\n    Extract the textures to transfer, possibly convert with maketx and\n    remap the node paths to the destination path. Note that a source\n    might be included more than once amongst the resources as they could\n    be the input file to multiple nodes.\n\n    \"\"\"\n\n    resources = instance.data[\"resources\"]\n    color_management = lib.get_color_management_preferences()\n\n    # TODO: Temporary disable all hardlinking, due to the feature not being\n    # used or properly working.\n    self.log.info(\n        \"Forcing copy instead of hardlink.\"\n    )\n    force_copy = True\n\n    if not force_copy and platform.system().lower() == \"windows\":\n        # Temporary fix to NOT create hardlinks on windows machines\n        self.log.warning(\n            \"Forcing copy instead of hardlink due to issues on Windows...\"\n        )\n        force_copy = True\n\n    destinations_cache = {}\n\n    def get_resource_destination_cached(path):\n        \"\"\"Get resource destination with cached result per filepath\"\"\"\n        if path not in destinations_cache:\n            destination = self.get_resource_destination(\n                path, instance.data[\"resourcesDir\"], processors)\n            destinations_cache[path] = destination\n        return destinations_cache[path]\n\n    # Process all resource's individual files\n    processed_files = {}\n    transfers = []\n    hardlinks = []\n    hashes = {}\n    remap = OrderedDict()\n    for resource in resources:\n        colorspace = resource[\"color_space\"]\n\n        for filepath in resource[\"files\"]:\n            filepath = os.path.normpath(filepath)\n\n            if filepath in processed_files:\n                # The file was already processed, likely due to usage by\n                # another resource in the scene. We confirm here it\n                # didn't do color spaces different than the current\n                # resource.\n                processed_file = processed_files[filepath]\n                self.log.debug(\n                    \"File was already processed. Likely used by another \"\n                    \"resource too: {}\".format(filepath)\n                )\n\n                if colorspace != processed_file[\"color_space\"]:\n                    self.log.warning(\n                        \"File '{}' was already processed using colorspace \"\n                        \"'{}' instead of the current resource's \"\n                        \"colorspace '{}'. The already processed texture \"\n                        \"result's colorspace '{}' will be used.\"\n                        \"\".format(filepath,\n                                  colorspace,\n                                  processed_file[\"color_space\"],\n                                  processed_file[\"result_color_space\"]))\n\n                self._set_resource_result_colorspace(\n                    resource,\n                    colorspace=processed_file[\"result_color_space\"]\n                )\n                continue\n\n            texture_result = self._process_texture(\n                filepath,\n                processors=processors,\n                staging_dir=staging_dir,\n                force_copy=force_copy,\n                color_management=color_management,\n                colorspace=colorspace\n            )\n\n            # Set the resulting color space on the resource\n            self._set_resource_result_colorspace(\n                resource, colorspace=texture_result.colorspace\n            )\n\n            processed_files[filepath] = {\n                \"color_space\": colorspace,\n                \"result_color_space\": texture_result.colorspace,\n            }\n\n            source = texture_result.path\n            destination = get_resource_destination_cached(source)\n            if force_copy or texture_result.transfer_mode == COPY:\n                transfers.append((source, destination))\n                self.log.debug('file will be copied {} -&gt; {}'.format(\n                    source, destination))\n            elif texture_result.transfer_mode == HARDLINK:\n                hardlinks.append((source, destination))\n                self.log.debug('file will be hardlinked {} -&gt; {}'.format(\n                    source, destination))\n\n            # Store the hashes from hash to destination to include in the\n            # database\n            hashes[texture_result.file_hash] = destination\n\n        # Set up remapping attributes for the node during the publish\n        # The order of these can be important if one attribute directly\n        # affects another, e.g. we set colorspace after filepath because\n        # maya sometimes tries to guess the colorspace when changing\n        # filepaths (which is avoidable, but we don't want to have those\n        # attributes changed in the resulting publish)\n        # Remap filepath to publish destination\n        # TODO It would be much better if we could use the destination path\n        #   from the actual processed texture results, but since the\n        #   attribute will need to preserve tokens like &lt;f&gt;, &lt;udim&gt; etc for\n        #   now we will define the output path from the attribute value\n        #   including the tokens to persist them.\n        filepath_attr = resource[\"attribute\"]\n        remap[filepath_attr] = get_resource_destination_cached(\n            resource[\"source\"]\n        )\n\n        # Preserve color space values (force value after filepath change)\n        # This will also trigger in the same order at end of context to\n        # ensure after context it's still the original value.\n        node = resource[\"node\"]\n        if cmds.attributeQuery(\"colorSpace\", node=node, exists=True):\n            color_space_attr = \"{}.colorSpace\".format(node)\n            remap[color_space_attr] = resource[\"result_color_space\"]\n\n    self.log.debug(\"Finished remapping destinations ...\")\n\n    return {\n        \"fileTransfers\": transfers,\n        \"fileHardlinks\": hardlinks,\n        \"fileHashes\": hashes,\n        \"attrRemap\": remap,\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_look.html#client.ayon_maya.plugins.publish.extract_look.ExtractModelRenderSets","title":"<code>ExtractModelRenderSets</code>","text":"<p>               Bases: <code>ExtractLook</code></p> <p>Extract model render attribute sets as model metadata</p> <p>Only extracts the render attrib sets (NO shadingEngines) alongside a .json file that stores it relationships for the sets and \"attribute\" data for the instance members.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_look.py</code> <pre><code>class ExtractModelRenderSets(ExtractLook):\n    \"\"\"Extract model render attribute sets as model metadata\n\n    Only extracts the render attrib sets (NO shadingEngines) alongside\n    a .json file that stores it relationships for the sets and \"attribute\"\n    data for the instance members.\n\n    \"\"\"\n\n    label = \"Model Render Sets\"\n    hosts = [\"maya\"]\n    families = [\"model\"]\n    scene_type_prefix = \"meta.render.\"\n    look_data_type = \"meta.render.json\"\n\n    def get_maya_scene_type(self, instance):\n        typ = super(ExtractModelRenderSets, self).get_maya_scene_type(instance)\n        # add prefix\n        self.scene_type = self.scene_type_prefix + self.scene_type\n\n        return typ\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_look.html#client.ayon_maya.plugins.publish.extract_look.MakeRSTexBin","title":"<code>MakeRSTexBin</code>","text":"<p>               Bases: <code>TextureProcessor</code></p> <p>Make <code>.rstexbin</code> using <code>redshiftTextureProcessor</code></p> Source code in <code>client/ayon_maya/plugins/publish/extract_look.py</code> <pre><code>class MakeRSTexBin(TextureProcessor):\n    \"\"\"Make `.rstexbin` using `redshiftTextureProcessor`\"\"\"\n\n    extension = \".rstexbin\"\n\n    def process(self,\n                source,\n                colorspace,\n                color_management,\n                staging_dir):\n\n        texture_processor_path = self.get_redshift_tool(\n            \"redshiftTextureProcessor\"\n        )\n        if not texture_processor_path:\n            raise KnownPublishError(\"Must have Redshift available.\")\n\n        subprocess_args = [\n            texture_processor_path,\n            source\n        ]\n\n        # if color management is enabled we pass color space information\n        if color_management[\"enabled\"]:\n            config_path = color_management[\"config\"]\n            if not os.path.exists(config_path):\n                raise RuntimeError(\"OCIO config not found at: \"\n                                   \"{}\".format(config_path))\n\n            if not os.getenv(\"OCIO\"):\n                self.log.debug(\n                    \"OCIO environment variable not set.\"\n                    \"Setting it with OCIO config from Maya.\"\n                )\n                os.environ[\"OCIO\"] = config_path\n\n            self.log.debug(\"converting colorspace {0} to redshift render \"\n                           \"colorspace\".format(colorspace))\n            subprocess_args.extend([\"-cs\", colorspace])\n\n        hash_args = [\"rstex\"]\n        texture_hash = source_hash(source, *hash_args)\n\n        # Redshift stores the output texture next to the input but with\n        # the extension replaced to `.rstexbin`\n        basename, ext = os.path.splitext(source)\n        destination = \"{}{}\".format(basename, self.extension)\n\n        self.log.debug(\" \".join(subprocess_args))\n        try:\n            run_subprocess(subprocess_args, logger=self.log)\n        except Exception:\n            self.log.error(\"Texture .rstexbin conversion failed\",\n                           exc_info=True)\n            raise\n\n        return TextureResult(\n            path=destination,\n            file_hash=texture_hash,\n            colorspace=colorspace,\n            transfer_mode=COPY\n        )\n\n    @staticmethod\n    def get_redshift_tool(tool_name):\n        \"\"\"Path to redshift texture processor.\n\n        On Windows it adds .exe extension if missing from tool argument.\n\n        Args:\n            tool_name (string): Tool name.\n\n        Returns:\n            str: Full path to redshift texture processor executable.\n        \"\"\"\n        if \"REDSHIFT_COREDATAPATH\" not in os.environ:\n            raise RuntimeError(\"Must have Redshift available.\")\n\n        redshift_tool_path = os.path.join(\n            os.environ[\"REDSHIFT_COREDATAPATH\"],\n            \"bin\",\n            tool_name\n        )\n\n        return find_executable(redshift_tool_path)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_look.html#client.ayon_maya.plugins.publish.extract_look.MakeRSTexBin.get_redshift_tool","title":"<code>get_redshift_tool(tool_name)</code>  <code>staticmethod</code>","text":"<p>Path to redshift texture processor.</p> <p>On Windows it adds .exe extension if missing from tool argument.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>string</code> <p>Tool name.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Full path to redshift texture processor executable.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_look.py</code> <pre><code>@staticmethod\ndef get_redshift_tool(tool_name):\n    \"\"\"Path to redshift texture processor.\n\n    On Windows it adds .exe extension if missing from tool argument.\n\n    Args:\n        tool_name (string): Tool name.\n\n    Returns:\n        str: Full path to redshift texture processor executable.\n    \"\"\"\n    if \"REDSHIFT_COREDATAPATH\" not in os.environ:\n        raise RuntimeError(\"Must have Redshift available.\")\n\n    redshift_tool_path = os.path.join(\n        os.environ[\"REDSHIFT_COREDATAPATH\"],\n        \"bin\",\n        tool_name\n    )\n\n    return find_executable(redshift_tool_path)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_look.html#client.ayon_maya.plugins.publish.extract_look.MakeTX","title":"<code>MakeTX</code>","text":"<p>               Bases: <code>TextureProcessor</code></p> <p>Make <code>.tx</code> using <code>maketx</code> with some default settings.</p> <p>Some hardcoded arguments passed to <code>maketx</code> are based on the defaults used in Arnold's txManager tool.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_look.py</code> <pre><code>class MakeTX(TextureProcessor):\n    \"\"\"Make `.tx` using `maketx` with some default settings.\n\n    Some hardcoded arguments passed to `maketx` are based on the defaults used\n    in Arnold's txManager tool.\n\n    \"\"\"\n\n    extension = \".tx\"\n\n    def __init__(self, log=None):\n        super(MakeTX, self).__init__(log=log)\n        self.extra_args = []\n\n    def apply_settings(self, project_settings):\n        # Allow extra maketx arguments from project settings\n        args_settings = (\n            project_settings[\"maya\"][\"publish\"]\n            .get(\"ExtractLook\", {}).get(\"maketx_arguments\", [])\n        )\n        extra_args = []\n        for arg_data in args_settings:\n            argument = arg_data[\"argument\"]\n            parameters = arg_data[\"parameters\"]\n            if not argument:\n                self.log.debug(\"Ignoring empty parameter from \"\n                               \"`maketx_arguments` setting..\")\n                continue\n\n            extra_args.append(argument)\n            extra_args.extend(parameters)\n\n        self.extra_args = extra_args\n\n    def process(self,\n                source,\n                colorspace,\n                color_management,\n                staging_dir):\n        \"\"\"Process the texture.\n\n        This function requires the `maketx` executable to be available in an\n        OpenImageIO toolset detectable by AYON.\n\n        Args:\n            source (str): Path to source file.\n            colorspace (str): Colorspace of the source file.\n            color_management (dict): Maya Color management data from\n                `lib.get_color_management_preferences`\n            staging_dir (str): Output directory to write to.\n\n        Returns:\n            TextureResult: The resulting texture information.\n\n        \"\"\"\n\n        try:\n            maketx_args = get_oiio_tool_args(\"maketx\")\n        except ToolNotFoundError:\n            raise KnownPublishError(\n                \"OpenImageIO is not available on the machine\")\n\n        # Define .tx filepath in staging if source file is not .tx\n        fname, ext = os.path.splitext(os.path.basename(source))\n        if ext == \".tx\":\n            # Do nothing if the source file is already a .tx file.\n            return TextureResult(\n                path=source,\n                file_hash=source_hash(source),\n                colorspace=colorspace,\n                transfer_mode=COPY\n            )\n\n        # Hardcoded default arguments for maketx conversion based on Arnold's\n        # txManager in Maya\n        args = [\n            # unpremultiply before conversion (recommended when alpha present)\n            \"--unpremult\",\n            # use oiio-optimized settings for tile-size, planarconfig, metadata\n            \"--oiio\",\n            \"--filter\", \"lanczos3\",\n        ]\n        if color_management[\"enabled\"]:\n            config_path = color_management[\"config\"]\n            if not os.path.exists(config_path):\n                raise RuntimeError(\"OCIO config not found at: \"\n                                   \"{}\".format(config_path))\n\n            render_colorspace = color_management[\"rendering_space\"]\n\n            self.log.debug(\"tx: converting colorspace {0} \"\n                          \"-&gt; {1}\".format(colorspace,\n                                          render_colorspace))\n            args.extend([\"--colorconvert\", colorspace, render_colorspace])\n            args.extend([\"--colorconfig\", config_path])\n\n        else:\n            # Maya Color management is disabled. We cannot rely on an OCIO\n            self.log.debug(\"tx: Maya color management is disabled. No color \"\n                           \"conversion will be applied to .tx conversion for: \"\n                           \"{}\".format(source))\n            # Assume linear\n            render_colorspace = \"linear\"\n\n        # Note: The texture hash is only reliable if we include any potential\n        # conversion arguments provide to e.g. `maketx`\n        hash_args = [\"maketx\"] + args + self.extra_args\n        texture_hash = source_hash(source, *hash_args)\n\n        # Ensure folder exists\n        resources_dir = os.path.join(staging_dir, \"resources\")\n        if not os.path.exists(resources_dir):\n            os.makedirs(resources_dir)\n\n        self.log.debug(\"Generating .tx file for %s ..\" % source)\n\n        subprocess_args = maketx_args + [\n            \"-v\",  # verbose\n            \"-u\",  # update mode\n            # --checknan doesn't influence the output file but aborts the\n            # conversion if it finds any. So we can avoid it for the file hash\n            \"--checknan\",\n            source\n        ]\n\n        subprocess_args.extend(args)\n        if self.extra_args:\n            subprocess_args.extend(self.extra_args)\n\n        # Add source hash attribute after other arguments for log readability\n        # Note: argument is excluded from the hash since it is the hash itself\n        subprocess_args.extend([\n            \"--sattrib\",\n            \"sourceHash\",\n            texture_hash\n        ])\n\n        destination = os.path.join(resources_dir, fname + \".tx\")\n        subprocess_args.extend([\"-o\", destination])\n\n        # We want to make sure we are explicit about what OCIO config gets\n        # used. So when we supply no --colorconfig flag that no fallback to\n        # an OCIO env var occurs.\n        env = os.environ.copy()\n        env.pop(\"OCIO\", None)\n\n        self.log.debug(\" \".join(subprocess_args))\n        try:\n            run_subprocess(subprocess_args, env=env)\n        except Exception:\n            self.log.error(\"Texture maketx conversion failed\",\n                           exc_info=True)\n            raise\n\n        return TextureResult(\n            path=destination,\n            file_hash=texture_hash,\n            colorspace=render_colorspace,\n            transfer_mode=COPY\n        )\n\n    @staticmethod\n    def _has_arnold():\n        \"\"\"Return whether the arnold package is available and importable.\"\"\"\n        try:\n            import arnold  # noqa: F401\n            return True\n        except (ImportError, ModuleNotFoundError):\n            return False\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_look.html#client.ayon_maya.plugins.publish.extract_look.MakeTX.process","title":"<code>process(source, colorspace, color_management, staging_dir)</code>","text":"<p>Process the texture.</p> <p>This function requires the <code>maketx</code> executable to be available in an OpenImageIO toolset detectable by AYON.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Path to source file.</p> required <code>colorspace</code> <code>str</code> <p>Colorspace of the source file.</p> required <code>color_management</code> <code>dict</code> <p>Maya Color management data from <code>lib.get_color_management_preferences</code></p> required <code>staging_dir</code> <code>str</code> <p>Output directory to write to.</p> required <p>Returns:</p> Name Type Description <code>TextureResult</code> <p>The resulting texture information.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_look.py</code> <pre><code>def process(self,\n            source,\n            colorspace,\n            color_management,\n            staging_dir):\n    \"\"\"Process the texture.\n\n    This function requires the `maketx` executable to be available in an\n    OpenImageIO toolset detectable by AYON.\n\n    Args:\n        source (str): Path to source file.\n        colorspace (str): Colorspace of the source file.\n        color_management (dict): Maya Color management data from\n            `lib.get_color_management_preferences`\n        staging_dir (str): Output directory to write to.\n\n    Returns:\n        TextureResult: The resulting texture information.\n\n    \"\"\"\n\n    try:\n        maketx_args = get_oiio_tool_args(\"maketx\")\n    except ToolNotFoundError:\n        raise KnownPublishError(\n            \"OpenImageIO is not available on the machine\")\n\n    # Define .tx filepath in staging if source file is not .tx\n    fname, ext = os.path.splitext(os.path.basename(source))\n    if ext == \".tx\":\n        # Do nothing if the source file is already a .tx file.\n        return TextureResult(\n            path=source,\n            file_hash=source_hash(source),\n            colorspace=colorspace,\n            transfer_mode=COPY\n        )\n\n    # Hardcoded default arguments for maketx conversion based on Arnold's\n    # txManager in Maya\n    args = [\n        # unpremultiply before conversion (recommended when alpha present)\n        \"--unpremult\",\n        # use oiio-optimized settings for tile-size, planarconfig, metadata\n        \"--oiio\",\n        \"--filter\", \"lanczos3\",\n    ]\n    if color_management[\"enabled\"]:\n        config_path = color_management[\"config\"]\n        if not os.path.exists(config_path):\n            raise RuntimeError(\"OCIO config not found at: \"\n                               \"{}\".format(config_path))\n\n        render_colorspace = color_management[\"rendering_space\"]\n\n        self.log.debug(\"tx: converting colorspace {0} \"\n                      \"-&gt; {1}\".format(colorspace,\n                                      render_colorspace))\n        args.extend([\"--colorconvert\", colorspace, render_colorspace])\n        args.extend([\"--colorconfig\", config_path])\n\n    else:\n        # Maya Color management is disabled. We cannot rely on an OCIO\n        self.log.debug(\"tx: Maya color management is disabled. No color \"\n                       \"conversion will be applied to .tx conversion for: \"\n                       \"{}\".format(source))\n        # Assume linear\n        render_colorspace = \"linear\"\n\n    # Note: The texture hash is only reliable if we include any potential\n    # conversion arguments provide to e.g. `maketx`\n    hash_args = [\"maketx\"] + args + self.extra_args\n    texture_hash = source_hash(source, *hash_args)\n\n    # Ensure folder exists\n    resources_dir = os.path.join(staging_dir, \"resources\")\n    if not os.path.exists(resources_dir):\n        os.makedirs(resources_dir)\n\n    self.log.debug(\"Generating .tx file for %s ..\" % source)\n\n    subprocess_args = maketx_args + [\n        \"-v\",  # verbose\n        \"-u\",  # update mode\n        # --checknan doesn't influence the output file but aborts the\n        # conversion if it finds any. So we can avoid it for the file hash\n        \"--checknan\",\n        source\n    ]\n\n    subprocess_args.extend(args)\n    if self.extra_args:\n        subprocess_args.extend(self.extra_args)\n\n    # Add source hash attribute after other arguments for log readability\n    # Note: argument is excluded from the hash since it is the hash itself\n    subprocess_args.extend([\n        \"--sattrib\",\n        \"sourceHash\",\n        texture_hash\n    ])\n\n    destination = os.path.join(resources_dir, fname + \".tx\")\n    subprocess_args.extend([\"-o\", destination])\n\n    # We want to make sure we are explicit about what OCIO config gets\n    # used. So when we supply no --colorconfig flag that no fallback to\n    # an OCIO env var occurs.\n    env = os.environ.copy()\n    env.pop(\"OCIO\", None)\n\n    self.log.debug(\" \".join(subprocess_args))\n    try:\n        run_subprocess(subprocess_args, env=env)\n    except Exception:\n        self.log.error(\"Texture maketx conversion failed\",\n                       exc_info=True)\n        raise\n\n    return TextureResult(\n        path=destination,\n        file_hash=texture_hash,\n        colorspace=render_colorspace,\n        transfer_mode=COPY\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_look.html#client.ayon_maya.plugins.publish.extract_look.TextureProcessor","title":"<code>TextureProcessor</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>client/ayon_maya/plugins/publish/extract_look.py</code> <pre><code>class TextureProcessor(ABC):\n\n    extension = None\n\n    def __init__(self, log=None):\n        if log is None:\n            log = logging.getLogger(self.__class__.__name__)\n        self.log = log\n\n    def apply_settings(self, project_settings):\n        \"\"\"Apply AYON system/project settings to the TextureProcessor\n\n        Args:\n            project_settings (dict): AYON project settings\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def process(self,\n                source,\n                colorspace,\n                color_management,\n                staging_dir):\n        \"\"\"Process the `source` texture.\n\n        Must be implemented on inherited class.\n\n        This must always return a TextureResult even when it does not generate\n        a texture. If it doesn't generate a texture then it should return a\n        TextureResult using the input path and colorspace.\n\n        Args:\n            source (str): Path to source file.\n            colorspace (str): Colorspace of the source file.\n            color_management (dict): Maya Color management data from\n                `lib.get_color_management_preferences`\n            staging_dir (str): Output directory to write to.\n\n        Returns:\n            TextureResult: The resulting texture information.\n\n        \"\"\"\n        pass\n\n    def __repr__(self):\n        # Log instance as class name\n        return self.__class__.__name__\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_look.html#client.ayon_maya.plugins.publish.extract_look.TextureProcessor.apply_settings","title":"<code>apply_settings(project_settings)</code>","text":"<p>Apply AYON system/project settings to the TextureProcessor</p> <p>Parameters:</p> Name Type Description Default <code>project_settings</code> <code>dict</code> <p>AYON project settings</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_maya/plugins/publish/extract_look.py</code> <pre><code>def apply_settings(self, project_settings):\n    \"\"\"Apply AYON system/project settings to the TextureProcessor\n\n    Args:\n        project_settings (dict): AYON project settings\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_look.html#client.ayon_maya.plugins.publish.extract_look.TextureProcessor.process","title":"<code>process(source, colorspace, color_management, staging_dir)</code>  <code>abstractmethod</code>","text":"<p>Process the <code>source</code> texture.</p> <p>Must be implemented on inherited class.</p> <p>This must always return a TextureResult even when it does not generate a texture. If it doesn't generate a texture then it should return a TextureResult using the input path and colorspace.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Path to source file.</p> required <code>colorspace</code> <code>str</code> <p>Colorspace of the source file.</p> required <code>color_management</code> <code>dict</code> <p>Maya Color management data from <code>lib.get_color_management_preferences</code></p> required <code>staging_dir</code> <code>str</code> <p>Output directory to write to.</p> required <p>Returns:</p> Name Type Description <code>TextureResult</code> <p>The resulting texture information.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_look.py</code> <pre><code>@abstractmethod\ndef process(self,\n            source,\n            colorspace,\n            color_management,\n            staging_dir):\n    \"\"\"Process the `source` texture.\n\n    Must be implemented on inherited class.\n\n    This must always return a TextureResult even when it does not generate\n    a texture. If it doesn't generate a texture then it should return a\n    TextureResult using the input path and colorspace.\n\n    Args:\n        source (str): Path to source file.\n        colorspace (str): Colorspace of the source file.\n        color_management (dict): Maya Color management data from\n            `lib.get_color_management_preferences`\n        staging_dir (str): Output directory to write to.\n\n    Returns:\n        TextureResult: The resulting texture information.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_look.html#client.ayon_maya.plugins.publish.extract_look.TextureResult","title":"<code>TextureResult</code>","text":"<p>               Bases: <code>object</code></p> <p>The resulting texture of a processed file for a resource</p> Source code in <code>client/ayon_maya/plugins/publish/extract_look.py</code> <pre><code>@attr.s\nclass TextureResult(object):\n    \"\"\"The resulting texture of a processed file for a resource\"\"\"\n    # Path to the file\n    path = attr.ib()\n    # Colorspace of the resulting texture. This might not be the input\n    # colorspace of the texture if a TextureProcessor has processed the file.\n    colorspace = attr.ib()\n    # Hash generated for the texture using ayon_core.lib.source_hash\n    file_hash = attr.ib()\n    # The transfer mode, e.g. COPY or HARDLINK\n    transfer_mode = attr.ib()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_look.html#client.ayon_maya.plugins.publish.extract_look.find_paths_by_hash","title":"<code>find_paths_by_hash(texture_hash)</code>","text":"<p>Find the texture hash key in the dictionary.</p> <p>All paths that originate from it.</p> <p>Parameters:</p> Name Type Description Default <code>texture_hash</code> <code>str</code> <p>Hash of the texture.</p> required Return <p>str: path to texture if found.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_look.py</code> <pre><code>def find_paths_by_hash(texture_hash):\n    \"\"\"Find the texture hash key in the dictionary.\n\n    All paths that originate from it.\n\n    Args:\n        texture_hash (str): Hash of the texture.\n\n    Return:\n        str: path to texture if found.\n\n    \"\"\"\n    raise KnownPublishError(\n        \"This is a bug. \\\"find_paths_by_hash\\\" is not compatible with AYON.\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_look.html#client.ayon_maya.plugins.publish.extract_look.no_workspace_dir","title":"<code>no_workspace_dir()</code>","text":"<p>Force maya to a fake temporary workspace directory.</p> <p>Note: This is not maya.cmds.workspace 'rootDirectory' but the 'directory'</p> <p>This helps to avoid Maya automatically remapping image paths to files relative to the currently set directory.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_look.py</code> <pre><code>@contextlib.contextmanager\ndef no_workspace_dir():\n    \"\"\"Force maya to a fake temporary workspace directory.\n\n    Note: This is not maya.cmds.workspace 'rootDirectory' but the 'directory'\n\n    This helps to avoid Maya automatically remapping image paths to files\n    relative to the currently set directory.\n\n    \"\"\"\n\n    # Store current workspace\n    original = cmds.workspace(query=True, directory=True)\n\n    # Set a fake workspace\n    fake_workspace_dir = tempfile.mkdtemp()\n    cmds.workspace(directory=fake_workspace_dir)\n\n    try:\n        yield\n    finally:\n        try:\n            cmds.workspace(directory=original)\n        except RuntimeError:\n            # If the original workspace directory didn't exist either\n            # ignore the fact that it fails to reset it to the old path\n            pass\n\n        # Remove the temporary directory\n        os.rmdir(fake_workspace_dir)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_maya_scene_raw.html","title":"extract_maya_scene_raw","text":"<p>Extract data as Maya scene (raw).</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_maya_scene_raw.html#client.ayon_maya.plugins.publish.extract_maya_scene_raw.ExtractMayaSceneRaw","title":"<code>ExtractMayaSceneRaw</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code>, <code>AYONPyblishPluginMixin</code></p> <p>Extract as Maya Scene (raw).</p> <p>This will preserve all references, construction history, etc.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_maya_scene_raw.py</code> <pre><code>class ExtractMayaSceneRaw(plugin.MayaExtractorPlugin, AYONPyblishPluginMixin):\n    \"\"\"Extract as Maya Scene (raw).\n\n    This will preserve all references, construction history, etc.\n    \"\"\"\n\n    label = \"Maya Scene (Raw)\"\n    families = [\"mayaAscii\",\n                \"mayaScene\",\n                \"setdress\",\n                \"layout\",\n                \"camerarig\"]\n    scene_type = \"ma\"\n\n    # Defined by settings\n    add_for_families: list[str] = []\n\n    @classmethod\n    def get_attribute_defs(cls):\n        return [\n            BoolDef(\n                \"preserve_references\",\n                label=\"Preserve References\",\n                tooltip=(\n                    \"When enabled references will still be references \"\n                    \"in the published file.\\nWhen disabled the references \"\n                    \"are imported into the published file generating a \"\n                    \"file without references.\"\n                ),\n                default=True,\n            )\n        ]\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\"\"\"\n        maya_settings = instance.context.data[\"project_settings\"][\"maya\"]\n        ext_mapping = {\n            item[\"name\"]: item[\"value\"]\n            for item in maya_settings[\"ext_mapping\"]\n        }\n        scene_type: str = self.scene_type\n\n        # Use `families` for lookup in extension mapping and add for families\n        families = [instance.data[\"productType\"]]\n        families.extend(instance.data.get(\"families\", []))\n\n        # use extension mapping for first family found\n        for family in families:\n            if family in ext_mapping:\n                self.log.debug(\n                    f\"Using '{scene_type}' as scene type for '{family}'\"\n                )\n                scene_type = ext_mapping[family]\n                break\n        else:\n            families_label = \", \".join(set(families))\n            self.log.debug(\n                f\"Using default '{scene_type}' as scene type because no \"\n                \"extension mapping settings found for families: \"\n                f\"{families_label}.\"\n            )\n\n        # Define extract output file path\n        dir_path = self.staging_dir(instance)\n        filename = \"{0}.{1}\".format(instance.name, scene_type)\n        path = os.path.join(dir_path, filename)\n\n        # Whether to include all nodes in the instance (including those from\n        # history) or only use the exact set members\n        members_only = instance.data.get(\"exactSetMembersOnly\", True)\n        if members_only:\n            members = instance.data.get(\"setMembers\", list())\n            if not members:\n                raise RuntimeError(\n                    \"Can't export 'exact set members only' when set is empty.\"\n                )\n        else:\n            members = instance[:]\n\n        # For some families, like `layout` we collect the containers so we\n        # maintain the containers of the members in the resulting product.\n        # However, if `exactSetMembersOnly` is true (which it is for layouts)\n        # searching the exact set members for containers doesn't make much\n        # sense. We must always search the full hierarchy to actually find\n        # the relevant containers\n        selection = list(members)  # make a copy to not affect input list\n        add_for_families = set(self.add_for_families)\n        if add_for_families and add_for_families.intersection(families):\n            containers = self._get_loaded_containers(instance[:])\n            self.log.debug(f\"Collected containers: {containers}\")\n            selection.extend(containers)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction ...\")\n        attribute_values = self.get_attr_values_from_data(instance.data)\n\n        file_type = \"mayaAscii\" if scene_type == \"ma\" else \"mayaBinary\"\n        with maintained_selection():\n            cmds.select(selection, noExpand=True)\n            with contextlib.ExitStack() as stack:\n                if not instance.data.get(\"shader\", True):\n                    # Fix bug where export without shader may import the\n                    # geometry 'green' due to the lack of any shader on import.\n                    stack.enter_context(\n                        shader(selection, shadingEngine=\"initialShadingGroup\")\n                    )\n\n                cmds.file(\n                    path,\n                    force=True,\n                    typ=file_type,\n                    exportSelected=True,\n                    preserveReferences=attribute_values[\"preserve_references\"],\n                    constructionHistory=True,\n                    shader=instance.data.get(\"shader\", True),\n                    constraints=True,\n                    expressions=True,\n                )\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            \"name\": scene_type,\n            \"ext\": scene_type,\n            \"files\": filename,\n            \"stagingDir\": dir_path,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\n            \"Extracted instance '%s' to: %s\" % (instance.name, path)\n        )\n\n    @staticmethod\n    def _get_loaded_containers(members):\n        # type: (list[str]) -&gt; list[str]\n        refs_to_include = {\n            cmds.referenceQuery(node, referenceNode=True)\n            for node in members\n            if cmds.referenceQuery(node, isNodeReferenced=True)\n        }\n\n        members_with_refs = refs_to_include.union(members)\n\n        obj_sets = cmds.ls(\n            \"*.id\",\n            long=True,\n            type=\"objectSet\",\n            recursive=True,\n            objectsOnly=True,\n        )\n\n        loaded_containers = []\n        for obj_set in obj_sets:\n            if not cmds.attributeQuery(\"id\", node=obj_set, exists=True):\n                continue\n\n            id_attr = \"{}.id\".format(obj_set)\n            if cmds.getAttr(id_attr) not in {\n                AYON_CONTAINER_ID,\n                AVALON_CONTAINER_ID,\n            }:\n                continue\n\n            set_content = set(cmds.sets(obj_set, query=True) or [])\n            if set_content.intersection(members_with_refs):\n                loaded_containers.append(obj_set)\n\n        return loaded_containers\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_maya_scene_raw.html#client.ayon_maya.plugins.publish.extract_maya_scene_raw.ExtractMayaSceneRaw.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_maya_scene_raw.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\"\"\"\n    maya_settings = instance.context.data[\"project_settings\"][\"maya\"]\n    ext_mapping = {\n        item[\"name\"]: item[\"value\"]\n        for item in maya_settings[\"ext_mapping\"]\n    }\n    scene_type: str = self.scene_type\n\n    # Use `families` for lookup in extension mapping and add for families\n    families = [instance.data[\"productType\"]]\n    families.extend(instance.data.get(\"families\", []))\n\n    # use extension mapping for first family found\n    for family in families:\n        if family in ext_mapping:\n            self.log.debug(\n                f\"Using '{scene_type}' as scene type for '{family}'\"\n            )\n            scene_type = ext_mapping[family]\n            break\n    else:\n        families_label = \", \".join(set(families))\n        self.log.debug(\n            f\"Using default '{scene_type}' as scene type because no \"\n            \"extension mapping settings found for families: \"\n            f\"{families_label}.\"\n        )\n\n    # Define extract output file path\n    dir_path = self.staging_dir(instance)\n    filename = \"{0}.{1}\".format(instance.name, scene_type)\n    path = os.path.join(dir_path, filename)\n\n    # Whether to include all nodes in the instance (including those from\n    # history) or only use the exact set members\n    members_only = instance.data.get(\"exactSetMembersOnly\", True)\n    if members_only:\n        members = instance.data.get(\"setMembers\", list())\n        if not members:\n            raise RuntimeError(\n                \"Can't export 'exact set members only' when set is empty.\"\n            )\n    else:\n        members = instance[:]\n\n    # For some families, like `layout` we collect the containers so we\n    # maintain the containers of the members in the resulting product.\n    # However, if `exactSetMembersOnly` is true (which it is for layouts)\n    # searching the exact set members for containers doesn't make much\n    # sense. We must always search the full hierarchy to actually find\n    # the relevant containers\n    selection = list(members)  # make a copy to not affect input list\n    add_for_families = set(self.add_for_families)\n    if add_for_families and add_for_families.intersection(families):\n        containers = self._get_loaded_containers(instance[:])\n        self.log.debug(f\"Collected containers: {containers}\")\n        selection.extend(containers)\n\n    # Perform extraction\n    self.log.debug(\"Performing extraction ...\")\n    attribute_values = self.get_attr_values_from_data(instance.data)\n\n    file_type = \"mayaAscii\" if scene_type == \"ma\" else \"mayaBinary\"\n    with maintained_selection():\n        cmds.select(selection, noExpand=True)\n        with contextlib.ExitStack() as stack:\n            if not instance.data.get(\"shader\", True):\n                # Fix bug where export without shader may import the\n                # geometry 'green' due to the lack of any shader on import.\n                stack.enter_context(\n                    shader(selection, shadingEngine=\"initialShadingGroup\")\n                )\n\n            cmds.file(\n                path,\n                force=True,\n                typ=file_type,\n                exportSelected=True,\n                preserveReferences=attribute_values[\"preserve_references\"],\n                constructionHistory=True,\n                shader=instance.data.get(\"shader\", True),\n                constraints=True,\n                expressions=True,\n            )\n\n    if \"representations\" not in instance.data:\n        instance.data[\"representations\"] = []\n\n    representation = {\n        \"name\": scene_type,\n        \"ext\": scene_type,\n        \"files\": filename,\n        \"stagingDir\": dir_path,\n    }\n    instance.data[\"representations\"].append(representation)\n\n    self.log.debug(\n        \"Extracted instance '%s' to: %s\" % (instance.name, path)\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_maya_usd.html","title":"extract_maya_usd","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_maya_usd.html#client.ayon_maya.plugins.publish.extract_maya_usd.ExtractMayaUsd","title":"<code>ExtractMayaUsd</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extractor for Maya USD Asset data.</p> <p>Upon publish a .usd (or .usdz) asset file will typically be written.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_maya_usd.py</code> <pre><code>class ExtractMayaUsd(plugin.MayaExtractorPlugin,\n                     publish.OptionalPyblishPluginMixin):\n    \"\"\"Extractor for Maya USD Asset data.\n\n    Upon publish a .usd (or .usdz) asset file will typically be written.\n    \"\"\"\n\n    enabled = True\n    label = \"Extract Maya USD Asset\"\n    families = [\"mayaUsd\"]\n\n    @property\n    def options(self):\n        \"\"\"Overridable options for Maya USD Export\n\n        Given in the following format\n            - {NAME: EXPECTED TYPE}\n\n        If the overridden option's type does not match,\n        the option is not included and a warning is logged.\n\n        \"\"\"\n\n        # TODO: Support more `mayaUSDExport` parameters\n        return {\n            \"chaser\": (list, None),  # optional list\n            \"chaserArgs\": (list, None),  # optional list\n            \"defaultUSDFormat\": str,\n            \"defaultMeshScheme\": str,\n            \"stripNamespaces\": bool,\n            \"mergeTransformAndShape\": bool,\n            \"exportDisplayColor\": bool,\n            \"exportColorSets\": bool,\n            \"exportInstances\": bool,\n            \"exportUVs\": bool,\n            \"exportVisibility\": bool,\n            \"exportComponentTags\": bool,\n            \"exportRefsAsInstanceable\": bool,\n            \"eulerFilter\": bool,\n            \"renderableOnly\": bool,\n            \"convertMaterialsTo\": str,\n            \"shadingMode\": (str, None),  # optional str\n            \"jobContext\": (list, None),  # optional list\n            \"filterTypes\": (list, None),  # optional list\n            \"staticSingleSample\": bool,\n            \"worldspace\": bool,\n        }\n\n    @property\n    def default_options(self):\n        \"\"\"The default options for Maya USD Export.\"\"\"\n\n        # TODO: Support more `mayaUSDExport` parameters\n        return {\n            \"chaser\": None,\n            \"chaserArgs\": None,\n            \"defaultUSDFormat\": \"usdc\",\n            \"defaultMeshScheme\": \"catmullClark\",\n            \"stripNamespaces\": True,\n            \"mergeTransformAndShape\": True,\n            \"exportDisplayColor\": False,\n            \"exportColorSets\": True,\n            \"exportInstances\": True,\n            \"exportUVs\": True,\n            \"exportVisibility\": True,\n            \"exportComponentTags\": False,\n            \"exportRefsAsInstanceable\": False,\n            \"eulerFilter\": True,\n            \"renderableOnly\": False,\n            \"shadingMode\": \"none\",\n            \"convertMaterialsTo\": \"none\",\n            \"jobContext\": None,\n            \"filterTypes\": None,\n            \"staticSingleSample\": True,\n            \"worldspace\": True\n        }\n\n    def parse_overrides(self, overrides, options):\n        \"\"\"Inspect data of instance to determine overridden options\"\"\"\n\n        for key in overrides:\n            if key not in self.options:\n                continue\n\n            # Ensure the data is of correct type\n            value = overrides[key]\n            if isinstance(value, str):\n                value = str(value)\n            if not isinstance(value, self.options[key]):\n                self.log.warning(\n                    \"Overridden attribute {key} was of \"\n                    \"the wrong type: {invalid_type} \"\n                    \"- should have been {valid_type}\".format(\n                        key=key,\n                        invalid_type=type(value).__name__,\n                        valid_type=self.options[key].__name__))\n                continue\n\n            options[key] = value\n\n        # Do not pass None values\n        for key, value in options.copy().items():\n            if value is None:\n                del options[key]\n\n        return options\n\n    def filter_members(self, members):\n        # Can be overridden by inherited classes\n        return members\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        if instance.data.get(\"farm\"):\n            self.log.debug(\"Should be processed on farm, skipping.\")\n            return\n\n        attr_values = self.get_attr_values_from_data(instance.data)\n\n        # Load plugin first\n        cmds.loadPlugin(\"mayaUsdPlugin\", quiet=True)\n\n        # Define output file path\n        staging_dir = self.staging_dir(instance)\n        file_name = \"{0}.usd\".format(instance.name)\n        file_path = os.path.join(staging_dir, file_name)\n        file_path = file_path.replace('\\\\', '/')\n\n        # Parse export options\n        options = self.default_options\n        options = self.parse_overrides(instance.data, options)\n        options = self.parse_overrides(attr_values, options)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction ...\")\n\n        members = instance.data(\"setMembers\")\n        self.log.debug('Collected objects: {}'.format(members))\n        members = self.filter_members(members)\n        if not members:\n            self.log.error('No members!')\n            return\n\n        export_anim_data = instance.data.get(\"exportAnimationData\", True)\n        start = instance.data.get(\"frameStartHandle\", 0)\n\n        if export_anim_data:\n            end = instance.data[\"frameEndHandle\"]\n            options[\"frameRange\"] = (start, end)\n            options[\"frameStride\"] = instance.data.get(\"step\", 1.0)\n\n        if instance.data.get(\"exportRoots\", True):\n            # Do not include 'objectSets' as roots because the export command\n            # will fail. We only include the transforms among the members.\n            options[\"exportRoots\"] = cmds.ls(members,\n                                             type=\"transform\",\n                                             long=True)\n        else:\n            options[\"selection\"] = True\n\n        # TODO: Remove hardcoded filterTypes\n        # We always filter constraint types because they serve no valuable\n        # data (it doesn't preserve the actual constraint) but it does\n        # introduce the problem that Shapes do not merge into the Transform\n        # on export anymore because they are usually parented under transforms\n        # See: https://github.com/Autodesk/maya-usd/issues/2070\n        options[\"filterTypes\"] = [\"constraint\"]\n\n        def parse_attr_str(attr_str):\n            \"\"\"Return list of strings from `a,b,c,d` to `[a, b, c, d]`.\n\n            Args:\n                attr_str (str): Concatenated attributes by comma\n\n            Returns:\n                List[str]: list of attributes\n            \"\"\"\n            result = list()\n            for attr in attr_str.split(\",\"):\n                attr = attr.strip()\n                if not attr:\n                    continue\n                result.append(attr)\n            return result\n\n        attrs = parse_attr_str(instance.data.get(\"attr\", \"\"))\n        attrs += instance.data.get(\"userDefinedAttributes\", [])\n        attrs += [\"cbId\"]\n        attr_prefixes = parse_attr_str(instance.data.get(\"attrPrefix\", \"\"))\n\n        # Remove arguments for Maya USD versions not supporting them yet\n        # Note: Maya 2022.3 ships with Maya USD 0.13.0.\n        # TODO: Remove this backwards compatibility if Maya 2022 support is\n        #   dropped\n        maya_usd_version = parse_version(\n            cmds.pluginInfo(\"mayaUsdPlugin\", query=True, version=True)\n        )\n        for key, required_minimal_version in {\n            \"exportComponentTags\": (0, 14, 0),\n            \"jobContext\": (0, 15, 0),\n            \"worldspace\": (0, 21, 0)\n        }.items():\n            if key in options and maya_usd_version &lt; required_minimal_version:\n                self.log.warning(\n                    \"Ignoring export flag '%s' because Maya USD version \"\n                    \"%s is lower than minimal supported version %s.\",\n                    key,\n                    maya_usd_version,\n                    required_minimal_version\n                )\n                del options[key]\n\n        # Fix default prim bug in Maya USD 0.30.0 where prefixed `|` remains\n        # See: https://github.com/Autodesk/maya-usd/issues/3991\n        if (\n                options.get(\"exportRoots\")          # only if roots are defined\n                and \"defaultPrim\" not in options    # ignore if already set\n                and \"rootPrim\" not in options       # ignore if root is created\n                and maya_usd_version == (0, 30, 0)  # only for Maya USD 0.30.0\n        ):\n            # Define the default prim name as it will end up in the USD file\n            # from the first export root node\n            first_root = options[\"exportRoots\"][0]\n            default_prim = first_root.rsplit(\"|\", 1)[-1]\n            if options[\"stripNamespaces\"]:\n                default_prim = default_prim.rsplit(\":\", 1)[-1]\n            options[\"defaultPrim\"] = default_prim\n\n        self.log.debug(\"Export options: {0}\".format(options))\n        self.log.debug('Exporting USD: {} / {}'.format(file_path, members))\n        with maintained_time():\n            with maintained_selection():\n                if not export_anim_data:\n                    # Use start frame as current time\n                    cmds.currentTime(start)\n\n                with usd_export_attributes(instance[:],\n                                           attrs=attrs,\n                                           attr_prefixes=attr_prefixes):\n                    cmds.select(members, replace=True, noExpand=True)\n                    cmds.mayaUSDExport(file=file_path,\n                                       **options)\n\n        representation = {\n            'name': \"usd\",\n            'ext': \"usd\",\n            'files': file_name,\n            'stagingDir': staging_dir\n        }\n        instance.data.setdefault(\"representations\", []).append(representation)\n\n        self.log.debug(\n            \"Extracted instance {} to {}\".format(instance.name, file_path)\n        )\n\n    @classmethod\n    def register_create_context_callbacks(cls, create_context):\n        create_context.add_value_changed_callback(cls.on_values_changed)\n\n    @classmethod\n    def on_values_changed(cls, event):\n        \"\"\"Update instance attribute definitions on attribute changes.\"\"\"\n        for instance_change in event[\"changes\"]:\n            # First check if there's a change we want to respond to\n            instance = instance_change[\"instance\"]\n            if instance is None:\n                # Change is on context\n                continue\n\n            # Check if active state is toggled\n            value_changes = instance_change[\"changes\"]\n            if \"publish_attributes\" not in value_changes:\n                continue\n\n            publish_attributes = value_changes[\"publish_attributes\"]\n            class_name = cls.__name__\n            if class_name not in publish_attributes:\n                continue\n\n            if \"active\" not in publish_attributes[class_name]:\n                continue\n\n            # Update the attribute definitions\n            new_attrs = cls.get_attr_defs_for_instance(\n                event[\"create_context\"], instance\n            )\n            instance.set_publish_plugin_attr_defs(class_name, new_attrs)\n\n    @classmethod\n    def get_attr_defs_for_instance(cls, create_context, instance):\n        is_enabled = cls.enabled\n        if not is_enabled:\n            return []\n\n        if not cls.instance_matches_plugin_families(instance):\n            return []\n\n        if cls.optional:\n            plugin_attr_values = (\n                instance.data\n                .get(\"publish_attributes\", {})\n                .get(cls.__name__, {})\n            )\n            is_enabled = plugin_attr_values.get(\"active\", cls.active)\n\n        attr_defs = [\n            UISeparatorDef(\"sep_usd_options\"),\n            UILabelDef(\"USD Options\"),\n        ]\n        attr_defs.extend(\n            super().get_attr_defs_for_instance(create_context, instance)\n        )\n        attr_defs.extend(cls._get_additional_attr_defs(is_enabled))\n        attr_defs.append(\n            UISeparatorDef(\"sep_usd_options_end\")\n        )\n        return attr_defs\n\n    @classmethod\n    def convert_attribute_values(cls, create_context, instance):\n        # Convert creator attribute 'mergeTransformAndShape' to\n        # plugin attribute, because this attribute has moved from\n        # the `io.openpype.creators.maya.mayausd` creator to this extractor\n        super().convert_attribute_values(create_context, instance)\n        if (\n                not cls.enabled\n                or not instance\n                or not cls.instance_matches_plugin_families(instance)\n        ):\n            return\n        if (\n                instance.data.get(\"creator_identifier\")\n                != \"io.openpype.creators.maya.mayausd\"\n        ):\n            return\n        creator_attributes = instance.data.get(\"creator_attributes\", {})\n        if not creator_attributes:\n            return\n\n        keys = [\"mergeTransformAndShape\"]\n        for key in keys:\n            if key in creator_attributes:\n                # Set attribute value for this plugin\n                value = creator_attributes.pop(key)\n                class_name = cls.__name__\n                instance.publish_attributes[class_name][key] = value\n\n    @classmethod\n    def _get_additional_attr_defs(cls, visible: bool) -&gt; list:\n        return [\n            BoolDef(\"stripNamespaces\",\n                    label=\"Strip Namespaces\",\n                    tooltip=\"Strip Namespaces in the USD Export\",\n                    visible=visible,\n                    default=True),\n            BoolDef(\"worldspace\",\n                    label=\"World-Space\",\n                    tooltip=\"Export all root prim using their full worldspace \"\n                            \"transform instead of their local transform.\",\n                    visible=visible,\n                    default=True),\n            BoolDef(\"exportComponentTags\",\n                    label=\"Export Component Tags\",\n                    tooltip=\"When enabled, export any geometry component tags \"\n                            \"as UsdGeomSubset data.\",\n                    visible=visible,\n                    default=False),\n            BoolDef(\"exportVisibility\",\n                    label=\"Export Visibility\",\n                    tooltip=\"Export any state and animation on Maya visibility\"\n                            \" attributes.\",\n                    visible=visible,\n                    default=True),\n            BoolDef(\"mergeTransformAndShape\",\n                    label=\"Merge Transform and Shape\",\n                    tooltip=(\n                        \"Combine Maya transform and shape into a single USD\"\n                        \"prim that has transform and geometry, for all\"\n                        \" \\\"geometric primitives\\\" (gprims).\\n\"\n                        \"This results in smaller and faster scenes. Gprims \"\n                        \"will be \\\"unpacked\\\" back into transform and shape \"\n                        \"nodes when imported into Maya from USD.\"\n                    ),\n                    visible=visible,\n                    default=True),\n            EnumDef(\"defaultMeshScheme\",\n                    label=\"Default Subdivision Method\",\n                    items=[\n                        {\"value\": \"catmullClark\", \"label\": \"Catmull Clark\"},\n                        {\"value\": \"loop\", \"label\": \"Loop\"},\n                        {\"value\": \"bilinear\", \"label\": \"Bilinear\"},\n                        {\"value\": \"none\", \"label\": \"None\"},\n                    ],\n                    tooltip=(\n                        \"Default subdivision method for meshes.\\n\"\n                        \"Options are: catmullClark, loop, bilinear, none.\"\n                        \"\\n\\n\"\n                        \"To specify per mesh subdivision schemes add a \"\n                        \"USD_ATTR_subdivisionScheme attribute.\"\n                    ),\n                    visible=visible,\n                    default=\"catmullClark\"\n            )\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_maya_usd.html#client.ayon_maya.plugins.publish.extract_maya_usd.ExtractMayaUsd.default_options","title":"<code>default_options</code>  <code>property</code>","text":"<p>The default options for Maya USD Export.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_maya_usd.html#client.ayon_maya.plugins.publish.extract_maya_usd.ExtractMayaUsd.options","title":"<code>options</code>  <code>property</code>","text":"<p>Overridable options for Maya USD Export</p> <p>Given in the following format     - {NAME: EXPECTED TYPE}</p> <p>If the overridden option's type does not match, the option is not included and a warning is logged.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_maya_usd.html#client.ayon_maya.plugins.publish.extract_maya_usd.ExtractMayaUsd.on_values_changed","title":"<code>on_values_changed(event)</code>  <code>classmethod</code>","text":"<p>Update instance attribute definitions on attribute changes.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_maya_usd.py</code> <pre><code>@classmethod\ndef on_values_changed(cls, event):\n    \"\"\"Update instance attribute definitions on attribute changes.\"\"\"\n    for instance_change in event[\"changes\"]:\n        # First check if there's a change we want to respond to\n        instance = instance_change[\"instance\"]\n        if instance is None:\n            # Change is on context\n            continue\n\n        # Check if active state is toggled\n        value_changes = instance_change[\"changes\"]\n        if \"publish_attributes\" not in value_changes:\n            continue\n\n        publish_attributes = value_changes[\"publish_attributes\"]\n        class_name = cls.__name__\n        if class_name not in publish_attributes:\n            continue\n\n        if \"active\" not in publish_attributes[class_name]:\n            continue\n\n        # Update the attribute definitions\n        new_attrs = cls.get_attr_defs_for_instance(\n            event[\"create_context\"], instance\n        )\n        instance.set_publish_plugin_attr_defs(class_name, new_attrs)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_maya_usd.html#client.ayon_maya.plugins.publish.extract_maya_usd.ExtractMayaUsd.parse_overrides","title":"<code>parse_overrides(overrides, options)</code>","text":"<p>Inspect data of instance to determine overridden options</p> Source code in <code>client/ayon_maya/plugins/publish/extract_maya_usd.py</code> <pre><code>def parse_overrides(self, overrides, options):\n    \"\"\"Inspect data of instance to determine overridden options\"\"\"\n\n    for key in overrides:\n        if key not in self.options:\n            continue\n\n        # Ensure the data is of correct type\n        value = overrides[key]\n        if isinstance(value, str):\n            value = str(value)\n        if not isinstance(value, self.options[key]):\n            self.log.warning(\n                \"Overridden attribute {key} was of \"\n                \"the wrong type: {invalid_type} \"\n                \"- should have been {valid_type}\".format(\n                    key=key,\n                    invalid_type=type(value).__name__,\n                    valid_type=self.options[key].__name__))\n            continue\n\n        options[key] = value\n\n    # Do not pass None values\n    for key, value in options.copy().items():\n        if value is None:\n            del options[key]\n\n    return options\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_maya_usd.html#client.ayon_maya.plugins.publish.extract_maya_usd.ExtractMayaUsdAnim","title":"<code>ExtractMayaUsdAnim</code>","text":"<p>               Bases: <code>ExtractMayaUsd</code></p> <p>Extractor for Maya USD Animation Sparse Cache data.</p> <p>This will extract the sparse cache data from the scene and generate a USD file with all the animation data.</p> <p>Upon publish a .usd sparse cache will be written.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_maya_usd.py</code> <pre><code>class ExtractMayaUsdAnim(ExtractMayaUsd):\n    \"\"\"Extractor for Maya USD Animation Sparse Cache data.\n\n    This will extract the sparse cache data from the scene and generate a\n    USD file with all the animation data.\n\n    Upon publish a .usd sparse cache will be written.\n    \"\"\"\n    label = \"Extract USD Animation\"\n    families = [\"animation\"]\n\n    # Exposed in settings\n    optional = True\n    active = False\n\n    # TODO: Support writing out point deformation only, avoid writing UV sets\n    #       component tags and potentially remove `faceVertexCounts`,\n    #       `faceVertexIndices` and `doubleSided` parameters as well.\n    def filter_members(self, members):\n        out_set = next((i for i in members if i.endswith(\"out_SET\")), None)\n\n        if out_set is None:\n            self.log.warning(\"Expecting out_SET\")\n            return None\n\n        members = cmds.ls(cmds.sets(out_set, query=True), long=True)\n        return members\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_maya_usd.html#client.ayon_maya.plugins.publish.extract_maya_usd.ExtractMayaUsdModel","title":"<code>ExtractMayaUsdModel</code>","text":"<p>               Bases: <code>ExtractMayaUsd</code></p> <p>Extractor for Maya USD Asset data for model family</p> <p>Upon publish a .usd (or .usdz) asset file will typically be written.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_maya_usd.py</code> <pre><code>class ExtractMayaUsdModel(ExtractMayaUsd):\n    \"\"\"Extractor for Maya USD Asset data for model family\n\n    Upon publish a .usd (or .usdz) asset file will typically be written.\n    \"\"\"\n\n    label = \"Extract USD\"\n    families = [\"model\"]\n\n    # Exposed in settings\n    optional = True\n    active = False\n\n    def process(self, instance):\n        # TODO: Fix this without changing instance data\n        instance.data[\"exportAnimationData\"] = False\n        super(ExtractMayaUsdModel, self).process(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_maya_usd.html#client.ayon_maya.plugins.publish.extract_maya_usd.ExtractMayaUsdPointcache","title":"<code>ExtractMayaUsdPointcache</code>","text":"<p>               Bases: <code>ExtractMayaUsd</code></p> <p>Extractor for Maya USD for 'pointcache' family</p> Source code in <code>client/ayon_maya/plugins/publish/extract_maya_usd.py</code> <pre><code>class ExtractMayaUsdPointcache(ExtractMayaUsd):\n    \"\"\"Extractor for Maya USD for 'pointcache' family\"\"\"\n\n    label = \"Extract USD\"\n    families = [\"pointcache\"]\n\n    # Exposed in settings\n    optional = True\n    active = False\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_maya_usd.html#client.ayon_maya.plugins.publish.extract_maya_usd.get_node_hash","title":"<code>get_node_hash(node)</code>","text":"<p>Return integer MObjectHandle hash code.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>Maya node path.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>MObjectHandle.hashCode()</p> Source code in <code>client/ayon_maya/plugins/publish/extract_maya_usd.py</code> <pre><code>def get_node_hash(node):\n    \"\"\"Return integer MObjectHandle hash code.\n\n    Arguments:\n        node (str): Maya node path.\n\n    Returns:\n        int: MObjectHandle.hashCode()\n\n    \"\"\"\n    sel = om.MSelectionList()\n    sel.add(node)\n    return om.MObjectHandle(sel.getDependNode(0)).hashCode()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_maya_usd.html#client.ayon_maya.plugins.publish.extract_maya_usd.parse_version","title":"<code>parse_version(version_str)</code>","text":"<p>Parse string like '0.26.0' to (0, 26, 0)</p> Source code in <code>client/ayon_maya/plugins/publish/extract_maya_usd.py</code> <pre><code>def parse_version(version_str):\n    \"\"\"Parse string like '0.26.0' to (0, 26, 0)\"\"\"\n    return tuple(int(v) for v in version_str.split(\".\"))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_maya_usd.html#client.ayon_maya.plugins.publish.extract_maya_usd.usd_export_attributes","title":"<code>usd_export_attributes(nodes, attrs=None, attr_prefixes=None, mapping=None)</code>","text":"<p>Define attributes for the given nodes that should be exported.</p> <p>MayaUSDExport will export custom attributes if the Maya node has a string attribute <code>USD_UserExportedAttributesJson</code> that provides an export mapping for the maya attributes. This context manager will try to autogenerate such an attribute during the export to include attributes for the export.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>List[str]</code> <p>Nodes to process.</p> required <code>attrs</code> <code>Optional[List[str]]</code> <p>Full name of attributes to include.</p> <code>None</code> <code>attr_prefixes</code> <code>Optional[List[str]]</code> <p>Prefixes of attributes to include.</p> <code>None</code> <code>mapping</code> <code>Optional[Dict[Dict]]</code> <p>A mapping per attribute name for the conversion to a USD attribute, including renaming, defining type, converting attribute precision, etc. This match the usual <code>USD_UserExportedAttributesJson</code> json mapping of <code>mayaUSDExport</code>. When no mapping provided for an attribute it will use <code>{}</code> as value.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with usd_export_attributes(\n&gt;&gt;&gt;     [\"pCube1\"], attrs=\"myDoubleAttributeAsFloat\", mapping={\n&gt;&gt;&gt;         \"myDoubleAttributeAsFloat\": {\n&gt;&gt;&gt;           \"usdAttrName\": \"my:namespace:attrib\",\n&gt;&gt;&gt;           \"translateMayaDoubleToUsdSinglePrecision\": True,\n&gt;&gt;&gt;         }\n&gt;&gt;&gt; })\n</code></pre> Source code in <code>client/ayon_maya/plugins/publish/extract_maya_usd.py</code> <pre><code>@contextlib.contextmanager\ndef usd_export_attributes(nodes, attrs=None, attr_prefixes=None, mapping=None):\n    \"\"\"Define attributes for the given nodes that should be exported.\n\n    MayaUSDExport will export custom attributes if the Maya node has a\n    string attribute `USD_UserExportedAttributesJson` that provides an\n    export mapping for the maya attributes. This context manager will try\n    to autogenerate such an attribute during the export to include attributes\n    for the export.\n\n    Arguments:\n        nodes (List[str]): Nodes to process.\n        attrs (Optional[List[str]]): Full name of attributes to include.\n        attr_prefixes (Optional[List[str]]): Prefixes of attributes to include.\n        mapping (Optional[Dict[Dict]]): A mapping per attribute name for the\n            conversion to a USD attribute, including renaming, defining type,\n            converting attribute precision, etc. This match the usual\n            `USD_UserExportedAttributesJson` json mapping of `mayaUSDExport`.\n            When no mapping provided for an attribute it will use `{}` as\n            value.\n\n    Examples:\n          &gt;&gt;&gt; with usd_export_attributes(\n          &gt;&gt;&gt;     [\"pCube1\"], attrs=\"myDoubleAttributeAsFloat\", mapping={\n          &gt;&gt;&gt;         \"myDoubleAttributeAsFloat\": {\n          &gt;&gt;&gt;           \"usdAttrName\": \"my:namespace:attrib\",\n          &gt;&gt;&gt;           \"translateMayaDoubleToUsdSinglePrecision\": True,\n          &gt;&gt;&gt;         }\n          &gt;&gt;&gt; })\n\n    \"\"\"\n    # todo: this might be better done with a custom export chaser\n    #   see `chaser` argument for `mayaUSDExport`\n\n    if not attrs and not attr_prefixes:\n        # context manager does nothing\n        yield\n        return\n\n    if attrs is None:\n        attrs = []\n    if attr_prefixes is None:\n        attr_prefixes = []\n    if mapping is None:\n        mapping = {}\n\n    usd_json_attr = \"USD_UserExportedAttributesJson\"\n    strings = attrs + [\"{}*\".format(prefix) for prefix in attr_prefixes]\n    context_state = {}\n\n    # Keep track of the processed nodes as a node might appear more than once\n    # e.g. when there are instances.\n    processed = set()\n    for node in set(nodes):\n        node_attrs = cmds.listAttr(node, st=strings)\n        if not node_attrs:\n            # Nothing to do for this node\n            continue\n\n        hash_code = get_node_hash(node)\n        if hash_code in processed:\n            continue\n\n        node_attr_data = {}\n        for node_attr in set(node_attrs):\n            node_attr_data[node_attr] = mapping.get(node_attr, {})\n        if cmds.attributeQuery(usd_json_attr, node=node, exists=True):\n            existing_node_attr_value = cmds.getAttr(\n                \"{}.{}\".format(node, usd_json_attr)\n            )\n            if existing_node_attr_value and existing_node_attr_value != \"{}\":\n                # Any existing attribute mappings in an existing\n                # `USD_UserExportedAttributesJson` attribute always take\n                # precedence over what this function tries to imprint\n                existing_node_attr_data = json.loads(existing_node_attr_value)\n                node_attr_data.update(existing_node_attr_data)\n\n        processed.add(hash_code)\n        context_state[node] = json.dumps(node_attr_data)\n\n    sel = om.MSelectionList()\n    dg_mod = om.MDGModifier()\n    fn_string = om.MFnStringData()\n    fn_typed = om.MFnTypedAttribute()\n    try:\n        for node, value in context_state.items():\n            data = fn_string.create(value)\n            sel.clear()\n            if cmds.attributeQuery(usd_json_attr, node=node, exists=True):\n                # Set the attribute value\n                sel.add(\"{}.{}\".format(node, usd_json_attr))\n                plug = sel.getPlug(0)\n                dg_mod.newPlugValue(plug, data)\n            else:\n                # Create attribute with the value as default value\n                sel.add(node)\n                node_obj = sel.getDependNode(0)\n                attr_obj = fn_typed.create(usd_json_attr,\n                                           usd_json_attr,\n                                           om.MFnData.kString,\n                                           data)\n                dg_mod.addAttribute(node_obj, attr_obj)\n        dg_mod.doIt()\n        yield\n    finally:\n        dg_mod.undoIt()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_maya_usd_layer.html","title":"extract_maya_usd_layer","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_maya_usd_layer.html#client.ayon_maya.plugins.publish.extract_maya_usd_layer.ExtractMayaUsdLayer","title":"<code>ExtractMayaUsdLayer</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extractor for Maya USD Layer from <code>mayaUsdProxyShape</code></p> <p>Exports a single Sdf.Layer from a mayaUsdPlugin <code>mayaUsdProxyShape</code>. These layers are the same managed via Maya's Windows &gt; USD Layer Editor.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_maya_usd_layer.py</code> <pre><code>class ExtractMayaUsdLayer(publish.Extractor):\n    \"\"\"Extractor for Maya USD Layer from `mayaUsdProxyShape`\n\n    Exports a single Sdf.Layer from a mayaUsdPlugin `mayaUsdProxyShape`.\n    These layers are the same managed via Maya's Windows &gt; USD Layer Editor.\n\n    \"\"\"\n\n    label = \"Extract Maya USD Layer\"\n    hosts = [\"maya\"]\n    families = [\"mayaUsdLayer\"]\n\n    def process(self, instance):\n\n        import mayaUsd\n\n        # Load plugin first\n        cmds.loadPlugin(\"mayaUsdPlugin\", quiet=True)\n\n        data = instance.data[\"stageLayerIdentifier\"]\n        self.log.debug(f\"Using proxy layer: {data}\")\n\n        proxy, layer_identifier = data.split(\"&gt;\", 1)\n        # TODO: The stage and layer should actually be retrieved during\n        #  Collecting so that they can be validated upon and potentially that\n        #  any 'child layers' can potentially be recursively exported along\n        stage = mayaUsd.ufe.getStage(proxy)\n        layers = stage.GetLayerStack(includeSessionLayers=False)\n        layer = next(\n            layer for layer in layers if layer.identifier == layer_identifier\n        )\n\n        # Define output file path\n        staging_dir = self.staging_dir(instance)\n        file_name = \"{0}.usd\".format(instance.name)\n        file_path = os.path.join(staging_dir, file_name)\n        file_path = file_path.replace('\\\\', '/')\n\n        self.log.debug(\"Exporting USD layer to: {}\".format(file_path))\n        layer.Export(file_path, args={\n            \"format\": instance.data.get(\"defaultUSDFormat\", \"usdc\")\n        })\n\n        # TODO: We might want to remap certain paths - to do so we could take\n        #  the SdfLayer and transfer its contents into a anonymous SdfLayer\n        #  then we can use the copy to alter it in memory to our like before\n        #  writing out\n\n        representation = {\n            'name': \"usd\",\n            'ext': \"usd\",\n            'files': file_name,\n            'stagingDir': staging_dir\n        }\n        instance.data.setdefault(\"representations\", []).append(representation)\n        self.log.debug(\n            \"Extracted instance {} to {}\".format(instance.name, file_path)\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_model.html","title":"extract_model","text":"<p>Extract model as Maya Scene.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_model.html#client.ayon_maya.plugins.publish.extract_model.ExtractModel","title":"<code>ExtractModel</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract as Model (Maya Scene).</p> <p>Only extracts contents based on the original \"setMembers\" data to ensure publishing the least amount of required shapes. From that it only takes the shapes that are not intermediateObjects</p> <p>During export it sets a temporary context to perform a clean extraction. The context ensures:     - Smooth preview is turned off for the geometry     - Default shader is assigned (no materials are exported)     - Remove display layers</p> Source code in <code>client/ayon_maya/plugins/publish/extract_model.py</code> <pre><code>class ExtractModel(plugin.MayaExtractorPlugin,\n                   publish.OptionalPyblishPluginMixin):\n    \"\"\"Extract as Model (Maya Scene).\n\n    Only extracts contents based on the original \"setMembers\" data to ensure\n    publishing the least amount of required shapes. From that it only takes\n    the shapes that are not intermediateObjects\n\n    During export it sets a temporary context to perform a clean extraction.\n    The context ensures:\n        - Smooth preview is turned off for the geometry\n        - Default shader is assigned (no materials are exported)\n        - Remove display layers\n\n    \"\"\"\n\n    label = \"Model (Maya Scene)\"\n    families = [\"model\"]\n    scene_type = \"ma\"\n    optional = True\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\"\"\"\n        if not self.is_active(instance.data):\n            return\n\n        maya_settings = instance.context.data[\"project_settings\"][\"maya\"]\n        ext_mapping = {\n            item[\"name\"]: item[\"value\"]\n            for item in maya_settings[\"ext_mapping\"]\n        }\n        if ext_mapping:\n            self.log.debug(\"Looking in settings for scene type ...\")\n            # use extension mapping for first family found\n            for family in self.families:\n                try:\n                    self.scene_type = ext_mapping[family]\n                    self.log.debug(\n                        \"Using {} as scene type\".format(self.scene_type))\n                    break\n                except KeyError:\n                    # no preset found\n                    pass\n        # Define extract output file path\n        stagingdir = self.staging_dir(instance)\n        filename = \"{0}.{1}\".format(instance.name, self.scene_type)\n        path = os.path.join(stagingdir, filename)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction ...\")\n\n        # Get only the shape contents we need in such a way that we avoid\n        # taking along intermediateObjects\n        members = instance.data(\"setMembers\")\n        members = cmds.ls(members,\n                          dag=True,\n                          shapes=True,\n                          type=(\"mesh\", \"nurbsCurve\"),\n                          noIntermediate=True,\n                          long=True)\n\n        # Check if shaders should be included as part of the model export. If\n        # False, the default shader is assigned to the geometry.\n        include_shaders = instance.data.get(\"include_shaders\", False)\n\n        with lib.no_display_layers(instance):\n            with lib.displaySmoothness(members,\n                                       divisionsU=0,\n                                       divisionsV=0,\n                                       pointsWire=4,\n                                       pointsShaded=1,\n                                       polygonObject=1):\n                with (\n                    nullcontext()\n                    if include_shaders\n                    else lib.shader(members, shadingEngine=\"initialShadingGroup\")\n                ):\n                    with lib.maintained_selection():\n                        cmds.select(members, noExpand=True)\n                        cmds.file(path,\n                                  force=True,\n                                  typ=\"mayaAscii\" if self.scene_type == \"ma\" else \"mayaBinary\",  # noqa: E501\n                                  exportSelected=True,\n                                  preserveReferences=False,\n                                  channels=False,\n                                  constraints=False,\n                                  expressions=False,\n                                  constructionHistory=False)\n\n                        # Store reference for integration\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': self.scene_type,\n            'ext': self.scene_type,\n            'files': filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\" % (instance.name,\n                                                           path))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_model.html#client.ayon_maya.plugins.publish.extract_model.ExtractModel.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_model.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\"\"\"\n    if not self.is_active(instance.data):\n        return\n\n    maya_settings = instance.context.data[\"project_settings\"][\"maya\"]\n    ext_mapping = {\n        item[\"name\"]: item[\"value\"]\n        for item in maya_settings[\"ext_mapping\"]\n    }\n    if ext_mapping:\n        self.log.debug(\"Looking in settings for scene type ...\")\n        # use extension mapping for first family found\n        for family in self.families:\n            try:\n                self.scene_type = ext_mapping[family]\n                self.log.debug(\n                    \"Using {} as scene type\".format(self.scene_type))\n                break\n            except KeyError:\n                # no preset found\n                pass\n    # Define extract output file path\n    stagingdir = self.staging_dir(instance)\n    filename = \"{0}.{1}\".format(instance.name, self.scene_type)\n    path = os.path.join(stagingdir, filename)\n\n    # Perform extraction\n    self.log.debug(\"Performing extraction ...\")\n\n    # Get only the shape contents we need in such a way that we avoid\n    # taking along intermediateObjects\n    members = instance.data(\"setMembers\")\n    members = cmds.ls(members,\n                      dag=True,\n                      shapes=True,\n                      type=(\"mesh\", \"nurbsCurve\"),\n                      noIntermediate=True,\n                      long=True)\n\n    # Check if shaders should be included as part of the model export. If\n    # False, the default shader is assigned to the geometry.\n    include_shaders = instance.data.get(\"include_shaders\", False)\n\n    with lib.no_display_layers(instance):\n        with lib.displaySmoothness(members,\n                                   divisionsU=0,\n                                   divisionsV=0,\n                                   pointsWire=4,\n                                   pointsShaded=1,\n                                   polygonObject=1):\n            with (\n                nullcontext()\n                if include_shaders\n                else lib.shader(members, shadingEngine=\"initialShadingGroup\")\n            ):\n                with lib.maintained_selection():\n                    cmds.select(members, noExpand=True)\n                    cmds.file(path,\n                              force=True,\n                              typ=\"mayaAscii\" if self.scene_type == \"ma\" else \"mayaBinary\",  # noqa: E501\n                              exportSelected=True,\n                              preserveReferences=False,\n                              channels=False,\n                              constraints=False,\n                              expressions=False,\n                              constructionHistory=False)\n\n                    # Store reference for integration\n\n    if \"representations\" not in instance.data:\n        instance.data[\"representations\"] = []\n\n    representation = {\n        'name': self.scene_type,\n        'ext': self.scene_type,\n        'files': filename,\n        \"stagingDir\": stagingdir,\n    }\n    instance.data[\"representations\"].append(representation)\n\n    self.log.debug(\"Extracted instance '%s' to: %s\" % (instance.name,\n                                                       path))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_multiverse_look.html","title":"extract_multiverse_look","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_multiverse_look.html#client.ayon_maya.plugins.publish.extract_multiverse_look.ExtractMultiverseLook","title":"<code>ExtractMultiverseLook</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extractor for Multiverse USD look data.</p> <p>This will extract:</p> <ul> <li>the shading networks that are assigned in MEOW as Maya material overrides   to a Multiverse Compound</li> <li>settings for a Multiverse Write Override operation.</li> </ul> <p>Relevant settings are visible in the Maya set node created by a Multiverse USD Look instance creator.</p> <p>The input data contained in the set is:</p> <ul> <li>a single Multiverse Compound node with any number of Maya material   overrides (typically set in MEOW)</li> </ul> <p>Upon publish two files will be written:</p> <ul> <li>a .usda override file containing material assignment information</li> <li>a .ma file containing shading networks</li> </ul> when layering the material assignment override on a loaded Compound, <p>remember to set a matching attribute override with the namespace of the loaded compound in order for the material assignment to resolve.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_multiverse_look.py</code> <pre><code>class ExtractMultiverseLook(plugin.MayaExtractorPlugin):\n    \"\"\"Extractor for Multiverse USD look data.\n\n    This will extract:\n\n    - the shading networks that are assigned in MEOW as Maya material overrides\n      to a Multiverse Compound\n    - settings for a Multiverse Write Override operation.\n\n    Relevant settings are visible in the Maya set node created by a Multiverse\n    USD Look instance creator.\n\n    The input data contained in the set is:\n\n    - a single Multiverse Compound node with any number of Maya material\n      overrides (typically set in MEOW)\n\n    Upon publish two files will be written:\n\n    - a .usda override file containing material assignment information\n    - a .ma file containing shading networks\n\n    Note: when layering the material assignment override on a loaded Compound,\n          remember to set a matching attribute override with the namespace of\n          the loaded compound in order for the material assignment to resolve.\n    \"\"\"\n\n    label = \"Extract Multiverse USD Look\"\n    families = [\"mvLook\"]\n    scene_type = \"usda\"\n    file_formats = [\"usda\", \"usd\"]\n\n    @property\n    def options(self):\n        \"\"\"Overridable options for Multiverse USD Export\n\n        Given in the following format\n            - {NAME: EXPECTED TYPE}\n\n        If the overridden option's type does not match,\n        the option is not included and a warning is logged.\n\n        \"\"\"\n\n        return {\n            \"writeAll\": bool,\n            \"writeTransforms\": bool,\n            \"writeVisibility\": bool,\n            \"writeAttributes\": bool,\n            \"writeMaterials\": bool,\n            \"writeVariants\": bool,\n            \"writeVariantsDefinition\": bool,\n            \"writeActiveState\": bool,\n            \"writeNamespaces\": bool,\n            \"numTimeSamples\": int,\n            \"timeSamplesSpan\": float\n        }\n\n    @property\n    def default_options(self):\n        \"\"\"The default options for Multiverse USD extraction.\"\"\"\n\n        return {\n            \"writeAll\": False,\n            \"writeTransforms\": False,\n            \"writeVisibility\": False,\n            \"writeAttributes\": True,\n            \"writeMaterials\": True,\n            \"writeVariants\": False,\n            \"writeVariantsDefinition\": False,\n            \"writeActiveState\": False,\n            \"writeNamespaces\": True,\n            \"numTimeSamples\": 1,\n            \"timeSamplesSpan\": 0.0\n        }\n\n    def get_file_format(self, instance):\n        fileFormat = instance.data[\"fileFormat\"]\n        if fileFormat in range(len(self.file_formats)):\n            self.scene_type = self.file_formats[fileFormat]\n\n    def process(self, instance):\n        # Load plugin first\n        cmds.loadPlugin(\"MultiverseForMaya\", quiet=True)\n\n        # Define output file path\n        staging_dir = self.staging_dir(instance)\n        self.get_file_format(instance)\n        file_name = \"{0}.{1}\".format(instance.name, self.scene_type)\n        file_path = os.path.join(staging_dir, file_name)\n        file_path = file_path.replace('\\\\', '/')\n\n        # Parse export options\n        options = self.default_options\n        self.log.debug(\"Export options: {0}\".format(options))\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction ...\")\n\n        with maintained_selection():\n            members = instance.data(\"setMembers\")\n            members = cmds.ls(members,\n                              dag=True,\n                              shapes=False,\n                              type=\"mvUsdCompoundShape\",\n                              noIntermediate=True,\n                              long=True)\n            self.log.debug('Collected object {}'.format(members))\n            if len(members) &gt; 1:\n                self.log.error('More than one member: {}'.format(members))\n\n            import multiverse\n\n            over_write_opts = multiverse.OverridesWriteOptions()\n            options_discard_keys = {\n                \"numTimeSamples\",\n                \"timeSamplesSpan\",\n                \"frameStart\",\n                \"frameEnd\",\n                \"handleStart\",\n                \"handleEnd\",\n                \"step\",\n                \"fps\"\n            }\n            for key, value in options.items():\n                if key in options_discard_keys:\n                    continue\n                setattr(over_write_opts, key, value)\n\n            for member in members:\n                # @TODO: Make sure there is only one here.\n\n                self.log.debug(\"Writing Override for '{}'\".format(member))\n                multiverse.WriteOverrides(file_path, member, over_write_opts)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': self.scene_type,\n            'ext': self.scene_type,\n            'files': file_name,\n            'stagingDir': staging_dir\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance {} to {}\".format(\n            instance.name, file_path))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_multiverse_look.html#client.ayon_maya.plugins.publish.extract_multiverse_look.ExtractMultiverseLook.default_options","title":"<code>default_options</code>  <code>property</code>","text":"<p>The default options for Multiverse USD extraction.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_multiverse_look.html#client.ayon_maya.plugins.publish.extract_multiverse_look.ExtractMultiverseLook.options","title":"<code>options</code>  <code>property</code>","text":"<p>Overridable options for Multiverse USD Export</p> <p>Given in the following format     - {NAME: EXPECTED TYPE}</p> <p>If the overridden option's type does not match, the option is not included and a warning is logged.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_multiverse_usd.html","title":"extract_multiverse_usd","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_multiverse_usd.html#client.ayon_maya.plugins.publish.extract_multiverse_usd.ExtractMultiverseUsd","title":"<code>ExtractMultiverseUsd</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extractor for Multiverse USD Asset data.</p> <p>This will extract settings for a Multiverse Write Asset operation: they are visible in the Maya set node created by a Multiverse USD Asset instance creator.</p> <p>The input data contained in the set is:</p> <ul> <li>a single hierarchy of Maya nodes. Multiverse supports a variety of Maya   nodes such as transforms, mesh, curves, particles, instances, particle   instancers, pfx, MASH, lights, cameras, joints, connected materials,   shading networks etc. including many of their attributes.</li> </ul> <p>Upon publish a .usd (or .usdz) asset file will be typically written.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_multiverse_usd.py</code> <pre><code>class ExtractMultiverseUsd(plugin.MayaExtractorPlugin):\n    \"\"\"Extractor for Multiverse USD Asset data.\n\n    This will extract settings for a Multiverse Write Asset operation:\n    they are visible in the Maya set node created by a Multiverse USD\n    Asset instance creator.\n\n    The input data contained in the set is:\n\n    - a single hierarchy of Maya nodes. Multiverse supports a variety of Maya\n      nodes such as transforms, mesh, curves, particles, instances, particle\n      instancers, pfx, MASH, lights, cameras, joints, connected materials,\n      shading networks etc. including many of their attributes.\n\n    Upon publish a .usd (or .usdz) asset file will be typically written.\n    \"\"\"\n\n    label = \"Extract Multiverse USD Asset\"\n    families = [\"mvUsd\"]\n    scene_type = \"usd\"\n    file_formats = [\"usd\", \"usda\", \"usdz\"]\n\n    @property\n    def options(self):\n        \"\"\"Overridable options for Multiverse USD Export\n\n        Given in the following format\n            - {NAME: EXPECTED TYPE}\n\n        If the overridden option's type does not match,\n        the option is not included and a warning is logged.\n\n        \"\"\"\n\n        return {\n            \"stripNamespaces\": bool,\n            \"mergeTransformAndShape\": bool,\n            \"writeAncestors\": bool,\n            \"flattenParentXforms\": bool,\n            \"writeSparseOverrides\": bool,\n            \"useMetaPrimPath\": bool,\n            \"customRootPath\": str,\n            \"customAttributes\": str,\n            \"nodeTypesToIgnore\": str,\n            \"writeMeshes\": bool,\n            \"writeCurves\": bool,\n            \"writeParticles\": bool,\n            \"writeCameras\": bool,\n            \"writeLights\": bool,\n            \"writeJoints\": bool,\n            \"writeCollections\": bool,\n            \"writePositions\": bool,\n            \"writeNormals\": bool,\n            \"writeUVs\": bool,\n            \"writeColorSets\": bool,\n            \"writeTangents\": bool,\n            \"writeRefPositions\": bool,\n            \"writeBlendShapes\": bool,\n            \"writeDisplayColor\": bool,\n            \"writeSkinWeights\": bool,\n            \"writeMaterialAssignment\": bool,\n            \"writeHardwareShader\": bool,\n            \"writeShadingNetworks\": bool,\n            \"writeTransformMatrix\": bool,\n            \"writeUsdAttributes\": bool,\n            \"writeInstancesAsReferences\": bool,\n            \"timeVaryingTopology\": bool,\n            \"customMaterialNamespace\": str,\n            \"numTimeSamples\": int,\n            \"timeSamplesSpan\": float\n        }\n\n    @property\n    def default_options(self):\n        \"\"\"The default options for Multiverse USD extraction.\"\"\"\n\n        return {\n            \"stripNamespaces\": False,\n            \"mergeTransformAndShape\": False,\n            \"writeAncestors\": False,\n            \"flattenParentXforms\": False,\n            \"writeSparseOverrides\": False,\n            \"useMetaPrimPath\": False,\n            \"customRootPath\": str(),\n            \"customAttributes\": str(),\n            \"nodeTypesToIgnore\": str(),\n            \"writeMeshes\": True,\n            \"writeCurves\": True,\n            \"writeParticles\": True,\n            \"writeCameras\": False,\n            \"writeLights\": False,\n            \"writeJoints\": False,\n            \"writeCollections\": False,\n            \"writePositions\": True,\n            \"writeNormals\": True,\n            \"writeUVs\": True,\n            \"writeColorSets\": False,\n            \"writeTangents\": False,\n            \"writeRefPositions\": False,\n            \"writeBlendShapes\": False,\n            \"writeDisplayColor\": False,\n            \"writeSkinWeights\": False,\n            \"writeMaterialAssignment\": False,\n            \"writeHardwareShader\": False,\n            \"writeShadingNetworks\": False,\n            \"writeTransformMatrix\": True,\n            \"writeUsdAttributes\": False,\n            \"writeInstancesAsReferences\": False,\n            \"timeVaryingTopology\": False,\n            \"customMaterialNamespace\": str(),\n            \"numTimeSamples\": 1,\n            \"timeSamplesSpan\": 0.0\n        }\n\n    def parse_overrides(self, instance, options):\n        \"\"\"Inspect data of instance to determine overridden options\"\"\"\n\n        for key in instance.data:\n            if key not in self.options:\n                continue\n\n            # Ensure the data is of correct type\n            value = instance.data[key]\n            if isinstance(value, str):\n                value = str(value)\n            if not isinstance(value, self.options[key]):\n                self.log.warning(\n                    \"Overridden attribute {key} was of \"\n                    \"the wrong type: {invalid_type} \"\n                    \"- should have been {valid_type}\".format(\n                        key=key,\n                        invalid_type=type(value).__name__,\n                        valid_type=self.options[key].__name__))\n                continue\n\n            options[key] = value\n\n        return options\n\n    def get_default_options(self):\n        return self.default_options\n\n    def filter_members(self, members):\n        return members\n\n    def process(self, instance):\n\n        # Load plugin first\n        cmds.loadPlugin(\"MultiverseForMaya\", quiet=True)\n\n        # Define output file path\n        staging_dir = self.staging_dir(instance)\n        file_format = instance.data.get(\"fileFormat\", 0)\n        if file_format in range(len(self.file_formats)):\n            self.scene_type = self.file_formats[file_format]\n        file_name = \"{0}.{1}\".format(instance.name, self.scene_type)\n        file_path = os.path.join(staging_dir, file_name)\n        file_path = file_path.replace('\\\\', '/')\n\n        # Parse export options\n        options = self.get_default_options()\n        options = self.parse_overrides(instance, options)\n        self.log.debug(\"Export options: {0}\".format(options))\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction ...\")\n\n        with maintained_selection():\n            members = instance.data(\"setMembers\")\n            self.log.debug('Collected objects: {}'.format(members))\n            members = self.filter_members(members)\n            if not members:\n                self.log.error('No members!')\n                return\n            self.log.debug(' - filtered: {}'.format(members))\n\n            import multiverse\n\n            time_opts = None\n            frame_start = instance.data['frameStart']\n            frame_end = instance.data['frameEnd']\n            if frame_end != frame_start:\n                time_opts = multiverse.TimeOptions()\n\n                time_opts.writeTimeRange = True\n\n                handle_start = instance.data['handleStart']\n                handle_end = instance.data['handleEnd']\n\n                time_opts.frameRange = (\n                    frame_start - handle_start, frame_end + handle_end)\n                time_opts.frameIncrement = instance.data['step']\n                time_opts.numTimeSamples = instance.data.get(\n                    'numTimeSamples', options['numTimeSamples'])\n                time_opts.timeSamplesSpan = instance.data.get(\n                    'timeSamplesSpan', options['timeSamplesSpan'])\n                time_opts.framePerSecond = instance.data.get(\n                    'fps', mel.eval('currentTimeUnitToFPS()'))\n\n            asset_write_opts = multiverse.AssetWriteOptions(time_opts)\n            options_discard_keys = {\n                'numTimeSamples',\n                'timeSamplesSpan',\n                'frameStart',\n                'frameEnd',\n                'handleStart',\n                'handleEnd',\n                'step',\n                'fps'\n            }\n            self.log.debug(\"Write Options:\")\n            for key, value in options.items():\n                if key in options_discard_keys:\n                    continue\n\n                self.log.debug(\" - {}={}\".format(key, value))\n                setattr(asset_write_opts, key, value)\n\n            self.log.debug('WriteAsset: {} / {}'.format(file_path, members))\n            multiverse.WriteAsset(file_path, members, asset_write_opts)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': self.scene_type,\n            'ext': self.scene_type,\n            'files': file_name,\n            'stagingDir': staging_dir\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance {} to {}\".format(\n            instance.name, file_path))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_multiverse_usd.html#client.ayon_maya.plugins.publish.extract_multiverse_usd.ExtractMultiverseUsd.default_options","title":"<code>default_options</code>  <code>property</code>","text":"<p>The default options for Multiverse USD extraction.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_multiverse_usd.html#client.ayon_maya.plugins.publish.extract_multiverse_usd.ExtractMultiverseUsd.options","title":"<code>options</code>  <code>property</code>","text":"<p>Overridable options for Multiverse USD Export</p> <p>Given in the following format     - {NAME: EXPECTED TYPE}</p> <p>If the overridden option's type does not match, the option is not included and a warning is logged.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_multiverse_usd.html#client.ayon_maya.plugins.publish.extract_multiverse_usd.ExtractMultiverseUsd.parse_overrides","title":"<code>parse_overrides(instance, options)</code>","text":"<p>Inspect data of instance to determine overridden options</p> Source code in <code>client/ayon_maya/plugins/publish/extract_multiverse_usd.py</code> <pre><code>def parse_overrides(self, instance, options):\n    \"\"\"Inspect data of instance to determine overridden options\"\"\"\n\n    for key in instance.data:\n        if key not in self.options:\n            continue\n\n        # Ensure the data is of correct type\n        value = instance.data[key]\n        if isinstance(value, str):\n            value = str(value)\n        if not isinstance(value, self.options[key]):\n            self.log.warning(\n                \"Overridden attribute {key} was of \"\n                \"the wrong type: {invalid_type} \"\n                \"- should have been {valid_type}\".format(\n                    key=key,\n                    invalid_type=type(value).__name__,\n                    valid_type=self.options[key].__name__))\n            continue\n\n        options[key] = value\n\n    return options\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_multiverse_usd.html#client.ayon_maya.plugins.publish.extract_multiverse_usd.ExtractMultiverseUsdAnim","title":"<code>ExtractMultiverseUsdAnim</code>","text":"<p>               Bases: <code>ExtractMultiverseUsd</code></p> <p>Extractor for Multiverse USD Animation Sparse Cache data.</p> <p>This will extract the sparse cache data from the scene and generate a USD file with all the animation data.</p> <p>Upon publish a .usd sparse cache will be written.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_multiverse_usd.py</code> <pre><code>class ExtractMultiverseUsdAnim(ExtractMultiverseUsd):\n    \"\"\"Extractor for Multiverse USD Animation Sparse Cache data.\n\n    This will extract the sparse cache data from the scene and generate a\n    USD file with all the animation data.\n\n    Upon publish a .usd sparse cache will be written.\n    \"\"\"\n    label = \"Extract Multiverse USD Animation Sparse Cache\"\n    families = [\"animation\", \"usd\"]\n    match = pyblish.api.Subset\n\n    def get_default_options(self):\n        anim_options = self.default_options\n        anim_options[\"writeSparseOverrides\"] = True\n        anim_options[\"writeUsdAttributes\"] = True\n        anim_options[\"stripNamespaces\"] = True\n        return anim_options\n\n    def filter_members(self, members):\n        out_set = next((i for i in members if i.endswith(\"out_SET\")), None)\n\n        if out_set is None:\n            self.log.warning(\"Expecting out_SET\")\n            return None\n\n        members = cmds.ls(cmds.sets(out_set, query=True), long=True)\n        return members\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_multiverse_usd_comp.html","title":"extract_multiverse_usd_comp","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_multiverse_usd_comp.html#client.ayon_maya.plugins.publish.extract_multiverse_usd_comp.ExtractMultiverseUsdComposition","title":"<code>ExtractMultiverseUsdComposition</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extractor of Multiverse USD Composition data.</p> <p>This will extract settings for a Multiverse Write Composition operation: they are visible in the Maya set node created by a Multiverse USD Composition instance creator.</p> <p>The input data contained in the set is either:</p> <ul> <li>a single hierarchy consisting of several Multiverse Compound nodes, with   any number of layers, and Maya transform nodes</li> <li>a single Compound node with more than one layer (in this case the \"Write   as Compound Layers\" option should be set).</li> </ul> <p>Upon publish a .usda composition file will be written.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_multiverse_usd_comp.py</code> <pre><code>class ExtractMultiverseUsdComposition(plugin.MayaExtractorPlugin):\n    \"\"\"Extractor of Multiverse USD Composition data.\n\n    This will extract settings for a Multiverse Write Composition operation:\n    they are visible in the Maya set node created by a Multiverse USD\n    Composition instance creator.\n\n    The input data contained in the set is either:\n\n    - a single hierarchy consisting of several Multiverse Compound nodes, with\n      any number of layers, and Maya transform nodes\n    - a single Compound node with more than one layer (in this case the \"Write\n      as Compound Layers\" option should be set).\n\n    Upon publish a .usda composition file will be written.\n    \"\"\"\n\n    label = \"Extract Multiverse USD Composition\"\n    families = [\"mvUsdComposition\"]\n    scene_type = \"usd\"\n    # Order of `fileFormat` must match create_multiverse_usd_comp.py\n    file_formats = [\"usda\", \"usd\"]\n\n    @property\n    def options(self):\n        \"\"\"Overridable options for Multiverse USD Export\n\n        Given in the following format\n            - {NAME: EXPECTED TYPE}\n\n        If the overridden option's type does not match,\n        the option is not included and a warning is logged.\n\n        \"\"\"\n\n        return {\n            \"stripNamespaces\": bool,\n            \"mergeTransformAndShape\": bool,\n            \"flattenContent\": bool,\n            \"writeAsCompoundLayers\": bool,\n            \"writePendingOverrides\": bool,\n            \"numTimeSamples\": int,\n            \"timeSamplesSpan\": float\n        }\n\n    @property\n    def default_options(self):\n        \"\"\"The default options for Multiverse USD extraction.\"\"\"\n\n        return {\n            \"stripNamespaces\": True,\n            \"mergeTransformAndShape\": False,\n            \"flattenContent\": False,\n            \"writeAsCompoundLayers\": False,\n            \"writePendingOverrides\": False,\n            \"numTimeSamples\": 1,\n            \"timeSamplesSpan\": 0.0\n        }\n\n    def parse_overrides(self, instance, options):\n        \"\"\"Inspect data of instance to determine overridden options\"\"\"\n\n        for key in instance.data:\n            if key not in self.options:\n                continue\n\n            # Ensure the data is of correct type\n            value = instance.data[key]\n            if not isinstance(value, self.options[key]):\n                self.log.warning(\n                    \"Overridden attribute {key} was of \"\n                    \"the wrong type: {invalid_type} \"\n                    \"- should have been {valid_type}\".format(\n                        key=key,\n                        invalid_type=type(value).__name__,\n                        valid_type=self.options[key].__name__))\n                continue\n\n            options[key] = value\n\n        return options\n\n    def process(self, instance):\n        # Load plugin first\n        cmds.loadPlugin(\"MultiverseForMaya\", quiet=True)\n\n        # Define output file path\n        staging_dir = self.staging_dir(instance)\n        file_format = instance.data.get(\"fileFormat\", 0)\n        if file_format in range(len(self.file_formats)):\n            self.scene_type = self.file_formats[file_format]\n        file_name = \"{0}.{1}\".format(instance.name, self.scene_type)\n        file_path = os.path.join(staging_dir, file_name)\n        file_path = file_path.replace('\\\\', '/')\n\n        # Parse export options\n        options = self.default_options\n        options = self.parse_overrides(instance, options)\n        self.log.debug(\"Export options: {0}\".format(options))\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction ...\")\n\n        with maintained_selection():\n            members = instance.data(\"setMembers\")\n            self.log.debug('Collected object {}'.format(members))\n\n            import multiverse\n\n            time_opts = None\n            frame_start = instance.data['frameStart']\n            frame_end = instance.data['frameEnd']\n            handle_start = instance.data['handleStart']\n            handle_end = instance.data['handleEnd']\n            step = instance.data['step']\n            fps = instance.data['fps']\n            if frame_end != frame_start:\n                time_opts = multiverse.TimeOptions()\n\n                time_opts.writeTimeRange = True\n                time_opts.frameRange = (\n                    frame_start - handle_start, frame_end + handle_end)\n                time_opts.frameIncrement = step\n                time_opts.numTimeSamples = instance.data[\"numTimeSamples\"]\n                time_opts.timeSamplesSpan = instance.data[\"timeSamplesSpan\"]\n                time_opts.framePerSecond = fps\n\n            comp_write_opts = multiverse.CompositionWriteOptions()\n\n            \"\"\"\n            OP tells MV to write to a staging directory, and then moves the\n            file to it's final publish directory. By default, MV write relative\n            paths, but these paths will break when the referencing file moves.\n            This option forces writes to absolute paths, which is ok within OP\n            because all published assets have static paths, and MV can only\n            reference published assets. When a proper UsdAssetResolver is used,\n            this won't be needed.\n            \"\"\"\n            comp_write_opts.forceAbsolutePaths = True\n\n            options_discard_keys = {\n                'numTimeSamples',\n                'timeSamplesSpan',\n                'frameStart',\n                'frameEnd',\n                'handleStart',\n                'handleEnd',\n                'step',\n                'fps'\n            }\n            for key, value in options.items():\n                if key in options_discard_keys:\n                    continue\n                setattr(comp_write_opts, key, value)\n\n            multiverse.WriteComposition(file_path, members, comp_write_opts)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': self.scene_type,\n            'ext': self.scene_type,\n            'files': file_name,\n            'stagingDir': staging_dir\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance {} to {}\".format(instance.name,\n                                                            file_path))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_multiverse_usd_comp.html#client.ayon_maya.plugins.publish.extract_multiverse_usd_comp.ExtractMultiverseUsdComposition.default_options","title":"<code>default_options</code>  <code>property</code>","text":"<p>The default options for Multiverse USD extraction.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_multiverse_usd_comp.html#client.ayon_maya.plugins.publish.extract_multiverse_usd_comp.ExtractMultiverseUsdComposition.options","title":"<code>options</code>  <code>property</code>","text":"<p>Overridable options for Multiverse USD Export</p> <p>Given in the following format     - {NAME: EXPECTED TYPE}</p> <p>If the overridden option's type does not match, the option is not included and a warning is logged.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_multiverse_usd_comp.html#client.ayon_maya.plugins.publish.extract_multiverse_usd_comp.ExtractMultiverseUsdComposition.parse_overrides","title":"<code>parse_overrides(instance, options)</code>","text":"<p>Inspect data of instance to determine overridden options</p> Source code in <code>client/ayon_maya/plugins/publish/extract_multiverse_usd_comp.py</code> <pre><code>def parse_overrides(self, instance, options):\n    \"\"\"Inspect data of instance to determine overridden options\"\"\"\n\n    for key in instance.data:\n        if key not in self.options:\n            continue\n\n        # Ensure the data is of correct type\n        value = instance.data[key]\n        if not isinstance(value, self.options[key]):\n            self.log.warning(\n                \"Overridden attribute {key} was of \"\n                \"the wrong type: {invalid_type} \"\n                \"- should have been {valid_type}\".format(\n                    key=key,\n                    invalid_type=type(value).__name__,\n                    valid_type=self.options[key].__name__))\n            continue\n\n        options[key] = value\n\n    return options\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_multiverse_usd_over.html","title":"extract_multiverse_usd_over","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_multiverse_usd_over.html#client.ayon_maya.plugins.publish.extract_multiverse_usd_over.ExtractMultiverseUsdOverride","title":"<code>ExtractMultiverseUsdOverride</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extractor for Multiverse USD Override data.</p> <p>This will extract settings for a Multiverse Write Override operation: they are visible in the Maya set node created by a Multiverse USD Override instance creator.</p> <p>The input data contained in the set is:</p> <ul> <li>a single Multiverse Compound node with any number of overrides (typically   set in MEOW)</li> </ul> <p>Upon publish a .usda override file will be written.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_multiverse_usd_over.py</code> <pre><code>class ExtractMultiverseUsdOverride(plugin.MayaExtractorPlugin):\n    \"\"\"Extractor for Multiverse USD Override data.\n\n    This will extract settings for a Multiverse Write Override operation:\n    they are visible in the Maya set node created by a Multiverse USD\n    Override instance creator.\n\n    The input data contained in the set is:\n\n    - a single Multiverse Compound node with any number of overrides (typically\n      set in MEOW)\n\n    Upon publish a .usda override file will be written.\n    \"\"\"\n\n    label = \"Extract Multiverse USD Override\"\n    families = [\"mvUsdOverride\"]\n    scene_type = \"usd\"\n    # Order of `fileFormat` must match create_multiverse_usd_over.py\n    file_formats = [\"usda\", \"usd\"]\n\n    @property\n    def options(self):\n        \"\"\"Overridable options for Multiverse USD Export\n\n        Given in the following format\n            - {NAME: EXPECTED TYPE}\n\n        If the overridden option's type does not match,\n        the option is not included and a warning is logged.\n\n        \"\"\"\n\n        return {\n            \"writeAll\": bool,\n            \"writeTransforms\": bool,\n            \"writeVisibility\": bool,\n            \"writeAttributes\": bool,\n            \"writeMaterials\": bool,\n            \"writeVariants\": bool,\n            \"writeVariantsDefinition\": bool,\n            \"writeActiveState\": bool,\n            \"writeNamespaces\": bool,\n            \"numTimeSamples\": int,\n            \"timeSamplesSpan\": float\n        }\n\n    @property\n    def default_options(self):\n        \"\"\"The default options for Multiverse USD extraction.\"\"\"\n\n        return {\n            \"writeAll\": False,\n            \"writeTransforms\": True,\n            \"writeVisibility\": True,\n            \"writeAttributes\": True,\n            \"writeMaterials\": True,\n            \"writeVariants\": True,\n            \"writeVariantsDefinition\": True,\n            \"writeActiveState\": True,\n            \"writeNamespaces\": False,\n            \"numTimeSamples\": 1,\n            \"timeSamplesSpan\": 0.0\n        }\n\n    def process(self, instance):\n        # Load plugin first\n        cmds.loadPlugin(\"MultiverseForMaya\", quiet=True)\n\n        # Define output file path\n        staging_dir = self.staging_dir(instance)\n        file_format = instance.data.get(\"fileFormat\", 0)\n        if file_format in range(len(self.file_formats)):\n            self.scene_type = self.file_formats[file_format]\n        file_name = \"{0}.{1}\".format(instance.name, self.scene_type)\n        file_path = os.path.join(staging_dir, file_name)\n        file_path = file_path.replace(\"\\\\\", \"/\")\n\n        # Parse export options\n        options = self.default_options\n        self.log.debug(\"Export options: {0}\".format(options))\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction ...\")\n\n        with maintained_selection():\n            members = instance.data(\"setMembers\")\n            members = cmds.ls(members,\n                              dag=True,\n                              shapes=False,\n                              type=\"mvUsdCompoundShape\",\n                              noIntermediate=True,\n                              long=True)\n            self.log.debug(\"Collected object {}\".format(members))\n\n            # TODO: Deal with asset, composition, override with options.\n            import multiverse\n\n            time_opts = None\n            frame_start = instance.data[\"frameStart\"]\n            frame_end = instance.data[\"frameEnd\"]\n            handle_start = instance.data[\"handleStart\"]\n            handle_end = instance.data[\"handleEnd\"]\n            step = instance.data[\"step\"]\n            fps = instance.data[\"fps\"]\n            if frame_end != frame_start:\n                time_opts = multiverse.TimeOptions()\n\n                time_opts.writeTimeRange = True\n                time_opts.frameRange = (\n                    frame_start - handle_start, frame_end + handle_end)\n                time_opts.frameIncrement = step\n                time_opts.numTimeSamples = instance.data[\"numTimeSamples\"]\n                time_opts.timeSamplesSpan = instance.data[\"timeSamplesSpan\"]\n                time_opts.framePerSecond = fps\n\n            over_write_opts = multiverse.OverridesWriteOptions(time_opts)\n            options_discard_keys = {\n                \"numTimeSamples\",\n                \"timeSamplesSpan\",\n                \"frameStart\",\n                \"frameEnd\",\n                \"handleStart\",\n                \"handleEnd\",\n                \"step\",\n                \"fps\"\n            }\n            for key, value in options.items():\n                if key in options_discard_keys:\n                    continue\n                setattr(over_write_opts, key, value)\n\n            for member in members:\n                multiverse.WriteOverrides(file_path, member, over_write_opts)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': self.scene_type,\n            'ext': self.scene_type,\n            'files': file_name,\n            'stagingDir': staging_dir\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance {} to {}\".format(\n            instance.name, file_path))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_multiverse_usd_over.html#client.ayon_maya.plugins.publish.extract_multiverse_usd_over.ExtractMultiverseUsdOverride.default_options","title":"<code>default_options</code>  <code>property</code>","text":"<p>The default options for Multiverse USD extraction.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_multiverse_usd_over.html#client.ayon_maya.plugins.publish.extract_multiverse_usd_over.ExtractMultiverseUsdOverride.options","title":"<code>options</code>  <code>property</code>","text":"<p>Overridable options for Multiverse USD Export</p> <p>Given in the following format     - {NAME: EXPECTED TYPE}</p> <p>If the overridden option's type does not match, the option is not included and a warning is logged.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_obj.html","title":"extract_obj","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_obj.html#client.ayon_maya.plugins.publish.extract_obj.ExtractObj","title":"<code>ExtractObj</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract OBJ from Maya.</p> <p>This extracts reproducible OBJ exports ignoring any of the settings set on the local machine in the OBJ export options window.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_obj.py</code> <pre><code>class ExtractObj(plugin.MayaExtractorPlugin,\n                 OptionalPyblishPluginMixin):\n    \"\"\"Extract OBJ from Maya.\n\n    This extracts reproducible OBJ exports ignoring any of the settings\n    set on the local machine in the OBJ export options window.\n\n    \"\"\"\n    order = pyblish.api.ExtractorOrder\n    label = \"Extract OBJ\"\n    families = [\"model\"]\n\n    # Default OBJ export options.\n    obj_options = {\n        \"groups\": 1,\n        \"ptgroups\": 1,\n        \"materials\": 0,\n        \"smoothing\": 1,\n        \"normals\": 1,\n    }\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Define output path\n\n        staging_dir = self.staging_dir(instance)\n        filename = \"{0}.obj\".format(instance.name)\n        path = os.path.join(staging_dir, filename)\n\n        # The export requires forward slashes because we need to\n        # format it into a string in a mel expression\n\n        self.log.debug(\"Extracting OBJ to: {0}\".format(path))\n\n        members = instance.data(\"setMembers\")\n        members = cmds.ls(members,\n                          dag=True,\n                          shapes=True,\n                          type=(\"mesh\", \"nurbsCurve\"),\n                          noIntermediate=True,\n                          long=True)\n        self.log.debug(\"Members: {0}\".format(members))\n        self.log.debug(\"Instance: {0}\".format(instance[:]))\n\n        if not cmds.pluginInfo('objExport', query=True, loaded=True):\n            cmds.loadPlugin('objExport')\n\n        # Check if shaders should be included as part of the model export. If\n        # False, the default shader is assigned to the geometry.\n        include_shaders = instance.data.get(\"include_shaders\", False)\n        options = self.obj_options.copy()\n        if include_shaders:\n            options[\"materials\"] = 1\n\n        # Format options for the OBJexport command.\n        options_str = ';'.join(\n            f\"{key}={val}\" for key, val in options.items()\n        )\n\n        # Export    \n        with lib.no_display_layers(instance):\n            with lib.displaySmoothness(members,\n                                       divisionsU=0,\n                                       divisionsV=0,\n                                       pointsWire=4,\n                                       pointsShaded=1,\n                                       polygonObject=1):\n                with lib.maintained_selection():\n                    cmds.select(members, noExpand=True)\n                    cmds.file(path,\n                              exportSelected=True,\n                              type='OBJexport',\n                              op=options_str,\n                              preserveReferences=True,\n                              force=True)\n\n        if include_shaders:\n            # Materials for `.obj` files are exported to a `.mtl` file that\n            # usually lives next to the `.obj` and is referenced to by filename\n            # from the `.obj` file itself, like:\n            # mtllib modelMain.mtl\n            # We want to copy the file over and preserve the filename for\n            # the materials to load correctly for the obj file, so we add it\n            # as explicit file transfer\n            mtl_source = path[:-len(\".obj\")] + \".mtl\"\n            mtl_filename = os.path.basename(mtl_source)\n            publish_dir = instance.data[\"publishDir\"]\n            mtl_destination = os.path.join(publish_dir, mtl_filename)\n            transfers = instance.data.setdefault(\"transfers\", [])\n            transfers.append((mtl_source, mtl_destination))\n            self.log.debug(f\"Including .mtl file: {mtl_filename}\")\n\n            # Include any images from the obj export\n            textures = get_textures_from_mtl(mtl_source)\n            for texture_src in textures:\n                texture_dest = os.path.join(publish_dir,\n                                            os.path.basename(texture_src))\n                self.log.debug(f\"Including texture: {texture_src}\")\n                transfers.append((texture_src, texture_dest))\n\n        if \"representation\" not in instance.data:\n            instance.data[\"representation\"] = []\n\n        representation = {\n            'name': 'obj',\n            'ext': 'obj',\n            'files': filename,\n            \"stagingDir\": staging_dir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extract OBJ successful to: {0}\".format(path))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_obj.html#client.ayon_maya.plugins.publish.extract_obj.get_textures_from_mtl","title":"<code>get_textures_from_mtl(mtl_filepath)</code>","text":"<p>Return all textures from a OBJ <code>.mtl</code> sidecar file.</p> <p>Each line has a separate entry, like <code>map_Ka</code>, where the filename is the last argument on that line.</p> Notes <p>Filenames with spaces in them are saved along with the <code>.obj</code> but with spaces replaced to underscores in the <code>.mtl</code> file so they can be detected as the single argument.</p> Also see <p>https://paulbourke.net/dataformats/mtl/</p> <p>Parameters:</p> Name Type Description Default <code>mtl_filepath</code> <code>str</code> <p>Full path to <code>.mtl</code> file to parse.</p> required <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: Set of files referenced in the MTL file.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_obj.py</code> <pre><code>def get_textures_from_mtl(mtl_filepath: str) -&gt; \"set[str]\":\n    \"\"\"Return all textures from a OBJ `.mtl` sidecar file.\n\n    Each line has a separate entry, like `map_Ka`, where the filename is the\n    last argument on that line.\n\n    Notes:\n        Filenames with spaces in them are saved along with the `.obj` but with\n        spaces replaced to underscores in the `.mtl` file so they can be\n        detected as the single argument.\n\n    Also see:\n        https://paulbourke.net/dataformats/mtl/\n\n    Arguments:\n        mtl_filepath (str): Full path to `.mtl` file to parse.\n\n    Returns:\n        set[str]: Set of files referenced in the MTL file.\n    \"\"\"\n\n    map_prefixes = (\n        \"map_Ka \", \n        \"map_Kd \", \n        \"map_Ks \", \n        \"map_Ns \", \n        \"map_d \", \n        \"disp \", \n        \"decal \",\n        \"bump \", \n        \"refl \"\n    )\n\n    folder = os.path.dirname(mtl_filepath)\n    filepaths = set()\n    with open(mtl_filepath, \"r\", encoding='utf-8') as f:\n        for line in f.readlines():\n            if line.startswith(map_prefixes):\n                line = line.strip()  # strip of end of line\n                filename = line.rsplit(\" \", 1)[-1]\n                filepath = os.path.join(folder, filename)\n                filepaths.add(filepath)\n\n    return filepaths\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_ornatrix_cache.html","title":"extract_ornatrix_cache","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_ornatrix_cache.html#client.ayon_maya.plugins.publish.extract_ornatrix_cache.ExtractOxCache","title":"<code>ExtractOxCache</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Producing Ornatrix cache files using scene time range.</p> <p>This will extract Ornatrix cache file sequence and fur settings.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_ornatrix_cache.py</code> <pre><code>class ExtractOxCache(plugin.MayaExtractorPlugin):\n    \"\"\"Producing Ornatrix cache files using scene time range.\n\n    This will extract Ornatrix cache file sequence and fur settings.\n    \"\"\"\n\n    label = \"Extract Ornatrix Cache\"\n    families = [\"oxrig\", \"oxcache\"]\n    targets = [\"local\", \"remote\"]\n\n    def process(self, instance):\n        cmds.loadPlugin(\"Ornatrix\", quiet=True)\n        dirname = self.staging_dir(instance)\n\n        ox_nodes = cmds.ls(instance[:], shapes=True, long=True)\n        ox_shape_nodes = cmds.ls(ox_nodes, type=\"HairShape\")\n        self.log.debug(\n            f\"Ornatrix HairShape nodes to extract: {ox_shape_nodes}\")\n\n        # Export the Alembic\n        ox_abc_path = os.path.join(dirname, f\"{instance.name}_ornatrix.abc\")\n        self._extract(instance, ox_shape_nodes, ox_abc_path)\n\n        # Export the .cachesettings\n        settings = instance.data[\"cachesettings\"]\n        self.log.debug(\"Writing metadata file\")\n        cachesettings_path = os.path.join(dirname, \"ornatrix.cachesettings\")\n        with open(cachesettings_path, \"w\") as fp:\n            json.dump(settings, fp, ensure_ascii=False)\n\n        # build representations\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        instance.data[\"representations\"].append(\n            {\n                'name': 'abc',\n                'ext': 'abc',\n                'files': os.path.basename(ox_abc_path),\n                'stagingDir': dirname\n            }\n        )\n\n        instance.data[\"representations\"].append(\n            {\n                'name': 'cachesettings',\n                'ext': 'cachesettings',\n                'files': os.path.basename(cachesettings_path),\n                'stagingDir': dirname\n            }\n        )\n\n        self.log.debug(\"Extracted {} to {}\".format(instance, dirname))\n\n    def _extract(self, instance, ox_shape_nodes, filepath):\n        \"\"\"Export Ornatrix Alembic by using `OxAlembicExport` command.\n\n        Args:\n            instance (pyblish.api.Instance): Publish instance.\n            filepath (str): output filepath\n        \"\"\"\n        attrs = instance.data[\"creator_attributes\"]\n        frame_range = get_frame_range(instance.data[\"taskEntity\"])\n        frame_start = attrs.get(\"frameStart\", frame_range[\"frameStart\"])\n        frame_end = attrs.get(\"frameEnd\", frame_range[\"frameEnd\"])\n\n        options = dict(\n            format=attrs.get(\"format\", 0),\n            fromTime=frame_start,\n            toTime=frame_end,\n            step=attrs.get(\"step\", 1.0),\n            renderVersion=attrs.get(\"renderVersion\", False),\n            upDirection=attrs.get(\"upDirection\", 0),\n            useWorldCoordinates=attrs.get(\"useWorldCoordinates\", True),\n            exportSurfacePositions=attrs.get(\"exportSurfacePositions\", True),\n            exportStrandData=attrs.get(\"exportStrandData\", True),\n            exportStrandIds=attrs.get(\"exportStrandIds\", True),\n            exportStrandGroups=attrs.get(\"exportStrandGroups\", True),\n            exportWidths=attrs.get(\"exportWidths\", True),\n            exportTextureCoordinates=attrs.get(\"exportTextureCoordinates\",\n                                               True),\n            exportNormals=attrs.get(\"exportNormals\", False),\n            exportVelocities=attrs.get(\"exportVelocities\", False),\n            velocityIntervalCenter=attrs.get(\"velocityIntervalCenter\", 0.0),\n            velocityIntervalLength=attrs.get(\"velocityIntervalLength\", 0.5),\n            oneObjectPerFile=False,\n            unrealEngineExport=False,\n            exportEachStrandAsSeparateObject=False\n        )\n        for key, value in options.items():\n            # Pass bool as int\n            if isinstance(value, bool):\n                options[key] = int(value)\n\n        options_str = \";\".join(\n            f\"{key}={value}\" for key, value in options.items()\n        )\n        self.log.debug(\"Extracting Ornatrix Alembic with options: %s\",\n                       options_str)\n        with lib.maintained_selection():\n            cmds.select(ox_shape_nodes, noExpand=True)\n            cmds.file(\n                filepath,\n                options=options_str,\n                type=\"Ornatrix Alembic\",\n                exportSelected=True,\n                force=True\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_ornatrix_rig.html","title":"extract_ornatrix_rig","text":"<p>Extract Ornatrix rig.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_ornatrix_rig.html#client.ayon_maya.plugins.publish.extract_ornatrix_rig.ExtractOxRig","title":"<code>ExtractOxRig</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extract the Ornatrix rig to a Maya Scene and write the Ornatrix rig data.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_ornatrix_rig.py</code> <pre><code>class ExtractOxRig(plugin.MayaExtractorPlugin):\n    \"\"\"Extract the Ornatrix rig to a Maya Scene and write the Ornatrix rig data.\"\"\"\n\n    label = \"Extract Ornatrix Rig\"\n    families = [\"oxrig\"]\n    scene_type = \"ma\"\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\"\"\"\n        cmds.loadPlugin(\"Ornatrix\", quiet=True)\n        maya_settings = instance.context.data[\"project_settings\"][\"maya\"]\n        ext_mapping = {\n            item[\"name\"]: item[\"value\"]\n            for item in maya_settings[\"ext_mapping\"]\n        }\n        if ext_mapping:\n            self.log.debug(\"Looking in settings for scene type ...\")\n            # use extension mapping for first family found\n            for family in self.families:\n                try:\n                    self.scene_type = ext_mapping[family]\n                    self.log.debug(\n                        \"Using {} as scene type\".format(self.scene_type))\n                    break\n                except KeyError:\n                    # no preset found\n                    pass\n\n        # Define extract output file path\n        dirname = self.staging_dir(instance)\n        settings_path = os.path.join(dirname, \"ornatrix.rigsettings\")\n        image_search_path = instance.data[\"resourcesDir\"]\n\n        # add textures to transfers\n        if 'transfers' not in instance.data:\n            instance.data['transfers'] = []\n\n        resources = instance.data.get(\"resources\", [])\n        for resource in resources:\n            for file in resource['files']:\n                src = file\n                dst = os.path.join(image_search_path, os.path.basename(file))\n                resource[\"destination_file\"] = dst\n                instance.data['transfers'].append([src, dst])\n\n                self.log.debug(\"adding transfer {} -&gt; {}\". format(src, dst))\n\n        self.log.debug(\"Writing metadata file: {}\".format(settings_path))\n\n        # The rigsettings contains a list of {\"node\": node_path} entries.\n        settings = []\n        for node in instance.data[\"setMembers\"]:\n            settings.append({\n                \"node\": node\n            })\n\n        with open(settings_path, \"w\") as fp:\n            json.dump(settings, fp, ensure_ascii=False)\n\n        texture_attributes = {\n            resource[\"texture_attribute\"]: resource[\"destination_file\"]\n            for resource in resources\n        }\n        # Ornatrix related staging dirs\n        maya_path = os.path.join(dirname,\n                                 \"ornatrix_rig.{}\".format(self.scene_type))\n        ox_groom_path = os.path.join(dirname, \"ornatrix_rig.oxg.zip\")\n        ox_groom_path = ox_groom_path.replace(\"\\\\\", \"/\")\n        nodes = instance.data[\"setMembers\"]\n        with lib.maintained_selection():\n            # Export ornatrix_rig.ma (or .mb)\n            with lib.attribute_values(texture_attributes):\n                cmds.select(nodes, noExpand=True)\n                cmds.file(maya_path,\n                          force=True,\n                          exportSelected=True,\n                          type=\"mayaAscii\" if self.scene_type == \"ma\" else \"mayaBinary\",  # noqa: E501\n                          preserveReferences=False,\n                          constructionHistory=True,\n                          shader=True)\n\n            # Export ornatrix_rig.oxg.zip\n            cmds.select(nodes, noExpand=True)\n            cmds.OxSaveGroom(path=ox_groom_path, optional=True)\n\n        # Ensure files can be stored\n        # build representations\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        self.log.debug(f\"Ornatrix rig file: {maya_path}\")\n        instance.data[\"representations\"].append(\n            {\n                'name': self.scene_type,\n                'ext': self.scene_type,\n                'files': os.path.basename(maya_path),\n                'stagingDir': dirname\n            }\n        )\n\n        self.log.debug(f\"OxGroom file: {ox_groom_path}\")\n        instance.data[\"representations\"].append(\n            {\n                'name': \"oxg.zip\",\n                'ext': \"oxg.zip\",\n                'files': os.path.basename(ox_groom_path),\n                'stagingDir': dirname\n            }\n        )\n\n        self.log.debug(f\"Ornatrix rigsettings file: {settings_path}\")\n        instance.data[\"representations\"].append(\n            {\n                'name': \"rigsettings\",\n                'ext': \"rigsettings\",\n                'files': os.path.basename(settings_path),\n                'stagingDir': dirname\n            }\n        )\n\n        self.log.debug(\"Extracted {} to {}\".format(instance, dirname))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_ornatrix_rig.html#client.ayon_maya.plugins.publish.extract_ornatrix_rig.ExtractOxRig.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_ornatrix_rig.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\"\"\"\n    cmds.loadPlugin(\"Ornatrix\", quiet=True)\n    maya_settings = instance.context.data[\"project_settings\"][\"maya\"]\n    ext_mapping = {\n        item[\"name\"]: item[\"value\"]\n        for item in maya_settings[\"ext_mapping\"]\n    }\n    if ext_mapping:\n        self.log.debug(\"Looking in settings for scene type ...\")\n        # use extension mapping for first family found\n        for family in self.families:\n            try:\n                self.scene_type = ext_mapping[family]\n                self.log.debug(\n                    \"Using {} as scene type\".format(self.scene_type))\n                break\n            except KeyError:\n                # no preset found\n                pass\n\n    # Define extract output file path\n    dirname = self.staging_dir(instance)\n    settings_path = os.path.join(dirname, \"ornatrix.rigsettings\")\n    image_search_path = instance.data[\"resourcesDir\"]\n\n    # add textures to transfers\n    if 'transfers' not in instance.data:\n        instance.data['transfers'] = []\n\n    resources = instance.data.get(\"resources\", [])\n    for resource in resources:\n        for file in resource['files']:\n            src = file\n            dst = os.path.join(image_search_path, os.path.basename(file))\n            resource[\"destination_file\"] = dst\n            instance.data['transfers'].append([src, dst])\n\n            self.log.debug(\"adding transfer {} -&gt; {}\". format(src, dst))\n\n    self.log.debug(\"Writing metadata file: {}\".format(settings_path))\n\n    # The rigsettings contains a list of {\"node\": node_path} entries.\n    settings = []\n    for node in instance.data[\"setMembers\"]:\n        settings.append({\n            \"node\": node\n        })\n\n    with open(settings_path, \"w\") as fp:\n        json.dump(settings, fp, ensure_ascii=False)\n\n    texture_attributes = {\n        resource[\"texture_attribute\"]: resource[\"destination_file\"]\n        for resource in resources\n    }\n    # Ornatrix related staging dirs\n    maya_path = os.path.join(dirname,\n                             \"ornatrix_rig.{}\".format(self.scene_type))\n    ox_groom_path = os.path.join(dirname, \"ornatrix_rig.oxg.zip\")\n    ox_groom_path = ox_groom_path.replace(\"\\\\\", \"/\")\n    nodes = instance.data[\"setMembers\"]\n    with lib.maintained_selection():\n        # Export ornatrix_rig.ma (or .mb)\n        with lib.attribute_values(texture_attributes):\n            cmds.select(nodes, noExpand=True)\n            cmds.file(maya_path,\n                      force=True,\n                      exportSelected=True,\n                      type=\"mayaAscii\" if self.scene_type == \"ma\" else \"mayaBinary\",  # noqa: E501\n                      preserveReferences=False,\n                      constructionHistory=True,\n                      shader=True)\n\n        # Export ornatrix_rig.oxg.zip\n        cmds.select(nodes, noExpand=True)\n        cmds.OxSaveGroom(path=ox_groom_path, optional=True)\n\n    # Ensure files can be stored\n    # build representations\n    if \"representations\" not in instance.data:\n        instance.data[\"representations\"] = []\n\n    self.log.debug(f\"Ornatrix rig file: {maya_path}\")\n    instance.data[\"representations\"].append(\n        {\n            'name': self.scene_type,\n            'ext': self.scene_type,\n            'files': os.path.basename(maya_path),\n            'stagingDir': dirname\n        }\n    )\n\n    self.log.debug(f\"OxGroom file: {ox_groom_path}\")\n    instance.data[\"representations\"].append(\n        {\n            'name': \"oxg.zip\",\n            'ext': \"oxg.zip\",\n            'files': os.path.basename(ox_groom_path),\n            'stagingDir': dirname\n        }\n    )\n\n    self.log.debug(f\"Ornatrix rigsettings file: {settings_path}\")\n    instance.data[\"representations\"].append(\n        {\n            'name': \"rigsettings\",\n            'ext': \"rigsettings\",\n            'files': os.path.basename(settings_path),\n            'stagingDir': dirname\n        }\n    )\n\n    self.log.debug(\"Extracted {} to {}\".format(instance, dirname))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_playblast.html","title":"extract_playblast","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_playblast.html#client.ayon_maya.plugins.publish.extract_playblast.ExtractPlayblast","title":"<code>ExtractPlayblast</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extract viewport playblast.</p> <p>Takes review camera and creates review Quicktime video based on viewport capture.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_playblast.py</code> <pre><code>class ExtractPlayblast(plugin.MayaExtractorPlugin):\n    \"\"\"Extract viewport playblast.\n\n    Takes review camera and creates review Quicktime video based on viewport\n    capture.\n\n    \"\"\"\n\n    label = \"Extract Playblast\"\n    families = [\"review\"]\n    optional = True\n    capture_preset = {}\n    profiles = None\n\n    def process(self, instance):\n        self.log.debug(\"Extracting playblast..\")\n\n        # get scene fps\n        fps = instance.data.get(\"fps\") or instance.context.data.get(\"fps\")\n\n        # if start and end frames cannot be determined, get them\n        # from Maya timeline\n        start = instance.data.get(\"frameStartFtrack\")\n        end = instance.data.get(\"frameEndFtrack\")\n        if start is None:\n            start = cmds.playbackOptions(query=True, animationStartTime=True)\n        if end is None:\n            end = cmds.playbackOptions(query=True, animationEndTime=True)\n\n        self.log.debug(\"start: {}, end: {}\".format(start, end))\n        task_data = instance.data[\"anatomyData\"].get(\"task\", {})\n        capture_preset = lib.get_capture_preset(\n            task_data.get(\"name\"),\n            task_data.get(\"type\"),\n            instance.data[\"productName\"],\n            instance.context.data[\"project_settings\"],\n            self.log\n        )\n        stagingdir = self.staging_dir(instance)\n        filename = instance.name\n        path = os.path.join(stagingdir, filename)\n        self.log.debug(\"Outputting images to %s\" % path)\n        # get cameras\n        camera = instance.data[\"review_camera\"]\n        preset = lib.generate_capture_preset(\n            instance, camera, path,\n            start=start, end=end,\n            capture_preset=capture_preset)\n        lib.render_capture_preset(preset)\n\n        # Find playblast sequence\n        collected_files = os.listdir(stagingdir)\n        patterns = [clique.PATTERNS[\"frames\"]]\n        collections, remainder = clique.assemble(collected_files,\n                                                 minimum_items=1,\n                                                 patterns=patterns)\n\n        self.log.debug(\"Searching playblast collection for: %s\", path)\n        frame_collection = None\n        for collection in collections:\n            filebase = collection.format(\"{head}\").rstrip(\".\")\n            self.log.debug(\"Checking collection head: %s\", filebase)\n            if filebase in path:\n                frame_collection = collection\n                self.log.debug(\n                    \"Found playblast collection: %s\", frame_collection\n                )\n\n        tags = [\"review\"]\n        if not instance.data.get(\"keepImages\"):\n            tags.append(\"delete\")\n\n        # Add camera node name to representation data\n        camera_node_name = cmds.listRelatives(camera, parent=True)[0]\n\n        collected_files = list(frame_collection)\n        # single frame file shouldn't be in list, only as a string\n        if len(collected_files) == 1:\n            collected_files = collected_files[0]\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            \"name\": capture_preset[\"Codec\"][\"compression\"],\n            \"ext\": capture_preset[\"Codec\"][\"compression\"],\n            \"files\": collected_files,\n            \"stagingDir\": stagingdir,\n            \"frameStart\": int(start),\n            \"frameEnd\": int(end),\n            \"fps\": fps,\n            \"tags\": tags,\n            \"camera_name\": camera_node_name\n        }\n        instance.data[\"representations\"].append(representation)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_pointcache.html","title":"extract_pointcache","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_pointcache.html#client.ayon_maya.plugins.publish.extract_pointcache.ExtractAlembic","title":"<code>ExtractAlembic</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Produce an alembic of just point positions and normals.</p> <p>Positions and normals, uvs, creases are preserved, but nothing more, for plain and predictable point caches.</p> <p>Plugin can run locally or remotely (on a farm - if instance is marked with \"farm\" it will be skipped in local processing, but processed on farm)</p> Source code in <code>client/ayon_maya/plugins/publish/extract_pointcache.py</code> <pre><code>class ExtractAlembic(plugin.MayaExtractorPlugin,\n                     OptionalPyblishPluginMixin):\n    \"\"\"Produce an alembic of just point positions and normals.\n\n    Positions and normals, uvs, creases are preserved, but nothing more,\n    for plain and predictable point caches.\n\n    Plugin can run locally or remotely (on a farm - if instance is marked with\n    \"farm\" it will be skipped in local processing, but processed on farm)\n    \"\"\"\n\n    label = \"Extract Pointcache (Alembic)\"\n    hosts = [\"maya\"]\n    families = [\"pointcache\", \"model\", \"vrayproxy.alembic\"]\n    targets = [\"local\", \"remote\"]\n    optional = False\n    # From settings\n    attr = []\n    attrPrefix = []\n    bake_attributes = []\n    bake_attribute_prefixes = []\n    dataFormat = \"ogawa\"\n    eulerFilter = False\n    melPerFrameCallback = \"\"\n    melPostJobCallback = \"\"\n    overrides = []\n    preRoll = False\n    preRollStartFrame = 0\n    pythonPerFrameCallback = \"\"\n    pythonPostJobCallback = \"\"\n    renderableOnly = False\n    stripNamespaces = True\n    uvsOnly = False\n    uvWrite = False\n    userAttr = \"\"\n    userAttrPrefix = \"\"\n    verbose = False\n    visibleOnly = False\n    wholeFrameGeo = False\n    worldSpace = True\n    writeColorSets = False\n    writeCreases = False\n    writeFaceSets = False\n    writeNormals = True\n    writeUVSets = False\n    writeVisibility = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        if instance.data.get(\"farm\"):\n            self.log.debug(\"Should be processed on farm, skipping.\")\n            return\n\n        nodes, roots = self.get_members_and_roots(instance)\n\n        # Collect the start and end including handles\n        start = float(instance.data.get(\"frameStartHandle\", 1))\n        end = float(instance.data.get(\"frameEndHandle\", 1))\n\n        attribute_values = self.get_attr_values_from_data(\n            instance.data\n        )\n\n        attrs = [\n            attr.strip()\n            for attr in attribute_values.get(\"attr\", \"\").split(\";\")\n            if attr.strip()\n        ]\n        attrs += instance.data.get(\"userDefinedAttributes\", [])\n        attrs += self.bake_attributes\n        attrs += [\"cbId\"]\n\n        attr_prefixes = [\n            attr.strip()\n            for attr in attribute_values.get(\"attrPrefix\", \"\").split(\";\")\n            if attr.strip()\n        ]\n        attr_prefixes += self.bake_attribute_prefixes\n\n        user_attrs = [\n            attr.strip()\n            for attr in attribute_values.get(\"userAttr\", \"\").split(\";\")\n            if attr.strip()\n        ]\n\n        user_attr_prefixes = [\n            attr.strip()\n            for attr in attribute_values.get(\"userAttrPrefix\", \"\").split(\";\")\n            if attr.strip()\n        ]\n\n        self.log.debug(\"Extracting pointcache..\")\n        dirname = self.staging_dir(instance)\n\n        parent_dir = self.staging_dir(instance)\n        filename = \"{name}.abc\".format(**instance.data)\n        path = os.path.join(parent_dir, filename)\n\n        root = None\n        if not instance.data.get(\"includeParentHierarchy\", True):\n            # Set the root nodes if we don't want to include parents\n            # The roots are to be considered the ones that are the actual\n            # direct members of the set\n            # We ignore members that are children of other members to avoid\n            # the parenting / ancestor relationship error on export and assume\n            # the user intended to export starting at the top of the two.\n            root = get_highest_in_hierarchy(roots)\n\n        kwargs = {\n            \"file\": path,\n            \"attr\": attrs,\n            \"attrPrefix\": attr_prefixes,\n            \"userAttr\": user_attrs,\n            \"userAttrPrefix\": user_attr_prefixes,\n            \"dataFormat\": attribute_values.get(\"dataFormat\", self.dataFormat),\n            \"endFrame\": end,\n            \"eulerFilter\": attribute_values.get(\n                \"eulerFilter\", self.eulerFilter\n            ),\n            \"preRoll\": attribute_values.get(\"preRoll\", self.preRoll),\n            \"preRollStartFrame\": attribute_values.get(\n                \"preRollStartFrame\", self.preRollStartFrame\n            ),\n            \"renderableOnly\": attribute_values.get(\n                \"renderableOnly\", self.renderableOnly\n            ),\n            \"root\": root,\n            \"selection\": True,\n            \"startFrame\": start,\n            \"step\": instance.data.get(\n                \"creator_attributes\", {}\n            ).get(\"step\", 1.0),\n            \"stripNamespaces\": attribute_values.get(\n                \"stripNamespaces\", self.stripNamespaces\n            ),\n            \"uvWrite\": attribute_values.get(\"uvWrite\", self.uvWrite),\n            \"verbose\": attribute_values.get(\"verbose\", self.verbose),\n            \"wholeFrameGeo\": attribute_values.get(\n                \"wholeFrameGeo\", self.wholeFrameGeo\n            ),\n            \"worldSpace\": attribute_values.get(\"worldSpace\", self.worldSpace),\n            \"writeColorSets\": attribute_values.get(\n                \"writeColorSets\", self.writeColorSets\n            ),\n            \"writeCreases\": attribute_values.get(\n                \"writeCreases\", self.writeCreases\n            ),\n            \"writeFaceSets\": attribute_values.get(\n                \"writeFaceSets\", self.writeFaceSets\n            ),\n            \"writeUVSets\": attribute_values.get(\n                \"writeUVSets\", self.writeUVSets\n            ),\n            \"writeVisibility\": attribute_values.get(\n                \"writeVisibility\", self.writeVisibility\n            ),\n            \"uvsOnly\": attribute_values.get(\n                \"uvsOnly\", self.uvsOnly\n            ),\n            \"melPerFrameCallback\": attribute_values.get(\n                \"melPerFrameCallback\", self.melPerFrameCallback\n            ),\n            \"melPostJobCallback\": attribute_values.get(\n                \"melPostJobCallback\", self.melPostJobCallback\n            ),\n            \"pythonPerFrameCallback\": attribute_values.get(\n                \"pythonPerFrameCallback\", self.pythonPostJobCallback\n            ),\n            \"pythonPostJobCallback\": attribute_values.get(\n                \"pythonPostJobCallback\", self.pythonPostJobCallback\n            ),\n            # Note that this converts `writeNormals` to `noNormals` for the\n            # `AbcExport` equivalent in `extract_alembic`\n            \"noNormals\": not attribute_values.get(\n                \"writeNormals\", self.writeNormals\n            ),\n        }\n\n        if attribute_values.get(\"visibleOnly\", False):\n            # If we only want to include nodes that are visible in the frame\n            # range then we need to do our own check. Alembic's `visibleOnly`\n            # flag does not filter out those that are only hidden on some\n            # frames as it counts \"animated\" or \"connected\" visibilities as\n            # if it's always visible.\n            nodes = list(\n                iter_visible_nodes_in_range(nodes, start=start, end=end)\n            )\n\n        # Our logic is that `preroll` means:\n        # - True: include a preroll from `preRollStartFrame` to the start\n        #  frame that is not included in the exported file. Just 'roll up'\n        #  the export from there.\n        # - False: do not roll up from `preRollStartFrame`.\n        # `AbcExport` however approaches this very differently.\n        # A call to `AbcExport` allows to export multiple \"jobs\" of frame\n        # ranges in one go. Using `-preroll` argument there means: this one\n        # job in the full list of jobs SKIP writing these frames into the\n        # Alembic. In short, marking that job as just preroll.\n        # Then additionally, separate from `-preroll` the `AbcExport` command\n        # allows to supply `preRollStartFrame` which, when not None, means\n        # always RUN UP from that start frame. Since our `preRollStartFrame`\n        # is always an integer attribute we will convert the attributes so\n        # they behave like how we intended them initially\n        if kwargs[\"preRoll\"]:\n            # Never mark `preRoll` as True because it would basically end up\n            # writing no samples at all. We just use this to leave\n            # `preRollStartFrame` as a number value.\n            kwargs[\"preRoll\"] = False\n        else:\n            kwargs[\"preRollStartFrame\"] = None\n\n        suspend = not instance.data.get(\"refresh\", False)\n        with contextlib.ExitStack() as stack:\n            stack.enter_context(suspended_refresh(suspend=suspend))\n            stack.enter_context(maintained_selection())\n            if instance.data.get(\"writeFaceSets\", True):\n                meshes = cmds.ls(nodes, type=\"mesh\", long=True)\n                stack.enter_context(force_shader_assignments_to_faces(meshes))\n            cmds.select(nodes, noExpand=True)\n            self.log.debug(\n                \"Running `extract_alembic` with the keyword arguments: \"\n                \"{}\".format(kwargs)\n            )\n            extract_alembic(**kwargs)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            \"name\": \"abc\",\n            \"ext\": \"abc\",\n            \"files\": filename,\n            \"stagingDir\": dirname\n        }\n        instance.data[\"representations\"].append(representation)\n\n        if not instance.data.get(\"stagingDir_persistent\", False):\n            instance.context.data[\"cleanupFullPaths\"].append(path)\n\n        self.log.debug(\"Extracted {} to {}\".format(instance, dirname))\n\n        # Extract proxy.\n        if not instance.data.get(\"proxy\"):\n            self.log.debug(\"No proxy nodes found. Skipping proxy extraction.\")\n            return\n\n        path = path.replace(\".abc\", \"_proxy.abc\")\n        kwargs[\"file\"] = path\n        if not instance.data.get(\"includeParentHierarchy\", True):\n            # Set the root nodes if we don't want to include parents\n            # The roots are to be considered the ones that are the actual\n            # direct members of the set\n            kwargs[\"root\"] = instance.data[\"proxyRoots\"]\n\n        with suspended_refresh(suspend=suspend):\n            with maintained_selection():\n                cmds.select(instance.data[\"proxy\"])\n                extract_alembic(**kwargs)\n        representation = {\n            \"name\": \"proxy\",\n            \"ext\": \"abc\",\n            \"files\": os.path.basename(path),\n            \"stagingDir\": dirname,\n            \"outputName\": \"proxy\"\n        }\n        instance.data[\"representations\"].append(representation)\n\n    def get_members_and_roots(self, instance):\n        return instance[:], instance.data.get(\"setMembers\")\n\n    @classmethod\n    def get_attribute_defs(cls):\n        defs = super(ExtractAlembic, cls).get_attribute_defs()\n        if not cls.overrides:\n            return defs\n\n        override_defs = OrderedDict({\n            \"eulerFilter\": BoolDef(\n                \"eulerFilter\",\n                label=\"Euler Filter\",\n                default=cls.eulerFilter,\n                tooltip=\"Apply Euler filter while sampling rotations.\"\n            ),\n            \"renderableOnly\": BoolDef(\n                \"renderableOnly\",\n                label=\"Renderable Only\",\n                default=cls.renderableOnly,\n                tooltip=\"Only export renderable visible shapes.\"\n            ),\n            \"stripNamespaces\": BoolDef(\n                \"stripNamespaces\",\n                label=\"Strip Namespaces\",\n                default=cls.stripNamespaces,\n                tooltip=(\n                    \"Namespaces will be stripped off of the node before being \"\n                    \"written to Alembic.\"\n                )\n            ),\n            \"uvsOnly\": BoolDef(\n                \"uvsOnly\",\n                label=\"UVs Only\",\n                default=cls.uvsOnly,\n                tooltip=(\n                    \"If this flag is present, only uv data for PolyMesh and \"\n                    \"SubD shapes will be written to the Alembic file.\"\n                )\n            ),\n            \"uvWrite\": BoolDef(\n                \"uvWrite\",\n                label=\"UV Write\",\n                default=cls.uvWrite,\n                tooltip=(\n                    \"Uv data for PolyMesh and SubD shapes will be written to \"\n                    \"the Alembic file.\"\n                )\n            ),\n            \"verbose\": BoolDef(\n                \"verbose\",\n                label=\"Verbose\",\n                default=cls.verbose,\n                tooltip=\"Prints the current frame that is being evaluated.\"\n            ),\n            \"visibleOnly\": BoolDef(\n                \"visibleOnly\",\n                label=\"Visible Only\",\n                default=cls.visibleOnly,\n                tooltip=\"Only export dag objects visible during frame range.\"\n            ),\n            \"wholeFrameGeo\": BoolDef(\n                \"wholeFrameGeo\",\n                label=\"Whole Frame Geo\",\n                default=cls.wholeFrameGeo,\n                tooltip=(\n                    \"Data for geometry will only be written out on whole \"\n                    \"frames.\"\n                )\n            ),\n            \"worldSpace\": BoolDef(\n                \"worldSpace\",\n                label=\"World Space\",\n                default=cls.worldSpace,\n                tooltip=\"Any root nodes will be stored in world space.\"\n            ),\n            \"writeColorSets\": BoolDef(\n                \"writeColorSets\",\n                label=\"Write Color Sets\",\n                default=cls.writeColorSets,\n                tooltip=\"Write vertex colors with the geometry.\"\n            ),\n            \"writeCreases\": BoolDef(\n                \"writeCreases\",\n                label=\"Write Creases\",\n                default=cls.writeCreases,\n                tooltip=\"Write the geometry's edge and vertex crease \"\n                        \"information.\"\n            ),\n            \"writeFaceSets\": BoolDef(\n                \"writeFaceSets\",\n                label=\"Write Face Sets\",\n                default=cls.writeFaceSets,\n                tooltip=\"Write face sets with the geometry.\"\n            ),\n            \"writeNormals\": BoolDef(\n                \"writeNormals\",\n                label=\"Write Normals\",\n                default=cls.writeNormals,\n                tooltip=\"Write normals with the deforming geometry.\"\n            ),\n            \"writeUVSets\": BoolDef(\n                \"writeUVSets\",\n                label=\"Write UV Sets\",\n                default=cls.writeUVSets,\n                tooltip=(\n                    \"Write all uv sets on MFnMeshes as vector 2 indexed \"\n                    \"geometry parameters with face varying scope.\"\n                )\n            ),\n            \"writeVisibility\": BoolDef(\n                \"writeVisibility\",\n                label=\"Write Visibility\",\n                default=cls.writeVisibility,\n                tooltip=(\n                    \"Visibility state will be stored in the Alembic file. \"\n                    \"Otherwise everything written out is treated as visible.\"\n                )\n            ),\n            \"preRoll\": BoolDef(\n                \"preRoll\",\n                label=\"Pre Roll\",\n                default=cls.preRoll,\n                tooltip=\"This frame range will not be sampled.\"\n            ),\n            \"preRollStartFrame\": NumberDef(\n                \"preRollStartFrame\",\n                label=\"Pre Roll Start Frame\",\n                tooltip=(\n                    \"The frame to start scene evaluation at. This is used\"\n                    \" to set the starting frame for time dependent \"\n                    \"translations and can be used to evaluate run-up that\"\n                    \" isn't actually translated.\"\n                ),\n                default=cls.preRollStartFrame\n            ),\n            \"dataFormat\": EnumDef(\n                \"dataFormat\",\n                label=\"Data Format\",\n                items=[\"ogawa\", \"HDF\"],\n                default=cls.dataFormat,\n                tooltip=\"The data format to use to write the file.\"\n            ),\n            \"attr\": TextDef(\n                \"attr\",\n                label=\"Custom Attributes\",\n                placeholder=\"attr1; attr2; ...\",\n                default=cls.attr,\n                tooltip=(\n                    \"Attributes matching by name will be included in the \"\n                    \"Alembic export. Attributes should be separated by \"\n                    \"semi-colon `;`\"\n                )\n            ),\n            \"attrPrefix\": TextDef(\n                \"attrPrefix\",\n                label=\"Custom Attributes Prefix\",\n                placeholder=\"prefix1; prefix2; ...\",\n                default=cls.attrPrefix,\n                tooltip=(\n                    \"Attributes starting with these prefixes will be included \"\n                    \"in the Alembic export. Attributes should be separated by \"\n                    \"semi-colon `;`\"\n                )\n            ),\n            \"userAttr\": TextDef(\n                \"userAttr\",\n                label=\"User Attr\",\n                placeholder=\"attr1; attr2; ...\",\n                default=cls.userAttr,\n                tooltip=(\n                    \"Attributes matching by name will be included in the \"\n                    \"Alembic export. Attributes should be separated by \"\n                    \"semi-colon `;`\"\n                )\n            ),\n            \"userAttrPrefix\": TextDef(\n                \"userAttrPrefix\",\n                label=\"User Attr Prefix\",\n                placeholder=\"prefix1; prefix2; ...\",\n                default=cls.userAttrPrefix,\n                tooltip=(\n                    \"Attributes starting with these prefixes will be included \"\n                    \"in the Alembic export. Attributes should be separated by \"\n                    \"semi-colon `;`\"\n                )\n            ),\n            \"melPerFrameCallback\": TextDef(\n                \"melPerFrameCallback\",\n                label=\"Mel Per Frame Callback\",\n                default=cls.melPerFrameCallback,\n                tooltip=(\n                    \"When each frame (and the static frame) is evaluated the \"\n                    \"string specified is evaluated as a Mel command.\"\n                )\n            ),\n            \"melPostJobCallback\": TextDef(\n                \"melPostJobCallback\",\n                label=\"Mel Post Job Callback\",\n                default=cls.melPostJobCallback,\n                tooltip=(\n                    \"When the translation has finished the string specified \"\n                    \"is evaluated as a Mel command.\"\n                )\n            ),\n            \"pythonPerFrameCallback\": TextDef(\n                \"pythonPerFrameCallback\",\n                label=\"Python Per Frame Callback\",\n                default=cls.pythonPerFrameCallback,\n                tooltip=(\n                    \"When each frame (and the static frame) is evaluated the \"\n                    \"string specified is evaluated as a python command.\"\n                )\n            ),\n            \"pythonPostJobCallback\": TextDef(\n                \"pythonPostJobCallback\",\n                label=\"Python Post Frame Callback\",\n                default=cls.pythonPostJobCallback,\n                tooltip=(\n                    \"When the translation has finished the string specified \"\n                    \"is evaluated as a python command.\"\n                )\n            )\n        })\n\n        defs.extend([\n            UISeparatorDef(\"sep_alembic_options\"),\n            UILabelDef(\"Alembic Options\"),\n        ])\n\n        # The Arguments that can be modified by the Publisher\n        overrides = set(cls.overrides)\n        for key, value in override_defs.items():\n            if key not in overrides:\n                continue\n\n            defs.append(value)\n\n        defs.append(\n            UISeparatorDef(\"sep_alembic_options_end\")\n        )\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_proxy_abc.html","title":"extract_proxy_abc","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_proxy_abc.html#client.ayon_maya.plugins.publish.extract_proxy_abc.ExtractProxyAlembic","title":"<code>ExtractProxyAlembic</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Produce an alembic for bounding box geometry</p> Source code in <code>client/ayon_maya/plugins/publish/extract_proxy_abc.py</code> <pre><code>class ExtractProxyAlembic(plugin.MayaExtractorPlugin):\n    \"\"\"Produce an alembic for bounding box geometry\n    \"\"\"\n\n    label = \"Extract Proxy (Alembic)\"\n    families = [\"proxyAbc\"]\n    targets = [\"local\", \"remote\"]\n\n    def process(self, instance):\n        name_suffix = instance.data.get(\"nameSuffix\")\n        # Collect the start and end including handles\n        start = float(instance.data.get(\"frameStartHandle\", 1))\n        end = float(instance.data.get(\"frameEndHandle\", 1))\n\n        attrs = instance.data.get(\"attr\", \"\").split(\";\")\n        attrs = [value for value in attrs if value.strip()]\n        attrs += [\"cbId\"]\n\n        attr_prefixes = instance.data.get(\"attrPrefix\", \"\").split(\";\")\n        attr_prefixes = [value for value in attr_prefixes if value.strip()]\n\n        self.log.debug(\"Extracting Proxy Alembic..\")\n        dirname = self.staging_dir(instance)\n\n        filename = \"{name}.abc\".format(**instance.data)\n        path = os.path.join(dirname, filename)\n\n        proxy_root = self.create_proxy_geometry(instance,\n                                                name_suffix,\n                                                start,\n                                                end)\n\n        options = {\n            \"step\": instance.data.get(\"step\", 1.0),\n            \"attr\": attrs,\n            \"attrPrefix\": attr_prefixes,\n            \"writeVisibility\": True,\n            \"writeCreases\": True,\n            \"writeColorSets\": instance.data.get(\"writeColorSets\", False),\n            \"writeFaceSets\": instance.data.get(\"writeFaceSets\", False),\n            \"uvWrite\": True,\n            \"selection\": True,\n            \"worldSpace\": instance.data.get(\"worldSpace\", True),\n            \"root\": proxy_root\n        }\n\n        if int(cmds.about(version=True)) &gt;= 2017:\n            # Since Maya 2017 alembic supports multiple uv sets - write them.\n            options[\"writeUVSets\"] = True\n\n        with suspended_refresh():\n            with maintained_selection():\n                cmds.select(proxy_root, hi=True, noExpand=True)\n                extract_alembic(file=path,\n                                startFrame=start,\n                                endFrame=end,\n                                **options)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'abc',\n            'ext': 'abc',\n            'files': filename,\n            \"stagingDir\": dirname\n        }\n        instance.data[\"representations\"].append(representation)\n\n        if not instance.data.get(\"stagingDir_persistent\", False):\n            instance.context.data[\"cleanupFullPaths\"].append(path)\n\n        self.log.debug(\"Extracted {} to {}\".format(instance, dirname))\n        # remove the bounding box\n        bbox_master = cmds.ls(\"bbox_grp\")\n        cmds.delete(bbox_master)\n\n    def create_proxy_geometry(self, instance, name_suffix, start, end):\n        nodes = instance[:]\n        nodes = list(iter_visible_nodes_in_range(nodes,\n                                                 start=start,\n                                                 end=end))\n\n        inst_selection = cmds.ls(nodes, long=True)\n        cmds.geomToBBox(inst_selection,\n                        nameSuffix=name_suffix,\n                        keepOriginal=True,\n                        single=False,\n                        bakeAnimation=True,\n                        startTime=start,\n                        endTime=end)\n        # create master group for bounding\n        # boxes as the main root\n        master_group = cmds.group(name=\"bbox_grp\")\n        bbox_sel = cmds.ls(master_group, long=True)\n        self.log.debug(\"proxy_root: {}\".format(bbox_sel))\n        return bbox_sel\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_redshift_proxy.html","title":"extract_redshift_proxy","text":"<p>Redshift Proxy extractor.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_redshift_proxy.html#client.ayon_maya.plugins.publish.extract_redshift_proxy.ExtractRedshiftProxy","title":"<code>ExtractRedshiftProxy</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extract the content of the instance to a redshift proxy file.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_redshift_proxy.py</code> <pre><code>class ExtractRedshiftProxy(plugin.MayaExtractorPlugin):\n    \"\"\"Extract the content of the instance to a redshift proxy file.\"\"\"\n\n    label = \"Redshift Proxy (.rs)\"\n    families = [\"redshiftproxy\"]\n    targets = [\"local\", \"remote\"]\n\n    def process(self, instance):\n        \"\"\"Extractor entry point.\"\"\"\n\n        # Make sure Redshift is loaded\n        cmds.loadPlugin(\"redshift4maya\", quiet=True)\n\n        anim_on: bool = instance.data[\"animation\"]\n        if anim_on:\n            # Add frame number #### placeholder for animated exports\n            file_name = \"{}.####.rs\".format(instance.name)\n        else:\n            file_name = \"{}.rs\".format(instance.name)\n\n        staging_dir = self.staging_dir(instance)\n        file_path = os.path.join(staging_dir, file_name)\n\n        rs_options = \"exportConnectivity=0;enableCompression=1;keepUnused=0;\"\n        repr_files: Union[str, list[str]] = file_name\n        if not anim_on:\n            # Remove animation information because it is not required for\n            # non-animated products\n            keys = [\"frameStart\",\n                    \"frameEnd\",\n                    \"handleStart\",\n                    \"handleEnd\",\n                    \"frameStartHandle\",\n                    \"frameEndHandle\"]\n            for key in keys:\n                instance.data.pop(key, None)\n\n        else:\n            start_frame = instance.data[\"frameStartHandle\"]\n            end_frame = instance.data[\"frameEndHandle\"]\n            rs_options = \"{}startFrame={};endFrame={};frameStep={};\".format(\n                rs_options, start_frame,\n                end_frame, instance.data[\"step\"]\n            )\n            repr_files: list[str] = []\n            for frame in range(\n                    int(start_frame),\n                    int(end_frame) + 1,\n                    int(instance.data[\"step\"])):\n                frame_padded = str(frame).rjust(4, \"0\")\n                frame_filename = file_name.replace(\n                    \".####.rs\", f\".{frame_padded}.rs\"\n                )\n                repr_files.append(frame_filename)\n\n        # Write out rs file\n        self.log.debug(\"Writing: '%s'\", file_path)\n\n        # Allow overriding what renderlayer to export from. By default, force\n        # it to the default render layer. (Note that the renderlayer isn't\n        # currently exposed as an attribute to artists)\n        layer = instance.data.get(\"renderLayer\", \"defaultRenderLayer\")\n\n        with maintained_selection():\n            with renderlayer(layer):\n                with allow_export_from_render_setup_layer():\n                    cmds.select(instance.data[\"setMembers\"], noExpand=True)\n                    cmds.file(file_path,\n                              preserveReferences=False,\n                              force=True,\n                              type=\"Redshift Proxy\",\n                              exportSelected=True,\n                              options=rs_options)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        self.log.debug(\"Files: {}\".format(repr_files))\n\n        representation = {\n            'name': 'rs',\n            'ext': 'rs',\n            'files': repr_files,\n            \"stagingDir\": staging_dir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\n            f\"Extracted instance '{instance.name}' to: {staging_dir}\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_redshift_proxy.html#client.ayon_maya.plugins.publish.extract_redshift_proxy.ExtractRedshiftProxy.process","title":"<code>process(instance)</code>","text":"<p>Extractor entry point.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_redshift_proxy.py</code> <pre><code>def process(self, instance):\n    \"\"\"Extractor entry point.\"\"\"\n\n    # Make sure Redshift is loaded\n    cmds.loadPlugin(\"redshift4maya\", quiet=True)\n\n    anim_on: bool = instance.data[\"animation\"]\n    if anim_on:\n        # Add frame number #### placeholder for animated exports\n        file_name = \"{}.####.rs\".format(instance.name)\n    else:\n        file_name = \"{}.rs\".format(instance.name)\n\n    staging_dir = self.staging_dir(instance)\n    file_path = os.path.join(staging_dir, file_name)\n\n    rs_options = \"exportConnectivity=0;enableCompression=1;keepUnused=0;\"\n    repr_files: Union[str, list[str]] = file_name\n    if not anim_on:\n        # Remove animation information because it is not required for\n        # non-animated products\n        keys = [\"frameStart\",\n                \"frameEnd\",\n                \"handleStart\",\n                \"handleEnd\",\n                \"frameStartHandle\",\n                \"frameEndHandle\"]\n        for key in keys:\n            instance.data.pop(key, None)\n\n    else:\n        start_frame = instance.data[\"frameStartHandle\"]\n        end_frame = instance.data[\"frameEndHandle\"]\n        rs_options = \"{}startFrame={};endFrame={};frameStep={};\".format(\n            rs_options, start_frame,\n            end_frame, instance.data[\"step\"]\n        )\n        repr_files: list[str] = []\n        for frame in range(\n                int(start_frame),\n                int(end_frame) + 1,\n                int(instance.data[\"step\"])):\n            frame_padded = str(frame).rjust(4, \"0\")\n            frame_filename = file_name.replace(\n                \".####.rs\", f\".{frame_padded}.rs\"\n            )\n            repr_files.append(frame_filename)\n\n    # Write out rs file\n    self.log.debug(\"Writing: '%s'\", file_path)\n\n    # Allow overriding what renderlayer to export from. By default, force\n    # it to the default render layer. (Note that the renderlayer isn't\n    # currently exposed as an attribute to artists)\n    layer = instance.data.get(\"renderLayer\", \"defaultRenderLayer\")\n\n    with maintained_selection():\n        with renderlayer(layer):\n            with allow_export_from_render_setup_layer():\n                cmds.select(instance.data[\"setMembers\"], noExpand=True)\n                cmds.file(file_path,\n                          preserveReferences=False,\n                          force=True,\n                          type=\"Redshift Proxy\",\n                          exportSelected=True,\n                          options=rs_options)\n\n    if \"representations\" not in instance.data:\n        instance.data[\"representations\"] = []\n\n    self.log.debug(\"Files: {}\".format(repr_files))\n\n    representation = {\n        'name': 'rs',\n        'ext': 'rs',\n        'files': repr_files,\n        \"stagingDir\": staging_dir,\n    }\n    instance.data[\"representations\"].append(representation)\n\n    self.log.debug(\n        f\"Extracted instance '{instance.name}' to: {staging_dir}\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_rendersetup.html","title":"extract_rendersetup","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_rendersetup.html#client.ayon_maya.plugins.publish.extract_rendersetup.ExtractRenderSetup","title":"<code>ExtractRenderSetup</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Produce renderSetup template file</p> <p>This will save whole renderSetup to json file for later use.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_rendersetup.py</code> <pre><code>class ExtractRenderSetup(plugin.MayaExtractorPlugin):\n    \"\"\"\n    Produce renderSetup template file\n\n    This will save whole renderSetup to json file for later use.\n    \"\"\"\n\n    label = \"Extract RenderSetup\"\n    families = [\"rendersetup\"]\n\n    def process(self, instance):\n        parent_dir = self.staging_dir(instance)\n        json_filename = \"{}.json\".format(instance.name)\n        json_path = os.path.join(parent_dir, json_filename)\n\n        with open(json_path, \"w+\") as file:\n            json.dump(\n                renderSetup.instance().encode(None),\n                fp=file, indent=2, sort_keys=True)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'json',\n            'ext': 'json',\n            'files': json_filename,\n            \"stagingDir\": parent_dir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\n            \"Extracted instance '%s' to: %s\" % (instance.name, json_path))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_rig.html","title":"extract_rig","text":"<p>Extract rig as Maya Scene.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_rig.html#client.ayon_maya.plugins.publish.extract_rig.ExtractRig","title":"<code>ExtractRig</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extract rig as Maya Scene.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_rig.py</code> <pre><code>class ExtractRig(plugin.MayaExtractorPlugin):\n    \"\"\"Extract rig as Maya Scene.\"\"\"\n\n    label = \"Extract Rig (Maya Scene)\"\n    families = [\"rig\"]\n    scene_type = \"ma\"\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\"\"\"\n        maya_settings = instance.context.data[\"project_settings\"][\"maya\"]\n        ext_mapping = {\n            item[\"name\"]: item[\"value\"]\n            for item in maya_settings[\"ext_mapping\"]\n        }\n        if ext_mapping:\n            self.log.debug(\"Looking in settings for scene type ...\")\n            # use extension mapping for first family found\n            for family in self.families:\n                try:\n                    self.scene_type = ext_mapping[family]\n                    self.log.debug(\n                        \"Using '.{}' as scene type\".format(self.scene_type))\n                    break\n                except AttributeError:\n                    # no preset found\n                    pass\n        # Define extract output file path\n        dir_path = self.staging_dir(instance)\n        filename = \"{0}.{1}\".format(instance.name, self.scene_type)\n        path = os.path.join(dir_path, filename)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction ...\")\n        with maintained_selection():\n            cmds.select(instance, noExpand=True)\n            cmds.file(path,\n                      force=True,\n                      typ=\"mayaAscii\" if self.scene_type == \"ma\" else \"mayaBinary\",  # noqa: E501\n                      exportSelected=True,\n                      preserveReferences=False,\n                      channels=True,\n                      constraints=True,\n                      expressions=True,\n                      constructionHistory=True)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': self.scene_type,\n            'ext': self.scene_type,\n            'files': filename,\n            \"stagingDir\": dir_path\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\", instance.name, path)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_rig.html#client.ayon_maya.plugins.publish.extract_rig.ExtractRig.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_rig.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\"\"\"\n    maya_settings = instance.context.data[\"project_settings\"][\"maya\"]\n    ext_mapping = {\n        item[\"name\"]: item[\"value\"]\n        for item in maya_settings[\"ext_mapping\"]\n    }\n    if ext_mapping:\n        self.log.debug(\"Looking in settings for scene type ...\")\n        # use extension mapping for first family found\n        for family in self.families:\n            try:\n                self.scene_type = ext_mapping[family]\n                self.log.debug(\n                    \"Using '.{}' as scene type\".format(self.scene_type))\n                break\n            except AttributeError:\n                # no preset found\n                pass\n    # Define extract output file path\n    dir_path = self.staging_dir(instance)\n    filename = \"{0}.{1}\".format(instance.name, self.scene_type)\n    path = os.path.join(dir_path, filename)\n\n    # Perform extraction\n    self.log.debug(\"Performing extraction ...\")\n    with maintained_selection():\n        cmds.select(instance, noExpand=True)\n        cmds.file(path,\n                  force=True,\n                  typ=\"mayaAscii\" if self.scene_type == \"ma\" else \"mayaBinary\",  # noqa: E501\n                  exportSelected=True,\n                  preserveReferences=False,\n                  channels=True,\n                  constraints=True,\n                  expressions=True,\n                  constructionHistory=True)\n\n    if \"representations\" not in instance.data:\n        instance.data[\"representations\"] = []\n\n    representation = {\n        'name': self.scene_type,\n        'ext': self.scene_type,\n        'files': filename,\n        \"stagingDir\": dir_path\n    }\n    instance.data[\"representations\"].append(representation)\n\n    self.log.debug(\"Extracted instance '%s' to: %s\", instance.name, path)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_skeleton_mesh.html","title":"extract_skeleton_mesh","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_skeleton_mesh.html#client.ayon_maya.plugins.publish.extract_skeleton_mesh.ExtractSkeletonMesh","title":"<code>ExtractSkeletonMesh</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract Rig in FBX format from Maya.</p> <p>This extracts the rig in fbx with the constraints and referenced asset content included. This also optionally extract animated rig in fbx with geometries included.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_skeleton_mesh.py</code> <pre><code>class ExtractSkeletonMesh(plugin.MayaExtractorPlugin,\n                          OptionalPyblishPluginMixin):\n    \"\"\"Extract Rig in FBX format from Maya.\n\n    This extracts the rig in fbx with the constraints\n    and referenced asset content included.\n    This also optionally extract animated rig in fbx with\n    geometries included.\n\n    \"\"\"\n    order = pyblish.api.ExtractorOrder\n    label = \"Extract Skeleton Mesh\"\n    families = [\"rig.fbx\"]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        # Define output path\n        staging_dir = self.staging_dir(instance)\n        filename = \"{0}.fbx\".format(instance.name)\n        path = os.path.join(staging_dir, filename)\n\n        fbx_exporter = fbx.FBXExtractor(log=self.log)\n        out_set = instance.data.get(\"skeleton_mesh\", [])\n\n        instance.data[\"constraints\"] = True\n        instance.data[\"skeletonDefinitions\"] = True\n\n        fbx_exporter.set_options_from_instance(instance)\n\n        # Export\n        fbx_exporter.export(out_set, path)\n\n        representations = instance.data.setdefault(\"representations\", [])\n        representations.append({\n            'name': 'fbx',\n            'ext': 'fbx',\n            'files': filename,\n            \"stagingDir\": staging_dir\n        })\n\n        self.log.debug(\"Extract FBX to: {0}\".format(path))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_thumbnail.html","title":"extract_thumbnail","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_thumbnail.html#client.ayon_maya.plugins.publish.extract_thumbnail.ExtractThumbnail","title":"<code>ExtractThumbnail</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extract viewport thumbnail.</p> <p>Takes review camera and creates a thumbnail based on viewport capture.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_thumbnail.py</code> <pre><code>class ExtractThumbnail(plugin.MayaExtractorPlugin):\n    \"\"\"Extract viewport thumbnail.\n\n    Takes review camera and creates a thumbnail based on viewport\n    capture.\n\n    \"\"\"\n    order = pyblish.api.ExtractorOrder - 0.3\n    label = \"Thumbnail\"\n    families = [\"review\"]\n\n    def process(self, instance):\n        self.log.debug(\"Extracting thumbnail..\")\n\n        camera = instance.data[\"review_camera\"]\n\n        task_data = instance.data[\"anatomyData\"].get(\"task\", {})\n        capture_preset = lib.get_capture_preset(\n            task_data.get(\"name\"),\n            task_data.get(\"type\"),\n            instance.data[\"productName\"],\n            instance.context.data[\"project_settings\"],\n            self.log\n        )\n\n        # Create temp directory for thumbnail\n        # - this is to avoid \"override\" of source file\n        dst_staging = tempfile.mkdtemp(prefix=\"pyblish_tmp_thumbnail\")\n        self.log.debug(\n            \"Create temp directory {} for thumbnail\".format(dst_staging)\n        )\n        # Store new staging to cleanup paths\n        filename = instance.name\n        path = os.path.join(dst_staging, filename)\n\n        self.log.debug(\"Outputting images to %s\" % path)\n\n        preset = lib.generate_capture_preset(\n            instance, camera, path,\n            start=1, end=1,\n            capture_preset=capture_preset)\n\n        preset[\"camera_options\"].update({\n            \"displayGateMask\": False,\n            \"displayResolution\": False,\n            \"displayFilmGate\": False,\n            \"displayFieldChart\": False,\n            \"displaySafeAction\": False,\n            \"displaySafeTitle\": False,\n            \"displayFilmPivot\": False,\n            \"displayFilmOrigin\": False,\n            \"overscan\": 1.0,\n        })\n        path = lib.render_capture_preset(preset)\n\n        playblast = self._fix_playblast_output_path(path)\n\n        _, thumbnail = os.path.split(playblast)\n\n        self.log.debug(\"file list  {}\".format(thumbnail))\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            \"name\": \"thumbnail\",\n            \"ext\": os.path.splitext(thumbnail)[-1].lstrip(\".\").lower(),\n            \"files\": thumbnail,\n            \"stagingDir\": dst_staging,\n            \"thumbnail\": True\n        }\n        instance.data[\"representations\"].append(representation)\n\n    def _fix_playblast_output_path(self, filepath):\n        \"\"\"Workaround a bug in maya.cmds.playblast to return correct filepath.\n\n        When the `viewer` argument is set to False and maya.cmds.playblast\n        does not automatically open the playblasted file the returned\n        filepath does not have the file's extension added correctly.\n\n        To workaround this we just glob.glob() for any file extensions and\n         assume the latest modified file is the correct file and return it.\n\n        \"\"\"\n        # Catch cancelled playblast\n        if filepath is None:\n            self.log.warning(\"Playblast did not result in output path. \"\n                             \"Playblast is probably interrupted.\")\n            return None\n\n        # Fix: playblast not returning correct filename (with extension)\n        # Lets assume the most recently modified file is the correct one.\n        if not os.path.exists(filepath):\n            directory = os.path.dirname(filepath)\n            filename = os.path.basename(filepath)\n            # check if the filepath is has frame based filename\n            # example : capture.####.png\n            parts = filename.split(\".\")\n            if len(parts) == 3:\n                query = os.path.join(directory, \"{}.*.{}\".format(parts[0],\n                                                                 parts[-1]))\n                files = glob.glob(query)\n            else:\n                files = glob.glob(\"{}.*\".format(filepath))\n\n            if not files:\n                raise RuntimeError(\"Couldn't find playblast from: \"\n                                   \"{0}\".format(filepath))\n            filepath = max(files, key=os.path.getmtime)\n\n        return filepath\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_unreal_skeletalmesh_abc.html","title":"extract_unreal_skeletalmesh_abc","text":"<p>Create Unreal Skeletal Mesh data to be extracted as FBX.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_unreal_skeletalmesh_abc.html#client.ayon_maya.plugins.publish.extract_unreal_skeletalmesh_abc.ExtractUnrealSkeletalMeshAbc","title":"<code>ExtractUnrealSkeletalMeshAbc</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extract Unreal Skeletal Mesh as FBX from Maya.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_unreal_skeletalmesh_abc.py</code> <pre><code>class ExtractUnrealSkeletalMeshAbc(plugin.MayaExtractorPlugin):\n    \"\"\"Extract Unreal Skeletal Mesh as FBX from Maya. \"\"\"\n\n    label = \"Extract Unreal Skeletal Mesh - Alembic\"\n    families = [\"skeletalMesh\"]\n    optional = True\n\n    def process(self, instance):\n        self.log.debug(\"Extracting pointcache..\")\n\n        geo = cmds.listRelatives(\n            instance.data.get(\"geometry\"), allDescendents=True, fullPath=True)\n        joints = cmds.listRelatives(\n            instance.data.get(\"joints\"), allDescendents=True, fullPath=True)\n\n        nodes = geo + joints\n\n        attrs = instance.data.get(\"attr\", \"\").split(\";\")\n        attrs = [value for value in attrs if value.strip()]\n        attrs += [\"cbId\"]\n\n        attr_prefixes = instance.data.get(\"attrPrefix\", \"\").split(\";\")\n        attr_prefixes = [value for value in attr_prefixes if value.strip()]\n\n        # Define output path\n        staging_dir = self.staging_dir(instance)\n        filename = \"{0}.abc\".format(instance.name)\n        path = os.path.join(staging_dir, filename)\n\n        # The export requires forward slashes because we need\n        # to format it into a string in a mel expression\n        path = path.replace('\\\\', '/')\n\n        self.log.debug(\"Extracting ABC to: {0}\".format(path))\n        self.log.debug(\"Members: {0}\".format(nodes))\n        self.log.debug(\"Instance: {0}\".format(instance[:]))\n\n        options = {\n            \"step\": instance.data.get(\"step\", 1.0),\n            \"attr\": attrs,\n            \"attrPrefix\": attr_prefixes,\n            \"writeVisibility\": True,\n            \"writeCreases\": True,\n            \"writeColorSets\": instance.data.get(\"writeColorSets\", False),\n            \"writeFaceSets\": instance.data.get(\"writeFaceSets\", False),\n            \"uvWrite\": True,\n            \"selection\": True,\n            \"worldSpace\": instance.data.get(\"worldSpace\", True)\n        }\n\n        self.log.debug(\"Options: {}\".format(options))\n\n        if int(cmds.about(version=True)) &gt;= 2017:\n            # Since Maya 2017 alembic supports multiple uv sets - write them.\n            options[\"writeUVSets\"] = True\n\n        if not instance.data.get(\"includeParentHierarchy\", True):\n            # Set the root nodes if we don't want to include parents\n            # The roots are to be considered the ones that are the actual\n            # direct members of the set\n            options[\"root\"] = instance.data.get(\"setMembers\")\n\n        with suspended_refresh(suspend=instance.data.get(\"refresh\", False)):\n            with maintained_selection():\n                cmds.select(nodes, noExpand=True)\n                extract_alembic(file=path,\n                                # startFrame=start,\n                                # endFrame=end,\n                                **options)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'abc',\n            'ext': 'abc',\n            'files': filename,\n            \"stagingDir\": staging_dir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extract ABC successful to: {0}\".format(path))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_unreal_skeletalmesh_fbx.html","title":"extract_unreal_skeletalmesh_fbx","text":"<p>Create Unreal Skeletal Mesh data to be extracted as FBX.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_unreal_skeletalmesh_fbx.html#client.ayon_maya.plugins.publish.extract_unreal_skeletalmesh_fbx.ExtractUnrealSkeletalMeshFbx","title":"<code>ExtractUnrealSkeletalMeshFbx</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extract Unreal Skeletal Mesh as FBX from Maya.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_unreal_skeletalmesh_fbx.py</code> <pre><code>class ExtractUnrealSkeletalMeshFbx(plugin.MayaExtractorPlugin):\n    \"\"\"Extract Unreal Skeletal Mesh as FBX from Maya. \"\"\"\n\n    order = pyblish.api.ExtractorOrder - 0.1\n    label = \"Extract Unreal Skeletal Mesh - FBX\"\n    families = [\"skeletalMesh\"]\n    optional = True\n\n    def process(self, instance):\n        fbx_exporter = fbx.FBXExtractor(log=self.log)\n\n        # Define output path\n        staging_dir = self.staging_dir(instance)\n        filename = \"{0}.fbx\".format(instance.name)\n        path = os.path.join(staging_dir, filename)\n\n        geo = instance.data.get(\"geometry\")\n        joints = instance.data.get(\"joints\")\n\n        to_extract = geo + joints\n\n        # The export requires forward slashes because we need\n        # to format it into a string in a mel expression\n        path = path.replace('\\\\', '/')\n\n        self.log.debug(\"Extracting FBX to: {0}\".format(path))\n        self.log.debug(\"Members: {0}\".format(to_extract))\n        self.log.debug(\"Instance: {0}\".format(instance[:]))\n\n        fbx_exporter.set_options_from_instance(instance)\n\n        # This magic is done for variants. To let Unreal merge correctly\n        # existing data, top node must have the same name. So for every\n        # variant we extract we need to rename top node of the rig correctly.\n        # It is finally done in context manager so it won't affect current\n        # scene.\n\n        # we rely on hierarchy under one root.\n        original_parent = to_extract[0].split(\"|\")[1]\n\n        parent_node = instance.data.get(\"folderPath\")\n        # this needs to be done for AYON\n        # WARNING: since AYON supports duplicity of asset names,\n        #          this needs to be refactored throughout the pipeline.\n        parent_node = parent_node.split(\"/\")[-1]\n\n        renamed_to_extract = []\n        for node in to_extract:\n            node_path = node.split(\"|\")\n            node_path[1] = parent_node\n            renamed_to_extract.append(\"|\".join(node_path))\n\n        with renamed(original_parent, parent_node):\n            self.log.debug(\"Extracting: {}\".format(renamed_to_extract))\n            fbx_exporter.export(renamed_to_extract, path)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'fbx',\n            'ext': 'fbx',\n            'files': filename,\n            \"stagingDir\": staging_dir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extract FBX successful to: {0}\".format(path))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_unreal_staticmesh.html","title":"extract_unreal_staticmesh","text":"<p>Create Unreal Static Mesh data to be extracted as FBX.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_unreal_staticmesh.html#client.ayon_maya.plugins.publish.extract_unreal_staticmesh.ExtractUnrealStaticMesh","title":"<code>ExtractUnrealStaticMesh</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extract Unreal Static Mesh as FBX from Maya.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_unreal_staticmesh.py</code> <pre><code>class ExtractUnrealStaticMesh(plugin.MayaExtractorPlugin):\n    \"\"\"Extract Unreal Static Mesh as FBX from Maya. \"\"\"\n\n    order = pyblish.api.ExtractorOrder - 0.1\n    label = \"Extract Unreal Static Mesh\"\n    families = [\"staticMesh\"]\n\n    def process(self, instance):\n        members = instance.data.get(\"geometryMembers\", [])\n        if instance.data.get(\"collisionMembers\"):\n            members = members + instance.data.get(\"collisionMembers\")\n\n        fbx_exporter = fbx.FBXExtractor(log=self.log)\n\n        # Define output path\n        staging_dir = self.staging_dir(instance)\n        filename = \"{0}.fbx\".format(instance.name)\n        path = os.path.join(staging_dir, filename)\n\n        # The export requires forward slashes because we need\n        # to format it into a string in a mel expression\n        path = path.replace('\\\\', '/')\n\n        self.log.debug(\"Extracting FBX to: {0}\".format(path))\n        self.log.debug(\"Members: {0}\".format(members))\n        self.log.debug(\"Instance: {0}\".format(instance[:]))\n\n        fbx_exporter.set_options_from_instance(instance)\n\n        with maintained_selection():\n            with parent_nodes(members):\n                self.log.debug(\"Un-parenting: {}\".format(members))\n                fbx_exporter.export(members, path)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'fbx',\n            'ext': 'fbx',\n            'files': filename,\n            \"stagingDir\": staging_dir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extract FBX successful to: {0}\".format(path))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_unreal_yeticache.html","title":"extract_unreal_yeticache","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_unreal_yeticache.html#client.ayon_maya.plugins.publish.extract_unreal_yeticache.ExtractUnrealYetiCache","title":"<code>ExtractUnrealYetiCache</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Producing Yeti cache files using scene time range.</p> <p>This will extract Yeti cache file sequence and fur settings.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_unreal_yeticache.py</code> <pre><code>class ExtractUnrealYetiCache(plugin.MayaExtractorPlugin):\n    \"\"\"Producing Yeti cache files using scene time range.\n\n    This will extract Yeti cache file sequence and fur settings.\n    \"\"\"\n\n    label = \"Extract Yeti Cache (Unreal)\"\n    families = [\"yeticacheUE\"]\n\n    def process(self, instance):\n\n        yeti_nodes = cmds.ls(instance, type=\"pgYetiMaya\")\n        if not yeti_nodes:\n            raise RuntimeError(\"No pgYetiMaya nodes found in the instance\")\n\n        # Define extract output file path\n        dirname = self.staging_dir(instance)\n\n        # Collect information for writing cache\n        start_frame = instance.data[\"frameStartHandle\"]\n        end_frame = instance.data[\"frameEndHandle\"]\n        preroll = instance.data[\"preroll\"]\n        if preroll &gt; 0:\n            start_frame -= preroll\n\n        kwargs = {}\n        samples = instance.data.get(\"samples\", 0)\n        if samples == 0:\n            kwargs.update({\"sampleTimes\": \"0.0 1.0\"})\n        else:\n            kwargs.update({\"samples\": samples})\n\n        self.log.debug(f\"Writing out cache {start_frame} - {end_frame}\")\n        filename = f\"{instance.name}.abc\"\n        path = os.path.join(dirname, filename)\n        cmds.pgYetiCommand(yeti_nodes,\n                           writeAlembic=path,\n                           range=(start_frame, end_frame),\n                           asUnrealAbc=True,\n                           **kwargs)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'abc',\n            'ext': 'abc',\n            'files': filename,\n            'stagingDir': dirname\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(f\"Extracted {instance} to {dirname}\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_vrayproxy.html","title":"extract_vrayproxy","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_vrayproxy.html#client.ayon_maya.plugins.publish.extract_vrayproxy.ExtractVRayProxy","title":"<code>ExtractVRayProxy</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extract the content of the instance to a vrmesh file</p> Things to pay attention to Source code in <code>client/ayon_maya/plugins/publish/extract_vrayproxy.py</code> <pre><code>class ExtractVRayProxy(plugin.MayaExtractorPlugin):\n    \"\"\"Extract the content of the instance to a vrmesh file\n\n    Things to pay attention to:\n        - If animation is toggled, are the frames correct\n        -\n    \"\"\"\n\n    label = \"VRay Proxy (.vrmesh)\"\n    families = [\"vrayproxy.vrmesh\"]\n    targets = [\"local\", \"remote\"]\n\n    def process(self, instance):\n\n        staging_dir = self.staging_dir(instance)\n        file_name = \"{}.vrmesh\".format(instance.name)\n        file_path = os.path.join(staging_dir, file_name)\n\n        anim_on = instance.data[\"animation\"]\n        if not anim_on:\n            # Remove animation information because it is not required for\n            # non-animated products\n            keys = [\"frameStart\", \"frameEnd\",\n                    \"handleStart\", \"handleEnd\",\n                    \"frameStartHandle\", \"frameEndHandle\"]\n            for key in keys:\n                instance.data.pop(key, None)\n\n            start_frame = 1\n            end_frame = 1\n        else:\n            start_frame = instance.data[\"frameStartHandle\"]\n            end_frame = instance.data[\"frameEndHandle\"]\n\n        vertex_colors = instance.data.get(\"vertexColors\", False)\n\n        # Write out vrmesh file\n        self.log.debug(\"Writing: '%s'\" % file_path)\n        with maintained_selection():\n            cmds.select(instance.data[\"setMembers\"], noExpand=True)\n            cmds.vrayCreateProxy(exportType=1,\n                                 dir=staging_dir,\n                                 fname=file_name,\n                                 animOn=anim_on,\n                                 animType=3,\n                                 startFrame=start_frame,\n                                 endFrame=end_frame,\n                                 vertexColorsOn=vertex_colors,\n                                 ignoreHiddenObjects=True,\n                                 createProxyNode=False)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'vrmesh',\n            'ext': 'vrmesh',\n            'files': file_name,\n            \"stagingDir\": staging_dir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\"\n                       % (instance.name, staging_dir))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_vrayproxy.html#client.ayon_maya.plugins.publish.extract_vrayproxy.ExtractVRayProxy---if-animation-is-toggled-are-the-frames-correct","title":"- If animation is toggled, are the frames correct","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_vrayscene.html","title":"extract_vrayscene","text":"<p>Extract vrayscene from specified families.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_vrayscene.html#client.ayon_maya.plugins.publish.extract_vrayscene.ExtractVrayscene","title":"<code>ExtractVrayscene</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extractor for vrscene.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_vrayscene.py</code> <pre><code>class ExtractVrayscene(plugin.MayaExtractorPlugin):\n    \"\"\"Extractor for vrscene.\"\"\"\n\n    label = \"VRay Scene (.vrscene)\"\n    families = [\"vrayscene_layer\"]\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\"\"\"\n        if instance.data.get(\"exportOnFarm\"):\n            self.log.debug(\"vrayscenes will be exported on farm.\")\n            raise NotImplementedError(\n                \"exporting vrayscenes is not implemented\")\n\n        # handle sequence\n        if instance.data.get(\"vraySceneMultipleFiles\"):\n            self.log.debug(\"vrayscenes will be exported on farm.\")\n            raise NotImplementedError(\n                \"exporting vrayscene sequences not implemented yet\")\n\n        vray_settings = cmds.ls(type=\"VRaySettingsNode\")\n        if not vray_settings:\n            node = cmds.createNode(\"VRaySettingsNode\")\n        else:\n            node = vray_settings[0]\n\n        # setMembers on vrayscene_layer should contain layer name.\n        layer_name = instance.data.get(\"layer\")\n\n        staging_dir = self.staging_dir(instance)\n        template = cmds.getAttr(\"{}.vrscene_filename\".format(node))\n        start_frame = instance.data.get(\n            \"frameStartHandle\") if instance.data.get(\n                \"vraySceneMultipleFiles\") else None\n        formatted_name = self.format_vray_output_filename(\n            os.path.basename(instance.data.get(\"source\")),\n            layer_name,\n            template,\n            start_frame\n        )\n\n        file_path = os.path.join(\n            staging_dir, \"vrayscene\", *formatted_name.split(\"/\"))\n\n        # Write out vrscene file\n        self.log.debug(\"Writing: '%s'\" % file_path)\n        with maintained_selection():\n            if \"*\" not in instance.data[\"setMembers\"]:\n                self.log.debug(\n                    \"Exporting: {}\".format(instance.data[\"setMembers\"]))\n                set_members = instance.data[\"setMembers\"]\n                cmds.select(set_members, noExpand=True)\n            else:\n                self.log.debug(\"Exporting all ...\")\n                set_members = cmds.ls(\n                    long=True, objectsOnly=True,\n                    geometry=True, lights=True, cameras=True)\n                cmds.select(set_members, noExpand=True)\n\n            self.log.debug(\"Appending layer name {}\".format(layer_name))\n            set_members.append(layer_name)\n\n            export_in_rs_layer(\n                file_path,\n                set_members,\n                export=lambda: cmds.file(\n                    file_path, type=\"V-Ray Scene\",\n                    pr=True, es=True, force=True))\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        files = file_path\n\n        representation = {\n            'name': 'vrscene',\n            'ext': 'vrscene',\n            'files': os.path.basename(files),\n            \"stagingDir\": os.path.dirname(files),\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\"\n                       % (instance.name, staging_dir))\n\n    @staticmethod\n    def format_vray_output_filename(\n            filename, layer, template, start_frame=None):\n        \"\"\"Format the expected output file of the Export job.\n\n        Example:\n            filename: /mnt/projects/foo/shot010_v006.mb\n            template: &lt;Scene&gt;/&lt;Layer&gt;/&lt;Layer&gt;\n            result: \"shot010_v006/CHARS/CHARS.vrscene\"\n\n        Args:\n            filename (str): path to scene file.\n            layer (str): layer name.\n            template (str): token template.\n            start_frame (int, optional): start frame - if set we use\n                multiple files export mode.\n\n        Returns:\n            str: formatted path.\n\n        \"\"\"\n        # format template to match pythons format specs\n        template = re.sub(r\"&lt;(\\w+?)&gt;\", r\"{\\1}\", template.lower())\n\n        # Ensure filename has no extension\n        file_name, _ = os.path.splitext(filename)\n        mapping = {\n            \"scene\": file_name,\n            \"layer\": layer\n        }\n\n        output_path = template.format(**mapping)\n\n        if start_frame:\n            filename_zero = \"{}_{:04d}.vrscene\".format(\n                output_path, start_frame)\n        else:\n            filename_zero = \"{}.vrscene\".format(output_path)\n\n        result = filename_zero.replace(\"\\\\\", \"/\")\n\n        return result\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_vrayscene.html#client.ayon_maya.plugins.publish.extract_vrayscene.ExtractVrayscene.format_vray_output_filename","title":"<code>format_vray_output_filename(filename, layer, template, start_frame=None)</code>  <code>staticmethod</code>","text":"<p>Format the expected output file of the Export job.</p> Example <p>filename: /mnt/projects/foo/shot010_v006.mb template: // result: \"shot010_v006/CHARS/CHARS.vrscene\" <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>path to scene file.</p> required <code>layer</code> <code>str</code> <p>layer name.</p> required <code>template</code> <code>str</code> <p>token template.</p> required <code>start_frame</code> <code>int</code> <p>start frame - if set we use multiple files export mode.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>formatted path.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_vrayscene.py</code> <pre><code>@staticmethod\ndef format_vray_output_filename(\n        filename, layer, template, start_frame=None):\n    \"\"\"Format the expected output file of the Export job.\n\n    Example:\n        filename: /mnt/projects/foo/shot010_v006.mb\n        template: &lt;Scene&gt;/&lt;Layer&gt;/&lt;Layer&gt;\n        result: \"shot010_v006/CHARS/CHARS.vrscene\"\n\n    Args:\n        filename (str): path to scene file.\n        layer (str): layer name.\n        template (str): token template.\n        start_frame (int, optional): start frame - if set we use\n            multiple files export mode.\n\n    Returns:\n        str: formatted path.\n\n    \"\"\"\n    # format template to match pythons format specs\n    template = re.sub(r\"&lt;(\\w+?)&gt;\", r\"{\\1}\", template.lower())\n\n    # Ensure filename has no extension\n    file_name, _ = os.path.splitext(filename)\n    mapping = {\n        \"scene\": file_name,\n        \"layer\": layer\n    }\n\n    output_path = template.format(**mapping)\n\n    if start_frame:\n        filename_zero = \"{}_{:04d}.vrscene\".format(\n            output_path, start_frame)\n    else:\n        filename_zero = \"{}.vrscene\".format(output_path)\n\n    result = filename_zero.replace(\"\\\\\", \"/\")\n\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_vrayscene.html#client.ayon_maya.plugins.publish.extract_vrayscene.ExtractVrayscene.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_vrayscene.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\"\"\"\n    if instance.data.get(\"exportOnFarm\"):\n        self.log.debug(\"vrayscenes will be exported on farm.\")\n        raise NotImplementedError(\n            \"exporting vrayscenes is not implemented\")\n\n    # handle sequence\n    if instance.data.get(\"vraySceneMultipleFiles\"):\n        self.log.debug(\"vrayscenes will be exported on farm.\")\n        raise NotImplementedError(\n            \"exporting vrayscene sequences not implemented yet\")\n\n    vray_settings = cmds.ls(type=\"VRaySettingsNode\")\n    if not vray_settings:\n        node = cmds.createNode(\"VRaySettingsNode\")\n    else:\n        node = vray_settings[0]\n\n    # setMembers on vrayscene_layer should contain layer name.\n    layer_name = instance.data.get(\"layer\")\n\n    staging_dir = self.staging_dir(instance)\n    template = cmds.getAttr(\"{}.vrscene_filename\".format(node))\n    start_frame = instance.data.get(\n        \"frameStartHandle\") if instance.data.get(\n            \"vraySceneMultipleFiles\") else None\n    formatted_name = self.format_vray_output_filename(\n        os.path.basename(instance.data.get(\"source\")),\n        layer_name,\n        template,\n        start_frame\n    )\n\n    file_path = os.path.join(\n        staging_dir, \"vrayscene\", *formatted_name.split(\"/\"))\n\n    # Write out vrscene file\n    self.log.debug(\"Writing: '%s'\" % file_path)\n    with maintained_selection():\n        if \"*\" not in instance.data[\"setMembers\"]:\n            self.log.debug(\n                \"Exporting: {}\".format(instance.data[\"setMembers\"]))\n            set_members = instance.data[\"setMembers\"]\n            cmds.select(set_members, noExpand=True)\n        else:\n            self.log.debug(\"Exporting all ...\")\n            set_members = cmds.ls(\n                long=True, objectsOnly=True,\n                geometry=True, lights=True, cameras=True)\n            cmds.select(set_members, noExpand=True)\n\n        self.log.debug(\"Appending layer name {}\".format(layer_name))\n        set_members.append(layer_name)\n\n        export_in_rs_layer(\n            file_path,\n            set_members,\n            export=lambda: cmds.file(\n                file_path, type=\"V-Ray Scene\",\n                pr=True, es=True, force=True))\n\n    if \"representations\" not in instance.data:\n        instance.data[\"representations\"] = []\n\n    files = file_path\n\n    representation = {\n        'name': 'vrscene',\n        'ext': 'vrscene',\n        'files': os.path.basename(files),\n        \"stagingDir\": os.path.dirname(files),\n    }\n    instance.data[\"representations\"].append(representation)\n\n    self.log.debug(\"Extracted instance '%s' to: %s\"\n                   % (instance.name, staging_dir))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_workfile_xgen.html","title":"extract_workfile_xgen","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_workfile_xgen.html#client.ayon_maya.plugins.publish.extract_workfile_xgen.ExtractWorkfileXgen","title":"<code>ExtractWorkfileXgen</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extract Workfile Xgen.</p> <p>When submitting a render, we need to prep Xgen side car files.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_workfile_xgen.py</code> <pre><code>class ExtractWorkfileXgen(plugin.MayaExtractorPlugin):\n    \"\"\"Extract Workfile Xgen.\n\n    When submitting a render, we need to prep Xgen side car files.\n    \"\"\"\n\n    # Offset to run before workfile scene save.\n    order = pyblish.api.ExtractorOrder - 0.499\n    label = \"Extract Workfile Xgen\"\n    families = [\"workfile\"]\n\n    def get_render_max_frame_range(self, context):\n        \"\"\"Return start to end frame range including all renderlayers in\n        context.\n\n         This will return the full frame range which includes all frames of the\n         renderlayer instances to be published/submitted.\n\n         Args:\n            context (pyblish.api.Context): Current publishing context.\n\n         Returns:\n            tuple or None: Start frame, end frame tuple if any renderlayers\n                found. Otherwise None is returned.\n\n         \"\"\"\n\n        def _is_active_renderlayer(i):\n            \"\"\"Return whether instance is active renderlayer\"\"\"\n            if not i.data.get(\"publish\", True):\n                return False\n\n            is_renderlayer = (\n                \"renderlayer\" in i.data.get(\"families\", []) or\n                i.data[\"productType\"] == \"renderlayer\"\n            )\n            return is_renderlayer\n\n        start_frame = None\n        end_frame = None\n        for instance in context:\n            if not _is_active_renderlayer(instance):\n                # Only consider renderlyare instances\n                continue\n\n            render_start_frame = instance.data[\"frameStart\"]\n            render_end_frame = instance.data[\"frameEnd\"]\n\n            if start_frame is None:\n                start_frame = render_start_frame\n            else:\n                start_frame = min(start_frame, render_start_frame)\n\n            if end_frame is None:\n                end_frame = render_end_frame\n            else:\n                end_frame = max(end_frame, render_end_frame)\n\n        if start_frame is None or end_frame is None:\n            return\n\n        return start_frame, end_frame\n\n    def process(self, instance):\n        transfers = []\n\n        # Validate there is any palettes in the scene.\n        if not cmds.ls(type=\"xgmPalette\"):\n            self.log.debug(\n                \"No collections found in the scene. Skipping Xgen extraction.\"\n            )\n            return\n\n        import xgenm\n\n        # Validate to extract only when we are publishing a renderlayer as\n        # well.\n        render_range = self.get_render_max_frame_range(instance.context)\n        if not render_range:\n            self.log.debug(\n                \"No publishable renderlayers found in context. Skipping Xgen\"\n                \" extraction.\"\n            )\n            return\n\n        start_frame, end_frame = render_range\n\n        # We decrement start frame and increment end frame so motion blur will\n        # render correctly.\n        start_frame -= 1\n        end_frame += 1\n\n        # Extract patches alembic.\n        path_no_ext, _ = os.path.splitext(instance.context.data[\"currentFile\"])\n        kwargs = {\"attrPrefix\": [\"xgen\"], \"stripNamespaces\": True}\n        alembic_files = []\n        for palette in cmds.ls(type=\"xgmPalette\"):\n            patch_names = []\n            for description in xgenm.descriptions(palette):\n                for name in xgenm.boundGeometry(palette, description):\n                    patch_names.append(name)\n\n            alembic_file = \"{}__{}.abc\".format(\n                path_no_ext, palette.replace(\":\", \"__ns__\")\n            )\n            extract_alembic(\n                alembic_file,\n                root=patch_names,\n                selection=False,\n                startFrame=float(start_frame),\n                endFrame=float(end_frame),\n                verbose=True,\n                **kwargs\n            )\n            alembic_files.append(alembic_file)\n\n        template_data = copy.deepcopy(instance.data[\"anatomyData\"])\n        anatomy = instance.context.data[\"anatomy\"]\n        publish_template = anatomy.get_template_item(\n            \"publish\", \"default\", \"file\"\n        )\n        published_maya_path = publish_template.format(template_data)\n        published_basename, _ = os.path.splitext(published_maya_path)\n\n        for source in alembic_files:\n            destination = os.path.join(\n                os.path.dirname(instance.data[\"resourcesDir\"]),\n                os.path.basename(\n                    source.replace(path_no_ext, published_basename)\n                )\n            )\n            transfers.append((source, destination))\n\n        # Validate that we are using the published workfile.\n        deadline_settings = instance.context.get(\"deadline\")\n        if deadline_settings:\n            publish_settings = deadline_settings[\"publish\"]\n            if not publish_settings[\"MayaSubmitDeadline\"][\"use_published\"]:\n                self.log.debug(\n                    \"Not using the published workfile. Abort Xgen extraction.\"\n                )\n                return\n\n        # Collect Xgen and Delta files.\n        xgen_files = []\n        sources = []\n        current_dir = os.path.dirname(instance.context.data[\"currentFile\"])\n        attrs = [\"xgFileName\", \"xgBaseFile\"]\n        for palette in cmds.ls(type=\"xgmPalette\"):\n            for attr in attrs:\n                source = os.path.join(\n                    current_dir, cmds.getAttr(palette + \".\" + attr)\n                )\n                if not os.path.exists(source):\n                    continue\n\n                ext = os.path.splitext(source)[1]\n                if ext == \".xgen\":\n                    xgen_files.append(source)\n                if ext == \".xgd\":\n                    sources.append(source)\n\n        # Copy .xgen file to temporary location and modify.\n        staging_dir = self.staging_dir(instance)\n        for source in xgen_files:\n            destination = os.path.join(staging_dir, os.path.basename(source))\n            shutil.copy(source, destination)\n\n            lines = []\n            with open(destination, \"r\") as f:\n                for line in [line.rstrip() for line in f]:\n                    if line.startswith(\"\\txgProjectPath\"):\n                        path = os.path.dirname(instance.data[\"resourcesDir\"])\n                        line = \"\\txgProjectPath\\t\\t{}/\".format(\n                            path.replace(\"\\\\\", \"/\")\n                        )\n\n                    lines.append(line)\n\n            with open(destination, \"w\") as f:\n                f.write(\"\\n\".join(lines))\n\n            sources.append(destination)\n\n        # Add resource files to workfile instance.\n        for source in sources:\n            basename = os.path.basename(source)\n            destination = os.path.join(\n                os.path.dirname(instance.data[\"resourcesDir\"]), basename\n            )\n            transfers.append((source, destination))\n\n        destination_dir = os.path.join(\n            instance.data[\"resourcesDir\"], \"collections\"\n        )\n        for palette in cmds.ls(type=\"xgmPalette\"):\n            project_path = xgenm.getAttr(\"xgProjectPath\", palette)\n            data_path = xgenm.getAttr(\"xgDataPath\", palette)\n            data_path = data_path.replace(\"${PROJECT}\", project_path)\n            for path in data_path.split(\";\"):\n                for root, _, files in os.walk(path):\n                    for f in files:\n                        source = os.path.join(root, f)\n                        destination = \"{}/{}{}\".format(\n                            destination_dir,\n                            palette.replace(\":\", \"__ns__\"),\n                            source.replace(path, \"\")\n                        )\n                        transfers.append((source, destination))\n\n        for source, destination in transfers:\n            self.log.debug(\"Transfer: {} &gt; {}\".format(source, destination))\n\n        instance.data[\"transfers\"] = transfers\n\n        # Set palette attributes in preparation for workfile publish.\n        attrs = {\"xgFileName\": None, \"xgBaseFile\": \"\"}\n        data = {}\n        for palette in cmds.ls(type=\"xgmPalette\"):\n            attrs[\"xgFileName\"] = \"resources/{}.xgen\".format(\n                palette.replace(\":\", \"__ns__\")\n            )\n            for attr, value in attrs.items():\n                node_attr = palette + \".\" + attr\n\n                old_value = cmds.getAttr(node_attr)\n                try:\n                    data[palette][attr] = old_value\n                except KeyError:\n                    data[palette] = {attr: old_value}\n\n                cmds.setAttr(node_attr, value, type=\"string\")\n                self.log.debug(\n                    \"Setting \\\"{}\\\" on \\\"{}\\\"\".format(value, node_attr)\n                )\n\n            cmds.setAttr(palette + \".\" + \"xgExportAsDelta\", False)\n\n        instance.data[\"xgenAttributes\"] = data\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_workfile_xgen.html#client.ayon_maya.plugins.publish.extract_workfile_xgen.ExtractWorkfileXgen.get_render_max_frame_range","title":"<code>get_render_max_frame_range(context)</code>","text":"<p>Return start to end frame range including all renderlayers in context.</p> <p>This will return the full frame range which includes all frames of the  renderlayer instances to be published/submitted.</p> <p>Args:     context (pyblish.api.Context): Current publishing context.</p> <p>Returns:     tuple or None: Start frame, end frame tuple if any renderlayers         found. Otherwise None is returned.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_workfile_xgen.py</code> <pre><code>def get_render_max_frame_range(self, context):\n    \"\"\"Return start to end frame range including all renderlayers in\n    context.\n\n     This will return the full frame range which includes all frames of the\n     renderlayer instances to be published/submitted.\n\n     Args:\n        context (pyblish.api.Context): Current publishing context.\n\n     Returns:\n        tuple or None: Start frame, end frame tuple if any renderlayers\n            found. Otherwise None is returned.\n\n     \"\"\"\n\n    def _is_active_renderlayer(i):\n        \"\"\"Return whether instance is active renderlayer\"\"\"\n        if not i.data.get(\"publish\", True):\n            return False\n\n        is_renderlayer = (\n            \"renderlayer\" in i.data.get(\"families\", []) or\n            i.data[\"productType\"] == \"renderlayer\"\n        )\n        return is_renderlayer\n\n    start_frame = None\n    end_frame = None\n    for instance in context:\n        if not _is_active_renderlayer(instance):\n            # Only consider renderlyare instances\n            continue\n\n        render_start_frame = instance.data[\"frameStart\"]\n        render_end_frame = instance.data[\"frameEnd\"]\n\n        if start_frame is None:\n            start_frame = render_start_frame\n        else:\n            start_frame = min(start_frame, render_start_frame)\n\n        if end_frame is None:\n            end_frame = render_end_frame\n        else:\n            end_frame = max(end_frame, render_end_frame)\n\n    if start_frame is None or end_frame is None:\n        return\n\n    return start_frame, end_frame\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_xgen.html","title":"extract_xgen","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_xgen.html#client.ayon_maya.plugins.publish.extract_xgen.ExtractXgen","title":"<code>ExtractXgen</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extract Xgen</p> <p>Workflow: - Duplicate nodes used for patches. - Export palette and import onto duplicate nodes. - Export/Publish duplicate nodes and palette. - Export duplicate palette to .xgen file and add to publish. - Publish all xgen files as resources.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_xgen.py</code> <pre><code>class ExtractXgen(plugin.MayaExtractorPlugin):\n    \"\"\"Extract Xgen\n\n    Workflow:\n    - Duplicate nodes used for patches.\n    - Export palette and import onto duplicate nodes.\n    - Export/Publish duplicate nodes and palette.\n    - Export duplicate palette to .xgen file and add to publish.\n    - Publish all xgen files as resources.\n    \"\"\"\n\n    label = \"Extract Xgen\"\n    families = [\"xgen\"]\n    scene_type = \"ma\"\n    targets = [\"local\", \"remote\"]\n\n    def process(self, instance):\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        staging_dir = self.staging_dir(instance)\n        maya_filename = \"{}.{}\".format(instance.data[\"name\"], self.scene_type)\n        maya_filepath = os.path.join(staging_dir, maya_filename)\n\n        # Get published xgen file name.\n        template_data = copy.deepcopy(instance.data[\"anatomyData\"])\n        template_data.update({\"ext\": \"xgen\"})\n        anatomy = instance.context.data[\"anatomy\"]\n        file_template = anatomy.get_template_item(\"publish\", \"default\", \"file\")\n        xgen_filename = file_template.format(template_data)\n\n        xgen_path = os.path.join(\n            self.staging_dir(instance), xgen_filename\n        ).replace(\"\\\\\", \"/\")\n        type = \"mayaAscii\" if self.scene_type == \"ma\" else \"mayaBinary\"\n\n        # Duplicate xgen setup.\n        with delete_after() as delete_bin:\n            duplicate_nodes = []\n            # Collect nodes to export.\n            for node in instance.data[\"xgenConnections\"]:\n                # Duplicate_transform subd patch geometry.\n                duplicate_transform = cmds.duplicate(node)[0]\n                delete_bin.append(duplicate_transform)\n\n                # Discard the children.\n                shapes = cmds.listRelatives(duplicate_transform, shapes=True)\n                children = cmds.listRelatives(\n                    duplicate_transform, children=True\n                )\n                cmds.delete(set(children) - set(shapes))\n\n                if cmds.listRelatives(duplicate_transform, parent=True):\n                    duplicate_transform = cmds.parent(\n                        duplicate_transform, world=True\n                    )[0]\n\n                duplicate_nodes.append(duplicate_transform)\n\n            # Export temp xgen palette files.\n            temp_xgen_path = os.path.join(\n                tempfile.gettempdir(), \"temp.xgen\"\n            ).replace(\"\\\\\", \"/\")\n            xgenm.exportPalette(\n                instance.data[\"xgmPalette\"].replace(\"|\", \"\"), temp_xgen_path\n            )\n            self.log.debug(\"Extracted to {}\".format(temp_xgen_path))\n\n            # Import xgen onto the duplicate.\n            with maintained_selection():\n                cmds.select(duplicate_nodes)\n                palette = xgenm.importPalette(temp_xgen_path, [])\n\n            delete_bin.append(palette)\n\n            # Copy shading assignments.\n            nodes = (\n                instance.data[\"xgmDescriptions\"] +\n                instance.data[\"xgmSubdPatches\"]\n            )\n            for node in nodes:\n                target_node = node.split(\":\")[-1]\n                shading_engine = cmds.listConnections(\n                    node, type=\"shadingEngine\"\n                )[0]\n                cmds.sets(target_node, edit=True, forceElement=shading_engine)\n\n            # Export duplicated palettes.\n            xgenm.exportPalette(palette, xgen_path)\n\n            # Export Maya file.\n            attribute_data = {\"{}.xgFileName\".format(palette): xgen_filename}\n            with attribute_values(attribute_data):\n                with maintained_selection():\n                    cmds.select(duplicate_nodes + [palette])\n                    cmds.file(\n                        maya_filepath,\n                        force=True,\n                        type=type,\n                        exportSelected=True,\n                        preserveReferences=False,\n                        constructionHistory=True,\n                        shader=True,\n                        constraints=True,\n                        expressions=True\n                    )\n\n            self.log.debug(\"Extracted to {}\".format(maya_filepath))\n\n        if os.path.exists(temp_xgen_path):\n            os.remove(temp_xgen_path)\n\n        data = {\n            \"xgDataPath\": os.path.join(\n                instance.data[\"resourcesDir\"],\n                \"collections\",\n                palette.replace(\":\", \"__ns__\")\n            ).replace(\"\\\\\", \"/\"),\n            \"xgProjectPath\": os.path.dirname(\n                instance.data[\"resourcesDir\"]\n            ).replace(\"\\\\\", \"/\")\n        }\n        write_xgen_file(data, xgen_path)\n\n        # Adding representations.\n        representation = {\n            \"name\": \"xgen\",\n            \"ext\": \"xgen\",\n            \"files\": xgen_filename,\n            \"stagingDir\": staging_dir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        representation = {\n            \"name\": self.scene_type,\n            \"ext\": self.scene_type,\n            \"files\": maya_filename,\n            \"stagingDir\": staging_dir\n        }\n        instance.data[\"representations\"].append(representation)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_yeti_cache.html","title":"extract_yeti_cache","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_yeti_cache.html#client.ayon_maya.plugins.publish.extract_yeti_cache.ExtractYetiCache","title":"<code>ExtractYetiCache</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Producing Yeti cache files using scene time range.</p> <p>This will extract Yeti cache file sequence and fur settings.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_yeti_cache.py</code> <pre><code>class ExtractYetiCache(plugin.MayaExtractorPlugin):\n    \"\"\"Producing Yeti cache files using scene time range.\n\n    This will extract Yeti cache file sequence and fur settings.\n    \"\"\"\n\n    label = \"Extract Yeti Cache\"\n    families = [\"yetiRig\", \"yeticache\"]\n    targets = [\"local\", \"remote\"]\n\n    def process(self, instance):\n\n        yeti_nodes = cmds.ls(instance, type=\"pgYetiMaya\")\n        if not yeti_nodes:\n            raise RuntimeError(\"No pgYetiMaya nodes found in the instance\")\n\n        # Define extract output file path\n        dirname = self.staging_dir(instance)\n\n        # Collect information for writing cache\n        start_frame = instance.data[\"frameStartHandle\"]\n        end_frame = instance.data[\"frameEndHandle\"]\n        preroll = instance.data[\"preroll\"]\n        if preroll &gt; 0:\n            start_frame -= preroll\n\n        kwargs = {}\n        samples = instance.data.get(\"samples\", 0)\n        if samples == 0:\n            kwargs.update({\"sampleTimes\": \"0.0 1.0\"})\n        else:\n            kwargs.update({\"samples\": samples})\n\n        self.log.debug(\n            \"Writing out cache {} - {}\".format(start_frame, end_frame))\n        # Start writing the files for snap shot\n        # &lt;NAME&gt; will be replace by the Yeti node name\n        path = os.path.join(dirname, \"&lt;NAME&gt;.%04d.fur\")\n        cmds.pgYetiCommand(yeti_nodes,\n                           writeCache=path,\n                           range=(start_frame, end_frame),\n                           updateViewport=False,\n                           generatePreview=False,\n                           **kwargs)\n\n        cache_files = [x for x in os.listdir(dirname) if x.endswith(\".fur\")]\n\n        self.log.debug(\"Writing metadata file\")\n        settings = instance.data[\"fursettings\"]\n        fursettings_path = os.path.join(dirname, \"yeti.fursettings\")\n        with open(fursettings_path, \"w\") as fp:\n            json.dump(settings, fp, ensure_ascii=False)\n\n        # build representations\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        self.log.debug(\"cache files: {}\".format(cache_files[0]))\n\n        # Workaround: We do not explicitly register these files with the\n        # representation solely so that we can write multiple sequences\n        # a single Subset without renaming - it's a bit of a hack\n        # TODO: Implement better way to manage this sort of integration\n        if 'transfers' not in instance.data:\n            instance.data['transfers'] = []\n\n        publish_dir = instance.data[\"publishDir\"]\n        for cache_filename in cache_files:\n            src = os.path.join(dirname, cache_filename)\n            dst = os.path.join(publish_dir, os.path.basename(cache_filename))\n            instance.data['transfers'].append([src, dst])\n\n        instance.data[\"representations\"].append(\n            {\n                'name': 'fur',\n                'ext': 'fursettings',\n                'files': os.path.basename(fursettings_path),\n                'stagingDir': dirname\n            }\n        )\n\n        self.log.debug(\"Extracted {} to {}\".format(instance, dirname))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_yeti_rig.html","title":"extract_yeti_rig","text":"<p>Extract Yeti rig.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_yeti_rig.html#client.ayon_maya.plugins.publish.extract_yeti_rig.ExtractYetiRig","title":"<code>ExtractYetiRig</code>","text":"<p>               Bases: <code>MayaExtractorPlugin</code></p> <p>Extract the Yeti rig to a Maya Scene and write the Yeti rig data.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_yeti_rig.py</code> <pre><code>class ExtractYetiRig(plugin.MayaExtractorPlugin):\n    \"\"\"Extract the Yeti rig to a Maya Scene and write the Yeti rig data.\"\"\"\n\n    label = \"Extract Yeti Rig\"\n    families = [\"yetiRig\"]\n    scene_type = \"ma\"\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\"\"\"\n        maya_settings = instance.context.data[\"project_settings\"][\"maya\"]\n        ext_mapping = {\n            item[\"name\"]: item[\"value\"]\n            for item in maya_settings[\"ext_mapping\"]\n        }\n        if ext_mapping:\n            self.log.debug(\"Looking in settings for scene type ...\")\n            # use extension mapping for first family found\n            for family in self.families:\n                try:\n                    self.scene_type = ext_mapping[family]\n                    self.log.debug(\n                        \"Using {} as scene type\".format(self.scene_type))\n                    break\n                except KeyError:\n                    # no preset found\n                    pass\n        yeti_nodes = cmds.ls(instance, type=\"pgYetiMaya\")\n        if not yeti_nodes:\n            raise RuntimeError(\"No pgYetiMaya nodes found in the instance\")\n\n        # Define extract output file path\n        dirname = self.staging_dir(instance)\n        settings_path = os.path.join(dirname, \"yeti.rigsettings\")\n\n        # Yeti related staging dirs\n        maya_path = os.path.join(dirname,\n                                 \"yeti_rig.{}\".format(self.scene_type))\n\n        self.log.debug(\"Writing metadata file: {}\".format(settings_path))\n\n        image_search_path = resources_dir = instance.data[\"resourcesDir\"]\n\n        settings = instance.data.get(\"rigsettings\", None)\n        assert settings, \"Yeti rig settings were not collected.\"\n        settings[\"imageSearchPath\"] = image_search_path\n        with open(settings_path, \"w\") as fp:\n            json.dump(settings, fp, ensure_ascii=False)\n\n        # add textures to transfers\n        if 'transfers' not in instance.data:\n            instance.data['transfers'] = []\n\n        for resource in instance.data.get('resources', []):\n            for file in resource['files']:\n                src = file\n                dst = os.path.join(image_search_path, os.path.basename(file))\n                instance.data['transfers'].append([src, dst])\n\n                self.log.debug(\"adding transfer {} -&gt; {}\". format(src, dst))\n\n        # Ensure the imageSearchPath is being remapped to the publish folder\n        attr_value = {\"%s.imageSearchPath\" % n: str(image_search_path) for\n                      n in yeti_nodes}\n\n        # Get input_SET members\n        input_set = next(i for i in instance if i == \"input_SET\")\n\n        # Get all items\n        set_members = cmds.sets(input_set, query=True) or []\n        set_members += cmds.listRelatives(set_members,\n                                          allDescendents=True,\n                                          fullPath=True) or []\n        members = cmds.ls(set_members, long=True)\n\n        nodes = instance.data[\"setMembers\"]\n        resources = instance.data.get(\"resources\", {})\n        with disconnect_plugs(settings, members):\n            with yetigraph_attribute_values(resources_dir, resources):\n                with lib.attribute_values(attr_value):\n                    cmds.select(nodes, noExpand=True)\n                    cmds.file(maya_path,\n                              force=True,\n                              exportSelected=True,\n                              typ=\"mayaAscii\" if self.scene_type == \"ma\" else \"mayaBinary\",  # noqa: E501\n                              preserveReferences=False,\n                              constructionHistory=True,\n                              shader=False)\n\n        # Ensure files can be stored\n        # build representations\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        self.log.debug(\"rig file: {}\".format(maya_path))\n        instance.data[\"representations\"].append(\n            {\n                'name': self.scene_type,\n                'ext': self.scene_type,\n                'files': os.path.basename(maya_path),\n                'stagingDir': dirname\n            }\n        )\n        self.log.debug(\"settings file: {}\".format(settings_path))\n        instance.data[\"representations\"].append(\n            {\n                'name': 'rigsettings',\n                'ext': 'rigsettings',\n                'files': os.path.basename(settings_path),\n                'stagingDir': dirname\n            }\n        )\n\n        self.log.debug(\"Extracted {} to {}\".format(instance, dirname))\n\n        cmds.select(clear=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_yeti_rig.html#client.ayon_maya.plugins.publish.extract_yeti_rig.ExtractYetiRig.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_yeti_rig.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\"\"\"\n    maya_settings = instance.context.data[\"project_settings\"][\"maya\"]\n    ext_mapping = {\n        item[\"name\"]: item[\"value\"]\n        for item in maya_settings[\"ext_mapping\"]\n    }\n    if ext_mapping:\n        self.log.debug(\"Looking in settings for scene type ...\")\n        # use extension mapping for first family found\n        for family in self.families:\n            try:\n                self.scene_type = ext_mapping[family]\n                self.log.debug(\n                    \"Using {} as scene type\".format(self.scene_type))\n                break\n            except KeyError:\n                # no preset found\n                pass\n    yeti_nodes = cmds.ls(instance, type=\"pgYetiMaya\")\n    if not yeti_nodes:\n        raise RuntimeError(\"No pgYetiMaya nodes found in the instance\")\n\n    # Define extract output file path\n    dirname = self.staging_dir(instance)\n    settings_path = os.path.join(dirname, \"yeti.rigsettings\")\n\n    # Yeti related staging dirs\n    maya_path = os.path.join(dirname,\n                             \"yeti_rig.{}\".format(self.scene_type))\n\n    self.log.debug(\"Writing metadata file: {}\".format(settings_path))\n\n    image_search_path = resources_dir = instance.data[\"resourcesDir\"]\n\n    settings = instance.data.get(\"rigsettings\", None)\n    assert settings, \"Yeti rig settings were not collected.\"\n    settings[\"imageSearchPath\"] = image_search_path\n    with open(settings_path, \"w\") as fp:\n        json.dump(settings, fp, ensure_ascii=False)\n\n    # add textures to transfers\n    if 'transfers' not in instance.data:\n        instance.data['transfers'] = []\n\n    for resource in instance.data.get('resources', []):\n        for file in resource['files']:\n            src = file\n            dst = os.path.join(image_search_path, os.path.basename(file))\n            instance.data['transfers'].append([src, dst])\n\n            self.log.debug(\"adding transfer {} -&gt; {}\". format(src, dst))\n\n    # Ensure the imageSearchPath is being remapped to the publish folder\n    attr_value = {\"%s.imageSearchPath\" % n: str(image_search_path) for\n                  n in yeti_nodes}\n\n    # Get input_SET members\n    input_set = next(i for i in instance if i == \"input_SET\")\n\n    # Get all items\n    set_members = cmds.sets(input_set, query=True) or []\n    set_members += cmds.listRelatives(set_members,\n                                      allDescendents=True,\n                                      fullPath=True) or []\n    members = cmds.ls(set_members, long=True)\n\n    nodes = instance.data[\"setMembers\"]\n    resources = instance.data.get(\"resources\", {})\n    with disconnect_plugs(settings, members):\n        with yetigraph_attribute_values(resources_dir, resources):\n            with lib.attribute_values(attr_value):\n                cmds.select(nodes, noExpand=True)\n                cmds.file(maya_path,\n                          force=True,\n                          exportSelected=True,\n                          typ=\"mayaAscii\" if self.scene_type == \"ma\" else \"mayaBinary\",  # noqa: E501\n                          preserveReferences=False,\n                          constructionHistory=True,\n                          shader=False)\n\n    # Ensure files can be stored\n    # build representations\n    if \"representations\" not in instance.data:\n        instance.data[\"representations\"] = []\n\n    self.log.debug(\"rig file: {}\".format(maya_path))\n    instance.data[\"representations\"].append(\n        {\n            'name': self.scene_type,\n            'ext': self.scene_type,\n            'files': os.path.basename(maya_path),\n            'stagingDir': dirname\n        }\n    )\n    self.log.debug(\"settings file: {}\".format(settings_path))\n    instance.data[\"representations\"].append(\n        {\n            'name': 'rigsettings',\n            'ext': 'rigsettings',\n            'files': os.path.basename(settings_path),\n            'stagingDir': dirname\n        }\n    )\n\n    self.log.debug(\"Extracted {} to {}\".format(instance, dirname))\n\n    cmds.select(clear=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_yeti_rig.html#client.ayon_maya.plugins.publish.extract_yeti_rig.disconnect_plugs","title":"<code>disconnect_plugs(settings, members)</code>","text":"<p>Disconnect and store attribute connections.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_yeti_rig.py</code> <pre><code>@contextlib.contextmanager\ndef disconnect_plugs(settings, members):\n    \"\"\"Disconnect and store attribute connections.\"\"\"\n    members = cmds.ls(members, long=True)\n    original_connections = []\n    try:\n        for input in settings[\"inputs\"]:\n\n            # Get source shapes\n            source_nodes = lib.lsattr(\"cbId\", input[\"sourceID\"])\n            if not source_nodes:\n                continue\n\n            source = next(s for s in source_nodes if s not in members)\n\n            # Get destination shapes (the shapes used as hook up)\n            destination_nodes = lib.lsattr(\"cbId\", input[\"destinationID\"])\n            destination = next(i for i in destination_nodes if i in members)\n\n            # Create full connection\n            connections = input[\"connections\"]\n            src_attribute = \"%s.%s\" % (source, connections[0])\n            dst_attribute = \"%s.%s\" % (destination, connections[1])\n\n            # Check if there is an actual connection\n            if not cmds.isConnected(src_attribute, dst_attribute):\n                print(\"No connection between %s and %s\" % (\n                    src_attribute, dst_attribute))\n                continue\n\n            # Break and store connection\n            cmds.disconnectAttr(src_attribute, dst_attribute)\n            original_connections.append([src_attribute, dst_attribute])\n        yield\n    finally:\n        # Restore previous connections\n        for connection in original_connections:\n            try:\n                cmds.connectAttr(connection[0], connection[1])\n            except Exception as e:\n                print(e)\n                continue\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/extract_yeti_rig.html#client.ayon_maya.plugins.publish.extract_yeti_rig.yetigraph_attribute_values","title":"<code>yetigraph_attribute_values(assumed_destination, resources)</code>","text":"<p>Get values from Yeti attributes in graph.</p> Source code in <code>client/ayon_maya/plugins/publish/extract_yeti_rig.py</code> <pre><code>@contextlib.contextmanager\ndef yetigraph_attribute_values(assumed_destination, resources):\n    \"\"\"Get values from Yeti attributes in graph.\"\"\"\n    try:\n        for resource in resources:\n            if \"graphnode\" not in resource:\n                continue\n\n            fname = os.path.basename(resource[\"source\"])\n            new_fpath = os.path.join(assumed_destination, fname)\n            new_fpath = new_fpath.replace(\"\\\\\", \"/\")\n\n            try:\n                cmds.pgYetiGraph(resource[\"node\"],\n                                 node=resource[\"graphnode\"],\n                                 param=resource[\"param\"],\n                                 setParamValueString=new_fpath)\n            except Exception as exc:\n                print(\"&gt;&gt;&gt; Exception:\", exc)\n        yield\n\n    finally:\n        for resource in resources:\n            if \"graphnode\" not in resources:\n                continue\n\n            try:\n                cmds.pgYetiGraph(resource[\"node\"],\n                                 node=resource[\"graphnode\"],\n                                 param=resource[\"param\"],\n                                 setParamValue=resource[\"source\"])\n            except RuntimeError:\n                pass\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/increment_current_file.html","title":"increment_current_file","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/increment_current_file.html#client.ayon_maya.plugins.publish.increment_current_file.IncrementCurrentFileMaya","title":"<code>IncrementCurrentFileMaya</code>","text":"<p>               Bases: <code>MayaContextPlugin</code></p> <p>Increment the current file.</p> <p>Saves the current maya scene with an increased version number.</p> Source code in <code>client/ayon_maya/plugins/publish/increment_current_file.py</code> <pre><code>class IncrementCurrentFileMaya(plugin.MayaContextPlugin):\n    \"\"\"Increment the current file.\n\n    Saves the current maya scene with an increased version number.\"\"\"\n\n    label = \"Increment current file\"\n    order = pyblish.api.IntegratorOrder + 9.0\n    families = [\"*\"]\n    targets = [\"local\"]\n\n    def process(self, context):\n        current_filepath: str = context.data[\"currentFile\"]\n        try:\n            from ayon_core.pipeline.workfile import save_next_version\n            from ayon_core.host.interfaces import SaveWorkfileOptionalData\n\n            current_filename = os.path.basename(current_filepath)\n            save_next_version(\n                description=(\n                    f\"Incremented by publishing from {current_filename}\"\n                ),\n                # Optimize the save by reducing needed queries for context\n                prepared_data=SaveWorkfileOptionalData(\n                    project_entity=context.data[\"projectEntity\"],\n                    project_settings=context.data[\"project_settings\"],\n                    anatomy=context.data[\"anatomy\"],\n                )\n            )\n        except ImportError:\n            # Backwards compatibility before ayon-core 1.5.0\n            self.log.debug(\n                \"Using legacy `version_up`. Update AYON core addon to \"\n                \"use newer `save_next_version` function.\"\n            )\n            new_filepath = version_up(current_filepath)\n            host: IWorkfileHost = registered_host()\n            host.save_workfile(new_filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/reset_xgen_attributes.html","title":"reset_xgen_attributes","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/reset_xgen_attributes.html#client.ayon_maya.plugins.publish.reset_xgen_attributes.ResetXgenAttributes","title":"<code>ResetXgenAttributes</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Reset Xgen attributes.</p> <p>When the incremental save of the workfile triggers, the Xgen attributes changes so this plugin will change it back to the values before publishing.</p> Source code in <code>client/ayon_maya/plugins/publish/reset_xgen_attributes.py</code> <pre><code>class ResetXgenAttributes(plugin.MayaInstancePlugin):\n    \"\"\"Reset Xgen attributes.\n\n    When the incremental save of the workfile triggers, the Xgen attributes\n    changes so this plugin will change it back to the values before publishing.\n    \"\"\"\n\n    label = \"Reset Xgen Attributes.\"\n    # Offset to run after workfile increment plugin.\n    order = pyblish.api.IntegratorOrder + 10.0\n    families = [\"workfile\"]\n\n    def process(self, instance):\n        xgen_attributes = instance.data.get(\"xgenAttributes\", {})\n        if not xgen_attributes:\n            return\n\n        for palette, data in xgen_attributes.items():\n            for attr, value in data.items():\n                node_attr = \"{}.{}\".format(palette, attr)\n                self.log.debug(\n                    \"Setting \\\"{}\\\" on \\\"{}\\\"\".format(value, node_attr)\n                )\n                cmds.setAttr(node_attr, value, type=\"string\")\n            cmds.setAttr(palette + \".xgExportAsDelta\", True)\n\n        # Need to save the scene, cause the attribute changes above does not\n        # mark the scene as modified so user can exit without committing the\n        # changes.\n        self.log.debug(\"Saving changes.\")\n        cmds.file(save=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/save_scene.html","title":"save_scene","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/save_scene.html#client.ayon_maya.plugins.publish.save_scene.SaveCurrentScene","title":"<code>SaveCurrentScene</code>","text":"<p>               Bases: <code>MayaContextPlugin</code></p> <p>Save current scene.</p> Source code in <code>client/ayon_maya/plugins/publish/save_scene.py</code> <pre><code>class SaveCurrentScene(plugin.MayaContextPlugin):\n    \"\"\"Save current scene.\"\"\"\n\n    label = \"Save current file\"\n    order = pyblish.api.ExtractorOrder - 0.49\n    families = [\"renderlayer\", \"workfile\"]\n    targets = [\"local\"]\n\n    def process(self, context):\n        import maya.cmds as cmds\n\n        current = cmds.file(query=True, sceneName=True)\n        assert context.data['currentFile'] == current\n\n        # If file has no modifications, skip forcing a file save\n        if not cmds.file(query=True, modified=True):\n            self.log.debug(\"Skipping file save as there \"\n                           \"are no modifications..\")\n            return\n        project_name = context.data[\"projectName\"]\n        project_settings = context.data[\"project_settings\"]\n        # remove lockfile before saving\n        if is_workfile_lock_enabled(\"maya\", project_name, project_settings):\n            remove_workfile_lock(current)\n        self.log.info(\"Saving current file: {}\".format(current))\n        cmds.file(save=True, force=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_alembic_options_defaults.html","title":"validate_alembic_options_defaults","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_alembic_options_defaults.html#client.ayon_maya.plugins.publish.validate_alembic_options_defaults.ValidateAlembicDefaultsAnimation","title":"<code>ValidateAlembicDefaultsAnimation</code>","text":"<p>               Bases: <code>ValidateAlembicDefaultsPointcache</code></p> <p>Validate the attributes on the instance are defaults.</p> <p>The defaults are defined in the project settings.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_alembic_options_defaults.py</code> <pre><code>class ValidateAlembicDefaultsAnimation(\n    ValidateAlembicDefaultsPointcache\n):\n    \"\"\"Validate the attributes on the instance are defaults.\n\n    The defaults are defined in the project settings.\n    \"\"\"\n    label = \"Validate Alembic Options Defaults\"\n    families = [\"animation\"]\n    plugin_name = \"ExtractAnimation\"\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_alembic_options_defaults.html#client.ayon_maya.plugins.publish.validate_alembic_options_defaults.ValidateAlembicDefaultsPointcache","title":"<code>ValidateAlembicDefaultsPointcache</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate the attributes on the instance are defaults.</p> <p>The defaults are defined in the project settings.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_alembic_options_defaults.py</code> <pre><code>class ValidateAlembicDefaultsPointcache(\n    plugin.MayaInstancePlugin, OptionalPyblishPluginMixin\n):\n    \"\"\"Validate the attributes on the instance are defaults.\n\n    The defaults are defined in the project settings.\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"pointcache\"]\n    label = \"Validate Alembic Options Defaults\"\n    actions = [RepairAction]\n    optional = True\n\n    plugin_name = \"ExtractAlembic\"\n\n    ignore_keys = {\"active\"}\n\n    @classmethod\n    def _get_settings(cls, context):\n        maya_settings = context.data[\"project_settings\"][\"maya\"]\n        settings = maya_settings[\"publish\"][\"ExtractAlembic\"]\n        return settings\n\n    @classmethod\n    def _get_publish_attributes(cls, instance):\n        return instance.data[\"publish_attributes\"][cls.plugin_name]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        settings = self._get_settings(instance.context)\n        attributes = self._get_publish_attributes(instance)\n\n        invalid = {}\n        for key, value in attributes.items():\n            if key in self.ignore_keys:\n                continue\n\n            if key not in settings:\n                # This may occur if attributes have changed over time and an\n                # existing instance has older legacy attributes that do not\n                # match the current settings definition.\n                self.log.warning(\n                    \"Publish attribute %s not found in Alembic Export \"\n                    \"default settings. Ignoring validation for attribute.\",\n                    key\n                )\n                continue\n\n            default_value = settings[key]\n\n            # Lists are best to compared sorted since we can't rely on\n            # the order of the items.\n            if isinstance(value, list):\n                value = sorted(value)\n                default_value = sorted(default_value)\n\n            if value != default_value:\n                invalid[key] = value, default_value\n\n        if invalid:\n            non_defaults = \"\\n\".join(\n                f\"- {key}: {value} \\t(default: {default_value})\"\n                for key, (value, default_value) in invalid.items()\n            )\n\n            raise PublishValidationError(\n                \"Alembic extract options differ from default values:\\n\"\n                f\"{non_defaults}\",\n                description=self.get_description()\n            )\n\n    @staticmethod\n    def get_description():\n        return inspect.cleandoc(\n            \"\"\"### Alembic Extract settings differ from defaults\n\n            The alembic export options differ from the project default values.\n\n            If this is intentional you can disable this validation by\n            disabling **Validate Alembic Options Default**.\n\n            If not you may use the \"Repair\" action to revert all the options to\n            their default values.\n\n            \"\"\"\n        )\n\n    @classmethod\n    def repair(cls, instance):\n        # Find create instance twin.\n        create_context = instance.context.data[\"create_context\"]\n        create_instance = create_context.get_instance_by_id(\n            instance.data[\"instance_id\"]\n        )\n\n        # Set the settings values on the create context then save to workfile.\n        settings = cls._get_settings(instance.context)\n        attributes: PublishAttributeValues = (\n            cls._get_publish_attributes(create_instance)\n        )\n        for key in attributes.keys():\n            if key in cls.ignore_keys:\n                continue\n\n            if key not in settings:\n                # This may occur if attributes have changed over time and an\n                # existing instance has older legacy attributes that do not\n                # match the current settings definition.\n                cls.log.warning(\n                    \"Publish attribute %s not found in Alembic Export \"\n                    \"default settings. Ignoring repair for attribute.\",\n                    key\n                )\n                continue\n            attributes[key] = settings[key]\n\n        create_context.save_changes()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_animation_content.html","title":"validate_animation_content","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_animation_content.html#client.ayon_maya.plugins.publish.validate_animation_content.ValidateAnimationContent","title":"<code>ValidateAnimationContent</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Adheres to the content of 'animation' product type</p> <ul> <li>Must have collected <code>out_hierarchy</code> data.</li> <li>All nodes in <code>out_hierarchy</code> must be in the instance.</li> </ul> Source code in <code>client/ayon_maya/plugins/publish/validate_animation_content.py</code> <pre><code>class ValidateAnimationContent(plugin.MayaInstancePlugin,\n                               OptionalPyblishPluginMixin):\n    \"\"\"Adheres to the content of 'animation' product type\n\n    - Must have collected `out_hierarchy` data.\n    - All nodes in `out_hierarchy` must be in the instance.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"animation\"]\n    label = \"Animation Content\"\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = False\n\n    @classmethod\n    def get_invalid(cls, instance):\n        if \"animation.abc\" not in instance.data[\"families\"]:\n            cls.log.debug(\"Skipping Validate Animation content.\")\n            return\n        out_set = next((i for i in instance.data[\"setMembers\"] if\n                        i.endswith(\"out_SET\")), None)\n\n        assert out_set, (\"Instance '%s' has no objectSet named: `OUT_set`. \"\n                         \"If this instance is an unloaded reference, \"\n                         \"please deactivate by toggling the 'Active' attribute\"\n                         % instance.name)\n\n        assert 'out_hierarchy' in instance.data, \"Missing `out_hierarchy` data\"\n\n        out_sets = [node for node in instance if node.endswith(\"out_SET\")]\n        msg = \"Couldn't find exactly one out_SET: {0}\".format(out_sets)\n        assert len(out_sets) == 1, msg\n\n        # All nodes in the `out_hierarchy` must be among the nodes that are\n        # in the instance. The nodes in the instance are found from the top\n        # group, as such this tests whether all nodes are under that top group.\n\n        lookup = set(instance[:])\n        invalid = [node for node in instance.data['out_hierarchy'] if\n                   node not in lookup]\n\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Animation content is invalid. See log.\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_animation_out_set_related_node_ids.html","title":"validate_animation_out_set_related_node_ids","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_animation_out_set_related_node_ids.html#client.ayon_maya.plugins.publish.validate_animation_out_set_related_node_ids.ValidateOutRelatedNodeIds","title":"<code>ValidateOutRelatedNodeIds</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate if deformed shapes have related IDs to the original shapes</p> <p>When a deformer is applied in the scene on a referenced mesh that already had deformers then Maya will create a new shape node for the mesh that does not have the original id. This validator checks whether the ids are valid on all the shape nodes in the instance.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_animation_out_set_related_node_ids.py</code> <pre><code>class ValidateOutRelatedNodeIds(plugin.MayaInstancePlugin,\n                                OptionalPyblishPluginMixin):\n    \"\"\"Validate if deformed shapes have related IDs to the original shapes\n\n    When a deformer is applied in the scene on a referenced mesh that already\n    had deformers then Maya will create a new shape node for the mesh that\n    does not have the original id. This validator checks whether the ids are\n    valid on all the shape nodes in the instance.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = ['animation', \"pointcache\", \"proxyAbc\"]\n    hosts = ['maya']\n    label = 'Animation Out Set Related Node Ids'\n    actions = [\n        ayon_maya.api.action.SelectInvalidAction,\n        RepairAction\n    ]\n    optional = False\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        # Preserve automatic settings applying logic\n        settings = get_plugin_settings(plugin=cls,\n                                       project_settings=project_settings,\n                                       log=cls.log,\n                                       category=\"maya\")\n        apply_plugin_settings_automatically(cls, settings, logger=cls.log)\n\n        # Disable plug-in if cbId workflow is disabled\n        if not project_settings[\"maya\"].get(\"use_cbid_workflow\", True):\n            cls.enabled = False\n            return\n\n    def process(self, instance):\n        \"\"\"Process all meshes\"\"\"\n        if not self.is_active(instance.data):\n            return\n        # Ensure all nodes have a cbId and a related ID to the original shapes\n        # if a deformer has been created on the shape\n        invalid = self.get_invalid(instance)\n        if invalid:\n\n            # Use the short names\n            invalid = cmds.ls(invalid)\n            invalid.sort()\n\n            # Construct a human-readable list\n            invalid = \"\\n\".join(\"- {}\".format(node) for node in invalid)\n\n            raise PublishXmlValidationError(\n                plugin=self,\n                message=(\n                    \"Nodes have different IDs than their input \"\n                    \"history: \\n{0}\".format(invalid)\n                )\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n        \"\"\"Get all nodes which do not match the criteria\"\"\"\n\n        invalid = []\n        types = [\"mesh\", \"nurbsCurve\", \"nurbsSurface\"]\n\n        # get asset id\n        nodes = instance.data.get(\"out_hierarchy\", instance[:])\n        for node in cmds.ls(nodes, type=types, long=True):\n\n            # We only check when the node is *not* referenced\n            if cmds.referenceQuery(node, isNodeReferenced=True):\n                continue\n\n            # Get the current id of the node\n            node_id = lib.get_id(node)\n\n            history_id = lib.get_id_from_sibling(node)\n            if history_id is not None and node_id != history_id:\n                invalid.append(node)\n\n        return invalid\n\n    @classmethod\n    def repair(cls, instance):\n\n        for node in cls.get_invalid(instance):\n            # Get the original id from history\n            history_id = lib.get_id_from_sibling(node)\n            if not history_id:\n                cls.log.error(\"Could not find ID in history for '%s'\", node)\n                continue\n\n            lib.set_id(node, history_id, overwrite=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_animation_out_set_related_node_ids.html#client.ayon_maya.plugins.publish.validate_animation_out_set_related_node_ids.ValidateOutRelatedNodeIds.get_invalid","title":"<code>get_invalid(instance)</code>  <code>classmethod</code>","text":"<p>Get all nodes which do not match the criteria</p> Source code in <code>client/ayon_maya/plugins/publish/validate_animation_out_set_related_node_ids.py</code> <pre><code>@classmethod\ndef get_invalid(cls, instance):\n    \"\"\"Get all nodes which do not match the criteria\"\"\"\n\n    invalid = []\n    types = [\"mesh\", \"nurbsCurve\", \"nurbsSurface\"]\n\n    # get asset id\n    nodes = instance.data.get(\"out_hierarchy\", instance[:])\n    for node in cmds.ls(nodes, type=types, long=True):\n\n        # We only check when the node is *not* referenced\n        if cmds.referenceQuery(node, isNodeReferenced=True):\n            continue\n\n        # Get the current id of the node\n        node_id = lib.get_id(node)\n\n        history_id = lib.get_id_from_sibling(node)\n        if history_id is not None and node_id != history_id:\n            invalid.append(node)\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_animation_out_set_related_node_ids.html#client.ayon_maya.plugins.publish.validate_animation_out_set_related_node_ids.ValidateOutRelatedNodeIds.process","title":"<code>process(instance)</code>","text":"<p>Process all meshes</p> Source code in <code>client/ayon_maya/plugins/publish/validate_animation_out_set_related_node_ids.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all meshes\"\"\"\n    if not self.is_active(instance.data):\n        return\n    # Ensure all nodes have a cbId and a related ID to the original shapes\n    # if a deformer has been created on the shape\n    invalid = self.get_invalid(instance)\n    if invalid:\n\n        # Use the short names\n        invalid = cmds.ls(invalid)\n        invalid.sort()\n\n        # Construct a human-readable list\n        invalid = \"\\n\".join(\"- {}\".format(node) for node in invalid)\n\n        raise PublishXmlValidationError(\n            plugin=self,\n            message=(\n                \"Nodes have different IDs than their input \"\n                \"history: \\n{0}\".format(invalid)\n            )\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_animation_product_type_publish.html","title":"validate_animation_product_type_publish","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_animation_product_type_publish.html#client.ayon_maya.plugins.publish.validate_animation_product_type_publish.ValidateAnimationProductTypePublish","title":"<code>ValidateAnimationProductTypePublish</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validate at least a single product type is exported for the instance.</p> <p>Validate either fbx animation collector or collect animation output  geometry(Alembic) enabled for publishing otherwise no products would be generated for the instance - publishing nothing valid.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_animation_product_type_publish.py</code> <pre><code>class ValidateAnimationProductTypePublish(plugin.MayaInstancePlugin):\n    \"\"\"Validate at least a single product type is exported for the instance.\n\n    Validate either fbx animation collector or collect animation output \n    geometry(Alembic) enabled for publishing otherwise no products\n    would be generated for the instance - publishing nothing valid.\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"animation\"]\n    label = \"Animation Product Type Publish\"\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        plugins = instance.context.data[\"create_context\"].publish_plugins\n        plugins_by_name = {plugin.__name__: plugin for plugin in plugins}\n\n        def _is_plugin_active(plugin_name: str) -&gt; bool:\n            \"\"\"Return whether plugin is active for instance\"\"\"\n            # Check if Plug-in is found\n            plugin = plugins_by_name.get(plugin_name)\n            if not plugin:\n                cls.log.debug(f\"Plugin {plugin_name} not found. \"\n                              f\"It may be disabled in settings\")\n                return False\n\n            # Check if plug-in is globally enabled\n            if not getattr(plugin, \"enabled\", True):\n                cls.log.debug(f\"Plugin {plugin_name} is disabled. \"\n                              f\"It is disabled in settings\")\n                return False\n\n            # Check if optional state has active state set to False\n            publish_attributes = instance.data[\"publish_attributes\"]\n            default_active = getattr(plugin, \"active\", True)\n            active_for_instance = publish_attributes.get(\n                plugin_name, {}).get(\"active\", default_active)\n            if not active_for_instance:\n                cls.log.debug(\n                    f\"Plugin {plugin_name} is disabled for this instance.\")\n                return False\n\n            # Check if the instance, according to pyblish is a match for the\n            # plug-in. This may e.g. be excluded due to different families\n            # or matching algorithm (e.g. ExtractMultiverseUsdAnim uses\n            # `pyblish.api.Subset`\n            if not pyblish.api.instances_by_plugin([instance], plugin):\n                cls.log.debug(\n                    f\"Plugin {plugin_name} does not match for this instance.\")\n                return False\n\n            return True\n\n        active_check = {\n            \"fbx\": \"animation.fbx\" in instance.data[\"families\"],\n            \"ExtractAnimation\": _is_plugin_active(\"ExtractAnimation\"),\n            \"ExtractMayaUsdAnim\": _is_plugin_active(\"ExtractMayaUsdAnim\"),\n            \"ExtractMultiverseUsdAnim\": _is_plugin_active(\n                \"ExtractMultiverseUsdAnim\"),\n        }\n        active = [key for key, state in active_check.items() if state]\n\n        if active:\n            active_str = \", \".join(active)\n            cls.log.debug(f\"Found active animation extractions: {active_str}\")\n            return []\n\n        return [instance.data[\"instance_node\"]]\n\n    def process(self, instance):\n        invalid = self.get_invalid(instance)\n        if invalid:\n            name = invalid[0]\n            raise PublishValidationError(\n                f\"Animation instance generates no products: {name}\\n\"\n                \"Make sure to enable at least one of the export(s) \"\n                \"product types: FBX, Alembic and/or USD.\",\n                description=self.get_description()\n            )\n\n    @staticmethod\n    def get_description():\n        return inspect.cleandoc(\"\"\"\n            ## Instance generates no products\n\n            The animation instance generates no products. As a result of that\n            there is nothing to publish.\n\n            Please make sure to enable at least one of the product types to \n            export: FBX, Alembic and/or USD.\n        \"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_animation_rig_content.html","title":"validate_animation_rig_content","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_animation_rig_content.html#client.ayon_maya.plugins.publish.validate_animation_rig_content.ValidateAnimatedRigContent","title":"<code>ValidateAnimatedRigContent</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates the <code>skeletonAnim_SET</code> must have one or more objects</p> Source code in <code>client/ayon_maya/plugins/publish/validate_animation_rig_content.py</code> <pre><code>class ValidateAnimatedRigContent(plugin.MayaInstancePlugin,\n                                 OptionalPyblishPluginMixin):\n    \"\"\"Validates the `skeletonAnim_SET` must have one or more objects\n    \"\"\"\n    order = ValidateContentsOrder + 0.05\n    label = \"Animated Rig Content\"\n    families = [\"animation.fbx\"]\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        skeleton_anim_nodes = instance.data(\"animated_skeleton\", [])\n        if not skeleton_anim_nodes:\n            raise PublishValidationError(\n                \"The skeletonAnim_SET includes no objects.\",\n                description=self.get_description())\n\n    @staticmethod\n    def get_description():\n        return inspect.cleandoc(\"\"\"\n            ### Invalid FBX export\n\n            FBX export is enabled for your animation instance however the\n            instance does not meet the required configurations for a valid\n            export.\n\n            It must contain at one or more objects in the `skeletonAnim_SET`.\n\n        \"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_arnold_scene_source.html","title":"validate_arnold_scene_source","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_arnold_scene_source.html#client.ayon_maya.plugins.publish.validate_arnold_scene_source.ValidateArnoldSceneSource","title":"<code>ValidateArnoldSceneSource</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validate Arnold Scene Source.</p> <p>Ensure no nodes are hidden.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_arnold_scene_source.py</code> <pre><code>class ValidateArnoldSceneSource(plugin.MayaInstancePlugin):\n    \"\"\"Validate Arnold Scene Source.\n\n    Ensure no nodes are hidden.\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"ass\", \"assProxy\"]\n    label = \"Validate Arnold Scene Source\"\n\n    def process(self, instance):\n        # Validate against having nodes hidden, which will result in the\n        # extraction to ignore the node.\n        nodes = instance.data[\"members\"] + instance.data.get(\"proxy\", [])\n        nodes = [x for x in nodes if cmds.objectType(x, isAType='dagNode')]\n        hidden_nodes = [\n            x for x in nodes if not is_visible(x, intermediateObject=False)\n        ]\n        if hidden_nodes:\n            raise PublishValidationError(\n                \"Found hidden nodes:\\n\\n{}\\n\\nPlease unhide for\"\n                \" publishing.\".format(\"\\n\".join(hidden_nodes))\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_arnold_scene_source.html#client.ayon_maya.plugins.publish.validate_arnold_scene_source.ValidateArnoldSceneSourceProxy","title":"<code>ValidateArnoldSceneSourceProxy</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validate Arnold Scene Source Proxy.</p> <p>When using proxies we need the nodes to share the same names and not be parent to the world. This ends up needing at least two groups with content nodes and proxy nodes in another.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_arnold_scene_source.py</code> <pre><code>class ValidateArnoldSceneSourceProxy(pyblish.api.InstancePlugin):\n    \"\"\"Validate Arnold Scene Source Proxy.\n\n    When using proxies we need the nodes to share the same names and not be\n    parent to the world. This ends up needing at least two groups with content\n    nodes and proxy nodes in another.\n    \"\"\"\n\n    order = ValidateContentsOrder\n    hosts = [\"maya\"]\n    families = [\"assProxy\"]\n    label = \"Validate Arnold Scene Source Proxy\"\n\n    def _get_nodes_by_name(self, nodes):\n        ungrouped_nodes = []\n        nodes_by_name = {}\n        parents = []\n        for node in nodes:\n            node_split = node.split(\"|\")\n            if len(node_split) == 2:\n                ungrouped_nodes.append(node)\n\n            parent = \"|\".join(node_split[:-1])\n            if parent:\n                parents.append(parent)\n\n            node_name = node.rsplit(\"|\", 1)[-1].rsplit(\":\", 1)[-1]\n            nodes_by_name[node_name] = node\n\n        return ungrouped_nodes, nodes_by_name, parents\n\n    def process(self, instance):\n        # Validate against nodes directly parented to world.\n        ungrouped_nodes = []\n\n        nodes, content_nodes_by_name, content_parents = (\n            self._get_nodes_by_name(instance.data[\"members\"])\n        )\n        ungrouped_nodes.extend(nodes)\n\n        nodes, proxy_nodes_by_name, proxy_parents = self._get_nodes_by_name(\n            instance.data.get(\"proxy\", [])\n        )\n        ungrouped_nodes.extend(nodes)\n\n        if ungrouped_nodes:\n            raise PublishValidationError(\n                \"Found nodes parented to the world: {}\\n\"\n                \"All nodes need to be grouped.\".format(ungrouped_nodes)\n            )\n\n        # Validate for content and proxy nodes amount being the same.\n        if len(instance.data[\"members\"]) != len(instance.data[\"proxy\"]):\n            raise PublishValidationError(\n                \"Amount of content nodes ({}) and proxy nodes ({}) needs to \"\n                \"be the same.\\nContent nodes: {}\\nProxy nodes:{}\".format(\n                    len(instance.data[\"members\"]),\n                    len(instance.data[\"proxy\"]),\n                    instance.data[\"members\"],\n                    instance.data[\"proxy\"]\n                )\n            )\n\n        # Validate against content and proxy nodes sharing same parent.\n        if list(set(content_parents) &amp; set(proxy_parents)):\n            raise PublishValidationError(\n                \"Content and proxy nodes cannot share the same parent.\"\n            )\n\n        # Validate for content and proxy nodes sharing same names.\n        sorted_content_names = sorted(content_nodes_by_name.keys())\n        sorted_proxy_names = sorted(proxy_nodes_by_name.keys())\n        odd_content_names = list(\n            set(sorted_content_names) - set(sorted_proxy_names)\n        )\n        odd_content_nodes = [\n            content_nodes_by_name[x] for x in odd_content_names\n        ]\n        odd_proxy_names = list(\n            set(sorted_proxy_names) - set(sorted_content_names)\n        )\n        odd_proxy_nodes = [\n            proxy_nodes_by_name[x] for x in odd_proxy_names\n        ]\n        if not sorted_content_names == sorted_proxy_names:\n            raise PublishValidationError(\n                \"Content and proxy nodes need to share the same names.\\n\"\n                \"Content nodes not matching: {}\\n\"\n                \"Proxy nodes not matching: {}\".format(\n                    odd_content_nodes, odd_proxy_nodes\n                )\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_arnold_scene_source_cbid.html","title":"validate_arnold_scene_source_cbid","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_arnold_scene_source_cbid.html#client.ayon_maya.plugins.publish.validate_arnold_scene_source_cbid.ValidateArnoldSceneSourceCbid","title":"<code>ValidateArnoldSceneSourceCbid</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate Arnold Scene Source Cbid.</p> <p>It is required for the proxy and content nodes to share the same cbid.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_arnold_scene_source_cbid.py</code> <pre><code>class ValidateArnoldSceneSourceCbid(plugin.MayaInstancePlugin,\n                                    OptionalPyblishPluginMixin):\n    \"\"\"Validate Arnold Scene Source Cbid.\n\n    It is required for the proxy and content nodes to share the same cbid.\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"assProxy\"]\n    label = \"Validate Arnold Scene Source CBID\"\n    actions = [RepairAction]\n    optional = False\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        # Disable plug-in if cbId workflow is disabled\n        if not project_settings[\"maya\"].get(\"use_cbid_workflow\", True):\n            cls.enabled = False\n            return\n\n    @staticmethod\n    def _get_nodes_by_name(nodes):\n        nodes_by_name = {}\n        for node in nodes:\n            node_name = node.rsplit(\"|\", 1)[-1].rsplit(\":\", 1)[-1]\n            nodes_by_name[node_name] = node\n\n        return nodes_by_name\n\n    @classmethod\n    def get_invalid_couples(cls, instance):\n        nodes_by_name = cls._get_nodes_by_name(instance.data[\"members\"])\n        proxy_nodes_by_name = cls._get_nodes_by_name(instance.data[\"proxy\"])\n\n        invalid_couples = []\n        for content_name, content_node in nodes_by_name.items():\n            proxy_node = proxy_nodes_by_name.get(content_name, None)\n\n            if not proxy_node:\n                cls.log.debug(\n                    \"Content node '{}' has no matching proxy node.\".format(\n                        content_node\n                    )\n                )\n                continue\n\n            content_id = lib.get_id(content_node)\n            proxy_id = lib.get_id(proxy_node)\n            if content_id != proxy_id:\n                invalid_couples.append((content_node, proxy_node))\n\n        return invalid_couples\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        # Proxy validation.\n        if not instance.data[\"proxy\"]:\n            return\n\n        # Validate for proxy nodes sharing the same cbId as content nodes.\n        invalid_couples = self.get_invalid_couples(instance)\n        if invalid_couples:\n            raise PublishValidationError(\n                \"Found proxy nodes with mismatching cbid:\\n{}\".format(\n                    invalid_couples\n                )\n            )\n\n    @classmethod\n    def repair(cls, instance):\n        for content_node, proxy_node in cls.get_invalid_couples(instance):\n            lib.set_id(proxy_node, lib.get_id(content_node), overwrite=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_ass_relative_paths.html","title":"validate_ass_relative_paths","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_ass_relative_paths.html#client.ayon_maya.plugins.publish.validate_ass_relative_paths.ValidateAssRelativePaths","title":"<code>ValidateAssRelativePaths</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure exporting ass file has set relative texture paths</p> Source code in <code>client/ayon_maya/plugins/publish/validate_ass_relative_paths.py</code> <pre><code>class ValidateAssRelativePaths(plugin.MayaInstancePlugin,\n                               OptionalPyblishPluginMixin):\n    \"\"\"Ensure exporting ass file has set relative texture paths\"\"\"\n\n    order = ValidateContentsOrder\n    families = ['ass']\n    label = \"ASS has relative texture paths\"\n    actions = [RepairAction]\n    optional = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        # we cannot ask this until user open render settings as\n        # `defaultArnoldRenderOptions` doesn't exist\n        errors = []\n\n        try:\n            absolute_texture = cmds.getAttr(\n                \"defaultArnoldRenderOptions.absolute_texture_paths\")\n            absolute_procedural = cmds.getAttr(\n                \"defaultArnoldRenderOptions.absolute_procedural_paths\")\n            texture_search_path = cmds.getAttr(\n                \"defaultArnoldRenderOptions.tspath\"\n            )\n            procedural_search_path = cmds.getAttr(\n                \"defaultArnoldRenderOptions.pspath\"\n            )\n        except ValueError:\n            raise PublishValidationError(\n                \"Default Arnold options has not been created yet.\"\n            )\n\n        scene_dir, scene_basename = os.path.split(cmds.file(q=True, loc=True))\n        scene_name, _ = os.path.splitext(scene_basename)\n\n        if self.maya_is_true(absolute_texture):\n            errors.append(\"Texture path is set to be absolute\")\n        if self.maya_is_true(absolute_procedural):\n            errors.append(\"Procedural path is set to be absolute\")\n\n        anatomy = instance.context.data[\"anatomy\"]\n\n        # Use project root variables for multiplatform support, see:\n        # https://docs.arnoldrenderer.com/display/A5AFMUG/Search+Path\n        # ':' as path separator is supported by Arnold for all platforms.\n        keys = anatomy.root_environments().keys()\n        paths = []\n        for k in keys:\n            paths.append(\"[{}]\".format(k))\n\n        self.log.debug(\"discovered roots: {}\".format(\":\".join(paths)))\n\n        if \":\".join(paths) not in texture_search_path:\n            errors.append((\n                \"Project roots {} are not in texture_search_path: {}\"\n            ).format(paths, texture_search_path))\n\n        if \":\".join(paths) not in procedural_search_path:\n            errors.append((\n                \"Project roots {} are not in procedural_search_path: {}\"\n            ).format(paths, procedural_search_path))\n\n        if errors:\n            errors = \"\\n\".join(f\"- {error}\" for error in errors)\n            raise PublishValidationError(errors,\n                                         description=self.get_description())\n\n    @classmethod\n    def repair(cls, instance):\n        createOptions()\n\n        texture_path = cmds.getAttr(\"defaultArnoldRenderOptions.tspath\")\n        procedural_path = cmds.getAttr(\"defaultArnoldRenderOptions.pspath\")\n\n        # Use project root variables for multiplatform support, see:\n        # https://docs.arnoldrenderer.com/display/A5AFMUG/Search+Path\n        # ':' as path separator is supported by Arnold for all platforms.\n        anatomy = instance.context.data[\"anatomy\"]\n        keys = anatomy.root_environments().keys()\n        paths = []\n        for k in keys:\n            paths.append(\"[{}]\".format(k))\n\n        cmds.setAttr(\n            \"defaultArnoldRenderOptions.tspath\",\n            \":\".join([p for p in paths + [texture_path] if p]),\n            type=\"string\"\n        )\n        cmds.setAttr(\n            \"defaultArnoldRenderOptions.absolute_texture_paths\",\n            False\n        )\n\n        cmds.setAttr(\n            \"defaultArnoldRenderOptions.pspath\",\n            \":\".join([p for p in paths + [procedural_path] if p]),\n            type=\"string\"\n        )\n        cmds.setAttr(\n            \"defaultArnoldRenderOptions.absolute_procedural_paths\",\n            False\n        )\n\n    @staticmethod\n    def find_absolute_path(relative_path, all_root_paths):\n        for root_path in all_root_paths:\n            possible_path = os.path.join(root_path, relative_path)\n            if os.path.exists(possible_path):\n                return possible_path\n\n    def maya_is_true(self, attr_val):\n        \"\"\"\n        Whether a Maya attr evaluates to True.\n        When querying an attribute value from an ambiguous object the\n        Maya API will return a list of values, which need to be properly\n        handled to evaluate properly.\n        \"\"\"\n        if isinstance(attr_val, bool):\n            return attr_val\n        elif isinstance(attr_val, (list, types.GeneratorType)):\n            return any(attr_val)\n        else:\n            return bool(attr_val)\n\n    def get_description(self):\n        return inspect.cleandoc(\"\"\"\n            ### ASS must have relative texture paths\n\n            The Arnold Render Settings must be set to:\n\n            - Texture paths must be relative\n            - Procedural paths must be relative\n            - Texture search path must include the project roots\n            - Procedural search path must include the project roots\n\n            By enforcing this, the textures can be remapped correctly depending\n            on where the project might be located on another OS or machine like\n            a renderfarm.\n\n            The settings are in the `Render Settings &gt; System &gt; Search Paths`\n            section.\n\n            ### Repair\n\n            Using **Repair** will set the required render settings for you.\n        \"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_ass_relative_paths.html#client.ayon_maya.plugins.publish.validate_ass_relative_paths.ValidateAssRelativePaths.maya_is_true","title":"<code>maya_is_true(attr_val)</code>","text":"<p>Whether a Maya attr evaluates to True. When querying an attribute value from an ambiguous object the Maya API will return a list of values, which need to be properly handled to evaluate properly.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_ass_relative_paths.py</code> <pre><code>def maya_is_true(self, attr_val):\n    \"\"\"\n    Whether a Maya attr evaluates to True.\n    When querying an attribute value from an ambiguous object the\n    Maya API will return a list of values, which need to be properly\n    handled to evaluate properly.\n    \"\"\"\n    if isinstance(attr_val, bool):\n        return attr_val\n    elif isinstance(attr_val, (list, types.GeneratorType)):\n        return any(attr_val)\n    else:\n        return bool(attr_val)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_assembly_name.html","title":"validate_assembly_name","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_assembly_name.html#client.ayon_maya.plugins.publish.validate_assembly_name.ValidateAssemblyName","title":"<code>ValidateAssemblyName</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure Assembly name ends with <code>GRP</code></p> <p>Check if assembly name ends with <code>_GRP</code> string.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_assembly_name.py</code> <pre><code>class ValidateAssemblyName(plugin.MayaInstancePlugin,\n                           OptionalPyblishPluginMixin):\n    \"\"\" Ensure Assembly name ends with `GRP`\n\n    Check if assembly name ends with `_GRP` string.\n    \"\"\"\n\n    label = \"Validate Assembly Name\"\n    order = pyblish.api.ValidatorOrder\n    families = [\"assembly\"]\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    active = False\n    optional = True\n\n    @classmethod\n    def get_invalid(cls, instance):\n        cls.log.debug(\"Checking name of {}\".format(instance.name))\n\n        content_instance = instance.data.get(\"setMembers\", None)\n        if not content_instance:\n            cls.log.error(\"Instance has no nodes!\")\n            return True\n\n        # All children will be included in the extracted export so we also\n        # validate *all* descendents of the set members and we skip any\n        # intermediate shapes\n        descendants = cmds.listRelatives(content_instance,\n                                         allDescendents=True,\n                                         fullPath=True) or []\n        descendants = cmds.ls(\n            descendants, noIntermediate=True, type=\"transform\")\n        content_instance = list(set(content_instance + descendants))\n        assemblies = cmds.ls(content_instance, assemblies=True, long=True)\n\n        invalid = []\n        for cr in assemblies:\n            if not cr.endswith('_GRP'):\n                cls.log.error(\"{} doesn't end with _GRP\".format(cr))\n                invalid.append(cr)\n\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\"Found {} invalid named assembly \"\n                               \"items\".format(len(invalid)))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_assembly_namespaces.html","title":"validate_assembly_namespaces","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_assembly_namespaces.html#client.ayon_maya.plugins.publish.validate_assembly_namespaces.ValidateAssemblyNamespaces","title":"<code>ValidateAssemblyNamespaces</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure namespaces are not nested.</p> In the outliner an item in a normal namespace looks as following <p>props_desk_01_:modelDefault</p> <p>Any namespace which diverts from that is illegal, example of an illegal namespace:     room_study_01_:props_desk_01_:modelDefault</p> Source code in <code>client/ayon_maya/plugins/publish/validate_assembly_namespaces.py</code> <pre><code>class ValidateAssemblyNamespaces(plugin.MayaInstancePlugin,\n                                 OptionalPyblishPluginMixin):\n    \"\"\"Ensure namespaces are not nested.\n\n    In the outliner an item in a normal namespace looks as following:\n        props_desk_01_:modelDefault\n\n    Any namespace which diverts from that is illegal, example of an illegal\n    namespace:\n        room_study_01_:props_desk_01_:modelDefault\n\n    \"\"\"\n\n    label = \"Validate Assembly Namespaces\"\n    order = pyblish.api.ValidatorOrder\n    families = [\"assembly\"]\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        self.log.debug(\"Checking namespace for %s\" % instance.name)\n        if self.get_invalid(instance):\n            raise PublishValidationError(\"Nested namespaces found\")\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        from maya import cmds\n\n        invalid = []\n        for item in cmds.ls(instance):\n            item_parts = item.split(\"|\", 1)[0].rsplit(\":\")\n            if len(item_parts[:-1]) &gt; 1:\n                invalid.append(item)\n\n        return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_assembly_transforms.html","title":"validate_assembly_transforms","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_assembly_transforms.html#client.ayon_maya.plugins.publish.validate_assembly_transforms.ValidateAssemblyModelTransforms","title":"<code>ValidateAssemblyModelTransforms</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Verify only root nodes of the loaded asset have transformations.</p> <p>Note: This check is temporary and is subject to change.</p> <p>Example outliner: &lt;&gt; means referenced ===================================================================</p> <p>setdress_GRP|     props_GRP|         barrel_01_:modelDefault|        [can have transforms]             &lt;&gt; barrel_01_:barrel_GRP    [CAN'T have transforms]</p> <pre><code>    fence_01_:modelDefault|         [can have transforms]\n        &lt;&gt; fence_01_:fence_GRP      [CAN'T have transforms]\n</code></pre> Source code in <code>client/ayon_maya/plugins/publish/validate_assembly_transforms.py</code> <pre><code>class ValidateAssemblyModelTransforms(plugin.MayaInstancePlugin,\n                                      OptionalPyblishPluginMixin):\n    \"\"\"Verify only root nodes of the loaded asset have transformations.\n\n    Note: This check is temporary and is subject to change.\n\n    Example outliner:\n    &lt;&gt; means referenced\n    ===================================================================\n\n    setdress_GRP|\n        props_GRP|\n            barrel_01_:modelDefault|        [can have transforms]\n                &lt;&gt; barrel_01_:barrel_GRP    [CAN'T have transforms]\n\n            fence_01_:modelDefault|         [can have transforms]\n                &lt;&gt; fence_01_:fence_GRP      [CAN'T have transforms]\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder + 0.49\n    label = \"Assembly Model Transforms\"\n    families = [\"assembly\"]\n    actions = [ayon_maya.api.action.SelectInvalidAction,\n               RepairAction]\n\n    prompt_message = (\"You are about to reset the matrix to the default values.\"\n                      \" This can alter the look of your scene. \"\n                      \"Are you sure you want to continue?\")\n\n    optional = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                (\"Found {} invalid transforms of assembly \"\n                 \"items\").format(len(invalid)))\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        from ayon_maya.api import lib\n\n        # Get all transforms in the loaded containers\n        container_roots = cmds.listRelatives(instance.data[\"nodesHierarchy\"],\n                                             children=True,\n                                             type=\"transform\",\n                                             fullPath=True)\n\n        transforms_in_container = cmds.listRelatives(container_roots,\n                                                     allDescendents=True,\n                                                     type=\"transform\",\n                                                     fullPath=True)\n\n        # Extra check due to the container roots still being passed through\n        transforms_in_container = [i for i in transforms_in_container if i\n                                   not in container_roots]\n\n        # Ensure all are identity matrix\n        invalid = []\n        for transform in transforms_in_container:\n            node_matrix = cmds.xform(transform,\n                                     query=True,\n                                     matrix=True,\n                                     objectSpace=True)\n            if not lib.matrix_equals(node_matrix, lib.DEFAULT_MATRIX):\n                invalid.append(transform)\n\n        return invalid\n\n    @classmethod\n    def repair(cls, instance):\n        \"\"\"Reset matrix for illegally transformed nodes\n\n        We want to ensure the user knows the reset will alter the look of\n        the current scene because the transformations were done on asset\n        nodes instead of the asset top node.\n\n        Args:\n            instance:\n\n        Returns:\n            None\n\n        \"\"\"\n\n        from ayon_maya.api import lib\n        from qtpy import QtWidgets\n\n        # Store namespace in variable, cosmetics thingy\n        choice = QtWidgets.QMessageBox.warning(\n            None,\n            \"Matrix reset\",\n            cls.prompt_message,\n            QtWidgets.QMessageBox.Ok | QtWidgets.QMessageBox.Cancel\n        )\n\n        invalid = cls.get_invalid(instance)\n        if not invalid:\n            cls.log.info(\"No invalid nodes\")\n            return\n\n        if choice:\n            cmds.xform(invalid, matrix=lib.DEFAULT_MATRIX, objectSpace=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_assembly_transforms.html#client.ayon_maya.plugins.publish.validate_assembly_transforms.ValidateAssemblyModelTransforms.repair","title":"<code>repair(instance)</code>  <code>classmethod</code>","text":"<p>Reset matrix for illegally transformed nodes</p> <p>We want to ensure the user knows the reset will alter the look of the current scene because the transformations were done on asset nodes instead of the asset top node.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_maya/plugins/publish/validate_assembly_transforms.py</code> <pre><code>@classmethod\ndef repair(cls, instance):\n    \"\"\"Reset matrix for illegally transformed nodes\n\n    We want to ensure the user knows the reset will alter the look of\n    the current scene because the transformations were done on asset\n    nodes instead of the asset top node.\n\n    Args:\n        instance:\n\n    Returns:\n        None\n\n    \"\"\"\n\n    from ayon_maya.api import lib\n    from qtpy import QtWidgets\n\n    # Store namespace in variable, cosmetics thingy\n    choice = QtWidgets.QMessageBox.warning(\n        None,\n        \"Matrix reset\",\n        cls.prompt_message,\n        QtWidgets.QMessageBox.Ok | QtWidgets.QMessageBox.Cancel\n    )\n\n    invalid = cls.get_invalid(instance)\n    if not invalid:\n        cls.log.info(\"No invalid nodes\")\n        return\n\n    if choice:\n        cmds.xform(invalid, matrix=lib.DEFAULT_MATRIX, objectSpace=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_attributes.html","title":"validate_attributes","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_attributes.html#client.ayon_maya.plugins.publish.validate_attributes.ValidateAttributes","title":"<code>ValidateAttributes</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure attributes are consistent.</p> <p>Attributes to validate and their values comes from the \"maya/attributes.json\" preset, which needs this structure:     {       \"family\": {         \"node_name.attribute_name\": attribute_value       }     }</p> Source code in <code>client/ayon_maya/plugins/publish/validate_attributes.py</code> <pre><code>class ValidateAttributes(plugin.MayaInstancePlugin,\n                         OptionalPyblishPluginMixin):\n    \"\"\"Ensure attributes are consistent.\n\n    Attributes to validate and their values comes from the\n    \"maya/attributes.json\" preset, which needs this structure:\n        {\n          \"family\": {\n            \"node_name.attribute_name\": attribute_value\n          }\n        }\n    \"\"\"\n\n    order = ValidateContentsOrder\n    label = \"Validate Attributes\"\n    actions = [RepairAction]\n    optional = True\n\n    attributes = \"{}\"\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Check for preset existence.\n        if not self.get_attributes_data():\n            return\n\n        invalid = self.get_invalid(instance, compute=True)\n        if invalid:\n            raise PublishValidationError(\n                \"Found attributes with invalid values: {}\".format(invalid)\n            )\n\n    @classmethod\n    def get_attributes_data(cls):\n        return json.loads(cls.attributes)\n\n    @classmethod\n    def get_invalid(cls, instance, compute=False):\n        if compute:\n            return cls.get_invalid_attributes(instance)\n        else:\n            return instance.data.get(\"invalid_attributes\", [])\n\n    @classmethod\n    def get_invalid_attributes(cls, instance):\n        invalid_attributes = []\n\n        attributes_data = cls.get_attributes_data()\n        # Filter families.\n        families = [instance.data[\"productType\"]]\n        families += instance.data.get(\"families\", [])\n        families = set(families) &amp; set(attributes_data.keys())\n        if not families:\n            return []\n\n        # Get all attributes to validate.\n        attributes = defaultdict(dict)\n        for family in families:\n            if family not in attributes_data:\n                # No attributes to validate for family\n                continue\n\n            for preset_attr, preset_value in attributes_data[family].items():\n                node_name, attribute_name = preset_attr.split(\".\", 1)\n                attributes[node_name][attribute_name] = preset_value\n\n        if not attributes:\n            return []\n\n        # Get invalid attributes.\n        nodes = cmds.ls(long=True)\n        for node in nodes:\n            node_name = node.rsplit(\"|\", 1)[-1].rsplit(\":\", 1)[-1]\n            if node_name not in attributes:\n                continue\n\n            for attr_name, expected in attributes[node_name].items():\n\n                # Skip if attribute does not exist\n                if not cmds.attributeQuery(attr_name, node=node, exists=True):\n                    continue\n\n                plug = \"{}.{}\".format(node, attr_name)\n                value = cmds.getAttr(plug)\n                if value != expected:\n                    invalid_attributes.append(\n                        {\n                            \"attribute\": plug,\n                            \"expected\": expected,\n                            \"current\": value\n                        }\n                    )\n\n        instance.data[\"invalid_attributes\"] = invalid_attributes\n        return invalid_attributes\n\n    @classmethod\n    def repair(cls, instance):\n        invalid = cls.get_invalid(instance)\n        for data in invalid:\n            node, attr = data[\"attribute\"].split(\".\", 1)\n            value = data[\"expected\"]\n            set_attribute(node=node, attribute=attr, value=value)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_camera_attributes.html","title":"validate_camera_attributes","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_camera_attributes.html#client.ayon_maya.plugins.publish.validate_camera_attributes.ValidateCameraAttributes","title":"<code>ValidateCameraAttributes</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates Camera has no invalid attribute keys or values.</p> <p>The Alembic file format does not a specific subset of attributes as such we validate that no values are set there as the output will not match the current scene. For example the preScale, film offsets and film roll.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_camera_attributes.py</code> <pre><code>class ValidateCameraAttributes(plugin.MayaInstancePlugin,\n                               OptionalPyblishPluginMixin):\n    \"\"\"Validates Camera has no invalid attribute keys or values.\n\n    The Alembic file format does not a specific subset of attributes as such\n    we validate that no values are set there as the output will not match the\n    current scene. For example the preScale, film offsets and film roll.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = ['camera']\n    hosts = ['maya']\n    label = 'Camera Attributes'\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = True\n\n    DEFAULTS = [\n        (\"filmFitOffset\", 0.0),\n        (\"horizontalFilmOffset\", 0.0),\n        (\"verticalFilmOffset\", 0.0),\n        (\"preScale\", 1.0),\n        (\"filmTranslateH\", 0.0),\n        (\"filmTranslateV\", 0.0),\n        (\"filmRollValue\", 0.0)\n    ]\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        # get cameras\n        members = instance.data['setMembers']\n        shapes = cmds.ls(members, dag=True, shapes=True, long=True)\n        cameras = cmds.ls(shapes, type='camera', long=True)\n\n        invalid = set()\n        for cam in cameras:\n\n            for attr, default_value in cls.DEFAULTS:\n                plug = \"{}.{}\".format(cam, attr)\n                value = cmds.getAttr(plug)\n\n                # Check if is default value\n                if value != default_value:\n                    cls.log.warning(\"Invalid attribute value: {0} \"\n                                    \"(should be: {1}))\".format(plug,\n                                                               default_value))\n                    invalid.add(cam)\n\n                if cmds.listConnections(plug, source=True, destination=False):\n                    # TODO: Validate correctly whether value always correct\n                    cls.log.warning(\"%s has incoming connections, validation \"\n                                    \"is unpredictable.\" % plug)\n\n        return list(invalid)\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance\"\"\"\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n\n        if invalid:\n            raise PublishValidationError(\n                \"Invalid camera attributes: {}\".format(invalid))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_camera_attributes.html#client.ayon_maya.plugins.publish.validate_camera_attributes.ValidateCameraAttributes.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance</p> Source code in <code>client/ayon_maya/plugins/publish/validate_camera_attributes.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance\"\"\"\n    if not self.is_active(instance.data):\n        return\n    invalid = self.get_invalid(instance)\n\n    if invalid:\n        raise PublishValidationError(\n            \"Invalid camera attributes: {}\".format(invalid))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_camera_contents.html","title":"validate_camera_contents","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_camera_contents.html#client.ayon_maya.plugins.publish.validate_camera_contents.ValidateCameraContents","title":"<code>ValidateCameraContents</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates Camera instance contents.</p> <p>A Camera instance may only hold a SINGLE camera's transform, nothing else.</p> <p>It may hold a \"locator\" as shape, but different shapes are down the hierarchy.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_camera_contents.py</code> <pre><code>class ValidateCameraContents(plugin.MayaInstancePlugin,\n                             OptionalPyblishPluginMixin):\n    \"\"\"Validates Camera instance contents.\n\n    A Camera instance may only hold a SINGLE camera's transform, nothing else.\n\n    It may hold a \"locator\" as shape, but different shapes are down the\n    hierarchy.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = ['camera']\n    label = 'Camera Contents'\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    validate_shapes = True\n    optional = False\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        # get cameras\n        members = instance.data['setMembers']\n        shapes = cmds.ls(members, dag=True, shapes=True, long=True)\n\n        # single camera\n        invalid = []\n        cameras = cmds.ls(shapes, type='camera', long=True)\n        if len(cameras) != 1:\n            cls.log.error(\"Camera instance must have a single camera. \"\n                          \"Found {0}: {1}\".format(len(cameras), cameras))\n            invalid.extend(cameras)\n\n            # We need to check this edge case because returning an extended\n            # list when there are no actual cameras results in\n            # still an empty 'invalid' list\n            if len(cameras) &lt; 1:\n                if members:\n                    # If there are members in the instance return all of\n                    # them as 'invalid' so the user can still select invalid\n                    cls.log.error(\"No cameras found in instance \"\n                                  \"members: {}\".format(members))\n                    return members\n\n                raise PublishValidationError(\n                    \"No cameras found in empty instance.\")\n\n        if not cls.validate_shapes:\n            cls.log.debug(\"Not validating shapes in the camera content\"\n                          \" because 'validate shapes' is disabled\")\n            return invalid\n\n        # non-camera shapes\n        valid_shapes = cmds.ls(shapes, type=('camera', 'locator'), long=True)\n        shapes = set(shapes) - set(valid_shapes)\n        if shapes:\n            shapes = list(shapes)\n            cls.log.error(\"Camera instance should only contain camera \"\n                          \"shapes. Found: {0}\".format(shapes))\n            invalid.extend(shapes)\n\n        invalid = list(set(invalid))\n        return invalid\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance\"\"\"\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\"Invalid camera contents: \"\n                               \"{0}\".format(invalid))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_camera_contents.html#client.ayon_maya.plugins.publish.validate_camera_contents.ValidateCameraContents.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance</p> Source code in <code>client/ayon_maya/plugins/publish/validate_camera_contents.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance\"\"\"\n    if not self.is_active(instance.data):\n        return\n    invalid = self.get_invalid(instance)\n    if invalid:\n        raise PublishValidationError(\"Invalid camera contents: \"\n                           \"{0}\".format(invalid))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_clashing_sibling_names.html","title":"validate_clashing_sibling_names","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_clashing_sibling_names.html#client.ayon_maya.plugins.publish.validate_clashing_sibling_names.ValidateClashingSiblingNames","title":"<code>ValidateClashingSiblingNames</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate siblings have unique names when namespaces are stripped.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_clashing_sibling_names.py</code> <pre><code>class ValidateClashingSiblingNames(plugin.MayaInstancePlugin,\n                                   OptionalPyblishPluginMixin):\n    \"\"\"Validate siblings have unique names when namespaces are stripped.\"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"pointcache\", \"animation\", \"usd\"]\n    label = \"Validate clashing sibling names\"\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n\n    @staticmethod\n    def get_invalid(instance):\n        \"\"\"Return all nodes that have non-unique names with siblings when\n        namespaces are stripped.\n\n        Returns:\n            list[str]: Non-unique siblings\n        \"\"\"\n        stripped_name_to_full_path = defaultdict(set)\n        for node in instance:\n            stripped_name = remove_namespace(node)\n            stripped_name_to_full_path[stripped_name].add(node)\n\n        invalid: \"list[str]\" = []\n        for _stripped_name, nodes in stripped_name_to_full_path.items():\n            if len(nodes) &gt; 1:\n                invalid.extend(nodes)\n\n        if invalid:\n            # We only care about the highest conflicts since child conflicts\n            # only occur due to the conflicts higher up anyway\n            invalid = lib.get_highest_in_hierarchy(invalid)\n\n        return invalid\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance \"objectSet\"\"\"\n        if not self.is_active(instance.data):\n            return\n\n        if \"publish_attributes\" not in instance.data:\n            # This is an instance generated at runtime, for example a USD\n            # contribution workflow instance. We will ignore this validation\n            self.log.debug(\"Skipping validation of clashing siblings for\"\n                           f\" '{instance}', because it is a runtime instance\"\n                           \" (has no publish attributes)\")\n            return\n\n        if not self.is_strip_namespaces_enabled(instance):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n\n            report_list = \"\\n\".join(f\"- {node}\" for node in sorted(invalid))\n\n            raise PublishValidationError(\n                \"With stripped namespaces there are conflicting sibling names \"\n                \"that are not unique:\\n\"\n                f\"{report_list}\",\n                description=self.get_description())\n\n    def is_strip_namespaces_enabled(self, instance) -&gt; bool:\n        \"\"\"Return whether any extractor is enabled for instance that has\n        `stripNamespaces` enabled.\"\"\"\n        # TODO: Preferably there would be a better way to detect whether the\n        #   flag was enabled or not.\n\n        plugins = instance.context.data[\"create_context\"].publish_plugins\n        plugins_by_name = {plugin.__name__: plugin for plugin in plugins}\n\n        def _is_plugin_active(plugin_name: str) -&gt; bool:\n            \"\"\"Return whether plugin is active for instance\"\"\"\n            # Check if Plug-in is found\n            plugin = plugins_by_name.get(plugin_name)\n            if not plugin:\n                self.log.debug(f\"Plugin {plugin_name} not found. \"\n                               \"It may be disabled in settings\")\n                return False\n\n            # Check if plug-in is globally enabled\n            if not getattr(plugin, \"enabled\", True):\n                self.log.debug(f\"Plugin {plugin_name} is disabled. \"\n                               \"It is disabled in settings\")\n                return False\n\n            # Check if optional state has active state set to False\n            publish_attributes = instance.data[\"publish_attributes\"]\n            default_active = getattr(plugin, \"active\", True)\n            active_for_instance = publish_attributes.get(\n                plugin_name, {}).get(\"active\", default_active)\n            if not active_for_instance:\n                self.log.debug(\n                  f\"Plugin {plugin_name} is disabled for this instance.\")\n                return False\n\n            # Check if the instance, according to pyblish is a match for the\n            # plug-in. This may e.g. be excluded due to different families\n            # or matching algorithm (e.g. ExtractMultiverseUsdAnim uses\n            # `pyblish.api.Subset`\n            if not pyblish.api.instances_by_plugin([instance], plugin):\n                self.log.debug(\n                    f\"Plugin {plugin_name} does not match for this instance.\")\n                return False\n\n            return True\n\n        for plugin_name in [\n            \"ExtractAlembic\",               # pointcache\n            \"ExtractAnimation\",             # animation\n            \"ExtractMayaUsd\",               # usd\n            \"ExtractMayaUsdPointcache\",     # pointcache\n            \"ExtractMayaUsdAnim\",           # animation\n        ]:\n            if _is_plugin_active(plugin_name):\n                plugin = plugins_by_name[plugin_name]\n\n                # Use the value from the instance publish attributes\n                publish_attributes = instance.data[\"publish_attributes\"]\n                strip_namespaces = publish_attributes.get(\n                    plugin_name, {}).get(\"stripNamespaces\")\n                if strip_namespaces:\n                    return True\n\n                # Find some default on the plugin class, if any\n                default = getattr(plugin, \"stripNamespaces\", False)\n                if default:\n                    self.log.debug(\n                        f\"{plugin_name} has strip namespaces enabled as \"\n                        \"default value.\")\n                    return True\n        return False\n\n    def get_description(self):\n        return inspect.cleandoc(\"\"\"\n            ### Clashing sibling names with stripped namespaces\n\n            The export has **strip namespaces** enabled but a conflict on \n            sibling names are found where, without namespaces, they do not have\n            unique names and can not be exported.\n\n            To resolve this, either export with 'strip namespaces' disabled or\n            reorder the hierarchy so that nodes sharing the parent do not have\n            the same name.\n        \"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_clashing_sibling_names.html#client.ayon_maya.plugins.publish.validate_clashing_sibling_names.ValidateClashingSiblingNames.get_invalid","title":"<code>get_invalid(instance)</code>  <code>staticmethod</code>","text":"<p>Return all nodes that have non-unique names with siblings when namespaces are stripped.</p> <p>Returns:</p> Type Description <p>list[str]: Non-unique siblings</p> Source code in <code>client/ayon_maya/plugins/publish/validate_clashing_sibling_names.py</code> <pre><code>@staticmethod\ndef get_invalid(instance):\n    \"\"\"Return all nodes that have non-unique names with siblings when\n    namespaces are stripped.\n\n    Returns:\n        list[str]: Non-unique siblings\n    \"\"\"\n    stripped_name_to_full_path = defaultdict(set)\n    for node in instance:\n        stripped_name = remove_namespace(node)\n        stripped_name_to_full_path[stripped_name].add(node)\n\n    invalid: \"list[str]\" = []\n    for _stripped_name, nodes in stripped_name_to_full_path.items():\n        if len(nodes) &gt; 1:\n            invalid.extend(nodes)\n\n    if invalid:\n        # We only care about the highest conflicts since child conflicts\n        # only occur due to the conflicts higher up anyway\n        invalid = lib.get_highest_in_hierarchy(invalid)\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_clashing_sibling_names.html#client.ayon_maya.plugins.publish.validate_clashing_sibling_names.ValidateClashingSiblingNames.is_strip_namespaces_enabled","title":"<code>is_strip_namespaces_enabled(instance)</code>","text":"<p>Return whether any extractor is enabled for instance that has <code>stripNamespaces</code> enabled.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_clashing_sibling_names.py</code> <pre><code>def is_strip_namespaces_enabled(self, instance) -&gt; bool:\n    \"\"\"Return whether any extractor is enabled for instance that has\n    `stripNamespaces` enabled.\"\"\"\n    # TODO: Preferably there would be a better way to detect whether the\n    #   flag was enabled or not.\n\n    plugins = instance.context.data[\"create_context\"].publish_plugins\n    plugins_by_name = {plugin.__name__: plugin for plugin in plugins}\n\n    def _is_plugin_active(plugin_name: str) -&gt; bool:\n        \"\"\"Return whether plugin is active for instance\"\"\"\n        # Check if Plug-in is found\n        plugin = plugins_by_name.get(plugin_name)\n        if not plugin:\n            self.log.debug(f\"Plugin {plugin_name} not found. \"\n                           \"It may be disabled in settings\")\n            return False\n\n        # Check if plug-in is globally enabled\n        if not getattr(plugin, \"enabled\", True):\n            self.log.debug(f\"Plugin {plugin_name} is disabled. \"\n                           \"It is disabled in settings\")\n            return False\n\n        # Check if optional state has active state set to False\n        publish_attributes = instance.data[\"publish_attributes\"]\n        default_active = getattr(plugin, \"active\", True)\n        active_for_instance = publish_attributes.get(\n            plugin_name, {}).get(\"active\", default_active)\n        if not active_for_instance:\n            self.log.debug(\n              f\"Plugin {plugin_name} is disabled for this instance.\")\n            return False\n\n        # Check if the instance, according to pyblish is a match for the\n        # plug-in. This may e.g. be excluded due to different families\n        # or matching algorithm (e.g. ExtractMultiverseUsdAnim uses\n        # `pyblish.api.Subset`\n        if not pyblish.api.instances_by_plugin([instance], plugin):\n            self.log.debug(\n                f\"Plugin {plugin_name} does not match for this instance.\")\n            return False\n\n        return True\n\n    for plugin_name in [\n        \"ExtractAlembic\",               # pointcache\n        \"ExtractAnimation\",             # animation\n        \"ExtractMayaUsd\",               # usd\n        \"ExtractMayaUsdPointcache\",     # pointcache\n        \"ExtractMayaUsdAnim\",           # animation\n    ]:\n        if _is_plugin_active(plugin_name):\n            plugin = plugins_by_name[plugin_name]\n\n            # Use the value from the instance publish attributes\n            publish_attributes = instance.data[\"publish_attributes\"]\n            strip_namespaces = publish_attributes.get(\n                plugin_name, {}).get(\"stripNamespaces\")\n            if strip_namespaces:\n                return True\n\n            # Find some default on the plugin class, if any\n            default = getattr(plugin, \"stripNamespaces\", False)\n            if default:\n                self.log.debug(\n                    f\"{plugin_name} has strip namespaces enabled as \"\n                    \"default value.\")\n                return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_clashing_sibling_names.html#client.ayon_maya.plugins.publish.validate_clashing_sibling_names.ValidateClashingSiblingNames.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance \"objectSet</p> Source code in <code>client/ayon_maya/plugins/publish/validate_clashing_sibling_names.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance \"objectSet\"\"\"\n    if not self.is_active(instance.data):\n        return\n\n    if \"publish_attributes\" not in instance.data:\n        # This is an instance generated at runtime, for example a USD\n        # contribution workflow instance. We will ignore this validation\n        self.log.debug(\"Skipping validation of clashing siblings for\"\n                       f\" '{instance}', because it is a runtime instance\"\n                       \" (has no publish attributes)\")\n        return\n\n    if not self.is_strip_namespaces_enabled(instance):\n        return\n\n    invalid = self.get_invalid(instance)\n    if invalid:\n\n        report_list = \"\\n\".join(f\"- {node}\" for node in sorted(invalid))\n\n        raise PublishValidationError(\n            \"With stripped namespaces there are conflicting sibling names \"\n            \"that are not unique:\\n\"\n            f\"{report_list}\",\n            description=self.get_description())\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_clashing_sibling_names.html#client.ayon_maya.plugins.publish.validate_clashing_sibling_names.remove_namespace","title":"<code>remove_namespace(path)</code>","text":"<p>Remove namespace from full path.</p> Example <p>remove_namespace(\"|aa:bb:foo|aa:bb:bar|cc:hello|dd:world\") '|foo|bar|hello|world'</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Full node path.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Node path with namespaces removed.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_clashing_sibling_names.py</code> <pre><code>def remove_namespace(path: str) -&gt; str:\n    \"\"\"Remove namespace from full path.\n\n    Example:\n        &gt;&gt;&gt; remove_namespace(\"|aa:bb:foo|aa:bb:bar|cc:hello|dd:world\")\n        '|foo|bar|hello|world'\n\n    Arguments:\n        path (str): Full node path.\n\n    Returns:\n        str: Node path with namespaces removed.\n    \"\"\"\n    return \"|\".join(\n        name.rsplit(\":\", 1)[-1] for name in path.split(\"|\")\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_color_sets.html","title":"validate_color_sets","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_color_sets.html#client.ayon_maya.plugins.publish.validate_color_sets.ValidateColorSets","title":"<code>ValidateColorSets</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate all meshes in the instance have unlocked normals</p> These can be removed manually through <p>Modeling &gt; Mesh Display &gt; Color Sets Editor</p> Source code in <code>client/ayon_maya/plugins/publish/validate_color_sets.py</code> <pre><code>class ValidateColorSets(plugin.MayaInstancePlugin,\n                        OptionalPyblishPluginMixin):\n    \"\"\"Validate all meshes in the instance have unlocked normals\n\n    These can be removed manually through:\n        Modeling &gt; Mesh Display &gt; Color Sets Editor\n\n    \"\"\"\n\n    order = ValidateMeshOrder\n    families = ['model']\n    label = 'Mesh ColorSets'\n    actions = [\n        ayon_maya.api.action.SelectInvalidAction, RepairAction\n    ]\n    optional = True\n\n    @staticmethod\n    def has_color_sets(mesh):\n        \"\"\"Return whether a mesh node has locked normals\"\"\"\n        return cmds.polyColorSet(mesh,\n                                 allColorSets=True,\n                                 query=True)\n\n    @classmethod\n    def get_invalid(cls, instance):\n        \"\"\"Return the meshes with ColorSets in instance\"\"\"\n\n        meshes = cmds.ls(instance, type='mesh', long=True)\n        return [mesh for mesh in meshes if cls.has_color_sets(mesh)]\n\n    def process(self, instance):\n        \"\"\"Raise invalid when any of the meshes have ColorSets\"\"\"\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n\n        if invalid:\n            raise PublishValidationError(\n                message=\"Meshes found with Color Sets: {0}\".format(invalid)\n            )\n\n    @classmethod\n    def repair(cls, instance):\n        \"\"\"Remove all Color Sets on the meshes in this instance.\"\"\"\n        invalid = cls.get_invalid(instance)\n        for mesh in invalid:\n            for set in cmds.polyColorSet(mesh, acs=True, q=True):\n                cmds.polyColorSet(mesh, colorSet=set, delete=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_color_sets.html#client.ayon_maya.plugins.publish.validate_color_sets.ValidateColorSets.get_invalid","title":"<code>get_invalid(instance)</code>  <code>classmethod</code>","text":"<p>Return the meshes with ColorSets in instance</p> Source code in <code>client/ayon_maya/plugins/publish/validate_color_sets.py</code> <pre><code>@classmethod\ndef get_invalid(cls, instance):\n    \"\"\"Return the meshes with ColorSets in instance\"\"\"\n\n    meshes = cmds.ls(instance, type='mesh', long=True)\n    return [mesh for mesh in meshes if cls.has_color_sets(mesh)]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_color_sets.html#client.ayon_maya.plugins.publish.validate_color_sets.ValidateColorSets.has_color_sets","title":"<code>has_color_sets(mesh)</code>  <code>staticmethod</code>","text":"<p>Return whether a mesh node has locked normals</p> Source code in <code>client/ayon_maya/plugins/publish/validate_color_sets.py</code> <pre><code>@staticmethod\ndef has_color_sets(mesh):\n    \"\"\"Return whether a mesh node has locked normals\"\"\"\n    return cmds.polyColorSet(mesh,\n                             allColorSets=True,\n                             query=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_color_sets.html#client.ayon_maya.plugins.publish.validate_color_sets.ValidateColorSets.process","title":"<code>process(instance)</code>","text":"<p>Raise invalid when any of the meshes have ColorSets</p> Source code in <code>client/ayon_maya/plugins/publish/validate_color_sets.py</code> <pre><code>def process(self, instance):\n    \"\"\"Raise invalid when any of the meshes have ColorSets\"\"\"\n    if not self.is_active(instance.data):\n        return\n\n    invalid = self.get_invalid(instance)\n\n    if invalid:\n        raise PublishValidationError(\n            message=\"Meshes found with Color Sets: {0}\".format(invalid)\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_color_sets.html#client.ayon_maya.plugins.publish.validate_color_sets.ValidateColorSets.repair","title":"<code>repair(instance)</code>  <code>classmethod</code>","text":"<p>Remove all Color Sets on the meshes in this instance.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_color_sets.py</code> <pre><code>@classmethod\ndef repair(cls, instance):\n    \"\"\"Remove all Color Sets on the meshes in this instance.\"\"\"\n    invalid = cls.get_invalid(instance)\n    for mesh in invalid:\n        for set in cmds.polyColorSet(mesh, acs=True, q=True):\n            cmds.polyColorSet(mesh, colorSet=set, delete=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_current_renderlayer_renderable.html","title":"validate_current_renderlayer_renderable","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_current_renderlayer_renderable.html#client.ayon_maya.plugins.publish.validate_current_renderlayer_renderable.ValidateCurrentRenderLayerIsRenderable","title":"<code>ValidateCurrentRenderLayerIsRenderable</code>","text":"<p>               Bases: <code>MayaContextPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate if current render layer has a renderable camera.</p> <p>There is a bug in Redshift which occurs when the current render layer at file open has no renderable camera. The error raised is as follows:</p> <p>\"No renderable cameras found. Aborting render\"</p> <p>This error is raised even if that render layer will not be rendered.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_current_renderlayer_renderable.py</code> <pre><code>class ValidateCurrentRenderLayerIsRenderable(plugin.MayaContextPlugin,\n                                             OptionalPyblishPluginMixin):\n    \"\"\"Validate if current render layer has a renderable camera.\n\n    There is a bug in Redshift which occurs when the current render layer\n    at file open has no renderable camera. The error raised is as follows:\n\n    \"No renderable cameras found. Aborting render\"\n\n    This error is raised even if that render layer will not be rendered.\n\n    \"\"\"\n\n    label = \"Current Render Layer Has Renderable Camera\"\n    order = pyblish.api.ValidatorOrder\n    families = [\"renderlayer\"]\n    optional = False\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            return\n        # Workaround bug pyblish-base#250\n        if not context_plugin_should_run(self, context):\n            return\n\n        # This validator only makes sense when publishing renderlayer instances\n        # with Redshift. We skip validation if there isn't any.\n        if not any(self.is_active_redshift_render_instance(instance)\n                   for instance in context):\n            return\n\n        cameras = cmds.ls(type=\"camera\", long=True)\n        renderable = any(c for c in cameras if cmds.getAttr(c + \".renderable\"))\n        if not renderable:\n            layer = cmds.editRenderLayerGlobals(query=True,\n                                                currentRenderLayer=True)\n            raise PublishValidationError(\n                \"Current render layer '{}' has no renderable camera\".format(\n                    layer\n                ),\n                description=inspect.getdoc(self)\n            )\n\n    @staticmethod\n    def is_active_redshift_render_instance(instance) -&gt; bool:\n        \"\"\"Return whether instance is an active renderlayer instance set to\n        render with Redshift renderer.\"\"\"\n        if not instance.data.get(\"active\", True):\n            return False\n\n        # Check this before families just because it's a faster check\n        if not instance.data.get(\"renderer\") == \"redshift\":\n            return False\n\n        families = set()\n        families.add(instance.data.get(\"family\"))\n        families.update(instance.data.get(\"families\", []))\n        if \"renderlayer\" not in families:\n            return False\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_current_renderlayer_renderable.html#client.ayon_maya.plugins.publish.validate_current_renderlayer_renderable.ValidateCurrentRenderLayerIsRenderable.is_active_redshift_render_instance","title":"<code>is_active_redshift_render_instance(instance)</code>  <code>staticmethod</code>","text":"<p>Return whether instance is an active renderlayer instance set to render with Redshift renderer.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_current_renderlayer_renderable.py</code> <pre><code>@staticmethod\ndef is_active_redshift_render_instance(instance) -&gt; bool:\n    \"\"\"Return whether instance is an active renderlayer instance set to\n    render with Redshift renderer.\"\"\"\n    if not instance.data.get(\"active\", True):\n        return False\n\n    # Check this before families just because it's a faster check\n    if not instance.data.get(\"renderer\") == \"redshift\":\n        return False\n\n    families = set()\n    families.add(instance.data.get(\"family\"))\n    families.update(instance.data.get(\"families\", []))\n    if \"renderlayer\" not in families:\n        return False\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_cycle_error.html","title":"validate_cycle_error","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_cycle_error.html#client.ayon_maya.plugins.publish.validate_cycle_error.ValidateCycleError","title":"<code>ValidateCycleError</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate nodes produce no cycle errors.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_cycle_error.py</code> <pre><code>class ValidateCycleError(plugin.MayaInstancePlugin,\n                         OptionalPyblishPluginMixin):\n    \"\"\"Validate nodes produce no cycle errors.\"\"\"\n\n    order = ValidateContentsOrder + 0.05\n    label = \"Cycle Errors\"\n    hosts = [\"maya\"]\n    families = [\"rig\"]\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Nodes produce a cycle error: {}\".format(invalid))\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        with maintained_selection():\n            cmds.select(instance[:], noExpand=True)\n            plugs = cmds.cycleCheck(all=False,  # check selection only\n                                    list=True)\n            invalid = cmds.ls(plugs, objectsOnly=True, long=True)\n            return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_excluded_parents_visible.html","title":"validate_excluded_parents_visible","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_excluded_parents_visible.html#client.ayon_maya.plugins.publish.validate_excluded_parents_visible.ValidateExcludedParentsVisible","title":"<code>ValidateExcludedParentsVisible</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate whether all parents are visible in frame range when 'include parent hierarchy' is disabled for the instance.</p> <p>This validation helps to detect the issue where an animator may have hidden or keyed visibilities on parent nodes for an export where these parents are not included in the export. Because if so, those invisibilities would not be included in the export either, giving a different visual result than what the artist likely intended in their workfile</p> Source code in <code>client/ayon_maya/plugins/publish/validate_excluded_parents_visible.py</code> <pre><code>class ValidateExcludedParentsVisible(plugin.MayaInstancePlugin,\n                                     OptionalPyblishPluginMixin):\n    \"\"\"Validate whether all parents are visible in frame range when 'include\n    parent hierarchy' is disabled for the instance.\n\n    This validation helps to detect the issue where an animator may have hidden\n    or keyed visibilities on parent nodes for an export where these parents\n    are not included in the export. Because if so, those invisibilities would\n    not be included in the export either, giving a different visual result than\n    what the artist likely intended in their workfile\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"pointcache\", \"animation\"]\n    label = \"Excluded parents visible\"\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        # Only validate if we exclude parent hierarchy\n        if instance.data.get(\"includeParentHierarchy\", True):\n            return []\n\n        if \"out_hierarchy\" in instance.data:\n            # Animation instances\n            members = instance.data[\"out_hierarchy\"]\n        else:\n            members = instance.data[\"setMembers\"]\n\n        members = cmds.ls(members, type=\"dagNode\", long=True)  # DAG nodes only\n        if not members:\n            cls.log.debug(\"No members found in instance.\")\n            return []\n\n        roots = lib.get_highest_in_hierarchy(members)\n\n        # If there are no parents to the root we are already including the\n        # full hierarchy, so we can skip checking visibilities on parents\n        parents = cmds.listRelatives(roots, parent=True, fullPath=True)\n        if not parents:\n            return []\n\n        # Include ancestors to check for visibilities on them\n        ancestors = list(parents)\n        for parent in parents:\n            ancestors.extend(lib.iter_parents(parent))\n\n        # Check if the parent is hidden anywhere within the frame range\n        invalid = []\n        frame_start = int(instance.data[\"frameStartHandle\"])\n        frame_end = int(instance.data[\"frameEndHandle\"])\n\n        cls.log.debug(\n            \"Validating invisibilities for excluded ancestors in frame \"\n            f\"range {frame_start}-{frame_end}: {ancestors}.\")\n        for ancestor in ancestors:\n            attr = f\"{ancestor}.visibility\"\n\n            # We need to check whether the ancestor is ever invisible\n            # during the frame range if it has inputs\n            has_inputs = bool(cmds.listConnections(\n                attr, source=True, destination=False))\n            if has_inputs:\n                for frame in range(frame_start, frame_end+1):\n                    if cmds.getAttr(attr, time=frame):\n                        continue\n\n                    # We found an invisible frame\n                    cls.log.warning(\n                        \"Excluded parent is invisible on frame \"\n                        f\"{frame}: {ancestor}\")\n                    invalid.append(ancestor)\n                    break\n\n            # If no inputs, check the current visibility\n            elif not cmds.getAttr(attr):\n                cls.log.warning(f\"Excluded parent is invisible: {ancestor}\")\n                invalid.append(ancestor)\n\n        return invalid\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance 'objectSet'\"\"\"\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            invalid_list = \"\\n\".join(f\"- {node}\" for node in invalid)\n\n            raise PublishValidationError(\n                \"Invisible parents found that are excluded from the export:\\n\"\n                \"{0}\".format(invalid_list),\n                title=\"Excluded parents are invisible\",\n                description=self.get_description()\n            )\n\n    @staticmethod\n    def get_description():\n        return inspect.cleandoc(\"\"\"### Excluded parents are invisible\n\n        The instance is set to exclude the parent hierarchy, however the\n        excluded parents are invisible within the exported frame range.\n        This may be on all frames, of if animated on only certain frames.\n\n        Because the export excludes those parents the exported geometry will\n        **not** have these (animated) invisibilities and will appear visible\n        in the output regardless of how your scene looked on export.\n\n        To resolve this, either move the invisibility down into the hierarchy\n        that you are including in the export. Or, export with include parent\n        hierarchy enabled.\n        \"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_excluded_parents_visible.html#client.ayon_maya.plugins.publish.validate_excluded_parents_visible.ValidateExcludedParentsVisible.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance 'objectSet'</p> Source code in <code>client/ayon_maya/plugins/publish/validate_excluded_parents_visible.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance 'objectSet'\"\"\"\n    if not self.is_active(instance.data):\n        return\n\n    invalid = self.get_invalid(instance)\n    if invalid:\n        invalid_list = \"\\n\".join(f\"- {node}\" for node in invalid)\n\n        raise PublishValidationError(\n            \"Invisible parents found that are excluded from the export:\\n\"\n            \"{0}\".format(invalid_list),\n            title=\"Excluded parents are invisible\",\n            description=self.get_description()\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_frame_range.html","title":"validate_frame_range","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_frame_range.html#client.ayon_maya.plugins.publish.validate_frame_range.ValidateFrameRange","title":"<code>ValidateFrameRange</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates the frame ranges.</p> <p>This is an optional validator checking if the frame range on instance matches the frame range specified for the asset.</p> <p>It also validates render frame ranges of render layers.</p> <p>Repair action will change everything to match the asset frame range.</p> <p>This can be turned off by the artist to allow custom ranges.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_frame_range.py</code> <pre><code>class ValidateFrameRange(plugin.MayaInstancePlugin,\n                         OptionalPyblishPluginMixin):\n    \"\"\"Validates the frame ranges.\n\n    This is an optional validator checking if the frame range on instance\n    matches the frame range specified for the asset.\n\n    It also validates render frame ranges of render layers.\n\n    Repair action will change everything to match the asset frame range.\n\n    This can be turned off by the artist to allow custom ranges.\n    \"\"\"\n\n    label = \"Validate Frame Range\"\n    order = ValidateContentsOrder\n    families = [\"animation\",\n                \"pointcache\",\n                \"camera\",\n                \"proxyAbc\",\n                \"renderlayer\",\n                \"review\",\n                \"yeticache\",\n                \"oxcache\"]\n    optional = True\n    actions = [RepairAction]\n    exclude_product_types = []\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        context = instance.context\n        if instance.data.get(\"tileRendering\"):\n            self.log.debug(\n                \"Skipping frame range validation because \"\n                \"tile rendering is enabled.\"\n            )\n            return\n\n        frame_start_handle = int(context.data.get(\"frameStartHandle\"))\n        frame_end_handle = int(context.data.get(\"frameEndHandle\"))\n        handle_start = int(context.data.get(\"handleStart\"))\n        handle_end = int(context.data.get(\"handleEnd\"))\n        frame_start = int(context.data.get(\"frameStart\"))\n        frame_end = int(context.data.get(\"frameEnd\"))\n\n        inst_start = int(instance.data.get(\"frameStartHandle\"))\n        inst_end = int(instance.data.get(\"frameEndHandle\"))\n        inst_frame_start = int(instance.data.get(\"frameStart\"))\n        inst_frame_end = int(instance.data.get(\"frameEnd\"))\n        inst_handle_start = int(instance.data.get(\"handleStart\"))\n        inst_handle_end = int(instance.data.get(\"handleEnd\"))\n\n        # basic sanity checks\n        assert frame_start_handle &lt;= frame_end_handle, (\n            \"start frame is lower then end frame\")\n\n        # compare with data on instance\n        errors = []\n        # QUESTION shouldn't this be just:\n        #   'if instance.data[\"productType\"] in self.exclude_product_types:'\n        if [ef for ef in self.exclude_product_types\n                if instance.data[\"productType\"] in ef]:\n            return\n        if (inst_start != frame_start_handle):\n            errors.append(\"Instance start frame [ {} ] doesn't \"\n                          \"match the one set on folder [ {} ]: \"\n                          \"{}/{}/{}/{} (handle/start/end/handle)\".format(\n                              inst_start,\n                              frame_start_handle,\n                              handle_start, frame_start, frame_end, handle_end\n                          ))\n\n        if (inst_end != frame_end_handle):\n            errors.append(\"Instance end frame [ {} ] doesn't \"\n                          \"match the one set on folder [ {} ]: \"\n                          \"{}/{}/{}/{} (handle/start/end/handle)\".format(\n                              inst_end,\n                              frame_end_handle,\n                              handle_start, frame_start, frame_end, handle_end\n                          ))\n\n        checks = {\n            \"frame start\": (frame_start, inst_frame_start),\n            \"frame end\": (frame_end, inst_frame_end),\n            \"handle start\": (handle_start, inst_handle_start),\n            \"handle end\": (handle_end, inst_handle_end)\n        }\n        for label, values in checks.items():\n            if values[0] != values[1]:\n                errors.append(\n                    \"{} on instance ({}) does not match with the folder \"\n                    \"({}).\".format(label.title(), values[1], values[0])\n                )\n\n        if errors:\n            report = \"Frame range settings are incorrect.\\n\\n\"\n            for error in errors:\n                report += \"- {}\\n\\n\".format(error)\n\n            raise PublishValidationError(report, title=\"Frame Range incorrect\")\n\n    @classmethod\n    def repair(cls, instance):\n        \"\"\"\n        Repair instance container to match folder data.\n        \"\"\"\n\n        if \"renderlayer\" in instance.data.get(\"families\"):\n            # Special behavior for renderlayers\n            cls.repair_renderlayer(instance)\n            return\n\n        node = instance.data[\"name\"]\n        context = instance.context\n\n        frame_start_handle = int(context.data.get(\"frameStartHandle\"))\n        frame_end_handle = int(context.data.get(\"frameEndHandle\"))\n        handle_start = int(context.data.get(\"handleStart\"))\n        handle_end = int(context.data.get(\"handleEnd\"))\n        frame_start = int(context.data.get(\"frameStart\"))\n        frame_end = int(context.data.get(\"frameEnd\"))\n\n        # Start\n        if cmds.attributeQuery(\"handleStart\", node=node, exists=True):\n            cmds.setAttr(\"{}.handleStart\".format(node), handle_start)\n            cmds.setAttr(\"{}.frameStart\".format(node), frame_start)\n        else:\n            # Include start handle in frame start if no separate handleStart\n            # attribute exists on the node\n            cmds.setAttr(\"{}.frameStart\".format(node), frame_start_handle)\n\n        # End\n        if cmds.attributeQuery(\"handleEnd\", node=node, exists=True):\n            cmds.setAttr(\"{}.handleEnd\".format(node), handle_end)\n            cmds.setAttr(\"{}.frameEnd\".format(node), frame_end)\n        else:\n            # Include end handle in frame end if no separate handleEnd\n            # attribute exists on the node\n            cmds.setAttr(\"{}.frameEnd\".format(node), frame_end_handle)\n\n    @classmethod\n    def repair_renderlayer(cls, instance):\n        \"\"\"Apply frame range in render settings\"\"\"\n\n        layer = instance.data[\"renderlayer\"]\n        context = instance.context\n\n        start_attr = \"defaultRenderGlobals.startFrame\"\n        end_attr = \"defaultRenderGlobals.endFrame\"\n\n        frame_start_handle = int(context.data.get(\"frameStartHandle\"))\n        frame_end_handle = int(context.data.get(\"frameEndHandle\"))\n\n        cls._set_attr_in_layer(start_attr, layer, frame_start_handle)\n        cls._set_attr_in_layer(end_attr, layer, frame_end_handle)\n\n    @classmethod\n    def _set_attr_in_layer(cls, node_attr, layer, value):\n\n        if get_attr_in_layer(node_attr, layer=layer) == value:\n            # Already ok. This can happen if you have multiple renderlayers\n            # validated and there are no frame range overrides. The first\n            # layer's repair would have fixed the global value already\n            return\n\n        overrides = list(get_attr_overrides(node_attr, layer=layer))\n        if overrides:\n            # We set the last absolute override if it is an absolute override\n            # otherwise we'll add an Absolute override\n            last_override = overrides[-1][1]\n            if not isinstance(last_override, AbsOverride):\n                collection = last_override.parent()\n                node, attr = node_attr.split(\".\", 1)\n                last_override = collection.createAbsoluteOverride(node, attr)\n\n            cls.log.debug(\"Setting {attr} absolute override in \"\n                          \"layer '{layer}': {value}\".format(layer=layer,\n                                                            attr=node_attr,\n                                                            value=value))\n            cmds.setAttr(last_override.name() + \".attrValue\", value)\n\n        else:\n            # Set the attribute directly\n            # (Note that this will set the global attribute)\n            cls.log.debug(\"Setting global {attr}: {value}\".format(\n                attr=node_attr,\n                value=value\n            ))\n            cmds.setAttr(node_attr, value)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_frame_range.html#client.ayon_maya.plugins.publish.validate_frame_range.ValidateFrameRange.repair","title":"<code>repair(instance)</code>  <code>classmethod</code>","text":"<p>Repair instance container to match folder data.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_frame_range.py</code> <pre><code>@classmethod\ndef repair(cls, instance):\n    \"\"\"\n    Repair instance container to match folder data.\n    \"\"\"\n\n    if \"renderlayer\" in instance.data.get(\"families\"):\n        # Special behavior for renderlayers\n        cls.repair_renderlayer(instance)\n        return\n\n    node = instance.data[\"name\"]\n    context = instance.context\n\n    frame_start_handle = int(context.data.get(\"frameStartHandle\"))\n    frame_end_handle = int(context.data.get(\"frameEndHandle\"))\n    handle_start = int(context.data.get(\"handleStart\"))\n    handle_end = int(context.data.get(\"handleEnd\"))\n    frame_start = int(context.data.get(\"frameStart\"))\n    frame_end = int(context.data.get(\"frameEnd\"))\n\n    # Start\n    if cmds.attributeQuery(\"handleStart\", node=node, exists=True):\n        cmds.setAttr(\"{}.handleStart\".format(node), handle_start)\n        cmds.setAttr(\"{}.frameStart\".format(node), frame_start)\n    else:\n        # Include start handle in frame start if no separate handleStart\n        # attribute exists on the node\n        cmds.setAttr(\"{}.frameStart\".format(node), frame_start_handle)\n\n    # End\n    if cmds.attributeQuery(\"handleEnd\", node=node, exists=True):\n        cmds.setAttr(\"{}.handleEnd\".format(node), handle_end)\n        cmds.setAttr(\"{}.frameEnd\".format(node), frame_end)\n    else:\n        # Include end handle in frame end if no separate handleEnd\n        # attribute exists on the node\n        cmds.setAttr(\"{}.frameEnd\".format(node), frame_end_handle)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_frame_range.html#client.ayon_maya.plugins.publish.validate_frame_range.ValidateFrameRange.repair_renderlayer","title":"<code>repair_renderlayer(instance)</code>  <code>classmethod</code>","text":"<p>Apply frame range in render settings</p> Source code in <code>client/ayon_maya/plugins/publish/validate_frame_range.py</code> <pre><code>@classmethod\ndef repair_renderlayer(cls, instance):\n    \"\"\"Apply frame range in render settings\"\"\"\n\n    layer = instance.data[\"renderlayer\"]\n    context = instance.context\n\n    start_attr = \"defaultRenderGlobals.startFrame\"\n    end_attr = \"defaultRenderGlobals.endFrame\"\n\n    frame_start_handle = int(context.data.get(\"frameStartHandle\"))\n    frame_end_handle = int(context.data.get(\"frameEndHandle\"))\n\n    cls._set_attr_in_layer(start_attr, layer, frame_start_handle)\n    cls._set_attr_in_layer(end_attr, layer, frame_end_handle)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_glsl_material.html","title":"validate_glsl_material","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_glsl_material.html#client.ayon_maya.plugins.publish.validate_glsl_material.ValidateGLSLMaterial","title":"<code>ValidateGLSLMaterial</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate if the asset uses GLSL Shader</p> Source code in <code>client/ayon_maya/plugins/publish/validate_glsl_material.py</code> <pre><code>class ValidateGLSLMaterial(plugin.MayaInstancePlugin,\n                           OptionalPyblishPluginMixin):\n    \"\"\"\n    Validate if the asset uses GLSL Shader\n    \"\"\"\n\n    order = ValidateContentsOrder + 0.1\n    families = ['gltf']\n    label = 'GLSL Shader for GLTF'\n    actions = [RepairAction]\n    optional = True\n    active = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        shading_grp = self.get_material_from_shapes(instance)\n        if not shading_grp:\n            raise PublishValidationError(\"No shading group found\")\n        invalid = self.get_texture_shader_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\"Non GLSL Shader found: \"\n                                         \"{0}\".format(invalid))\n\n    def get_material_from_shapes(self, instance):\n        shapes = cmds.ls(instance, type=\"mesh\", long=True)\n        for shape in shapes:\n            shading_grp = cmds.listConnections(shape,\n                                               destination=True,\n                                               type=\"shadingEngine\")\n\n            return shading_grp or []\n\n    def get_texture_shader_invalid(self, instance):\n\n        invalid = set()\n        shading_grp = self.get_material_from_shapes(instance)\n        for shading_group in shading_grp:\n            material_name = \"{}.surfaceShader\".format(shading_group)\n            material = cmds.listConnections(material_name,\n                                            source=True,\n                                            destination=False,\n                                            type=\"GLSLShader\")\n\n            if not material:\n                # add material name\n                material = cmds.listConnections(material_name)[0]\n                invalid.add(material)\n\n        return list(invalid)\n\n    @classmethod\n    def repair(cls, instance):\n        \"\"\"\n        Repair instance by assigning GLSL Shader\n        to the material\n        \"\"\"\n        cls.assign_glsl_shader(instance)\n        return\n\n    @classmethod\n    def assign_glsl_shader(cls, instance):\n        \"\"\"\n        Converting StingrayPBS material to GLSL Shaders\n        for the glb export through Maya2GLTF plugin\n        \"\"\"\n\n        meshes = cmds.ls(instance, type=\"mesh\", long=True)\n        cls.log.debug(\"meshes: {}\".format(meshes))\n        # load the glsl shader plugin\n        cmds.loadPlugin(\"glslShader\", quiet=True)\n\n        for mesh in meshes:\n            # create glsl shader\n            glsl = cmds.createNode('GLSLShader')\n            glsl_shading_grp = cmds.sets(name=glsl + \"SG\", empty=True,\n                                         renderable=True, noSurfaceShader=True)\n            cmds.connectAttr(glsl + \".outColor\",\n                             glsl_shading_grp + \".surfaceShader\")\n\n            # load the maya2gltf shader\n            ogsfx_path = instance.context.data[\"project_settings\"][\"maya\"][\"publish\"][\"ExtractGLB\"][\"ogsfx_path\"]  # noqa\n            if not os.path.exists(ogsfx_path):\n                if ogsfx_path:\n                    # if custom ogsfx path is not specified\n                    # the log below is the warning for the user\n                    cls.log.warning(\"ogsfx shader file \"\n                                    \"not found in {}\".format(ogsfx_path))\n\n                cls.log.debug(\"Searching the ogsfx shader file in \"\n                              \"default maya directory...\")\n                # re-direct to search the ogsfx path in maya_dir\n                ogsfx_path = os.getenv(\"MAYA_APP_DIR\") + ogsfx_path\n                if not os.path.exists(ogsfx_path):\n                    raise PublishValidationError(\"The ogsfx shader file does not \"      # noqa\n                                                 \"exist: {}\".format(ogsfx_path))        # noqa\n\n            cmds.setAttr(glsl + \".shader\", ogsfx_path, typ=\"string\")\n            # list the materials used for the assets\n            shading_grp = cmds.listConnections(mesh,\n                                               destination=True,\n                                               type=\"shadingEngine\")\n\n            # get the materials related to the selected assets\n            for material in shading_grp:\n                pbs_shader = cmds.listConnections(material,\n                                                  destination=True,\n                                                  type=\"StingrayPBS\")\n                if pbs_shader:\n                    cls.pbs_shader_conversion(pbs_shader, glsl)\n                # setting up to relink the texture if\n                # the mesh is with aiStandardSurface\n                arnold_shader = cmds.listConnections(material,\n                                                     destination=True,\n                                                     type=\"aiStandardSurface\")\n                if arnold_shader:\n                    cls.arnold_shader_conversion(arnold_shader, glsl)\n\n            cmds.sets(mesh, forceElement=str(glsl_shading_grp))\n\n    @classmethod\n    def pbs_shader_conversion(cls, main_shader, glsl):\n\n        cls.log.debug(\"StringrayPBS detected \"\n                      \"-&gt; Can do texture conversion\")\n\n        for shader in main_shader:\n            # get the file textures related to the PBS Shader\n            albedo = cmds.listConnections(shader +\n                                          \".TEX_color_map\")\n            if albedo:\n                dif_output = albedo[0] + \".outColor\"\n                # get the glsl_shader input\n                # reconnect the file nodes to maya2gltf shader\n                glsl_dif = glsl + \".u_BaseColorTexture\"\n                cmds.connectAttr(dif_output, glsl_dif)\n\n            # connect orm map if there is one\n            orm_packed = cmds.listConnections(shader +\n                                              \".TEX_ao_map\")\n            if orm_packed:\n                orm_output = orm_packed[0] + \".outColor\"\n\n                mtl = glsl + \".u_MetallicTexture\"\n                ao = glsl + \".u_OcclusionTexture\"\n                rough = glsl + \".u_RoughnessTexture\"\n\n                cmds.connectAttr(orm_output, mtl)\n                cmds.connectAttr(orm_output, ao)\n                cmds.connectAttr(orm_output, rough)\n\n            # connect nrm map if there is one\n            nrm = cmds.listConnections(shader +\n                                       \".TEX_normal_map\")\n            if nrm:\n                nrm_output = nrm[0] + \".outColor\"\n                glsl_nrm = glsl + \".u_NormalTexture\"\n                cmds.connectAttr(nrm_output, glsl_nrm)\n\n    @classmethod\n    def arnold_shader_conversion(cls, main_shader, glsl):\n        cls.log.debug(\"aiStandardSurface detected \"\n                      \"-&gt; Can do texture conversion\")\n\n        for shader in main_shader:\n            # get the file textures related to the PBS Shader\n            albedo = cmds.listConnections(shader + \".baseColor\")\n            if albedo:\n                dif_output = albedo[0] + \".outColor\"\n                # get the glsl_shader input\n                # reconnect the file nodes to maya2gltf shader\n                glsl_dif = glsl + \".u_BaseColorTexture\"\n                cmds.connectAttr(dif_output, glsl_dif)\n\n            orm_packed = cmds.listConnections(shader +\n                                              \".specularRoughness\")\n            if orm_packed:\n                orm_output = orm_packed[0] + \".outColor\"\n\n                mtl = glsl + \".u_MetallicTexture\"\n                ao = glsl + \".u_OcclusionTexture\"\n                rough = glsl + \".u_RoughnessTexture\"\n\n                cmds.connectAttr(orm_output, mtl)\n                cmds.connectAttr(orm_output, ao)\n                cmds.connectAttr(orm_output, rough)\n\n            # connect nrm map if there is one\n            bump_node = cmds.listConnections(shader +\n                                             \".normalCamera\")\n            if bump_node:\n                for bump in bump_node:\n                    nrm = cmds.listConnections(bump +\n                                               \".bumpValue\")\n                    if nrm:\n                        nrm_output = nrm[0] + \".outColor\"\n                        glsl_nrm = glsl + \".u_NormalTexture\"\n                        cmds.connectAttr(nrm_output, glsl_nrm)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_glsl_material.html#client.ayon_maya.plugins.publish.validate_glsl_material.ValidateGLSLMaterial.assign_glsl_shader","title":"<code>assign_glsl_shader(instance)</code>  <code>classmethod</code>","text":"<p>Converting StingrayPBS material to GLSL Shaders for the glb export through Maya2GLTF plugin</p> Source code in <code>client/ayon_maya/plugins/publish/validate_glsl_material.py</code> <pre><code>@classmethod\ndef assign_glsl_shader(cls, instance):\n    \"\"\"\n    Converting StingrayPBS material to GLSL Shaders\n    for the glb export through Maya2GLTF plugin\n    \"\"\"\n\n    meshes = cmds.ls(instance, type=\"mesh\", long=True)\n    cls.log.debug(\"meshes: {}\".format(meshes))\n    # load the glsl shader plugin\n    cmds.loadPlugin(\"glslShader\", quiet=True)\n\n    for mesh in meshes:\n        # create glsl shader\n        glsl = cmds.createNode('GLSLShader')\n        glsl_shading_grp = cmds.sets(name=glsl + \"SG\", empty=True,\n                                     renderable=True, noSurfaceShader=True)\n        cmds.connectAttr(glsl + \".outColor\",\n                         glsl_shading_grp + \".surfaceShader\")\n\n        # load the maya2gltf shader\n        ogsfx_path = instance.context.data[\"project_settings\"][\"maya\"][\"publish\"][\"ExtractGLB\"][\"ogsfx_path\"]  # noqa\n        if not os.path.exists(ogsfx_path):\n            if ogsfx_path:\n                # if custom ogsfx path is not specified\n                # the log below is the warning for the user\n                cls.log.warning(\"ogsfx shader file \"\n                                \"not found in {}\".format(ogsfx_path))\n\n            cls.log.debug(\"Searching the ogsfx shader file in \"\n                          \"default maya directory...\")\n            # re-direct to search the ogsfx path in maya_dir\n            ogsfx_path = os.getenv(\"MAYA_APP_DIR\") + ogsfx_path\n            if not os.path.exists(ogsfx_path):\n                raise PublishValidationError(\"The ogsfx shader file does not \"      # noqa\n                                             \"exist: {}\".format(ogsfx_path))        # noqa\n\n        cmds.setAttr(glsl + \".shader\", ogsfx_path, typ=\"string\")\n        # list the materials used for the assets\n        shading_grp = cmds.listConnections(mesh,\n                                           destination=True,\n                                           type=\"shadingEngine\")\n\n        # get the materials related to the selected assets\n        for material in shading_grp:\n            pbs_shader = cmds.listConnections(material,\n                                              destination=True,\n                                              type=\"StingrayPBS\")\n            if pbs_shader:\n                cls.pbs_shader_conversion(pbs_shader, glsl)\n            # setting up to relink the texture if\n            # the mesh is with aiStandardSurface\n            arnold_shader = cmds.listConnections(material,\n                                                 destination=True,\n                                                 type=\"aiStandardSurface\")\n            if arnold_shader:\n                cls.arnold_shader_conversion(arnold_shader, glsl)\n\n        cmds.sets(mesh, forceElement=str(glsl_shading_grp))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_glsl_material.html#client.ayon_maya.plugins.publish.validate_glsl_material.ValidateGLSLMaterial.repair","title":"<code>repair(instance)</code>  <code>classmethod</code>","text":"<p>Repair instance by assigning GLSL Shader to the material</p> Source code in <code>client/ayon_maya/plugins/publish/validate_glsl_material.py</code> <pre><code>@classmethod\ndef repair(cls, instance):\n    \"\"\"\n    Repair instance by assigning GLSL Shader\n    to the material\n    \"\"\"\n    cls.assign_glsl_shader(instance)\n    return\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_glsl_plugin.html","title":"validate_glsl_plugin","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_glsl_plugin.html#client.ayon_maya.plugins.publish.validate_glsl_plugin.ValidateGLSLPlugin","title":"<code>ValidateGLSLPlugin</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate if the asset uses GLSL Shader</p> Source code in <code>client/ayon_maya/plugins/publish/validate_glsl_plugin.py</code> <pre><code>class ValidateGLSLPlugin(plugin.MayaInstancePlugin,\n                         OptionalPyblishPluginMixin):\n    \"\"\"\n    Validate if the asset uses GLSL Shader\n    \"\"\"\n\n    order = ValidateContentsOrder + 0.15\n    families = ['gltf']\n    label = 'maya2glTF plugin'\n    actions = [RepairAction]\n    optional = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        if not cmds.pluginInfo(\"maya2glTF\", query=True, loaded=True):\n            raise PublishValidationError(\"maya2glTF is not loaded\")\n\n    @classmethod\n    def repair(cls, instance):\n        \"\"\"\n        Repair instance by enabling the plugin\n        \"\"\"\n        return cmds.loadPlugin(\"maya2glTF\", quiet=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_glsl_plugin.html#client.ayon_maya.plugins.publish.validate_glsl_plugin.ValidateGLSLPlugin.repair","title":"<code>repair(instance)</code>  <code>classmethod</code>","text":"<p>Repair instance by enabling the plugin</p> Source code in <code>client/ayon_maya/plugins/publish/validate_glsl_plugin.py</code> <pre><code>@classmethod\ndef repair(cls, instance):\n    \"\"\"\n    Repair instance by enabling the plugin\n    \"\"\"\n    return cmds.loadPlugin(\"maya2glTF\", quiet=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_instance_has_members.html","title":"validate_instance_has_members","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_instance_has_members.html#client.ayon_maya.plugins.publish.validate_instance_has_members.ValidateInstanceHasMembers","title":"<code>ValidateInstanceHasMembers</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validates instance objectSet has any members.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_instance_has_members.py</code> <pre><code>class ValidateInstanceHasMembers(plugin.MayaInstancePlugin):\n    \"\"\"Validates instance objectSet has *any* members.\"\"\"\n\n    order = ValidateContentsOrder\n    label = 'Instance has members'\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n\n    @classmethod\n    def get_invalid(cls, instance):\n        invalid = list()\n        if not instance.data.get(\"setMembers\"):\n            objectset_name = instance.data['name']\n            invalid.append(objectset_name)\n\n        return invalid\n\n    def process(self, instance):\n        # Allow renderlayer, rendersetup and workfile to be empty\n        skip_families = {\"workfile\",\n                         \"renderlayer\",\n                         \"rendersetup\",\n                         \"mayaUsdLayer\",\n                         \"usdLayer\",\n                         \"usdAsset\"}\n        families = {instance.data.get(\"family\")}\n        families.update(instance.data.get(\"families\", []))\n        if families.intersection(skip_families):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            # Invalid will always be a single entry, we log the single name\n            name = invalid[0]\n            raise PublishValidationError(\n                title=\"Empty instance\",\n                message=\"Instance '{0}' is empty\".format(name)\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_instance_in_context.html","title":"validate_instance_in_context","text":"<p>Validate if instance asset is the same as context asset.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_instance_in_context.html#client.ayon_maya.plugins.publish.validate_instance_in_context.ValidateInstanceInContext","title":"<code>ValidateInstanceInContext</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validator to check if instance asset match context asset.</p> <p>When working in per-shot style you always publish data in context of current asset (shot). This validator checks if this is so. It is optional so it can be disabled when needed.</p> <p>Action on this validator will select invalid instances in Outliner.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_instance_in_context.py</code> <pre><code>class ValidateInstanceInContext(plugin.MayaInstancePlugin,\n                                OptionalPyblishPluginMixin):\n    \"\"\"Validator to check if instance asset match context asset.\n\n    When working in per-shot style you always publish data in context of\n    current asset (shot). This validator checks if this is so. It is optional\n    so it can be disabled when needed.\n\n    Action on this validator will select invalid instances in Outliner.\n    \"\"\"\n\n    order = ValidateContentsOrder\n    label = \"Instance in same Context\"\n    optional = True\n    actions = [\n        ayon_maya.api.action.SelectInvalidAction, RepairAction\n    ]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        folder_path = instance.data.get(\"folderPath\")\n        task = instance.data.get(\"task\")\n        context = self.get_context(instance)\n        if (folder_path, task) != context:\n            context_label = \"{} &gt; {}\".format(*context)\n            instance_label = \"{} &gt; {}\".format(folder_path, task)\n            raise PublishValidationError(\n                message=(\n                    \"Instance '{}' publishes to different context than current\"\n                    \" context: {}. Current context: {}\".format(\n                        instance.name, instance_label, context_label\n                    )\n                ),\n                description=(\n                    \"## Publishing to a different context data\\n\"\n                    \"There are publish instances present which are publishing \"\n                    \"into a different folder than your current context.\\n\\n\"\n                    \"Usually this is not what you want but there can be cases \"\n                    \"where you might want to publish into another folder or \"\n                    \"shot. If that's the case you can disable the validation \"\n                    \"on the instance to ignore it.\"\n                )\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n        return [instance.data[\"instance_node\"]]\n\n    @classmethod\n    def repair(cls, instance):\n        context_folder_path, context_task = cls.get_context(\n            instance)\n\n        create_context = instance.context.data[\"create_context\"]\n        instance_id = instance.data[\"instance_id\"]\n        created_instance = create_context.get_instance_by_id(\n            instance_id\n        )\n        created_instance[\"folderPath\"] = context_folder_path\n        created_instance[\"task\"] = context_task\n        create_context.save_changes()\n\n    @staticmethod\n    def get_context(instance):\n        \"\"\"Return asset, task from publishing context data\"\"\"\n        context = instance.context\n        return context.data[\"folderPath\"], context.data[\"task\"]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_instance_in_context.html#client.ayon_maya.plugins.publish.validate_instance_in_context.ValidateInstanceInContext.get_context","title":"<code>get_context(instance)</code>  <code>staticmethod</code>","text":"<p>Return asset, task from publishing context data</p> Source code in <code>client/ayon_maya/plugins/publish/validate_instance_in_context.py</code> <pre><code>@staticmethod\ndef get_context(instance):\n    \"\"\"Return asset, task from publishing context data\"\"\"\n    context = instance.context\n    return context.data[\"folderPath\"], context.data[\"task\"]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_instance_subset.html","title":"validate_instance_subset","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_instance_subset.html#client.ayon_maya.plugins.publish.validate_instance_subset.ValidateSubsetName","title":"<code>ValidateSubsetName</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validates product name has only valid characters</p> Source code in <code>client/ayon_maya/plugins/publish/validate_instance_subset.py</code> <pre><code>class ValidateSubsetName(plugin.MayaInstancePlugin):\n    \"\"\"Validates product name has only valid characters\"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"*\"]\n    label = \"Product Name\"\n\n    def process(self, instance):\n\n        product_name = instance.data.get(\"productName\", None)\n\n        # Ensure product data\n        if product_name is None:\n            raise PublishValidationError(\n                \"Instance is missing product name: {0}\".format(product_name)\n            )\n\n        if not isinstance(product_name, str):\n            raise PublishValidationError((\n                \"Instance product name must be string, got: {0} ({1})\"\n            ).format(product_name, type(product_name)))\n\n        # Ensure is not empty product\n        if not product_name:\n            raise PublishValidationError(\n                \"Instance product name is empty: {0}\".format(product_name)\n            )\n\n        # Validate product characters\n        if not validate_name(product_name):\n            raise PublishValidationError((\n                \"Instance product name contains invalid characters: {0}\"\n            ).format(product_name))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_loaded_plugin.html","title":"validate_loaded_plugin","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_loaded_plugin.html#client.ayon_maya.plugins.publish.validate_loaded_plugin.ValidateLoadedPlugin","title":"<code>ValidateLoadedPlugin</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure there are no unauthorized loaded plugins</p> Source code in <code>client/ayon_maya/plugins/publish/validate_loaded_plugin.py</code> <pre><code>class ValidateLoadedPlugin(plugin.MayaInstancePlugin,\n                           OptionalPyblishPluginMixin):\n    \"\"\"Ensure there are no unauthorized loaded plugins\"\"\"\n\n    label = \"Loaded Plugin\"\n    order = pyblish.api.ValidatorOrder\n    actions = [RepairContextAction]\n    optional = True\n\n    @classmethod\n    def get_invalid(cls, context):\n\n        invalid = []\n        loaded_plugins = cmds.pluginInfo(query=True, listPlugins=True)\n        # get variable from AYON settings\n        whitelist_native_plugins = cls.whitelist_native_plugins\n        authorized_plugins = cls.authorized_plugins or []\n\n        for maya_plugin in loaded_plugins:\n            if not whitelist_native_plugins and os.getenv('MAYA_LOCATION') \\\n                    in cmds.pluginInfo(maya_plugin, query=True, path=True):\n                continue\n            if maya_plugin not in authorized_plugins:\n                invalid.append(maya_plugin)\n\n        return invalid\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            return\n        invalid = self.get_invalid(context)\n        if invalid:\n            raise PublishValidationError(\n                \"Found forbidden plugin name: {}\".format(\", \".join(invalid))\n            )\n\n    @classmethod\n    def repair(cls, context):\n        \"\"\"Unload forbidden plugins\"\"\"\n\n        for maya_plugin in cls.get_invalid(context):\n            cmds.pluginInfo(maya_plugin, edit=True, autoload=False)\n            cmds.unloadPlugin(maya_plugin, force=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_loaded_plugin.html#client.ayon_maya.plugins.publish.validate_loaded_plugin.ValidateLoadedPlugin.repair","title":"<code>repair(context)</code>  <code>classmethod</code>","text":"<p>Unload forbidden plugins</p> Source code in <code>client/ayon_maya/plugins/publish/validate_loaded_plugin.py</code> <pre><code>@classmethod\ndef repair(cls, context):\n    \"\"\"Unload forbidden plugins\"\"\"\n\n    for maya_plugin in cls.get_invalid(context):\n        cmds.pluginInfo(maya_plugin, edit=True, autoload=False)\n        cmds.unloadPlugin(maya_plugin, force=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_contents.html","title":"validate_look_contents","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_contents.html#client.ayon_maya.plugins.publish.validate_look_contents.ValidateLookContents","title":"<code>ValidateLookContents</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validate look instance contents</p> Rules <ul> <li>Look data must have <code>relationships</code> and <code>attributes</code> keys.</li> <li>At least one relationship must be collection.</li> <li>All relationship object sets at least have an ID value</li> </ul> Tip <ul> <li>When no node IDs are found on shadingEngines please save your scene and try again.</li> </ul> Source code in <code>client/ayon_maya/plugins/publish/validate_look_contents.py</code> <pre><code>class ValidateLookContents(plugin.MayaInstancePlugin):\n    \"\"\"Validate look instance contents\n\n    Rules:\n        * Look data must have `relationships` and `attributes` keys.\n        * At least one relationship must be collection.\n        * All relationship object sets at least have an ID value\n\n    Tip:\n        * When no node IDs are found on shadingEngines please save your scene\n        and try again.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = ['look']\n    label = 'Look Data Contents'\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n\n    def process(self, instance: pyblish.api.Instance):\n        \"\"\"Process all the nodes in the instance\"\"\"\n\n        if not instance[:]:\n            raise PublishValidationError(\n                \"Instance is empty\", description=self.get_description())\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                f\"'{instance.name}' has invalid look content\",\n                description=self.get_description())\n\n    @classmethod\n    def get_invalid(cls, instance: pyblish.api.Instance) -&gt; List[str]:\n        \"\"\"Get all invalid nodes\"\"\"\n\n        # check if data has the right attributes and content\n        attributes = cls.validate_lookdata_attributes(instance)\n        # check the looks for ID\n        looks = cls.validate_looks(instance)\n\n        invalid = looks + attributes\n        return invalid\n\n    @classmethod\n    def validate_lookdata_attributes(\n            cls, instance: pyblish.api.Instance) -&gt; List[str]:\n        \"\"\"Check if the lookData has the required attributes\"\"\"\n\n        invalid = set()\n\n        keys = [\"relationships\", \"attributes\"]\n        lookdata = instance.data[\"lookData\"]\n        for key in keys:\n            if key not in lookdata:\n                cls.log.error(f\"Look Data has no key '{key}'\")\n                invalid.add(instance.name)\n\n        # Validate at least one single relationship is collected\n        if not lookdata[\"relationships\"]:\n            cls.log.error(\n                \"Look '%s' has no relationships. This usually indicates that \"\n                \"geometry or shaders are lacking the required 'cbId'. \"\n                \"Re-save your scene, try again. If still an issue investigate \"\n                \"the attributes on the meshes or shaders.\" % instance.name)\n            invalid.add(instance.name)\n\n        # Check if attributes are on a node with an ID, crucial for rebuild!\n        for attr_changes in lookdata[\"attributes\"]:\n            if not attr_changes[\"uuid\"] and not attr_changes[\"attributes\"]:\n                cls.log.error(\"Node '%s' has no cbId, please set the \"\n                              \"attributes to its children if it has any.\"\n                              % attr_changes[\"name\"])\n                invalid.add(instance.name)\n\n        return list(invalid)\n\n    @classmethod\n    def validate_looks(cls, instance: pyblish.api.Instance) -&gt; List[str]:\n\n        looks = instance.data[\"lookData\"][\"relationships\"]\n        invalid = []\n\n        # Ignore objects that are default objects, like e.g. default shading\n        # engines because those should be captured by other validators.\n        ignored_defaults = set(cmds.ls(defaultNodes=True))\n\n        for name, data in looks.items():\n            if name in ignored_defaults:\n                cls.log.warning(f\"Ignoring default node without UUID '{name}'\")\n                continue\n\n            if not data[\"uuid\"]:\n                cls.log.error(\"Look '{}' has no UUID\".format(name))\n                invalid.append(name)\n\n        return invalid\n\n    @classmethod\n    def validate_renderer(cls, instance: pyblish.api.Instance):\n        # TODO: Rewrite this to be more specific and configurable\n        renderer = cmds.getAttr(\n            'defaultRenderGlobals.currentRenderer').lower()\n        do_maketx = instance.data.get(\"maketx\", False)\n        do_rstex = instance.data.get(\"rstex\", False)\n        processors = []\n\n        if do_maketx:\n            processors.append('arnold')\n        if do_rstex:\n            processors.append('redshift')\n\n        for processor in processors:\n            if processor == renderer:\n                continue\n            else:\n                cls.log.error(\n                    \"Converted texture does not match current renderer.\")\n\n    @staticmethod\n    def get_description() -&gt; str:\n        return inspect.cleandoc(\"\"\"\n            ## Invalid look contents\n\n            This validator does a general validation on the look contents and\n            settings.\n\n            Common issues:\n\n            - The look must have geometry members.\n            - All shader and set relationships must have valid `cbId` \n              attributes so that they can be correctly applied elsewhere.\n\n            #### Issues with cbId attributes\n\n            The most common issue here is the `cbId` attribute being invalid.\n            These IDs get generated on scene save (on non-referenced nodes) so\n            a good first step is usually saving your scene, and trying again.\n            If it still fails, then likely you have referenced nodes that do\n            not have a valid `cbId`. This should usually be fixed in the scene\n            from which that geometry or shader was initially created.\n        \"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_contents.html#client.ayon_maya.plugins.publish.validate_look_contents.ValidateLookContents.get_invalid","title":"<code>get_invalid(instance)</code>  <code>classmethod</code>","text":"<p>Get all invalid nodes</p> Source code in <code>client/ayon_maya/plugins/publish/validate_look_contents.py</code> <pre><code>@classmethod\ndef get_invalid(cls, instance: pyblish.api.Instance) -&gt; List[str]:\n    \"\"\"Get all invalid nodes\"\"\"\n\n    # check if data has the right attributes and content\n    attributes = cls.validate_lookdata_attributes(instance)\n    # check the looks for ID\n    looks = cls.validate_looks(instance)\n\n    invalid = looks + attributes\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_contents.html#client.ayon_maya.plugins.publish.validate_look_contents.ValidateLookContents.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance</p> Source code in <code>client/ayon_maya/plugins/publish/validate_look_contents.py</code> <pre><code>def process(self, instance: pyblish.api.Instance):\n    \"\"\"Process all the nodes in the instance\"\"\"\n\n    if not instance[:]:\n        raise PublishValidationError(\n            \"Instance is empty\", description=self.get_description())\n    invalid = self.get_invalid(instance)\n    if invalid:\n        raise PublishValidationError(\n            f\"'{instance.name}' has invalid look content\",\n            description=self.get_description())\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_contents.html#client.ayon_maya.plugins.publish.validate_look_contents.ValidateLookContents.validate_lookdata_attributes","title":"<code>validate_lookdata_attributes(instance)</code>  <code>classmethod</code>","text":"<p>Check if the lookData has the required attributes</p> Source code in <code>client/ayon_maya/plugins/publish/validate_look_contents.py</code> <pre><code>@classmethod\ndef validate_lookdata_attributes(\n        cls, instance: pyblish.api.Instance) -&gt; List[str]:\n    \"\"\"Check if the lookData has the required attributes\"\"\"\n\n    invalid = set()\n\n    keys = [\"relationships\", \"attributes\"]\n    lookdata = instance.data[\"lookData\"]\n    for key in keys:\n        if key not in lookdata:\n            cls.log.error(f\"Look Data has no key '{key}'\")\n            invalid.add(instance.name)\n\n    # Validate at least one single relationship is collected\n    if not lookdata[\"relationships\"]:\n        cls.log.error(\n            \"Look '%s' has no relationships. This usually indicates that \"\n            \"geometry or shaders are lacking the required 'cbId'. \"\n            \"Re-save your scene, try again. If still an issue investigate \"\n            \"the attributes on the meshes or shaders.\" % instance.name)\n        invalid.add(instance.name)\n\n    # Check if attributes are on a node with an ID, crucial for rebuild!\n    for attr_changes in lookdata[\"attributes\"]:\n        if not attr_changes[\"uuid\"] and not attr_changes[\"attributes\"]:\n            cls.log.error(\"Node '%s' has no cbId, please set the \"\n                          \"attributes to its children if it has any.\"\n                          % attr_changes[\"name\"])\n            invalid.add(instance.name)\n\n    return list(invalid)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_contents.html#client.ayon_maya.plugins.publish.validate_look_contents.ValidateLookContentsFiles","title":"<code>ValidateLookContentsFiles</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validate look resources have valid files.</p> Rules <ul> <li>Look data must have <code>relationships</code> and <code>attributes</code> keys.</li> <li>At least one relationship must be collection.</li> <li>All relationship object sets at least have an ID value</li> </ul> Tip <ul> <li>When no node IDs are found on shadingEngines please save your scene and try again.</li> </ul> Source code in <code>client/ayon_maya/plugins/publish/validate_look_contents.py</code> <pre><code>class ValidateLookContentsFiles(plugin.MayaInstancePlugin):\n    \"\"\"Validate look resources have valid files.\n\n    Rules:\n        * Look data must have `relationships` and `attributes` keys.\n        * At least one relationship must be collection.\n        * All relationship object sets at least have an ID value\n\n    Tip:\n        * When no node IDs are found on shadingEngines please save your scene\n        and try again.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = ['look']\n    label = 'Textures Have No Files'\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n\n    def process(self, instance: pyblish.api.Instance):\n        if self.get_invalid(instance):\n            raise PublishValidationError(\n                \"Look has file nodes for which no files were found on disk.\",\n                description=self.get_description())\n\n    @classmethod\n    def get_invalid(cls, instance: pyblish.api.Instance) -&gt; List[str]:\n        \"\"\"Get all invalid nodes\"\"\"\n        invalid = []\n        resources = instance.data.get(\"resources\", [])\n        for resource in resources:\n            files = resource[\"files\"]\n            if len(files) == 0:\n                node = resource[\"node\"]\n                cls.log.error(\"File node '%s' uses no or non-existing \"\n                              \"files\" % node)\n                invalid.append(node)\n        return invalid\n\n    @staticmethod\n    def get_description() -&gt; str:\n        return inspect.cleandoc(\"\"\"\n            ### Look texture has no files\n\n            Missing files on disk for textures used by the look. This may be\n            because the texture has no filepath set or points to a non-existing\n            path.\n\n            Files used by the textures and file nodes must exist on disk. \n            Please update the relevant filepaths.                    \n        \"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_contents.html#client.ayon_maya.plugins.publish.validate_look_contents.ValidateLookContentsFiles.get_invalid","title":"<code>get_invalid(instance)</code>  <code>classmethod</code>","text":"<p>Get all invalid nodes</p> Source code in <code>client/ayon_maya/plugins/publish/validate_look_contents.py</code> <pre><code>@classmethod\ndef get_invalid(cls, instance: pyblish.api.Instance) -&gt; List[str]:\n    \"\"\"Get all invalid nodes\"\"\"\n    invalid = []\n    resources = instance.data.get(\"resources\", [])\n    for resource in resources:\n        files = resource[\"files\"]\n        if len(files) == 0:\n            node = resource[\"node\"]\n            cls.log.error(\"File node '%s' uses no or non-existing \"\n                          \"files\" % node)\n            invalid.append(node)\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_default_shaders_connections.html","title":"validate_look_default_shaders_connections","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_default_shaders_connections.html#client.ayon_maya.plugins.publish.validate_look_default_shaders_connections.ValidateLookDefaultShadersConnections","title":"<code>ValidateLookDefaultShadersConnections</code>","text":"<p>               Bases: <code>MayaContextPlugin</code></p> <p>Validate default shaders in the scene have their default connections.</p> <p>Any of the following should be connected to initialShadingGroup: - openPBR_shader1 (maya 2026+), - standardSurface1 (maya 2024-2025), - or lambert1 (maya 2023 and before)</p> <p>When disconnected then another material than e.g. the lambert1 will be identified as the default shader which can have unpredictable results.</p> <p>To fix, the default connections need to be made again. See the logs for more details on which connections are missing.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_look_default_shaders_connections.py</code> <pre><code>class ValidateLookDefaultShadersConnections(plugin.MayaContextPlugin):\n    \"\"\"Validate default shaders in the scene have their default connections.\n\n    Any of the following should be connected to initialShadingGroup:\n    - openPBR_shader1 (maya 2026+),\n    - standardSurface1 (maya 2024-2025),\n    - or lambert1 (maya 2023 and before)\n\n    When disconnected then another material than e.g. the lambert1 will be\n    identified as the default shader which can have unpredictable results.\n\n    To fix, the default connections need to be made again. See the logs for\n    more details on which connections are missing.\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder - 0.4999\n    families = ['look']\n    label = 'Look Default Shader Connections'\n    actions = [RepairContextAction]\n\n    # The default connections to check\n    DEFAULTS = {\n        \"initialShadingGroup.surfaceShader\": [\n            \"openPBR_shader1.outColor\",\n            \"standardSurface1.outColor\",\n            \"lambert1.outColor\",\n        ],\n        \"initialParticleSE.surfaceShader\": [\n            \"openPBR_shader1.outColor\",\n            \"standardSurface1.outColor\",\n            \"lambert1.outColor\",\n        ],\n        \"initialParticleSE.volumeShader\": [\"particleCloud1.outColor\"],\n    }\n\n    def process(self, context):\n\n        if self.get_invalid():\n            raise PublishValidationError(\n                \"Default shaders in your scene do not have their \"\n                \"default shader connections. Please repair them to continue.\"\n            )\n\n    @classmethod\n    def get_invalid(cls):\n\n        # Process as usual\n        invalid = list()\n        for plug, valid_inputs in cls.DEFAULTS.items():\n            inputs = cmds.listConnections(plug,\n                                          source=True,\n                                          destination=False,\n                                          plugs=True) or None\n            if not inputs or inputs[0] not in valid_inputs:\n                cls.log.error(\n                    \"{0} is not connected to {1}. This can result in \"\n                    \"unexpected behavior. Please reconnect to continue.\"\n                    \"\".format(plug, \" or \".join(valid_inputs))\n                )\n                invalid.append(plug)\n\n        return invalid\n\n    @classmethod\n    def repair(cls, context):\n        invalid = cls.get_invalid()\n        for plug in invalid:\n            valid_inputs = cls.DEFAULTS[plug]\n            for valid_input in valid_inputs:\n                if cmds.objExists(valid_input):\n                    cls.log.info(\n                        \"Connecting {} -&gt; {}\".format(valid_input, plug)\n                    )\n                    cmds.connectAttr(valid_input, plug, force=True)\n                    break\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_id_reference_edits.html","title":"validate_look_id_reference_edits","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_id_reference_edits.html#client.ayon_maya.plugins.publish.validate_look_id_reference_edits.ValidateLookIdReferenceEdits","title":"<code>ValidateLookIdReferenceEdits</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validate nodes in look have no reference edits to cbId.</p> Note <p>This only validates the cbId edits on the referenced nodes that are used in the look. For example, a transform can have its cbId changed without being invalidated when it is not used in the look's assignment.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_look_id_reference_edits.py</code> <pre><code>class ValidateLookIdReferenceEdits(plugin.MayaInstancePlugin):\n    \"\"\"Validate nodes in look have no reference edits to cbId.\n\n    Note:\n        This only validates the cbId edits on the referenced nodes that are\n        used in the look. For example, a transform can have its cbId changed\n        without being invalidated when it is not used in the look's assignment.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = ['look']\n    label = 'Look Id Reference Edits'\n    actions = [ayon_maya.api.action.SelectInvalidAction,\n               RepairAction]\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        # Disable plug-in if cbId workflow is disabled\n        if not project_settings[\"maya\"].get(\"use_cbid_workflow\", True):\n            cls.enabled = False\n            return\n\n    def process(self, instance):\n        invalid = self.get_invalid(instance)\n\n        if invalid:\n            raise PublishValidationError(\"Invalid nodes %s\" % (invalid,))\n\n    @staticmethod\n    def get_invalid(instance):\n\n        # Collect all referenced members\n        references = defaultdict(set)\n        relationships = instance.data[\"lookData\"][\"relationships\"]\n        for relationship in relationships.values():\n            for member in relationship['members']:\n                node = member[\"name\"]\n\n                if cmds.referenceQuery(node, isNodeReferenced=True):\n                    ref = cmds.referenceQuery(node, referenceNode=True)\n                    references[ref].add(node)\n\n        # Validate whether any has changes to 'cbId' attribute\n        invalid = list()\n        for ref, nodes in references.items():\n            edits = cmds.referenceQuery(editAttrs=True,\n                                        editNodes=True,\n                                        showDagPath=True,\n                                        showNamespace=True,\n                                        onReferenceNode=ref)\n            for edit in edits:\n\n                # Ensure it is an attribute ending with .cbId\n                # thus also ignore just node edits (like parenting)\n                if not edit.endswith(\".cbId\"):\n                    continue\n\n                # Ensure the attribute is 'cbId' (and not a nested attribute)\n                node, attr = edit.split(\".\", 1)\n                if attr != \"cbId\":\n                    continue\n\n                if node in nodes:\n                    invalid.append(node)\n\n        return invalid\n\n    @classmethod\n    def repair(cls, instance):\n\n        invalid = cls.get_invalid(instance)\n\n        # Group invalid nodes by reference node\n        references = defaultdict(set)\n        for node in invalid:\n            ref = cmds.referenceQuery(node, referenceNode=True)\n            references[ref].add(node)\n\n        # Remove the reference edits on the nodes per reference node\n        for ref, nodes in references.items():\n            for node in nodes:\n\n                # Somehow this only works if you run the removal\n                # per edit command.\n                for command in [\"addAttr\",\n                                \"connectAttr\",\n                                \"deleteAttr\",\n                                \"disconnectAttr\",\n                                \"setAttr\"]:\n                    cmds.referenceEdit(\"{}.cbId\".format(node),\n                                       removeEdits=True,\n                                       successfulEdits=True,\n                                       failedEdits=True,\n                                       editCommand=command,\n                                       onReferenceNode=ref)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_no_default_shaders.html","title":"validate_look_no_default_shaders","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_no_default_shaders.html#client.ayon_maya.plugins.publish.validate_look_no_default_shaders.ValidateLookNoDefaultShaders","title":"<code>ValidateLookNoDefaultShaders</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validate if any node has a connection to a default shader.</p> <p>This checks whether the look has any members of: - lambert1 - initialShadingGroup - initialParticleSE - particleCloud1</p> <p>If any of those is present it will raise an error. A look is not allowed to have any of the \"default\" shaders present in a scene as they can introduce problems when referenced (overriding local scene shaders).</p> <p>To fix this no shape nodes in the look must have any of default shaders applied.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_look_no_default_shaders.py</code> <pre><code>class ValidateLookNoDefaultShaders(plugin.MayaInstancePlugin):\n    \"\"\"Validate if any node has a connection to a default shader.\n\n    This checks whether the look has any members of:\n    - lambert1\n    - initialShadingGroup\n    - initialParticleSE\n    - particleCloud1\n\n    If any of those is present it will raise an error. A look is not allowed\n    to have any of the \"default\" shaders present in a scene as they can\n    introduce problems when referenced (overriding local scene shaders).\n\n    To fix this no shape nodes in the look must have any of default shaders\n    applied.\n\n    \"\"\"\n\n    order = ValidateContentsOrder - 0.01\n    families = ['look']\n    label = 'Look No Default Shaders'\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n\n    DEFAULT_SHADERS = {\"lambert1\", \"initialShadingGroup\",\n                      \"initialParticleSE\", \"particleCloud1\"}\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance\"\"\"\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Nodes found with default shader assigned. \"\n                \"Please assign a different shader.\",\n                description=self.get_description()\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        invalid = set()\n        invalid_by_shader = defaultdict(list)\n        for node in instance:\n            # Get shading engine connections\n            shaders = cmds.listConnections(node, type=\"shadingEngine\") or []\n            for shader in cls.DEFAULT_SHADERS.intersection(shaders):\n                invalid_by_shader[shader].append(node)\n                invalid.add(node)\n\n        # Log all the invalid connections\n        for shader, nodes in invalid_by_shader.items():\n            node_list = \"\\n\".join(f\"- {node}\" for node in sorted(nodes))\n            cls.log.error(\n                f\"Default shader '{shader}' found on:\\n{node_list}\"\n            )\n\n        return list(invalid)\n\n    @staticmethod\n    def get_description() -&gt; str:\n        return inspect.cleandoc(\"\"\"\n            ### Default shaders are assigned\n\n            Some nodes in the look have default shaders assigned to them. \n            Default shaders are not allowed in the look as they can introduce\n            problems when referenced (overriding local scene shaders). \n\n            Avoid using for example _lambert1_ or _standardSurface1_ in your \n            look.\n\n            To fix this, please assign a different shader to the nodes.\n        \"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_no_default_shaders.html#client.ayon_maya.plugins.publish.validate_look_no_default_shaders.ValidateLookNoDefaultShaders.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance</p> Source code in <code>client/ayon_maya/plugins/publish/validate_look_no_default_shaders.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance\"\"\"\n    invalid = self.get_invalid(instance)\n    if invalid:\n        raise PublishValidationError(\n            \"Nodes found with default shader assigned. \"\n            \"Please assign a different shader.\",\n            description=self.get_description()\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_sets.html","title":"validate_look_sets","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_sets.html#client.ayon_maya.plugins.publish.validate_look_sets.ValidateLookSets","title":"<code>ValidateLookSets</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validate if any sets relationships are not being collected.</p> <p>Usually this collection fails if either the geometry or the shader are lacking a valid <code>cbId</code> attribute.</p> <p>If the relationship needs to be maintained you may need to create a different* relationship or ensure the node has the <code>cbId</code>.</p> <p>*The relationship might be too broad (assigned to top node of hierarchy). This can be countered by creating the relationship on the shape or its transform. In essence, ensure the node the shader is assigned to has a <code>cbId</code>.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_sets.html#client.ayon_maya.plugins.publish.validate_look_sets.ValidateLookSets--for-example","title":"For example:","text":"<p>Displacement objectSets (like V-Ray):</p> <p>It is best practice to add the transform of the shape to the displacement objectSet. Any parent groups will not work as groups do not receive a <code>cbId</code>. As such the assignments need to be made to the shapes or their transform.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_look_sets.py</code> <pre><code>class ValidateLookSets(plugin.MayaInstancePlugin):\n    \"\"\"Validate if any sets relationships are not being collected.\n\n    Usually this collection fails if either the geometry or the shader are\n    lacking a valid `cbId` attribute.\n\n    If the relationship needs to be maintained you may need to\n    create a *different** relationship or ensure the node has the `cbId`.\n\n    **The relationship might be too broad (assigned to top node of hierarchy).\n    This can be countered by creating the relationship on the shape or its\n    transform. In essence, ensure the node the shader is assigned to has a\n    `cbId`.*\n\n    ### For example:\n\n    Displacement objectSets (like V-Ray):\n\n    It is best practice to add the transform of the shape to the\n    displacement objectSet. Any parent groups will not work as groups\n    do not receive a `cbId`. As such the assignments need to be\n    made to the shapes or their transform.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = ['look']\n    label = 'Look Sets'\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance\"\"\"\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                f\"'{instance.name}' has relationships that could not be \"\n                f\"collected, likely due to lack of a `cbId` on the relevant \"\n                f\"nodes or sets.\",\n                description=self.get_description())\n\n    @classmethod\n    def get_invalid(cls, instance):\n        \"\"\"Get all invalid nodes\"\"\"\n\n        relationships = instance.data[\"lookData\"][\"relationships\"]\n        invalid = []\n\n        renderlayer = instance.data.get(\"renderlayer\", \"defaultRenderLayer\")\n        with lib.renderlayer(renderlayer):\n            for node in instance:\n                # get the connected objectSets of the node\n                sets = lib.get_related_sets(node)\n                if not sets:\n                    continue\n\n                # check if any objectSets are not present in the relationships\n                missing_sets = [s for s in sets if s not in relationships]\n                # We ignore sets with `_SET` for legacy reasons but unclear why\n                # TODO: should we remove this exclusion?\n                missing_sets = [s for s in missing_sets if '_SET' not in s]\n                if missing_sets:\n                    for missing_set in missing_sets:\n                        cls.log.debug(missing_set)\n\n                    # A set of this node is not coming along.\n                    cls.log.error(\"Missing sets for node '{}':\\n - {}\".format(\n                        node, \"\\n - \".join(missing_sets)\n                    ))\n                    invalid.append(node)\n                    continue\n\n                # Ensure the node is in the sets that are collected\n                for shader_set, data in relationships.items():\n                    if shader_set not in sets:\n                        # no need to check for a set if the node\n                        # isn't in it anyway\n                        continue\n\n                    member_nodes = [member['name'] for member in\n                                    data['members']]\n                    if node not in member_nodes:\n                        # The node is not found in the collected set\n                        # relationships\n                        cls.log.error(\"Missing '{}' in collected set node \"\n                                      \"'{}'\".format(node, shader_set))\n                        invalid.append(node)\n                        continue\n\n        return invalid\n\n    @classmethod\n    def get_description(cls):\n        return \"\"\"## Missing look sets\\n\"\"\" + inspect.getdoc(cls)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_sets.html#client.ayon_maya.plugins.publish.validate_look_sets.ValidateLookSets.get_invalid","title":"<code>get_invalid(instance)</code>  <code>classmethod</code>","text":"<p>Get all invalid nodes</p> Source code in <code>client/ayon_maya/plugins/publish/validate_look_sets.py</code> <pre><code>@classmethod\ndef get_invalid(cls, instance):\n    \"\"\"Get all invalid nodes\"\"\"\n\n    relationships = instance.data[\"lookData\"][\"relationships\"]\n    invalid = []\n\n    renderlayer = instance.data.get(\"renderlayer\", \"defaultRenderLayer\")\n    with lib.renderlayer(renderlayer):\n        for node in instance:\n            # get the connected objectSets of the node\n            sets = lib.get_related_sets(node)\n            if not sets:\n                continue\n\n            # check if any objectSets are not present in the relationships\n            missing_sets = [s for s in sets if s not in relationships]\n            # We ignore sets with `_SET` for legacy reasons but unclear why\n            # TODO: should we remove this exclusion?\n            missing_sets = [s for s in missing_sets if '_SET' not in s]\n            if missing_sets:\n                for missing_set in missing_sets:\n                    cls.log.debug(missing_set)\n\n                # A set of this node is not coming along.\n                cls.log.error(\"Missing sets for node '{}':\\n - {}\".format(\n                    node, \"\\n - \".join(missing_sets)\n                ))\n                invalid.append(node)\n                continue\n\n            # Ensure the node is in the sets that are collected\n            for shader_set, data in relationships.items():\n                if shader_set not in sets:\n                    # no need to check for a set if the node\n                    # isn't in it anyway\n                    continue\n\n                member_nodes = [member['name'] for member in\n                                data['members']]\n                if node not in member_nodes:\n                    # The node is not found in the collected set\n                    # relationships\n                    cls.log.error(\"Missing '{}' in collected set node \"\n                                  \"'{}'\".format(node, shader_set))\n                    invalid.append(node)\n                    continue\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_sets.html#client.ayon_maya.plugins.publish.validate_look_sets.ValidateLookSets.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance</p> Source code in <code>client/ayon_maya/plugins/publish/validate_look_sets.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance\"\"\"\n\n    invalid = self.get_invalid(instance)\n    if invalid:\n        raise PublishValidationError(\n            f\"'{instance.name}' has relationships that could not be \"\n            f\"collected, likely due to lack of a `cbId` on the relevant \"\n            f\"nodes or sets.\",\n            description=self.get_description())\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_shading_group.html","title":"validate_look_shading_group","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_shading_group.html#client.ayon_maya.plugins.publish.validate_look_shading_group.ValidateShadingEngine","title":"<code>ValidateShadingEngine</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate all shading engines are named after the surface material.</p> <p>Shading engines should be named \"{surface_shader}SG\"</p> Source code in <code>client/ayon_maya/plugins/publish/validate_look_shading_group.py</code> <pre><code>class ValidateShadingEngine(plugin.MayaInstancePlugin,\n                            OptionalPyblishPluginMixin):\n    \"\"\"Validate all shading engines are named after the surface material.\n\n    Shading engines should be named \"{surface_shader}SG\"\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"look\"]\n    label = \"Look Shading Engine Naming\"\n    actions = [\n        ayon_maya.api.action.SelectInvalidAction, RepairAction\n    ]\n    optional = True\n\n    # The default connections to check\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            node_list = \"\\n\".join(f\"- {node}\" for node in invalid)\n            raise PublishValidationError(\n                \"Found assigned shaders with incorrect names:\"\n                \"\\n{}\".format(node_list),\n                description=self.get_description()\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n        shapes = cmds.ls(instance, type=[\"nurbsSurface\", \"mesh\"], long=True)\n        if not shapes:\n            return []\n\n        ignored_default_nodes = set(cmds.ls(defaultNodes=True))\n        shading_engines = set(cmds.listConnections(\n            shapes, destination=True, type=\"shadingEngine\"\n        ) or [])\n        invalid = []\n        for shading_engine in sorted(shading_engines):\n            materials = cmds.listConnections(\n                shading_engine + \".surfaceShader\",\n                source=True, destination=False\n            )\n            if not materials:\n                cls.log.warning(\n                    \"Shading engine '{}' has no material connected to its \"\n                    \".surfaceShader attribute.\".format(shading_engine))\n                continue\n\n            material = materials[0]  # there should only ever be one input\n            name = material + \"SG\"\n            if shading_engine != name:\n                # Ignore referenced or read-only shading engines\n                if cmds.referenceQuery(shading_engine,\n                                       isNodeReferenced=True):\n                    cls.log.warning(\n                        \"Ignoring referenced shading engine \"\n                        f\"with invalid name: {shading_engine}\")\n\n                if shading_engine in ignored_default_nodes:\n                    cls.log.warning(\n                        \"Ignoring default shading engine \"\n                        f\"with invalid name: {shading_engine}\")\n                    continue\n\n                invalid.append(shading_engine)\n\n        return list(set(invalid))\n\n    @classmethod\n    def repair(cls, instance):\n        shading_engines = cls.get_invalid(instance)\n        for shading_engine in shading_engines:\n            name = (\n                cmds.listConnections(shading_engine + \".surfaceShader\")[0]\n                + \"SG\"\n            )\n            cmds.rename(shading_engine, name)\n\n    @staticmethod\n    def get_description():\n        return inspect.cleandoc(\"\"\"\n            ### Shaders found with incorrect names\n\n            The shading engine of a shader should be named after the connected\n            material to its `.surfaceShader` attribute. The name should be\n            `\"{material}SG\"`.\n\n            Use the repair action to rename the shading engine to the correct\n            names automatically.\n        \"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_single_shader.html","title":"validate_look_single_shader","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_look_single_shader.html#client.ayon_maya.plugins.publish.validate_look_single_shader.ValidateSingleShader","title":"<code>ValidateSingleShader</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validate all nurbsSurfaces and meshes have exactly one shader assigned.</p> <p>This will error if a shape has no shaders or more than one shader.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_look_single_shader.py</code> <pre><code>class ValidateSingleShader(plugin.MayaInstancePlugin):\n    \"\"\"Validate all nurbsSurfaces and meshes have exactly one shader assigned.\n\n    This will error if a shape has no shaders or more than one shader.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = ['look']\n    label = 'Look Single Shader Per Shape'\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n\n    # The default connections to check\n    def process(self, instance):\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                (\"Found shapes which don't have a single shader \"\n                 \"assigned:\\n{}\").format(invalid))\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        # Get all shapes from the instance\n        shapes = cmds.ls(instance, type=[\"nurbsSurface\", \"mesh\"], long=True)\n\n        # Check the number of connected shadingEngines per shape\n        no_shaders = []\n        more_than_one_shaders = []\n        for shape in shapes:\n            shading_engines = cmds.listConnections(shape,\n                                                   destination=True,\n                                                   type=\"shadingEngine\") or []\n\n            # Only interested in unique shading engines.\n            shading_engines = list(set(shading_engines))\n\n            if not shading_engines:\n                no_shaders.append(shape)\n            elif len(shading_engines) &gt; 1:\n                more_than_one_shaders.append(shape)\n\n        if no_shaders:\n            cls.log.error(\"No shaders found on: {}\".format(no_shaders))\n        if more_than_one_shaders:\n            cls.log.error(\"More than one shader found on: \"\n                          \"{}\".format(more_than_one_shaders))\n\n        return no_shaders + more_than_one_shaders\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_maya_units.html","title":"validate_maya_units","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_maya_units.html#client.ayon_maya.plugins.publish.validate_maya_units.ValidateMayaUnits","title":"<code>ValidateMayaUnits</code>","text":"<p>               Bases: <code>MayaContextPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Check if the Maya units are set correct</p> Source code in <code>client/ayon_maya/plugins/publish/validate_maya_units.py</code> <pre><code>class ValidateMayaUnits(plugin.MayaContextPlugin,\n                        OptionalPyblishPluginMixin):\n    \"\"\"Check if the Maya units are set correct\"\"\"\n\n    order = ValidateSceneOrder\n    label = \"Maya Units\"\n    actions = [RepairContextAction]\n\n    validate_linear_units = True\n\n    validate_angular_units = True\n\n    validate_fps = True\n\n    nice_message_format = (\n        \"- &lt;b&gt;{setting}&lt;/b&gt; must be &lt;b&gt;{required_value}&lt;/b&gt;.  \"\n        \"Your scene is set to &lt;b&gt;{current_value}&lt;/b&gt;\"\n    )\n    log_message_format = (\n        \"Maya scene {setting} must be '{required_value}'. \"\n        \"Current value is '{current_value}'.\"\n    )\n    optional = False\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            return\n        # Collected units\n        linearunits = context.data.get('linearUnits')\n        angularunits = context.data.get('angularUnits')\n\n        fps = context.data.get('fps')\n\n        folder_attributes = context.data[\"folderEntity\"][\"attrib\"]\n        folder_fps = mayalib.convert_to_maya_fps(folder_attributes[\"fps\"])\n\n        self.log.info('Units (linear): {0}'.format(linearunits))\n        self.log.info('Units (angular): {0}'.format(angularunits))\n        self.log.info('Units (time): {0} FPS'.format(fps))\n\n        invalid = []\n\n        project_settings: dict = context.data[\"project_settings\"]\n        linear_units, angular_units = get_scene_units_settings(\n            project_settings\n        )\n\n        # Check if units are correct\n        if (\n            self.validate_linear_units\n            and linearunits\n            and linearunits != linear_units\n        ):\n            invalid.append({\n                \"setting\": \"Linear units\",\n                \"required_value\": linear_units,\n                \"current_value\": linearunits\n            })\n\n        if (\n            self.validate_angular_units\n            and angularunits\n            and angularunits != angular_units\n        ):\n            invalid.append({\n                \"setting\": \"Angular units\",\n                \"required_value\": angular_units,\n                \"current_value\": angularunits\n            })\n\n        if self.validate_fps and fps and fps != folder_fps:\n            invalid.append({\n                \"setting\": \"FPS\",\n                \"required_value\": folder_fps,\n                \"current_value\": fps\n            })\n\n        if invalid:\n\n            issues = []\n            for data in invalid:\n                self.log.error(self.log_message_format.format(**data))\n                issues.append(self.nice_message_format.format(**data))\n            issues = \"\\n\".join(issues)\n\n            raise PublishXmlValidationError(\n                plugin=self,\n                message=\"Invalid maya scene units\",\n                formatting_data={\"issues\": issues}\n            )\n\n    @classmethod\n    def repair(cls, context):\n        \"\"\"Fix the current FPS setting of the scene, set to PAL(25.0 fps)\"\"\"\n\n        linear_units, angular_units = get_scene_units_settings()\n        if cls.validate_angular_units:\n            cls.log.info(\"Setting angular unit to '{}'\".format(angular_units))\n            cmds.currentUnit(angle=angular_units)\n\n        if cls.validate_linear_units:\n            cls.log.info(\"Setting linear unit to '{}'\".format(linear_units))\n            cmds.currentUnit(linear=linear_units)\n\n        cls.log.info(\"Setting time unit to match project\")\n        folder_entity = context.data[\"folderEntity\"]\n        mayalib.set_scene_fps(folder_entity[\"attrib\"][\"fps\"])\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_maya_units.html#client.ayon_maya.plugins.publish.validate_maya_units.ValidateMayaUnits.repair","title":"<code>repair(context)</code>  <code>classmethod</code>","text":"<p>Fix the current FPS setting of the scene, set to PAL(25.0 fps)</p> Source code in <code>client/ayon_maya/plugins/publish/validate_maya_units.py</code> <pre><code>@classmethod\ndef repair(cls, context):\n    \"\"\"Fix the current FPS setting of the scene, set to PAL(25.0 fps)\"\"\"\n\n    linear_units, angular_units = get_scene_units_settings()\n    if cls.validate_angular_units:\n        cls.log.info(\"Setting angular unit to '{}'\".format(angular_units))\n        cmds.currentUnit(angle=angular_units)\n\n    if cls.validate_linear_units:\n        cls.log.info(\"Setting linear unit to '{}'\".format(linear_units))\n        cmds.currentUnit(linear=linear_units)\n\n    cls.log.info(\"Setting time unit to match project\")\n    folder_entity = context.data[\"folderEntity\"]\n    mayalib.set_scene_fps(folder_entity[\"attrib\"][\"fps\"])\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_arnold_attributes.html","title":"validate_mesh_arnold_attributes","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_arnold_attributes.html#client.ayon_maya.plugins.publish.validate_mesh_arnold_attributes.ValidateMeshArnoldAttributes","title":"<code>ValidateMeshArnoldAttributes</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate the mesh has default Arnold attributes.</p> <p>It compares all Arnold attributes from a default mesh. This is to ensure later published looks can discover non-default Arnold attributes.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_arnold_attributes.py</code> <pre><code>class ValidateMeshArnoldAttributes(plugin.MayaInstancePlugin,\n                                   OptionalPyblishPluginMixin):\n    \"\"\"Validate the mesh has default Arnold attributes.\n\n    It compares all Arnold attributes from a default mesh. This is to ensure\n    later published looks can discover non-default Arnold attributes.\n    \"\"\"\n\n    order = ValidateMeshOrder\n    hosts = [\"maya\"]\n    families = [\"model\"]\n    label = \"Mesh Arnold Attributes\"\n    actions = [\n        ayon_maya.api.action.SelectInvalidAction,\n        RepairAction\n    ]\n\n    optional = True\n\n    # cache (will be `dict` when cached)\n    arnold_mesh_defaults = None\n\n    @classmethod\n    def get_default_attributes(cls):\n\n        if cls.arnold_mesh_defaults is not None:\n            # Use from cache\n            return cls.arnold_mesh_defaults\n\n        # Get default arnold attribute values for mesh type.\n        defaults = {}\n        with delete_after() as tmp:\n            transform = cmds.createNode(\"transform\", skipSelect=True)\n            tmp.append(transform)\n\n            mesh = cmds.createNode(\"mesh\", parent=transform, skipSelect=True)\n            arnold_attributes = cmds.listAttr(mesh,\n                                              string=\"ai*\",\n                                              fromPlugin=True) or []\n            for attr in arnold_attributes:\n                plug = \"{}.{}\".format(mesh, attr)\n                try:\n                    defaults[attr] = get_attribute(plug)\n                except PublishValidationError:\n                    cls.log.debug(\"Ignoring arnold attribute: {}\".format(attr))\n\n        cls.arnold_mesh_defaults = defaults  # assign cache\n        return defaults\n\n    @classmethod\n    def get_invalid_attributes(cls, instance, compute=False):\n        invalid = []\n\n        if compute:\n\n            meshes = cmds.ls(instance, type=\"mesh\", long=True)\n            if not meshes:\n                return []\n\n            # Compare the values against the defaults\n            defaults = cls.get_default_attributes()\n            for mesh in meshes:\n                for attr_name, default_value in defaults.items():\n                    plug = \"{}.{}\".format(mesh, attr_name)\n                    if get_attribute(plug) != default_value:\n                        invalid.append(plug)\n\n            instance.data[\"nondefault_arnold_attributes\"] = invalid\n\n        return instance.data.get(\"nondefault_arnold_attributes\", [])\n\n    @classmethod\n    def get_invalid(cls, instance):\n        invalid_attrs = cls.get_invalid_attributes(instance, compute=False)\n        invalid_nodes = set(attr.split(\".\", 1)[0] for attr in invalid_attrs)\n        return sorted(invalid_nodes)\n\n    @classmethod\n    def repair(cls, instance):\n        with maintained_selection():\n            with undo_chunk():\n                defaults = cls.get_default_attributes()\n                attributes = cls.get_invalid_attributes(\n                    instance, compute=False\n                )\n                for attr in attributes:\n                    node, attr_name = attr.split(\".\", 1)\n                    value = defaults[attr_name]\n                    set_attribute(\n                        node=node,\n                        attribute=attr_name,\n                        value=value\n                    )\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        if not cmds.pluginInfo(\"mtoa\", query=True, loaded=True):\n            # Arnold attributes only exist if plug-in is loaded\n            return\n\n        invalid = self.get_invalid_attributes(instance, compute=True)\n        if invalid:\n            raise PublishValidationError(\n                \"Non-default Arnold attributes found in instance:\"\n                \" {0}\".format(invalid)\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_empty.html","title":"validate_mesh_empty","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_empty.html#client.ayon_maya.plugins.publish.validate_mesh_empty.ValidateMeshEmpty","title":"<code>ValidateMeshEmpty</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validate meshes have some vertices.</p> <p>Its possible to have meshes without any vertices. To replicate this issue, delete all faces/polygons then all edges.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_empty.py</code> <pre><code>class ValidateMeshEmpty(plugin.MayaInstancePlugin):\n    \"\"\"Validate meshes have some vertices.\n\n    Its possible to have meshes without any vertices. To replicate\n    this issue, delete all faces/polygons then all edges.\n    \"\"\"\n\n    order = ValidateMeshOrder\n    families = [\"model\"]\n    label = \"Mesh Empty\"\n    actions = [\n        ayon_maya.api.action.SelectInvalidAction, RepairAction\n    ]\n\n    @classmethod\n    def repair(cls, instance):\n        invalid = cls.get_invalid(instance)\n        for node in invalid:\n            cmds.delete(node)\n\n    @classmethod\n    def get_invalid(cls, instance):\n        invalid = []\n\n        meshes = cmds.ls(instance, type=\"mesh\", long=True)\n        for mesh in meshes:\n            num_vertices = cmds.polyEvaluate(mesh, vertex=True)\n\n            if num_vertices == 0:\n                cls.log.warning(\n                    \"\\\"{}\\\" does not have any vertices.\".format(mesh)\n                )\n                invalid.append(mesh)\n\n        return invalid\n\n    def process(self, instance):\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Meshes found without any vertices: %s\" % invalid\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_has_uv.html","title":"validate_mesh_has_uv","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_has_uv.html#client.ayon_maya.plugins.publish.validate_mesh_has_uv.ValidateMeshHasUVs","title":"<code>ValidateMeshHasUVs</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate the current mesh has UVs.</p> <p>It validates whether the current UV set has non-zero UVs and at least more than the vertex count. It's not really bulletproof, but a simple quick validation to check if there are likely UVs for every face.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_has_uv.py</code> <pre><code>class ValidateMeshHasUVs(plugin.MayaInstancePlugin,\n                         OptionalPyblishPluginMixin):\n    \"\"\"Validate the current mesh has UVs.\n\n    It validates whether the current UV set has non-zero UVs and\n    at least more than the vertex count. It's not really bulletproof,\n    but a simple quick validation to check if there are likely\n    UVs for every face.\n    \"\"\"\n\n    order = ValidateMeshOrder\n    families = ['model']\n    label = 'Mesh Has UVs'\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = True\n\n    @classmethod\n    def get_invalid(cls, instance):\n        invalid = []\n\n        for node in cmds.ls(instance, type='mesh'):\n            num_vertices = cmds.polyEvaluate(node, vertex=True)\n\n            if num_vertices == 0:\n                cls.log.warning(\n                    \"Skipping \\\"{}\\\", cause it does not have any \"\n                    \"vertices.\".format(node)\n                )\n                continue\n\n            uv = cmds.polyEvaluate(node, uv=True)\n\n            if uv == 0:\n                invalid.append(node)\n                continue\n\n            vertex = cmds.polyEvaluate(node, vertex=True)\n            if uv &lt; vertex:\n                # Workaround:\n                # Maya can have instanced UVs in a single mesh, for example\n                # imported from an Alembic. With instanced UVs the UV count\n                # from `maya.cmds.polyEvaluate(uv=True)` will only result in\n                # the unique UV count instead of for all vertices.\n                #\n                # Note: Maya can save instanced UVs to `mayaAscii` but cannot\n                #       load this as instanced. So saving, opening and saving\n                #       again will lose this information.\n                map_attr = \"{}.map[*]\".format(node)\n                uv_to_vertex = cmds.polyListComponentConversion(map_attr,\n                                                                toVertex=True)\n                uv_vertex_count = len_flattened(uv_to_vertex)\n                if uv_vertex_count &lt; vertex:\n                    invalid.append(node)\n                else:\n                    cls.log.warning(\"Node has instanced UV points: \"\n                                    \"{0}\".format(node))\n\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n\n            names = \"\\n\".join(\n                \" - {}\".format(node) for node in invalid\n            )\n\n            raise PublishValidationError(\n                title=\"Mesh has missing UVs\",\n                message=\"Model meshes are required to have UVs.\\n\\n\"\n                        \"Meshes detected with invalid or missing UVs:\\n\"\n                        \"{0}\".format(names)\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_lamina_faces.html","title":"validate_mesh_lamina_faces","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_lamina_faces.html#client.ayon_maya.plugins.publish.validate_mesh_lamina_faces.ValidateMeshLaminaFaces","title":"<code>ValidateMeshLaminaFaces</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate meshes don't have lamina faces.</p> <p>Lamina faces share all of their edges.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_lamina_faces.py</code> <pre><code>class ValidateMeshLaminaFaces(plugin.MayaInstancePlugin,\n                              OptionalPyblishPluginMixin):\n    \"\"\"Validate meshes don't have lamina faces.\n\n    Lamina faces share all of their edges.\n\n    \"\"\"\n\n    order = ValidateMeshOrder\n    families = ['model']\n    label = 'Mesh Lamina Faces'\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = True\n\n    description = (\n        \"## Meshes with Lamina Faces\\n\"\n        \"Detected meshes with lamina faces. &lt;b&gt;Lamina faces&lt;/b&gt; are faces \"\n        \"that share all of their edges and thus are merged together on top of \"\n        \"each other.\\n\\n\"\n        \"### How to repair?\\n\"\n        \"You can repair them by using Maya's modeling tool `Mesh &gt; Cleanup..` \"\n        \"and select to cleanup matching polygons for lamina faces.\"\n    )\n\n    @staticmethod\n    def get_invalid(instance):\n        meshes = cmds.ls(instance, type='mesh', long=True)\n        invalid = [mesh for mesh in meshes if\n                   cmds.polyInfo(mesh, laminaFaces=True)]\n\n        return invalid\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance 'objectSet'\"\"\"\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n\n        if invalid:\n            raise PublishValidationError(\n                \"Meshes found with lamina faces: {0}\".format(invalid),\n                description=self.description)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_lamina_faces.html#client.ayon_maya.plugins.publish.validate_mesh_lamina_faces.ValidateMeshLaminaFaces.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance 'objectSet'</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_lamina_faces.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance 'objectSet'\"\"\"\n    if not self.is_active(instance.data):\n        return\n\n    invalid = self.get_invalid(instance)\n\n    if invalid:\n        raise PublishValidationError(\n            \"Meshes found with lamina faces: {0}\".format(invalid),\n            description=self.description)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_ngons.html","title":"validate_mesh_ngons","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_ngons.html#client.ayon_maya.plugins.publish.validate_mesh_ngons.ValidateMeshNgons","title":"<code>ValidateMeshNgons</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure that meshes don't have ngons</p> <p>Ngon are faces with more than 4 sides.</p> <p>To debug the problem on the meshes you can use Maya's modeling tool: \"Mesh &gt; Cleanup...\"</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_ngons.py</code> <pre><code>class ValidateMeshNgons(plugin.MayaInstancePlugin,\n                        OptionalPyblishPluginMixin):\n    \"\"\"Ensure that meshes don't have ngons\n\n    Ngon are faces with more than 4 sides.\n\n    To debug the problem on the meshes you can use Maya's modeling\n    tool: \"Mesh &gt; Cleanup...\"\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"model\"]\n    label = \"Mesh ngons\"\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = True\n\n    description = (\n        \"## Meshes with NGONs Faces\\n\"\n        \"Detected meshes with NGON faces. **NGONS** are faces that \"\n        \"with more than four sides.\\n\\n\"\n        \"### How to repair?\\n\"\n        \"You can repair them by usings Maya's modeling tool Mesh &gt; Cleanup.. \"\n        \"and select to cleanup matching polygons for lamina faces.\"\n    )\n\n    @staticmethod\n    def get_invalid(instance):\n\n        meshes = cmds.ls(instance, type='mesh', long=True)\n\n        # Get all faces\n        faces = ['{0}.f[*]'.format(node) for node in meshes]\n\n        # Skip meshes that for some reason have no faces, e.g. empty meshes\n        faces = cmds.ls(faces)\n        if not faces:\n            return []\n\n        # Filter to n-sided polygon faces (ngons)\n        invalid = lib.polyConstraint(faces,\n                                     t=0x0008,  # type=face\n                                     size=3)    # size=nsided\n\n        return invalid\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance \"objectSet\"\"\"\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Meshes found with n-gons: {0}\".format(invalid),\n                description=self.description)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_ngons.html#client.ayon_maya.plugins.publish.validate_mesh_ngons.ValidateMeshNgons.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance \"objectSet</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_ngons.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance \"objectSet\"\"\"\n    if not self.is_active(instance.data):\n        return\n\n    invalid = self.get_invalid(instance)\n    if invalid:\n        raise PublishValidationError(\n            \"Meshes found with n-gons: {0}\".format(invalid),\n            description=self.description)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_no_negative_scale.html","title":"validate_mesh_no_negative_scale","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_no_negative_scale.html#client.ayon_maya.plugins.publish.validate_mesh_no_negative_scale.ValidateMeshNoNegativeScale","title":"<code>ValidateMeshNoNegativeScale</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure that meshes don't have a negative scale.</p> <p>Using negatively scaled proxies in a VRayMesh results in inverted normals. As such we want to avoid this.</p> <p>We also avoid this on the rig or model because these are often the previous steps for those that are cached to proxies so we can catch this issue early.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_no_negative_scale.py</code> <pre><code>class ValidateMeshNoNegativeScale(plugin.MayaInstancePlugin,\n                                  OptionalPyblishPluginMixin):\n    \"\"\"Ensure that meshes don't have a negative scale.\n\n    Using negatively scaled proxies in a VRayMesh results in inverted\n    normals. As such we want to avoid this.\n\n    We also avoid this on the rig or model because these are often the\n    previous steps for those that are cached to proxies so we can catch this\n    issue early.\n\n    \"\"\"\n\n    order = ValidateMeshOrder\n    families = ['model']\n    label = 'Mesh No Negative Scale'\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = False\n\n    @staticmethod\n    def get_invalid(instance):\n        meshes = cmds.ls(instance,\n                         type='mesh',\n                         long=True,\n                         noIntermediate=True)\n\n        invalid = []\n        for mesh in meshes:\n            transform = cmds.listRelatives(mesh, parent=True, fullPath=True)[0]\n            scale = cmds.getAttr(\"{0}.scale\".format(transform))[0]\n\n            if any(x &lt; 0 for x in scale):\n                invalid.append(mesh)\n\n        return invalid\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance 'objectSet'\"\"\"\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n\n        if invalid:\n            raise PublishValidationError(\n                \"Meshes found with negative scale:\\n\\n{0}\".format(\n                    _as_report_list(sorted(invalid))\n                ),\n                title=\"Negative scale\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_no_negative_scale.html#client.ayon_maya.plugins.publish.validate_mesh_no_negative_scale.ValidateMeshNoNegativeScale.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance 'objectSet'</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_no_negative_scale.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance 'objectSet'\"\"\"\n    if not self.is_active(instance.data):\n        return\n    invalid = self.get_invalid(instance)\n\n    if invalid:\n        raise PublishValidationError(\n            \"Meshes found with negative scale:\\n\\n{0}\".format(\n                _as_report_list(sorted(invalid))\n            ),\n            title=\"Negative scale\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_non_manifold.html","title":"validate_mesh_non_manifold","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_non_manifold.html#client.ayon_maya.plugins.publish.validate_mesh_non_manifold.ValidateMeshNonManifold","title":"<code>ValidateMeshNonManifold</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure that meshes don't have non-manifold edges or vertices</p> <p>To debug the problem on the meshes you can use Maya's modeling tool: \"Mesh &gt; Cleanup...\"</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_non_manifold.py</code> <pre><code>class ValidateMeshNonManifold(plugin.MayaInstancePlugin,\n                              OptionalPyblishPluginMixin):\n    \"\"\"Ensure that meshes don't have non-manifold edges or vertices\n\n    To debug the problem on the meshes you can use Maya's modeling\n    tool: \"Mesh &gt; Cleanup...\"\n\n    \"\"\"\n\n    order = ValidateMeshOrder\n    families = ['model']\n    label = 'Mesh Non-Manifold Edges/Vertices'\n    actions = [ayon_maya.api.action.SelectInvalidAction,\n               CleanupMatchingPolygons]\n    optional = True\n\n    @staticmethod\n    def get_invalid(instance):\n\n        meshes = cmds.ls(instance, type='mesh', long=True)\n\n        invalid = []\n        for mesh in meshes:\n            components = cmds.polyInfo(mesh,\n                                       nonManifoldVertices=True,\n                                       nonManifoldEdges=True)\n            if components:\n                invalid.extend(components)\n\n        return invalid\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance 'objectSet'\"\"\"\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n\n        if invalid:\n            # Report only the meshes instead of all component indices\n            invalid_meshes = {\n                component.split(\".\", 1)[0] for component in invalid\n            }\n            invalid_meshes = _as_report_list(sorted(invalid_meshes))\n\n            raise PublishXmlValidationError(\n                plugin=self,\n                message=(\n                    \"Meshes found with non-manifold \"\n                    \"edges/vertices:\\n\\n{0}\".format(invalid_meshes)\n                )\n            )\n\n    @classmethod\n    def repair(cls, instance):\n        invalid_components = cls.get_invalid(instance)\n        if not invalid_components:\n            cls.log.info(\"No invalid components found to cleanup.\")\n            return\n\n        invalid_meshes = {\n            component.split(\".\", 1)[0] for component in invalid_components\n        }\n        poly_cleanup(meshes=list(invalid_meshes),\n                     select_only=True,\n                     non_manifold=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_non_manifold.html#client.ayon_maya.plugins.publish.validate_mesh_non_manifold.ValidateMeshNonManifold.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance 'objectSet'</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_non_manifold.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance 'objectSet'\"\"\"\n    if not self.is_active(instance.data):\n        return\n\n    invalid = self.get_invalid(instance)\n\n    if invalid:\n        # Report only the meshes instead of all component indices\n        invalid_meshes = {\n            component.split(\".\", 1)[0] for component in invalid\n        }\n        invalid_meshes = _as_report_list(sorted(invalid_meshes))\n\n        raise PublishXmlValidationError(\n            plugin=self,\n            message=(\n                \"Meshes found with non-manifold \"\n                \"edges/vertices:\\n\\n{0}\".format(invalid_meshes)\n            )\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_non_manifold.html#client.ayon_maya.plugins.publish.validate_mesh_non_manifold.poly_cleanup","title":"<code>poly_cleanup(version=4, meshes=None, all_meshes=False, select_only=False, history_on=True, quads=False, nsided=False, concave=False, holed=False, nonplanar=False, zeroGeom=False, zeroGeomTolerance=1e-05, zeroEdge=False, zeroEdgeTolerance=1e-05, zeroMap=False, zeroMapTolerance=1e-05, shared_uvs=False, non_manifold=False, lamina=False, invalid_components=False)</code>","text":"<p>Wrapper around <code>polyCleanupArgList</code> mel command</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_non_manifold.py</code> <pre><code>def poly_cleanup(version=4,\n                 meshes=None,\n                 # Version 1\n                 all_meshes=False,\n                 select_only=False,\n                 history_on=True,\n                 quads=False,\n                 nsided=False,\n                 concave=False,\n                 holed=False,\n                 nonplanar=False,\n                 zeroGeom=False,\n                 zeroGeomTolerance=1e-05,\n                 zeroEdge=False,\n                 zeroEdgeTolerance=1e-05,\n                 zeroMap=False,\n                 zeroMapTolerance=1e-05,\n                 # Version 2\n                 shared_uvs=False,\n                 non_manifold=False,\n                 # Version 3\n                 lamina=False,\n                 # Version 4\n                 invalid_components=False):\n    \"\"\"Wrapper around `polyCleanupArgList` mel command\"\"\"\n\n    # Get all inputs named as `dict` to easily do conversions and formatting\n    values = locals()\n\n    # Convert booleans to 1 or 0\n    for key in [\n        \"all_meshes\",\n        \"select_only\",\n        \"history_on\",\n        \"quads\",\n        \"nsided\",\n        \"concave\",\n        \"holed\",\n        \"nonplanar\",\n        \"zeroGeom\",\n        \"zeroEdge\",\n        \"zeroMap\",\n        \"shared_uvs\",\n        \"non_manifold\",\n        \"lamina\",\n        \"invalid_components\",\n    ]:\n        values[key] = 1 if values[key] else 0\n\n    cmd = (\n        'polyCleanupArgList {version} {{ '\n        '\"{all_meshes}\",'           # 0: All selectable meshes\n        '\"{select_only}\",'          # 1: Only perform a selection\n        '\"{history_on}\",'           # 2: Keep construction history\n        '\"{quads}\",'                # 3: Check for quads polys\n        '\"{nsided}\",'               # 4: Check for n-sides polys\n        '\"{concave}\",'              # 5: Check for concave polys\n        '\"{holed}\",'                # 6: Check for holed polys\n        '\"{nonplanar}\",'            # 7: Check for non-planar polys\n        '\"{zeroGeom}\",'             # 8: Check for 0 area faces\n        '\"{zeroGeomTolerance}\",'    # 9: Tolerance for face areas\n        '\"{zeroEdge}\",'             # 10: Check for 0 length edges\n        '\"{zeroEdgeTolerance}\",'    # 11: Tolerance for edge length\n        '\"{zeroMap}\",'              # 12: Check for 0 uv face area\n        '\"{zeroMapTolerance}\",'     # 13: Tolerance for uv face areas\n        '\"{shared_uvs}\",'           # 14: Unshare uvs that are shared\n                                    #     across vertices\n        '\"{non_manifold}\",'         # 15: Check for nonmanifold polys\n        '\"{lamina}\",'               # 16: Check for lamina polys\n        '\"{invalid_components}\"'    # 17: Remove invalid components\n        ' }};'.format(**values)\n    )\n\n    mel.eval(\"source polyCleanupArgList\")\n    if not all_meshes and meshes:\n        # Allow to specify meshes to run over by selecting them\n        cmds.select(meshes, replace=True)\n    mel.eval(cmd)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_non_zero_edge.html","title":"validate_mesh_non_zero_edge","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_non_zero_edge.html#client.ayon_maya.plugins.publish.validate_mesh_non_zero_edge.ValidateMeshNonZeroEdgeLength","title":"<code>ValidateMeshNonZeroEdgeLength</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate meshes don't have edges with a zero length.</p> <p>Based on Maya's polyCleanup 'Edges with zero length'.</p> Note <p>This can be slow for high-res meshes.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_non_zero_edge.py</code> <pre><code>class ValidateMeshNonZeroEdgeLength(plugin.MayaInstancePlugin,\n                                    OptionalPyblishPluginMixin):\n    \"\"\"Validate meshes don't have edges with a zero length.\n\n    Based on Maya's polyCleanup 'Edges with zero length'.\n\n    Note:\n        This can be slow for high-res meshes.\n\n    \"\"\"\n\n    order = ValidateMeshOrder\n    families = ['model']\n    label = 'Mesh Edge Length Non Zero'\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = True\n\n    __tolerance = 1e-5\n\n    @classmethod\n    def get_invalid(cls, instance):\n        \"\"\"Return the invalid edges.\n\n        Also see:\n\n        http://help.autodesk.com/view/MAYAUL/2015/ENU/?guid=Mesh__Cleanup\n\n        \"\"\"\n\n        meshes = cmds.ls(instance, type='mesh', long=True)\n        if not meshes:\n            return list()\n\n        valid_meshes = []\n        for mesh in meshes:\n            num_vertices = cmds.polyEvaluate(mesh, vertex=True)\n\n            if num_vertices == 0:\n                cls.log.warning(\n                    \"Skipping \\\"{}\\\", cause it does not have any \"\n                    \"vertices.\".format(mesh)\n                )\n                continue\n\n            valid_meshes.append(mesh)\n\n        # Get all edges\n        edges = ['{0}.e[*]'.format(node) for node in valid_meshes]\n\n        # Filter by constraint on edge length\n        invalid = lib.polyConstraint(edges,\n                                     t=0x8000,  # type=edge\n                                     length=1,\n                                     lengthbound=(0, cls.__tolerance))\n\n        return invalid\n\n    def process(self, instance):\n        \"\"\"Process all meshes\"\"\"\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            label = \"Meshes found with zero edge length\"\n            raise PublishValidationError(\n                message=\"{}: {}\".format(label, invalid),\n                title=label,\n                description=\"{}:\\n- \".format(label) + \"\\n- \".join(invalid)\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_non_zero_edge.html#client.ayon_maya.plugins.publish.validate_mesh_non_zero_edge.ValidateMeshNonZeroEdgeLength.get_invalid","title":"<code>get_invalid(instance)</code>  <code>classmethod</code>","text":"<p>Return the invalid edges.</p> <p>Also see:</p> <p>http://help.autodesk.com/view/MAYAUL/2015/ENU/?guid=Mesh__Cleanup</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_non_zero_edge.py</code> <pre><code>@classmethod\ndef get_invalid(cls, instance):\n    \"\"\"Return the invalid edges.\n\n    Also see:\n\n    http://help.autodesk.com/view/MAYAUL/2015/ENU/?guid=Mesh__Cleanup\n\n    \"\"\"\n\n    meshes = cmds.ls(instance, type='mesh', long=True)\n    if not meshes:\n        return list()\n\n    valid_meshes = []\n    for mesh in meshes:\n        num_vertices = cmds.polyEvaluate(mesh, vertex=True)\n\n        if num_vertices == 0:\n            cls.log.warning(\n                \"Skipping \\\"{}\\\", cause it does not have any \"\n                \"vertices.\".format(mesh)\n            )\n            continue\n\n        valid_meshes.append(mesh)\n\n    # Get all edges\n    edges = ['{0}.e[*]'.format(node) for node in valid_meshes]\n\n    # Filter by constraint on edge length\n    invalid = lib.polyConstraint(edges,\n                                 t=0x8000,  # type=edge\n                                 length=1,\n                                 lengthbound=(0, cls.__tolerance))\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_non_zero_edge.html#client.ayon_maya.plugins.publish.validate_mesh_non_zero_edge.ValidateMeshNonZeroEdgeLength.process","title":"<code>process(instance)</code>","text":"<p>Process all meshes</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_non_zero_edge.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all meshes\"\"\"\n    if not self.is_active(instance.data):\n        return\n\n    invalid = self.get_invalid(instance)\n    if invalid:\n        label = \"Meshes found with zero edge length\"\n        raise PublishValidationError(\n            message=\"{}: {}\".format(label, invalid),\n            title=label,\n            description=\"{}:\\n- \".format(label) + \"\\n- \".join(invalid)\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_normals_unlocked.html","title":"validate_mesh_normals_unlocked","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_normals_unlocked.html#client.ayon_maya.plugins.publish.validate_mesh_normals_unlocked.ValidateMeshNormalsUnlocked","title":"<code>ValidateMeshNormalsUnlocked</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate all meshes in the instance have unlocked normals</p> These can be unlocked manually through <p>Modeling &gt; Mesh Display &gt; Unlock Normals</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_normals_unlocked.py</code> <pre><code>class ValidateMeshNormalsUnlocked(plugin.MayaInstancePlugin,\n                                  OptionalPyblishPluginMixin):\n    \"\"\"Validate all meshes in the instance have unlocked normals\n\n    These can be unlocked manually through:\n        Modeling &gt; Mesh Display &gt; Unlock Normals\n\n    \"\"\"\n\n    order = ValidateMeshOrder\n    families = ['model']\n    label = 'Mesh Normals Unlocked'\n    actions = [ayon_maya.api.action.SelectInvalidAction,\n               RepairAction]\n    optional = True\n\n    @staticmethod\n    def has_locked_normals(mesh):\n        \"\"\"Return whether mesh has at least one locked normal\"\"\"\n\n        sel = om2.MGlobal.getSelectionListByName(mesh)\n        node = sel.getDependNode(0)\n        fn_mesh = om2.MFnMesh(node)\n        _, normal_ids = fn_mesh.getNormalIds()\n        for normal_id in normal_ids:\n            if fn_mesh.isNormalLocked(normal_id):\n                return True\n        return False\n\n    @classmethod\n    def get_invalid(cls, instance):\n        \"\"\"Return the meshes with locked normals in instance\"\"\"\n\n        meshes = cmds.ls(instance, type='mesh', long=True)\n        return [mesh for mesh in meshes if cls.has_locked_normals(mesh)]\n\n    def process(self, instance):\n        \"\"\"Raise invalid when any of the meshes have locked normals\"\"\"\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n\n        if invalid:\n            raise PublishValidationError(\n                \"Meshes found with locked normals:\\n\\n{0}\".format(\n                    _as_report_list(sorted(invalid))\n                ),\n                title=\"Locked normals\"\n            )\n\n    @classmethod\n    def repair(cls, instance):\n        \"\"\"Unlocks all normals on the meshes in this instance.\"\"\"\n        invalid = cls.get_invalid(instance)\n        for mesh in invalid:\n            cmds.polyNormalPerVertex(mesh, unFreezeNormal=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_normals_unlocked.html#client.ayon_maya.plugins.publish.validate_mesh_normals_unlocked.ValidateMeshNormalsUnlocked.get_invalid","title":"<code>get_invalid(instance)</code>  <code>classmethod</code>","text":"<p>Return the meshes with locked normals in instance</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_normals_unlocked.py</code> <pre><code>@classmethod\ndef get_invalid(cls, instance):\n    \"\"\"Return the meshes with locked normals in instance\"\"\"\n\n    meshes = cmds.ls(instance, type='mesh', long=True)\n    return [mesh for mesh in meshes if cls.has_locked_normals(mesh)]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_normals_unlocked.html#client.ayon_maya.plugins.publish.validate_mesh_normals_unlocked.ValidateMeshNormalsUnlocked.has_locked_normals","title":"<code>has_locked_normals(mesh)</code>  <code>staticmethod</code>","text":"<p>Return whether mesh has at least one locked normal</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_normals_unlocked.py</code> <pre><code>@staticmethod\ndef has_locked_normals(mesh):\n    \"\"\"Return whether mesh has at least one locked normal\"\"\"\n\n    sel = om2.MGlobal.getSelectionListByName(mesh)\n    node = sel.getDependNode(0)\n    fn_mesh = om2.MFnMesh(node)\n    _, normal_ids = fn_mesh.getNormalIds()\n    for normal_id in normal_ids:\n        if fn_mesh.isNormalLocked(normal_id):\n            return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_normals_unlocked.html#client.ayon_maya.plugins.publish.validate_mesh_normals_unlocked.ValidateMeshNormalsUnlocked.process","title":"<code>process(instance)</code>","text":"<p>Raise invalid when any of the meshes have locked normals</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_normals_unlocked.py</code> <pre><code>def process(self, instance):\n    \"\"\"Raise invalid when any of the meshes have locked normals\"\"\"\n    if not self.is_active(instance.data):\n        return\n\n    invalid = self.get_invalid(instance)\n\n    if invalid:\n        raise PublishValidationError(\n            \"Meshes found with locked normals:\\n\\n{0}\".format(\n                _as_report_list(sorted(invalid))\n            ),\n            title=\"Locked normals\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_normals_unlocked.html#client.ayon_maya.plugins.publish.validate_mesh_normals_unlocked.ValidateMeshNormalsUnlocked.repair","title":"<code>repair(instance)</code>  <code>classmethod</code>","text":"<p>Unlocks all normals on the meshes in this instance.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_normals_unlocked.py</code> <pre><code>@classmethod\ndef repair(cls, instance):\n    \"\"\"Unlocks all normals on the meshes in this instance.\"\"\"\n    invalid = cls.get_invalid(instance)\n    for mesh in invalid:\n        cmds.polyNormalPerVertex(mesh, unFreezeNormal=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_overlapping_uvs.html","title":"validate_mesh_overlapping_uvs","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_overlapping_uvs.html#client.ayon_maya.plugins.publish.validate_mesh_overlapping_uvs.GetOverlappingUVs","title":"<code>GetOverlappingUVs</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_overlapping_uvs.py</code> <pre><code>class GetOverlappingUVs(object):\n\n    def _createBoundingCircle(self, meshfn):\n        \"\"\" Represent a face by center and radius\n\n            :param meshfn: MFnMesh class\n            :type meshfn: :class:`maya.api.OpenMaya.MFnMesh`\n            :returns: (center, radius)\n            :rtype: tuple\n        \"\"\"\n        center = []\n        radius = []\n        for i in range(meshfn.numPolygons):  # noqa: F821\n            # get uvs from face\n            uarray = []\n            varray = []\n            for j in range(len(meshfn.getPolygonVertices(i))):\n                uv = meshfn.getPolygonUV(i, j)\n                uarray.append(uv[0])\n                varray.append(uv[1])\n\n            # loop through all vertices to construct edges/rays\n            cu = 0.0\n            cv = 0.0\n            for j in range(len(uarray)):\n                cu += uarray[j]\n                cv += varray[j]\n\n            cu /= len(uarray)\n            cv /= len(varray)\n            rsqr = 0.0\n            for j in range(len(varray)):\n                du = uarray[j] - cu\n                dv = varray[j] - cv\n                dsqr = du * du + dv * dv\n                rsqr = dsqr if dsqr &gt; rsqr else rsqr\n\n            center.append(cu)\n            center.append(cv)\n            radius.append(math.sqrt(rsqr))\n\n        return center, radius\n\n    def _createRayGivenFace(self, meshfn, faceId):\n        \"\"\" Represent a face by a series of edges(rays), i.e.\n\n            :param meshfn: MFnMesh class\n            :type meshfn: :class:`maya.api.OpenMaya.MFnMesh`\n            :param faceId: face id\n            :type faceId: int\n            :returns: False if no valid uv's.\n                      \"\"(True, orig, vec)\"\" or \"\"(False, None, None)\"\"\n            :rtype: tuple\n\n            .. code-block:: python\n\n            orig = [orig1u, orig1v, orig2u, orig2v, ... ]\n            vec  = [vec1u,  vec1v,  vec2u,  vec2v,  ... ]\n        \"\"\"\n        orig = []\n        vec = []\n        # get uvs\n        uarray = []\n        varray = []\n        for i in range(len(meshfn.getPolygonVertices(faceId))):\n            uv = meshfn.getPolygonUV(faceId, i)\n            uarray.append(uv[0])\n            varray.append(uv[1])\n\n        if len(uarray) == 0 or len(varray) == 0:\n            return (False, None, None)\n\n        # loop through all vertices to construct edges/rays\n        u = uarray[-1]\n        v = varray[-1]\n        for i in range(len(uarray)):  # noqa: F821\n            orig.append(uarray[i])\n            orig.append(varray[i])\n            vec.append(u - uarray[i])\n            vec.append(v - varray[i])\n            u = uarray[i]\n            v = varray[i]\n\n        return (True, orig, vec)\n\n    def _checkCrossingEdges(self,\n                            face1Orig,\n                            face1Vec,\n                            face2Orig,\n                            face2Vec):\n        \"\"\" Check if there are crossing edges between two faces.\n            Return True if there are crossing edges and False otherwise.\n\n            :param face1Orig: origin of face 1\n            :type face1Orig: tuple\n            :param face1Vec: face 1 edges\n            :type face1Vec: list\n            :param face2Orig: origin of face 2\n            :type face2Orig: tuple\n            :param face2Vec: face 2 edges\n            :type face2Vec: list\n\n            A face is represented by a series of edges(rays), i.e.\n            .. code-block:: python\n\n               faceOrig[] = [orig1u, orig1v, orig2u, orig2v, ... ]\n               faceVec[]  = [vec1u,  vec1v,  vec2u,  vec2v,  ... ]\n        \"\"\"\n        face1Size = len(face1Orig)\n        face2Size = len(face2Orig)\n        for i in range(0, face1Size, 2):  # noqa: F821\n            o1x = face1Orig[i]\n            o1y = face1Orig[i+1]\n            v1x = face1Vec[i]\n            v1y = face1Vec[i+1]\n            n1x = v1y\n            n1y = -v1x\n            for j in range(0, face2Size, 2):  # noqa: F821\n                # Given ray1(O1, V1) and ray2(O2, V2)\n                # Normal of ray1 is (V1.y, V1.x)\n                o2x = face2Orig[j]\n                o2y = face2Orig[j+1]\n                v2x = face2Vec[j]\n                v2y = face2Vec[j+1]\n                n2x = v2y\n                n2y = -v2x\n\n                # Find t for ray2\n                # t = [(o1x-o2x)n1x + (o1y-o2y)n1y] /\n                # (v2x * n1x + v2y * n1y)\n                denum = v2x * n1x + v2y * n1y\n                # Edges are parallel if denum is close to 0.\n                if math.fabs(denum) &lt; 0.000001:\n                    continue\n                t2 = ((o1x-o2x) * n1x + (o1y-o2y) * n1y) / denum\n                if (t2 &lt; 0.00001 or t2 &gt; 0.99999):\n                    continue\n\n                # Find t for ray1\n                # t = [(o2x-o1x)n2x\n                # + (o2y-o1y)n2y] / (v1x * n2x + v1y * n2y)\n                denum = v1x * n2x + v1y * n2y\n                # Edges are parallel if denum is close to 0.\n                if math.fabs(denum) &lt; 0.000001:\n                    continue\n                t1 = ((o2x-o1x) * n2x + (o2y-o1y) * n2y) / denum\n\n                # Edges intersect\n                if (t1 &gt; 0.00001 and t1 &lt; 0.99999):\n                    return 1\n\n        return 0\n\n    def _getOverlapUVFaces(self, meshName):\n        \"\"\" Return overlapping faces\n\n            :param meshName: name of mesh\n            :type meshName: str\n            :returns: list of overlapping faces\n            :rtype: list\n        \"\"\"\n        faces = []\n        # find polygon mesh node\n        selList = om.MSelectionList()\n        selList.add(meshName)\n        mesh = selList.getDependNode(0)\n        if mesh.apiType() == om.MFn.kTransform:\n            dagPath = selList.getDagPath(0)\n            dagFn = om.MFnDagNode(dagPath)\n            child = dagFn.child(0)\n            if child.apiType() != om.MFn.kMesh:\n                raise Exception(\"Can't find polygon mesh\")\n            mesh = child\n        meshfn = om.MFnMesh(mesh)\n\n        center, radius = self._createBoundingCircle(meshfn)\n        for i in range(meshfn.numPolygons):  # noqa: F821\n            rayb1, face1Orig, face1Vec = self._createRayGivenFace(meshfn, i)\n            if not rayb1:\n                continue\n            cui = center[2*i]\n            cvi = center[2*i+1]\n            ri = radius[i]\n            # Exclude the degenerate face\n            # if(area(face1Orig) &lt; 0.000001) continue;\n            # Loop through face j where j != i\n            for j in range(i+1, meshfn.numPolygons):\n                cuj = center[2*j]\n                cvj = center[2*j+1]\n                rj = radius[j]\n                du = cuj - cui\n                dv = cvj - cvi\n                dsqr = du * du + dv * dv\n                # Quick rejection if bounding circles don't overlap\n                if (dsqr &gt;= (ri + rj) * (ri + rj)):\n                    continue\n\n                rayb2, face2Orig, face2Vec = self._createRayGivenFace(meshfn,\n                                                                      j)\n                if not rayb2:\n                    continue\n                # Exclude the degenerate face\n                # if(area(face2Orig) &lt; 0.000001): continue;\n                if self._checkCrossingEdges(face1Orig,\n                                            face1Vec,\n                                            face2Orig,\n                                            face2Vec):\n                    face1 = '%s.f[%d]' % (meshfn.name(), i)\n                    face2 = '%s.f[%d]' % (meshfn.name(), j)\n                    if face1 not in faces:\n                        faces.append(face1)\n                    if face2 not in faces:\n                        faces.append(face2)\n        return faces\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_overlapping_uvs.html#client.ayon_maya.plugins.publish.validate_mesh_overlapping_uvs.ValidateMeshHasOverlappingUVs","title":"<code>ValidateMeshHasOverlappingUVs</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate the current mesh overlapping UVs.</p> <p>It validates whether the current UVs are overlapping or not. It is optional to warn publisher about it.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_overlapping_uvs.py</code> <pre><code>class ValidateMeshHasOverlappingUVs(plugin.MayaInstancePlugin,\n                                    OptionalPyblishPluginMixin):\n    \"\"\" Validate the current mesh overlapping UVs.\n\n    It validates whether the current UVs are overlapping or not.\n    It is optional to warn publisher about it.\n    \"\"\"\n\n    order = ValidateMeshOrder\n    families = ['model']\n    label = 'Mesh Has Overlapping UVs'\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = True\n\n    @classmethod\n    def _get_overlapping_uvs(cls, mesh):\n        \"\"\"Return overlapping UVs of mesh.\n\n        Args:\n            mesh (str): Mesh node name\n\n        Returns:\n            list: Overlapping uvs for the input mesh in all uv sets.\n\n        \"\"\"\n        ovl = GetOverlappingUVs()\n\n        # Store original uv set\n        original_current_uv_set = cmds.polyUVSet(mesh,\n                                                 query=True,\n                                                 currentUVSet=True)[0]\n\n        overlapping_faces = []\n        for uv_set in cmds.polyUVSet(mesh, query=True, allUVSets=True):\n            cmds.polyUVSet(mesh, currentUVSet=True, uvSet=uv_set)\n            overlapping_faces.extend(ovl._getOverlapUVFaces(mesh))\n\n        # Restore original uv set\n        cmds.polyUVSet(mesh, currentUVSet=True, uvSet=original_current_uv_set)\n\n        return overlapping_faces\n\n    @classmethod\n    def get_invalid(cls, instance, compute=False):\n\n        if compute:\n            invalid = []\n            for node in cmds.ls(instance, type=\"mesh\"):\n                faces = cls._get_overlapping_uvs(node)\n                invalid.extend(faces)\n\n            instance.data[\"overlapping_faces\"] = invalid\n\n        return instance.data.get(\"overlapping_faces\", [])\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance, compute=True)\n        if invalid:\n            raise PublishValidationError(\n                \"Meshes found with overlapping UVs:\\n\\n{0}\".format(\n                    _as_report_list(sorted(invalid))\n                ),\n                title=\"Overlapping UVs\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_shader_connections.html","title":"validate_mesh_shader_connections","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_shader_connections.html#client.ayon_maya.plugins.publish.validate_mesh_shader_connections.ValidateMeshShaderConnections","title":"<code>ValidateMeshShaderConnections</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure mesh shading engine connections are valid.</p> <p>In some scenarios Maya keeps connections to multiple shaders even if just a single one is assigned on the shape.</p> <p>These are related sets returned by <code>maya.cmds.listSets</code> that don't actually have the shape as member.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_shader_connections.py</code> <pre><code>class ValidateMeshShaderConnections(plugin.MayaInstancePlugin,\n                                    OptionalPyblishPluginMixin):\n    \"\"\"Ensure mesh shading engine connections are valid.\n\n    In some scenarios Maya keeps connections to multiple shaders even if just\n    a single one is assigned on the shape.\n\n    These are related sets returned by `maya.cmds.listSets` that don't\n    actually have the shape as member.\n\n    \"\"\"\n\n    order = ValidateMeshOrder\n    families = ['model']\n    label = \"Mesh Shader Connections\"\n    actions = [ayon_maya.api.action.SelectInvalidAction,\n               RepairAction]\n    optional = True\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance 'objectSet'\"\"\"\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n\n        if invalid:\n            raise PublishValidationError(\n                \"Shapes found with invalid shader connections: \"\n                \"{0}\".format(invalid))\n\n    @staticmethod\n    def get_invalid(instance):\n\n        nodes = instance[:]\n        shapes = cmds.ls(nodes, noIntermediate=True, long=True, type=\"mesh\")\n        invalid = get_invalid_sets(shapes).keys()\n\n        return invalid\n\n    @classmethod\n    def repair(cls, instance):\n\n        shapes = cls.get_invalid(instance)\n        invalid = get_invalid_sets(shapes)\n        for shape, invalid_sets in invalid.items():\n            for set_node in invalid_sets:\n                disconnect(shape, set_node)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_shader_connections.html#client.ayon_maya.plugins.publish.validate_mesh_shader_connections.ValidateMeshShaderConnections.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance 'objectSet'</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_shader_connections.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance 'objectSet'\"\"\"\n    if not self.is_active(instance.data):\n        return\n    invalid = self.get_invalid(instance)\n\n    if invalid:\n        raise PublishValidationError(\n            \"Shapes found with invalid shader connections: \"\n            \"{0}\".format(invalid))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_shader_connections.html#client.ayon_maya.plugins.publish.validate_mesh_shader_connections.disconnect","title":"<code>disconnect(node_a, node_b)</code>","text":"<p>Remove all connections between node a and b.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_shader_connections.py</code> <pre><code>def disconnect(node_a, node_b):\n    \"\"\"Remove all connections between node a and b.\"\"\"\n\n    # Disconnect outputs\n    outputs = cmds.listConnections(node_a,\n                                   plugs=True,\n                                   connections=True,\n                                   source=False,\n                                   destination=True)\n    for output, destination in pairs(outputs):\n        if destination.split(\".\", 1)[0] == node_b:\n            cmds.disconnectAttr(output, destination)\n\n    # Disconnect inputs\n    inputs = cmds.listConnections(node_a,\n                                  plugs=True,\n                                  connections=True,\n                                  source=True,\n                                  destination=False)\n    for input, source in pairs(inputs):\n        if source.split(\".\", 1)[0] == node_b:\n            cmds.disconnectAttr(source, input)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_shader_connections.html#client.ayon_maya.plugins.publish.validate_mesh_shader_connections.get_invalid_sets","title":"<code>get_invalid_sets(shapes)</code>","text":"<p>Return invalid sets for the given shapes.</p> <p>This takes a list of shape nodes to cache the set members for overlapping sets in the queries. This avoids many Maya set member queries.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary of shapes and their invalid sets, e.g. {\"pCubeShape\": [\"set1\", \"set2\"]}</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_shader_connections.py</code> <pre><code>def get_invalid_sets(shapes):\n    \"\"\"Return invalid sets for the given shapes.\n\n    This takes a list of shape nodes to cache the set members for overlapping\n    sets in the queries. This avoids many Maya set member queries.\n\n    Returns:\n        dict: Dictionary of shapes and their invalid sets, e.g.\n            {\"pCubeShape\": [\"set1\", \"set2\"]}\n\n    \"\"\"\n\n    cache = dict()\n    invalid = dict()\n\n    # Collect the sets from the shape\n    for shape in shapes:\n        invalid_sets = []\n        sets = cmds.listSets(object=shape, t=1, extendToShape=False) or []\n        for set_ in sets:\n\n            members = cache.get(set_, None)\n            if members is None:\n                members = set(cmds.ls(cmds.sets(set_,\n                                                query=True,\n                                                nodesOnly=True), long=True))\n                cache[set_] = members\n\n            # If the shape is not actually present as a member of the set\n            # consider it invalid\n            if shape not in members:\n                invalid_sets.append(set_)\n\n        if invalid_sets:\n            invalid[shape] = invalid_sets\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_shader_connections.html#client.ayon_maya.plugins.publish.validate_mesh_shader_connections.pairs","title":"<code>pairs(iterable)</code>","text":"<p>Iterate over iterable per group of two</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_shader_connections.py</code> <pre><code>def pairs(iterable):\n    \"\"\"Iterate over iterable per group of two\"\"\"\n    a = iter(iterable)\n    for i, y in zip(a, a):\n        yield i, y\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_single_uv_set.html","title":"validate_mesh_single_uv_set","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_single_uv_set.html#client.ayon_maya.plugins.publish.validate_mesh_single_uv_set.ValidateMeshSingleUVSet","title":"<code>ValidateMeshSingleUVSet</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Warn on multiple UV sets existing for each polygon mesh.</p> <p>On versions prior to Maya 2017 this will force no multiple uv sets because the Alembic exports in Maya prior to 2017 don't support writing multiple UV sets.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_single_uv_set.py</code> <pre><code>class ValidateMeshSingleUVSet(plugin.MayaInstancePlugin,\n                              OptionalPyblishPluginMixin):\n    \"\"\"Warn on multiple UV sets existing for each polygon mesh.\n\n    On versions prior to Maya 2017 this will force no multiple uv sets because\n    the Alembic exports in Maya prior to 2017 don't support writing multiple\n    UV sets.\n\n    \"\"\"\n\n    order = ValidateMeshOrder\n    families = ['model', 'pointcache']\n    optional = True\n    label = \"Mesh Single UV Set\"\n    actions = [ayon_maya.api.action.SelectInvalidAction,\n               RepairAction]\n\n    @staticmethod\n    def get_invalid(instance):\n\n        meshes = cmds.ls(instance, type='mesh', long=True)\n\n        invalid = []\n        for mesh in meshes:\n            uvSets = cmds.polyUVSet(mesh,\n                                    query=True,\n                                    allUVSets=True) or []\n\n            # ensure unique (sometimes maya will list 'map1' twice)\n            uvSets = set(uvSets)\n\n            if len(uvSets) != 1:\n                invalid.append(mesh)\n\n        return invalid\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance 'objectSet'\"\"\"\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n\n        if invalid:\n\n            message = \"Nodes found with multiple UV sets: {0}\".format(invalid)\n\n            # Maya 2017 and up allows multiple UV sets in Alembic exports\n            # so we allow it, yet just warn the user to ensure they know about\n            # the other UV sets.\n            allowed = int(cmds.about(version=True)) &gt;= 2017\n\n            if allowed:\n                self.log.warning(message)\n            else:\n                raise PublishValidationError(message)\n\n    @classmethod\n    def repair(cls, instance):\n        for mesh in cls.get_invalid(instance):\n            lib.remove_other_uv_sets(mesh)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_single_uv_set.html#client.ayon_maya.plugins.publish.validate_mesh_single_uv_set.ValidateMeshSingleUVSet.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance 'objectSet'</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_single_uv_set.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance 'objectSet'\"\"\"\n    if not self.is_active(instance.data):\n        return\n\n    invalid = self.get_invalid(instance)\n\n    if invalid:\n\n        message = \"Nodes found with multiple UV sets: {0}\".format(invalid)\n\n        # Maya 2017 and up allows multiple UV sets in Alembic exports\n        # so we allow it, yet just warn the user to ensure they know about\n        # the other UV sets.\n        allowed = int(cmds.about(version=True)) &gt;= 2017\n\n        if allowed:\n            self.log.warning(message)\n        else:\n            raise PublishValidationError(message)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_uv_set_map1.html","title":"validate_mesh_uv_set_map1","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_uv_set_map1.html#client.ayon_maya.plugins.publish.validate_mesh_uv_set_map1.ValidateMeshUVSetMap1","title":"<code>ValidateMeshUVSetMap1</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate model's default set exists and is named 'map1'.</p> <p>In Maya meshes by default have a uv set named \"map1\" that cannot be deleted. It can be renamed however, introducing some issues with some renderers. As such we ensure the first (default) UV set index is named \"map1\".</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_uv_set_map1.py</code> <pre><code>class ValidateMeshUVSetMap1(plugin.MayaInstancePlugin,\n                            OptionalPyblishPluginMixin):\n    \"\"\"Validate model's default set exists and is named 'map1'.\n\n    In Maya meshes by default have a uv set named \"map1\" that cannot be\n    deleted. It can be renamed however, introducing some issues with some\n    renderers. As such we ensure the first (default) UV set index is named\n    \"map1\".\n\n    \"\"\"\n\n    order = ValidateMeshOrder\n    families = ['model']\n    optional = True\n    label = \"Mesh has map1 UV Set\"\n    actions = [ayon_maya.api.action.SelectInvalidAction,\n               RepairAction]\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        meshes = cmds.ls(instance, type='mesh', long=True)\n\n        invalid = []\n        for mesh in meshes:\n\n            # Get existing mapping of uv sets by index\n            indices = cmds.polyUVSet(mesh, query=True, allUVSetsIndices=True)\n            maps = cmds.polyUVSet(mesh, query=True, allUVSets=True)\n            if not indices or not maps:\n                cls.log.warning(\"Mesh has no UV set: %s\", mesh)\n                invalid.append(mesh)\n                continue\n\n            mapping = dict(zip(indices, maps))\n\n            # Get the uv set at index zero.\n            name = mapping[0]\n            if name != \"map1\":\n                invalid.append(mesh)\n\n        return invalid\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance 'objectSet'\"\"\"\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n\n            invalid_list = \"\\n\".join(f\"- {node}\" for node in invalid)\n\n            raise PublishValidationError(\n                \"Meshes found without 'map1' UV set:\\n\"\n                \"{0}\".format(invalid_list),\n                description=self.get_description()\n            )\n\n    @classmethod\n    def repair(cls, instance):\n        \"\"\"Rename uv map at index zero to map1\"\"\"\n\n        for mesh in cls.get_invalid(instance):\n\n            # Get existing mapping of uv sets by index\n            indices = cmds.polyUVSet(mesh, query=True, allUVSetsIndices=True)\n            maps = cmds.polyUVSet(mesh, query=True, allUVSets=True)\n            if not indices or not maps:\n                # No UV set exist at all, create a `map1` uv set\n                # This may fail silently if the mesh has no geometry at all\n                cmds.polyUVSet(mesh, create=True, uvSet=\"map1\")\n                continue\n\n            mapping = dict(zip(indices, maps))\n\n            # Ensure there is no uv set named map1 to avoid\n            # a clash on renaming the \"default uv set\" to map1\n            existing = set(maps)\n            if \"map1\" in existing:\n\n                # Find a unique name index\n                i = 2\n                while True:\n                    name = \"map{0}\".format(i)\n                    if name not in existing:\n                        break\n                    i += 1\n\n                cls.log.warning(\"Renaming clashing uv set name on mesh\"\n                                \" %s to '%s'\", mesh, name)\n\n                cmds.polyUVSet(mesh,\n                               rename=True,\n                               uvSet=\"map1\",\n                               newUVSet=name)\n\n            # Rename the initial index to map1\n            original = mapping[0]\n            cmds.polyUVSet(mesh,\n                           rename=True,\n                           uvSet=original,\n                           newUVSet=\"map1\")\n\n    @staticmethod\n    def get_description():\n        return inspect.cleandoc(\"\"\"### Mesh found without map1 uv set\n\n        A mesh must have a default UV set named `map1` to adhere to the default\n        mesh behavior of Maya meshes.\n\n        There may be meshes that:\n        - Have no UV set\n        - Have no `map1` uv set but are using a different name\n        - Have a `map1` uv set, but it's not the default (first index)\n\n\n        #### Repair\n\n        Using repair will try to make the first UV set the `map1` uv set. If it\n        does not exist yet it will be created or renames the current first\n        UV set to `map1`.\n        \"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_uv_set_map1.html#client.ayon_maya.plugins.publish.validate_mesh_uv_set_map1.ValidateMeshUVSetMap1.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance 'objectSet'</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_uv_set_map1.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance 'objectSet'\"\"\"\n    if not self.is_active(instance.data):\n        return\n\n    invalid = self.get_invalid(instance)\n    if invalid:\n\n        invalid_list = \"\\n\".join(f\"- {node}\" for node in invalid)\n\n        raise PublishValidationError(\n            \"Meshes found without 'map1' UV set:\\n\"\n            \"{0}\".format(invalid_list),\n            description=self.get_description()\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_uv_set_map1.html#client.ayon_maya.plugins.publish.validate_mesh_uv_set_map1.ValidateMeshUVSetMap1.repair","title":"<code>repair(instance)</code>  <code>classmethod</code>","text":"<p>Rename uv map at index zero to map1</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_uv_set_map1.py</code> <pre><code>@classmethod\ndef repair(cls, instance):\n    \"\"\"Rename uv map at index zero to map1\"\"\"\n\n    for mesh in cls.get_invalid(instance):\n\n        # Get existing mapping of uv sets by index\n        indices = cmds.polyUVSet(mesh, query=True, allUVSetsIndices=True)\n        maps = cmds.polyUVSet(mesh, query=True, allUVSets=True)\n        if not indices or not maps:\n            # No UV set exist at all, create a `map1` uv set\n            # This may fail silently if the mesh has no geometry at all\n            cmds.polyUVSet(mesh, create=True, uvSet=\"map1\")\n            continue\n\n        mapping = dict(zip(indices, maps))\n\n        # Ensure there is no uv set named map1 to avoid\n        # a clash on renaming the \"default uv set\" to map1\n        existing = set(maps)\n        if \"map1\" in existing:\n\n            # Find a unique name index\n            i = 2\n            while True:\n                name = \"map{0}\".format(i)\n                if name not in existing:\n                    break\n                i += 1\n\n            cls.log.warning(\"Renaming clashing uv set name on mesh\"\n                            \" %s to '%s'\", mesh, name)\n\n            cmds.polyUVSet(mesh,\n                           rename=True,\n                           uvSet=\"map1\",\n                           newUVSet=name)\n\n        # Rename the initial index to map1\n        original = mapping[0]\n        cmds.polyUVSet(mesh,\n                       rename=True,\n                       uvSet=original,\n                       newUVSet=\"map1\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_vertices_have_edges.html","title":"validate_mesh_vertices_have_edges","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mesh_vertices_have_edges.html#client.ayon_maya.plugins.publish.validate_mesh_vertices_have_edges.ValidateMeshVerticesHaveEdges","title":"<code>ValidateMeshVerticesHaveEdges</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate meshes have only vertices that are connected to edges.</p> <p>Maya can have invalid geometry with vertices that have no edges or faces connected to them.</p> <p>In Maya 2016 EXT 2 and later there's a command to fix this:     <code>maya.cmds.polyClean(mesh, cleanVertices=True)</code></p> <p>In older versions of Maya it works to select the invalid vertices and merge the components.</p> <p>To find these invalid vertices select all vertices of the mesh that are visible in the viewport (drag to select), afterwards invert your selection (Ctrl + Shift + I). The remaining selection contains the invalid vertices.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_mesh_vertices_have_edges.py</code> <pre><code>class ValidateMeshVerticesHaveEdges(plugin.MayaInstancePlugin,\n                                    OptionalPyblishPluginMixin):\n    \"\"\"Validate meshes have only vertices that are connected to edges.\n\n    Maya can have invalid geometry with vertices that have no edges or\n    faces connected to them.\n\n    In Maya 2016 EXT 2 and later there's a command to fix this:\n        `maya.cmds.polyClean(mesh, cleanVertices=True)`\n\n    In older versions of Maya it works to select the invalid vertices\n    and merge the components.\n\n    To find these invalid vertices select all vertices of the mesh\n    that are visible in the viewport (drag to select), afterwards\n    invert your selection (Ctrl + Shift + I). The remaining selection\n    contains the invalid vertices.\n\n    \"\"\"\n\n    order = ValidateMeshOrder\n    families = ['model']\n    label = 'Mesh Vertices Have Edges'\n    actions = [ayon_maya.api.action.SelectInvalidAction,\n               RepairAction]\n    optional = True\n\n    @classmethod\n    def repair(cls, instance):\n\n        # This fix only works in Maya 2016 EXT2 and newer\n        if float(cmds.about(version=True)) &lt;= 2016.0:\n            raise PublishValidationError(\n                (\"Repair not supported in Maya version below \"\n                 \"2016 EXT 2\"))\n\n        invalid = cls.get_invalid(instance)\n        for node in invalid:\n            cmds.polyClean(node, cleanVertices=True)\n\n    @classmethod\n    def get_invalid(cls, instance):\n        invalid = []\n\n        meshes = cmds.ls(instance, type=\"mesh\", long=True)\n        for mesh in meshes:\n            num_vertices = cmds.polyEvaluate(mesh, vertex=True)\n\n            if num_vertices == 0:\n                cls.log.warning(\n                    \"Skipping \\\"{}\\\", cause it does not have any \"\n                    \"vertices.\".format(mesh)\n                )\n                continue\n\n            # Vertices from all edges\n            edges = \"%s.e[*]\" % mesh\n            vertices = cmds.polyListComponentConversion(edges, toVertex=True)\n            num_vertices_from_edges = len_flattened(vertices)\n\n            if num_vertices != num_vertices_from_edges:\n                invalid.append(mesh)\n\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                (\"Meshes found in instance with vertices that \"\n                 \"have no edges: {}\").format(invalid))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_model_content.html","title":"validate_model_content","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_model_content.html#client.ayon_maya.plugins.publish.validate_model_content.ValidateModelContent","title":"<code>ValidateModelContent</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Adheres to the content of 'model' product type</p> <p>See <code>get_description</code> for more details.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_model_content.py</code> <pre><code>class ValidateModelContent(plugin.MayaInstancePlugin,\n                           OptionalPyblishPluginMixin):\n    \"\"\"Adheres to the content of 'model' product type\n\n    See `get_description` for more details.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"model\"]\n    label = \"Model Content\"\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n\n    validate_top_group = True\n    optional = False\n\n    allowed = ('mesh', 'transform', 'nurbsCurve', 'nurbsSurface', 'locator')\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        content_instance = instance.data.get(\"setMembers\", None)\n        if not content_instance:\n            cls.log.error(\"Model instance has no nodes. \"\n                          \"It is not allowed to be empty\")\n            return [instance.data[\"instance_node\"]]\n\n        # All children will be included in the extracted export so we also\n        # validate *all* descendents of the set members and we skip any\n        # intermediate shapes\n        descendants = cmds.listRelatives(content_instance,\n                                         allDescendents=True,\n                                         fullPath=True) or []\n        descendants = cmds.ls(descendants, noIntermediate=True, long=True)\n        content_instance = list(set(content_instance + descendants))\n\n        # Ensure only valid node types\n        nodes = cmds.ls(content_instance, long=True)\n        valid = cmds.ls(content_instance, long=True, type=cls.allowed)\n        invalid = set(nodes) - set(valid)\n\n        if invalid:\n            # List as bullet points\n            invalid_bullets = \"\\n\".join(f\"- {node}\" for node in invalid)\n\n            cls.log.error(\n                \"These nodes are not allowed:\\n{}\\n\\n\"\n                \"The valid node types are: {}\".format(\n                    invalid_bullets, \", \".join(cls.allowed))\n            )\n            return list(invalid)\n\n        if not valid:\n            cls.log.error(\n                \"No valid nodes in the model instance.\\n\"\n                \"The valid node types are: {}\".format(\", \".join(cls.allowed))\n            )\n            return [instance.data[\"instance_node\"]]\n\n        # Ensure it has shapes\n        shapes = cmds.ls(valid, long=True, shapes=True)\n        if not shapes:\n            cls.log.error(\"No shapes in the model instance\")\n            return [instance.data[\"instance_node\"]]\n\n        # Ensure single top group\n        top_parents = {\"|\" + x.split(\"|\", 2)[1] for x in content_instance}\n        if cls.validate_top_group and len(top_parents) != 1:\n            cls.log.error(\n                \"A model instance must have exactly one top group. \"\n                \"Found top groups: {}\".format(\", \".join(top_parents))\n            )\n            return list(top_parents)\n\n        def _is_visible(node):\n            \"\"\"Return whether node is visible\"\"\"\n            return lib.is_visible(node,\n                                  displayLayer=False,\n                                  intermediateObject=True,\n                                  parentHidden=True,\n                                  visibility=True)\n\n        # The roots must be visible (the assemblies)\n        for parent in top_parents:\n            if not _is_visible(parent):\n                cls.log.error(\"Invisible parent (root node) is not \"\n                              \"allowed: {0}\".format(parent))\n                invalid.add(parent)\n\n        # Ensure at least one shape is visible\n        if not any(_is_visible(shape) for shape in shapes):\n            cls.log.error(\"No visible shapes in the model instance\")\n            invalid.update(shapes)\n\n        return list(invalid)\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n\n        if invalid:\n            raise PublishValidationError(\n                title=\"Model content is invalid\",\n                message=\"Model content is invalid. See log for more details.\",\n                description=self.get_description()\n            )\n\n    @classmethod\n    def get_description(cls):\n        return inspect.cleandoc(f\"\"\"\n            ### Model content is invalid\n\n            Your model instance does not adhere to the rules of a\n            model product type:\n\n            - Must have at least one visible shape in it, like a mesh.\n            - Must have one root node. When exporting multiple meshes they\n              must be inside a group.\n            - May only contain the following node types:\n            {\", \".join(cls.allowed)}\n        \"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_mvlook_contents.html","title":"validate_mvlook_contents","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_no_animation.html","title":"validate_no_animation","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_no_animation.html#client.ayon_maya.plugins.publish.validate_no_animation.ValidateNoAnimation","title":"<code>ValidateNoAnimation</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure no keyframes on nodes in the Instance.</p> <p>Even though a Model would extract without animCurves correctly this avoids getting different output from a model when extracted from a different frame than the first frame. (Might be overly restrictive though)</p> Source code in <code>client/ayon_maya/plugins/publish/validate_no_animation.py</code> <pre><code>class ValidateNoAnimation(plugin.MayaInstancePlugin,\n                          OptionalPyblishPluginMixin):\n    \"\"\"Ensure no keyframes on nodes in the Instance.\n\n    Even though a Model would extract without animCurves correctly this avoids\n    getting different output from a model when extracted from a different\n    frame than the first frame. (Might be overly restrictive though)\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    label = \"No Animation\"\n    hosts = [\"maya\"]\n    families = [\"model\"]\n    optional = True\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Keyframes found on:\\n\\n{0}\".format(\n                    _as_report_list(sorted(invalid))\n                ),\n                title=\"Keyframes on model\"\n            )\n\n    @staticmethod\n    def get_invalid(instance):\n\n        nodes = instance[:]\n        if not nodes:\n            return []\n\n        curves = cmds.keyframe(nodes, query=True, name=True)\n        if curves:\n            return list(set(cmds.listConnections(curves)))\n\n        return []\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_no_default_camera.html","title":"validate_no_default_camera","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_no_default_camera.html#client.ayon_maya.plugins.publish.validate_no_default_camera.ValidateNoDefaultCameras","title":"<code>ValidateNoDefaultCameras</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure no default (startup) cameras are in the instance.</p> <p>This might be unnecessary. In the past there were some issues with referencing/importing files that contained the start up cameras overriding settings when being loaded and sometimes being skipped.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_no_default_camera.py</code> <pre><code>class ValidateNoDefaultCameras(plugin.MayaInstancePlugin,\n                               OptionalPyblishPluginMixin):\n    \"\"\"Ensure no default (startup) cameras are in the instance.\n\n    This might be unnecessary. In the past there were some issues with\n    referencing/importing files that contained the start up cameras overriding\n    settings when being loaded and sometimes being skipped.\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = ['camera']\n    label = \"No Default Cameras\"\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = False\n\n    @staticmethod\n    def get_invalid(instance):\n        cameras = cmds.ls(instance, type='camera', long=True)\n        return [cam for cam in cameras if\n                cmds.camera(cam, query=True, startupCamera=True)]\n\n    def process(self, instance):\n        \"\"\"Process all the cameras in the instance\"\"\"\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Default cameras found:\\n\\n{0}\".format(\n                    _as_report_list(sorted(invalid))\n                ),\n                title=\"Default cameras\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_no_default_camera.html#client.ayon_maya.plugins.publish.validate_no_default_camera.ValidateNoDefaultCameras.process","title":"<code>process(instance)</code>","text":"<p>Process all the cameras in the instance</p> Source code in <code>client/ayon_maya/plugins/publish/validate_no_default_camera.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the cameras in the instance\"\"\"\n    if not self.is_active(instance.data):\n        return\n    invalid = self.get_invalid(instance)\n    if invalid:\n        raise PublishValidationError(\n            \"Default cameras found:\\n\\n{0}\".format(\n                _as_report_list(sorted(invalid))\n            ),\n            title=\"Default cameras\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_no_namespace.html","title":"validate_no_namespace","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_no_namespace.html#client.ayon_maya.plugins.publish.validate_no_namespace.ValidateNoNamespace","title":"<code>ValidateNoNamespace</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure the nodes don't have a namespace</p> Source code in <code>client/ayon_maya/plugins/publish/validate_no_namespace.py</code> <pre><code>class ValidateNoNamespace(plugin.MayaInstancePlugin,\n                          OptionalPyblishPluginMixin):\n    \"\"\"Ensure the nodes don't have a namespace\"\"\"\n\n    order = ValidateContentsOrder\n    families = ['model']\n    label = 'No Namespaces'\n    actions = [ayon_maya.api.action.SelectInvalidAction,\n               RepairAction]\n    optional = False\n\n    @staticmethod\n    def get_invalid(instance):\n        nodes = cmds.ls(instance, long=True)\n        return [node for node in nodes if get_namespace(node)]\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance\"\"\"\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n\n        if invalid:\n            invalid_namespaces = {get_namespace(node) for node in invalid}\n            raise PublishValidationError(\n                message=\"Namespaces found:\\n\\n{0}\".format(\n                    _as_report_list(sorted(invalid_namespaces))\n                ),\n                title=\"Namespaces in model\",\n                description=(\n                    \"## Namespaces found in model\\n\"\n                    \"It is not allowed to publish a model that contains \"\n                    \"namespaces.\"\n                )\n            )\n\n    @classmethod\n    def repair(cls, instance):\n        \"\"\"Remove all namespaces from the nodes in the instance\"\"\"\n\n        invalid = cls.get_invalid(instance)\n\n        # Iterate over the nodes by long to short names to iterate the lowest\n        # in hierarchy nodes first. This way we avoid having renamed parents\n        # before renaming children nodes\n        for node in sorted(invalid, key=len, reverse=True):\n\n            node_name = node.rsplit(\"|\", 1)[-1]\n            node_name_without_namespace = node_name.rsplit(\":\")[-1]\n            cmds.rename(node, node_name_without_namespace)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_no_namespace.html#client.ayon_maya.plugins.publish.validate_no_namespace.ValidateNoNamespace.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance</p> Source code in <code>client/ayon_maya/plugins/publish/validate_no_namespace.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance\"\"\"\n    if not self.is_active(instance.data):\n        return\n    invalid = self.get_invalid(instance)\n\n    if invalid:\n        invalid_namespaces = {get_namespace(node) for node in invalid}\n        raise PublishValidationError(\n            message=\"Namespaces found:\\n\\n{0}\".format(\n                _as_report_list(sorted(invalid_namespaces))\n            ),\n            title=\"Namespaces in model\",\n            description=(\n                \"## Namespaces found in model\\n\"\n                \"It is not allowed to publish a model that contains \"\n                \"namespaces.\"\n            )\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_no_namespace.html#client.ayon_maya.plugins.publish.validate_no_namespace.ValidateNoNamespace.repair","title":"<code>repair(instance)</code>  <code>classmethod</code>","text":"<p>Remove all namespaces from the nodes in the instance</p> Source code in <code>client/ayon_maya/plugins/publish/validate_no_namespace.py</code> <pre><code>@classmethod\ndef repair(cls, instance):\n    \"\"\"Remove all namespaces from the nodes in the instance\"\"\"\n\n    invalid = cls.get_invalid(instance)\n\n    # Iterate over the nodes by long to short names to iterate the lowest\n    # in hierarchy nodes first. This way we avoid having renamed parents\n    # before renaming children nodes\n    for node in sorted(invalid, key=len, reverse=True):\n\n        node_name = node.rsplit(\"|\", 1)[-1]\n        node_name_without_namespace = node_name.rsplit(\":\")[-1]\n        cmds.rename(node, node_name_without_namespace)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_no_null_transforms.html","title":"validate_no_null_transforms","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_no_null_transforms.html#client.ayon_maya.plugins.publish.validate_no_null_transforms.ValidateNoNullTransforms","title":"<code>ValidateNoNullTransforms</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure no null transforms are in the scene.</p> Warning <p>Transforms with only intermediate shapes are also considered null transforms. These transform nodes could potentially be used in your construction history, so take care when automatically fixing this or when deleting the empty transforms manually.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_no_null_transforms.py</code> <pre><code>class ValidateNoNullTransforms(plugin.MayaInstancePlugin,\n                               OptionalPyblishPluginMixin):\n    \"\"\"Ensure no null transforms are in the scene.\n\n    Warning:\n        Transforms with only intermediate shapes are also considered null\n        transforms. These transform nodes could potentially be used in your\n        construction history, so take care when automatically fixing this or\n        when deleting the empty transforms manually.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = ['model']\n    label = 'No Empty/Null Transforms'\n    actions = [RepairAction,\n               ayon_maya.api.action.SelectInvalidAction]\n    optional = False\n\n    @staticmethod\n    def get_invalid(instance):\n        \"\"\"Return invalid transforms in instance\"\"\"\n\n        transforms = cmds.ls(instance, type='transform', long=True)\n\n        invalid = []\n        for transform in transforms:\n            if not has_shape_children(transform):\n                invalid.append(transform)\n\n        return invalid\n\n    def process(self, instance):\n        \"\"\"Process all the transform nodes in the instance \"\"\"\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Empty transforms found without shapes:\\n\\n{0}\".format(\n                    _as_report_list(sorted(invalid))\n                ),\n                title=\"Empty transforms\"\n            )\n\n    @classmethod\n    def repair(cls, instance):\n        \"\"\"Delete all null transforms.\n\n        Note: If the node is used elsewhere (eg. connection to attributes or\n        in history) deletion might mess up things.\n\n        \"\"\"\n        invalid = cls.get_invalid(instance)\n        if invalid:\n            cmds.delete(invalid)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_no_null_transforms.html#client.ayon_maya.plugins.publish.validate_no_null_transforms.ValidateNoNullTransforms.get_invalid","title":"<code>get_invalid(instance)</code>  <code>staticmethod</code>","text":"<p>Return invalid transforms in instance</p> Source code in <code>client/ayon_maya/plugins/publish/validate_no_null_transforms.py</code> <pre><code>@staticmethod\ndef get_invalid(instance):\n    \"\"\"Return invalid transforms in instance\"\"\"\n\n    transforms = cmds.ls(instance, type='transform', long=True)\n\n    invalid = []\n    for transform in transforms:\n        if not has_shape_children(transform):\n            invalid.append(transform)\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_no_null_transforms.html#client.ayon_maya.plugins.publish.validate_no_null_transforms.ValidateNoNullTransforms.process","title":"<code>process(instance)</code>","text":"<p>Process all the transform nodes in the instance</p> Source code in <code>client/ayon_maya/plugins/publish/validate_no_null_transforms.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the transform nodes in the instance \"\"\"\n    if not self.is_active(instance.data):\n        return\n    invalid = self.get_invalid(instance)\n    if invalid:\n        raise PublishValidationError(\n            \"Empty transforms found without shapes:\\n\\n{0}\".format(\n                _as_report_list(sorted(invalid))\n            ),\n            title=\"Empty transforms\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_no_null_transforms.html#client.ayon_maya.plugins.publish.validate_no_null_transforms.ValidateNoNullTransforms.repair","title":"<code>repair(instance)</code>  <code>classmethod</code>","text":"<p>Delete all null transforms.</p> <p>Note: If the node is used elsewhere (eg. connection to attributes or in history) deletion might mess up things.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_no_null_transforms.py</code> <pre><code>@classmethod\ndef repair(cls, instance):\n    \"\"\"Delete all null transforms.\n\n    Note: If the node is used elsewhere (eg. connection to attributes or\n    in history) deletion might mess up things.\n\n    \"\"\"\n    invalid = cls.get_invalid(instance)\n    if invalid:\n        cmds.delete(invalid)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_no_unknown_nodes.html","title":"validate_no_unknown_nodes","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_no_unknown_nodes.html#client.ayon_maya.plugins.publish.validate_no_unknown_nodes.ValidateNoUnknownNodes","title":"<code>ValidateNoUnknownNodes</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Checks to see if there are any unknown nodes in the instance.</p> <p>This often happens if nodes from plug-ins are used but are not available on this machine.</p> Some studios use unknown nodes to store data on (as attributes) <p>because it's a lightweight node.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_no_unknown_nodes.py</code> <pre><code>class ValidateNoUnknownNodes(plugin.MayaInstancePlugin,\n                             OptionalPyblishPluginMixin):\n    \"\"\"Checks to see if there are any unknown nodes in the instance.\n\n    This often happens if nodes from plug-ins are used but are not available\n    on this machine.\n\n    Note: Some studios use unknown nodes to store data on (as attributes)\n        because it's a lightweight node.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    hosts = ['maya']\n    families = ['model', 'rig']\n    optional = True\n    label = \"Unknown Nodes\"\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n\n    @staticmethod\n    def get_invalid(instance):\n        return cmds.ls(instance, type='unknown')\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance\"\"\"\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Unknown nodes found:\\n\\n{0}\".format(\n                    _as_report_list(sorted(invalid))\n                ),\n                title=\"Unknown nodes\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_no_unknown_nodes.html#client.ayon_maya.plugins.publish.validate_no_unknown_nodes.ValidateNoUnknownNodes.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance</p> Source code in <code>client/ayon_maya/plugins/publish/validate_no_unknown_nodes.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance\"\"\"\n    if not self.is_active(instance.data):\n        return\n\n    invalid = self.get_invalid(instance)\n    if invalid:\n        raise PublishValidationError(\n            \"Unknown nodes found:\\n\\n{0}\".format(\n                _as_report_list(sorted(invalid))\n            ),\n            title=\"Unknown nodes\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_no_vraymesh.html","title":"validate_no_vraymesh","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_no_vraymesh.html#client.ayon_maya.plugins.publish.validate_no_vraymesh.ValidateNoVRayMesh","title":"<code>ValidateNoVRayMesh</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate there are no VRayMesh objects in the instance</p> Source code in <code>client/ayon_maya/plugins/publish/validate_no_vraymesh.py</code> <pre><code>class ValidateNoVRayMesh(plugin.MayaInstancePlugin,\n                         OptionalPyblishPluginMixin):\n    \"\"\"Validate there are no VRayMesh objects in the instance\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = 'No V-Ray Proxies (VRayMesh)'\n    families = [\"pointcache\"]\n    optional = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        if not cmds.pluginInfo(\"vrayformaya\", query=True, loaded=True):\n            return\n\n        shapes = cmds.ls(instance,\n                         shapes=True,\n                         type=\"mesh\")\n\n        inputs = cmds.listConnections(shapes,\n                                      destination=False,\n                                      source=True) or []\n        vray_meshes = cmds.ls(inputs, type='VRayMesh')\n        if vray_meshes:\n            raise PublishValidationError(\n                \"Meshes that are V-Ray Proxies should not be in an Alembic \"\n                \"pointcache.\\n\"\n                \"Found V-Ray proxies:\\n\\n{}\".format(\n                    _as_report_list(sorted(vray_meshes))\n                ),\n                title=\"V-Ray Proxies in pointcache\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_ids.html","title":"validate_node_ids","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_ids.html#client.ayon_maya.plugins.publish.validate_node_ids.ValidateNodeIDs","title":"<code>ValidateNodeIDs</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validate nodes have a Colorbleed Id.</p> <p>When IDs are missing from nodes save your scene and they should be automatically generated because IDs are created on non-referenced nodes in Maya upon scene save.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_node_ids.py</code> <pre><code>class ValidateNodeIDs(plugin.MayaInstancePlugin):\n    \"\"\"Validate nodes have a Colorbleed Id.\n\n    When IDs are missing from nodes *save your scene* and they should be\n    automatically generated because IDs are created on non-referenced nodes\n    in Maya upon scene save.\n\n    \"\"\"\n\n    order = ValidatePipelineOrder\n    label = 'Instance Nodes Have ID'\n    families = [\"model\",\n                \"look\",\n                \"rig\",\n                \"pointcache\",\n                \"animation\",\n                \"yetiRig\",\n                \"assembly\"]\n\n    actions = [ayon_maya.api.action.SelectInvalidAction,\n               ayon_maya.api.action.GenerateUUIDsOnInvalidAction]\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        # Disable plug-in if cbId workflow is disabled\n        if not project_settings[\"maya\"].get(\"use_cbid_workflow\", True):\n            cls.enabled = False\n            return\n\n    def process(self, instance):\n        \"\"\"Process all meshes\"\"\"\n\n        # Ensure all nodes have a cbId\n        invalid = self.get_invalid(instance)\n        if invalid:\n            names = \"\\n\".join(\n                \"- {}\".format(node) for node in sorted(invalid)\n            )\n            raise PublishXmlValidationError(\n                plugin=self,\n                message=\"Nodes found without IDs:\\n{}\".format(names)\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n        \"\"\"Return the member nodes that are invalid\"\"\"\n\n        # We do want to check the referenced nodes as it might be\n        # part of the end product.\n        id_nodes = lib.get_id_required_nodes(referenced_nodes=True,\n                                             nodes=instance[:],\n                                             # Exclude those with already\n                                             # existing ids\n                                             existing_ids=False)\n        return list(id_nodes)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_ids.html#client.ayon_maya.plugins.publish.validate_node_ids.ValidateNodeIDs.get_invalid","title":"<code>get_invalid(instance)</code>  <code>classmethod</code>","text":"<p>Return the member nodes that are invalid</p> Source code in <code>client/ayon_maya/plugins/publish/validate_node_ids.py</code> <pre><code>@classmethod\ndef get_invalid(cls, instance):\n    \"\"\"Return the member nodes that are invalid\"\"\"\n\n    # We do want to check the referenced nodes as it might be\n    # part of the end product.\n    id_nodes = lib.get_id_required_nodes(referenced_nodes=True,\n                                         nodes=instance[:],\n                                         # Exclude those with already\n                                         # existing ids\n                                         existing_ids=False)\n    return list(id_nodes)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_ids.html#client.ayon_maya.plugins.publish.validate_node_ids.ValidateNodeIDs.process","title":"<code>process(instance)</code>","text":"<p>Process all meshes</p> Source code in <code>client/ayon_maya/plugins/publish/validate_node_ids.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all meshes\"\"\"\n\n    # Ensure all nodes have a cbId\n    invalid = self.get_invalid(instance)\n    if invalid:\n        names = \"\\n\".join(\n            \"- {}\".format(node) for node in sorted(invalid)\n        )\n        raise PublishXmlValidationError(\n            plugin=self,\n            message=\"Nodes found without IDs:\\n{}\".format(names)\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_ids_deformed_shapes.html","title":"validate_node_ids_deformed_shapes","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_ids_deformed_shapes.html#client.ayon_maya.plugins.publish.validate_node_ids_deformed_shapes.ValidateNodeIdsDeformedShape","title":"<code>ValidateNodeIdsDeformedShape</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validate if deformed shapes have related IDs to the original shapes.</p> <p>When a deformer is applied in the scene on a referenced mesh that already had deformers then Maya will create a new shape node for the mesh that does not have the original id. This validator checks whether the ids are valid on all the shape nodes in the instance.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_node_ids_deformed_shapes.py</code> <pre><code>class ValidateNodeIdsDeformedShape(plugin.MayaInstancePlugin):\n    \"\"\"Validate if deformed shapes have related IDs to the original shapes.\n\n    When a deformer is applied in the scene on a referenced mesh that already\n    had deformers then Maya will create a new shape node for the mesh that\n    does not have the original id. This validator checks whether the ids are\n    valid on all the shape nodes in the instance.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = ['look']\n    label = 'Deformed shape ids'\n    actions = [\n        ayon_maya.api.action.SelectInvalidAction,\n        RepairAction\n    ]\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        # Disable plug-in if cbId workflow is disabled\n        if not project_settings[\"maya\"].get(\"use_cbid_workflow\", True):\n            cls.enabled = False\n            return\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance\"\"\"\n\n        # Ensure all nodes have a cbId and a related ID to the original shapes\n        # if a deformer has been created on the shape\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                (\"Shapes found that are considered 'Deformed'\"\n                 \"without object ids: {0}\").format(invalid))\n\n    @classmethod\n    def get_invalid(cls, instance):\n        \"\"\"Get all nodes which do not match the criteria\"\"\"\n\n        shapes = cmds.ls(instance[:],\n                         dag=True,\n                         leaf=True,\n                         shapes=True,\n                         long=True,\n                         noIntermediate=True)\n\n        invalid = []\n        for shape in shapes:\n            history_id = lib.get_id_from_sibling(shape)\n            if history_id:\n                current_id = lib.get_id(shape)\n                if current_id != history_id:\n                    invalid.append(shape)\n\n        return invalid\n\n    @classmethod\n    def repair(cls, instance):\n\n        for node in cls.get_invalid(instance):\n            # Get the original id from history\n            history_id = lib.get_id_from_sibling(node)\n            if not history_id:\n                cls.log.error(\"Could not find ID in history for '%s'\", node)\n                continue\n\n            lib.set_id(node, history_id, overwrite=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_ids_deformed_shapes.html#client.ayon_maya.plugins.publish.validate_node_ids_deformed_shapes.ValidateNodeIdsDeformedShape.get_invalid","title":"<code>get_invalid(instance)</code>  <code>classmethod</code>","text":"<p>Get all nodes which do not match the criteria</p> Source code in <code>client/ayon_maya/plugins/publish/validate_node_ids_deformed_shapes.py</code> <pre><code>@classmethod\ndef get_invalid(cls, instance):\n    \"\"\"Get all nodes which do not match the criteria\"\"\"\n\n    shapes = cmds.ls(instance[:],\n                     dag=True,\n                     leaf=True,\n                     shapes=True,\n                     long=True,\n                     noIntermediate=True)\n\n    invalid = []\n    for shape in shapes:\n        history_id = lib.get_id_from_sibling(shape)\n        if history_id:\n            current_id = lib.get_id(shape)\n            if current_id != history_id:\n                invalid.append(shape)\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_ids_deformed_shapes.html#client.ayon_maya.plugins.publish.validate_node_ids_deformed_shapes.ValidateNodeIdsDeformedShape.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance</p> Source code in <code>client/ayon_maya/plugins/publish/validate_node_ids_deformed_shapes.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance\"\"\"\n\n    # Ensure all nodes have a cbId and a related ID to the original shapes\n    # if a deformer has been created on the shape\n    invalid = self.get_invalid(instance)\n    if invalid:\n        raise PublishValidationError(\n            (\"Shapes found that are considered 'Deformed'\"\n             \"without object ids: {0}\").format(invalid))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_ids_in_database.html","title":"validate_node_ids_in_database","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_ids_in_database.html#client.ayon_maya.plugins.publish.validate_node_ids_in_database.ValidateNodeIdsInDatabase","title":"<code>ValidateNodeIdsInDatabase</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validate if the CB Id is related to an folder in the database</p> <p>All nodes with the <code>cbId</code> attribute will be validated to ensure that the loaded asset in the scene is related to the current project.</p> <p>Tip: If there is an asset which is being reused from a different project please ensure the asset is republished in the new project</p> Source code in <code>client/ayon_maya/plugins/publish/validate_node_ids_in_database.py</code> <pre><code>class ValidateNodeIdsInDatabase(plugin.MayaInstancePlugin):\n    \"\"\"Validate if the CB Id is related to an folder in the database\n\n    All nodes with the `cbId` attribute will be validated to ensure that\n    the loaded asset in the scene is related to the current project.\n\n    Tip: If there is an asset which is being reused from a different project\n    please ensure the asset is republished in the new project\n\n    \"\"\"\n\n    order = ValidatePipelineOrder\n    label = 'Node Ids in Database'\n    families = [\"*\"]\n\n    actions = [ayon_maya.api.action.SelectInvalidAction,\n               ayon_maya.api.action.GenerateUUIDsOnInvalidAction]\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        # Disable plug-in if cbId workflow is disabled\n        if not project_settings[\"maya\"].get(\"use_cbid_workflow\", True):\n            cls.enabled = False\n            return\n\n    def process(self, instance):\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Found folder ids which are not related to \"\n                \"current project in instance: `{}`\".format(instance.name))\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        nodes = instance[:]\n        if not nodes:\n            return\n\n        # Get all id required nodes\n        id_required_nodes = lib.get_id_required_nodes(referenced_nodes=False,\n                                                      nodes=nodes)\n        if not id_required_nodes:\n            return\n\n        # check ids against database ids\n        folder_ids = cls.get_project_folder_ids(context=instance.context)\n\n        # Get all asset IDs\n        invalid = []\n        for node in id_required_nodes:\n            cb_id = lib.get_id(node)\n\n            # Ignore nodes without id, those are validated elsewhere\n            if not cb_id:\n                continue\n\n            folder_id = cb_id.split(\":\", 1)[0]\n            if folder_id not in folder_ids:\n                cls.log.error(\"`%s` has unassociated folder id\" % node)\n                invalid.append(node)\n\n        return invalid\n\n    @classmethod\n    def get_project_folder_ids(cls, context):\n        \"\"\"Return all folder ids in the current project.\n\n        Arguments:\n            context (pyblish.api.Context): The publish context.\n\n        Returns:\n            set[str]: All folder ids in the current project.\n\n        \"\"\"\n        # We query the database only for the first instance instead of\n        # per instance by storing a cache in the context\n        key = \"__cache_project_folder_ids\"\n        if key in context.data:\n            return context.data[key]\n\n        # check ids against database\n        project_name = context.data[\"projectName\"]\n        folder_entities = ayon_api.get_folders(project_name, fields={\"id\"})\n        folder_ids = {\n            folder_entity[\"id\"]\n            for folder_entity in folder_entities\n        }\n\n        context.data[key] = folder_ids\n        return folder_ids\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_ids_in_database.html#client.ayon_maya.plugins.publish.validate_node_ids_in_database.ValidateNodeIdsInDatabase.get_project_folder_ids","title":"<code>get_project_folder_ids(context)</code>  <code>classmethod</code>","text":"<p>Return all folder ids in the current project.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>The publish context.</p> required <p>Returns:</p> Type Description <p>set[str]: All folder ids in the current project.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_node_ids_in_database.py</code> <pre><code>@classmethod\ndef get_project_folder_ids(cls, context):\n    \"\"\"Return all folder ids in the current project.\n\n    Arguments:\n        context (pyblish.api.Context): The publish context.\n\n    Returns:\n        set[str]: All folder ids in the current project.\n\n    \"\"\"\n    # We query the database only for the first instance instead of\n    # per instance by storing a cache in the context\n    key = \"__cache_project_folder_ids\"\n    if key in context.data:\n        return context.data[key]\n\n    # check ids against database\n    project_name = context.data[\"projectName\"]\n    folder_entities = ayon_api.get_folders(project_name, fields={\"id\"})\n    folder_ids = {\n        folder_entity[\"id\"]\n        for folder_entity in folder_entities\n    }\n\n    context.data[key] = folder_ids\n    return folder_ids\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_ids_related.html","title":"validate_node_ids_related","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_ids_related.html#client.ayon_maya.plugins.publish.validate_node_ids_related.ValidateNodeIDsRelated","title":"<code>ValidateNodeIDsRelated</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate nodes have a related <code>cbId</code> to the instance.data[folderPath]</p> Source code in <code>client/ayon_maya/plugins/publish/validate_node_ids_related.py</code> <pre><code>class ValidateNodeIDsRelated(plugin.MayaInstancePlugin,\n                             OptionalPyblishPluginMixin):\n    \"\"\"Validate nodes have a related `cbId` to the instance.data[folderPath]\"\"\"\n\n    order = ValidatePipelineOrder\n    label = 'Node Ids Related (ID)'\n    families = [\"model\",\n                \"look\",\n                \"rig\"]\n    optional = True\n\n    actions = [ayon_maya.api.action.SelectInvalidAction,\n               ayon_maya.api.action.GenerateUUIDsOnInvalidAction]\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        # Disable plug-in if cbId workflow is disabled\n        if not project_settings[\"maya\"].get(\"use_cbid_workflow\", True):\n            cls.enabled = False\n            return\n\n    def process(self, instance):\n        \"\"\"Process all nodes in instance (including hierarchy)\"\"\"\n        if not self.is_active(instance.data):\n            return\n\n        # Ensure all nodes have a cbId\n        invalid = self.get_invalid(instance)\n        if invalid:\n\n            invalid_list = \"\\n\".join(f\"- {node}\" for node in sorted(invalid))\n\n            raise PublishValidationError((\n                \"Nodes IDs found that are not related to folder '{}':\\n{}\"\n                ).format(instance.data[\"folderPath\"], invalid_list),\n                description=self.get_description()\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n        \"\"\"Return the member nodes that are invalid\"\"\"\n        folder_id = instance.data[\"folderEntity\"][\"id\"]\n\n        # We do want to check the referenced nodes as it might be\n        # part of the end product\n        invalid = list()\n        nodes_by_other_folder_ids = defaultdict(set)\n        for node in instance:\n            _id = lib.get_id(node)\n            if not _id:\n                continue\n\n            node_folder_id = _id.split(\":\", 1)[0]\n            if node_folder_id != folder_id:\n                invalid.append(node)\n                nodes_by_other_folder_ids[node_folder_id].add(node)\n\n        # Log what other assets were found.\n        if nodes_by_other_folder_ids:\n            project_name = instance.context.data[\"projectName\"]\n            other_folder_ids = set(nodes_by_other_folder_ids.keys())\n\n            # Remove folder ids that are not valid UUID identifiers, these\n            # may be legacy OpenPype ids\n            other_folder_ids = {folder_id for folder_id in other_folder_ids\n                                if is_valid_uuid(folder_id)}\n            if not other_folder_ids:\n                return invalid\n\n            folder_entities = get_folders(project_name=project_name,\n                                          folder_ids=other_folder_ids,\n                                          fields=[\"path\"])\n            if folder_entities:\n                # Log names of other assets detected\n                # We disregard logging nodes/ids for asset ids where no asset\n                # was found in the database because ValidateNodeIdsInDatabase\n                # takes care of that.\n                folder_paths = {entity[\"path\"] for entity in folder_entities}\n                cls.log.error(\n                    \"Found nodes related to other folders:\\n{}\".format(\n                        \"\\n\".join(f\"- {path}\" for path in sorted(folder_paths))\n                    )\n                )\n\n        return invalid\n\n    @staticmethod\n    def get_description():\n        return inspect.cleandoc(\"\"\"### Node IDs must match folder id\n\n        The node ids must match the folder entity id you are publishing to.\n\n        Usually these mismatch occurs if you are re-using nodes from another\n        folder or project.\n\n        #### How to repair?\n\n        The repair action will regenerate new ids for\n        the invalid nodes to match the instance's folder.\n        \"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_ids_related.html#client.ayon_maya.plugins.publish.validate_node_ids_related.ValidateNodeIDsRelated.get_invalid","title":"<code>get_invalid(instance)</code>  <code>classmethod</code>","text":"<p>Return the member nodes that are invalid</p> Source code in <code>client/ayon_maya/plugins/publish/validate_node_ids_related.py</code> <pre><code>@classmethod\ndef get_invalid(cls, instance):\n    \"\"\"Return the member nodes that are invalid\"\"\"\n    folder_id = instance.data[\"folderEntity\"][\"id\"]\n\n    # We do want to check the referenced nodes as it might be\n    # part of the end product\n    invalid = list()\n    nodes_by_other_folder_ids = defaultdict(set)\n    for node in instance:\n        _id = lib.get_id(node)\n        if not _id:\n            continue\n\n        node_folder_id = _id.split(\":\", 1)[0]\n        if node_folder_id != folder_id:\n            invalid.append(node)\n            nodes_by_other_folder_ids[node_folder_id].add(node)\n\n    # Log what other assets were found.\n    if nodes_by_other_folder_ids:\n        project_name = instance.context.data[\"projectName\"]\n        other_folder_ids = set(nodes_by_other_folder_ids.keys())\n\n        # Remove folder ids that are not valid UUID identifiers, these\n        # may be legacy OpenPype ids\n        other_folder_ids = {folder_id for folder_id in other_folder_ids\n                            if is_valid_uuid(folder_id)}\n        if not other_folder_ids:\n            return invalid\n\n        folder_entities = get_folders(project_name=project_name,\n                                      folder_ids=other_folder_ids,\n                                      fields=[\"path\"])\n        if folder_entities:\n            # Log names of other assets detected\n            # We disregard logging nodes/ids for asset ids where no asset\n            # was found in the database because ValidateNodeIdsInDatabase\n            # takes care of that.\n            folder_paths = {entity[\"path\"] for entity in folder_entities}\n            cls.log.error(\n                \"Found nodes related to other folders:\\n{}\".format(\n                    \"\\n\".join(f\"- {path}\" for path in sorted(folder_paths))\n                )\n            )\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_ids_related.html#client.ayon_maya.plugins.publish.validate_node_ids_related.ValidateNodeIDsRelated.process","title":"<code>process(instance)</code>","text":"<p>Process all nodes in instance (including hierarchy)</p> Source code in <code>client/ayon_maya/plugins/publish/validate_node_ids_related.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all nodes in instance (including hierarchy)\"\"\"\n    if not self.is_active(instance.data):\n        return\n\n    # Ensure all nodes have a cbId\n    invalid = self.get_invalid(instance)\n    if invalid:\n\n        invalid_list = \"\\n\".join(f\"- {node}\" for node in sorted(invalid))\n\n        raise PublishValidationError((\n            \"Nodes IDs found that are not related to folder '{}':\\n{}\"\n            ).format(instance.data[\"folderPath\"], invalid_list),\n            description=self.get_description()\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_ids_related.html#client.ayon_maya.plugins.publish.validate_node_ids_related.is_valid_uuid","title":"<code>is_valid_uuid(value)</code>","text":"<p>Return whether value is a valid UUID</p> Source code in <code>client/ayon_maya/plugins/publish/validate_node_ids_related.py</code> <pre><code>def is_valid_uuid(value) -&gt; bool:\n    \"\"\"Return whether value is a valid UUID\"\"\"\n    try:\n        uuid.UUID(value)\n    except ValueError:\n        return False\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_ids_unique.html","title":"validate_node_ids_unique","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_ids_unique.html#client.ayon_maya.plugins.publish.validate_node_ids_unique.ValidateNodeIdsUnique","title":"<code>ValidateNodeIdsUnique</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validate the nodes in the instance have a unique Colorbleed Id</p> <p>Here we ensure that what has been added to the instance is unique</p> Source code in <code>client/ayon_maya/plugins/publish/validate_node_ids_unique.py</code> <pre><code>class ValidateNodeIdsUnique(plugin.MayaInstancePlugin):\n    \"\"\"Validate the nodes in the instance have a unique Colorbleed Id\n\n    Here we ensure that what has been added to the instance is unique\n    \"\"\"\n\n    order = ValidatePipelineOrder\n    label = 'Non Duplicate Instance Members (ID)'\n    families = [\"model\",\n                \"look\",\n                \"rig\",\n                \"yetiRig\"]\n\n    actions = [ayon_maya.api.action.SelectInvalidAction,\n               ayon_maya.api.action.GenerateUUIDsOnInvalidAction]\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        # Disable plug-in if cbId workflow is disabled\n        if not project_settings[\"maya\"].get(\"use_cbid_workflow\", True):\n            cls.enabled = False\n            return\n\n    def process(self, instance):\n        \"\"\"Process all meshes\"\"\"\n\n        # Ensure all nodes have a cbId\n        invalid = self.get_invalid(instance)\n        if invalid:\n            label = \"Nodes found with non-unique folder ids\"\n            raise PublishValidationError(\n                message=\"{}, see log\".format(label),\n                title=\"Non-unique folder ids on nodes\",\n                description=\"{}\\n- {}\".format(label,\n                                              \"\\n- \".join(sorted(invalid)))\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n        \"\"\"Return the member nodes that are invalid\"\"\"\n\n        # Check only non intermediate shapes\n        # todo: must the instance itself ensure to have no intermediates?\n        # todo: how come there are intermediates?\n        instance_members = cmds.ls(instance, noIntermediate=True, long=True)\n\n        # Collect each id with their members\n        ids = defaultdict(list)\n        for member in instance_members:\n            object_id = lib.get_id(member)\n            if not object_id:\n                continue\n            ids[object_id].append(member)\n\n        # Take only the ids with more than one member\n        invalid = list()\n        for members in ids.values():\n            if len(members) &gt; 1:\n                members_text = \"\\n\".join(\n                    \"- {}\".format(member) for member in sorted(members)\n                )\n                cls.log.error(\n                    \"ID found on multiple nodes:\\n{}\".format(members_text)\n                )\n                invalid.extend(members)\n\n        return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_ids_unique.html#client.ayon_maya.plugins.publish.validate_node_ids_unique.ValidateNodeIdsUnique.get_invalid","title":"<code>get_invalid(instance)</code>  <code>classmethod</code>","text":"<p>Return the member nodes that are invalid</p> Source code in <code>client/ayon_maya/plugins/publish/validate_node_ids_unique.py</code> <pre><code>@classmethod\ndef get_invalid(cls, instance):\n    \"\"\"Return the member nodes that are invalid\"\"\"\n\n    # Check only non intermediate shapes\n    # todo: must the instance itself ensure to have no intermediates?\n    # todo: how come there are intermediates?\n    instance_members = cmds.ls(instance, noIntermediate=True, long=True)\n\n    # Collect each id with their members\n    ids = defaultdict(list)\n    for member in instance_members:\n        object_id = lib.get_id(member)\n        if not object_id:\n            continue\n        ids[object_id].append(member)\n\n    # Take only the ids with more than one member\n    invalid = list()\n    for members in ids.values():\n        if len(members) &gt; 1:\n            members_text = \"\\n\".join(\n                \"- {}\".format(member) for member in sorted(members)\n            )\n            cls.log.error(\n                \"ID found on multiple nodes:\\n{}\".format(members_text)\n            )\n            invalid.extend(members)\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_ids_unique.html#client.ayon_maya.plugins.publish.validate_node_ids_unique.ValidateNodeIdsUnique.process","title":"<code>process(instance)</code>","text":"<p>Process all meshes</p> Source code in <code>client/ayon_maya/plugins/publish/validate_node_ids_unique.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all meshes\"\"\"\n\n    # Ensure all nodes have a cbId\n    invalid = self.get_invalid(instance)\n    if invalid:\n        label = \"Nodes found with non-unique folder ids\"\n        raise PublishValidationError(\n            message=\"{}, see log\".format(label),\n            title=\"Non-unique folder ids on nodes\",\n            description=\"{}\\n- {}\".format(label,\n                                          \"\\n- \".join(sorted(invalid)))\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_no_ghosting.html","title":"validate_node_no_ghosting","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_node_no_ghosting.html#client.ayon_maya.plugins.publish.validate_node_no_ghosting.ValidateNodeNoGhosting","title":"<code>ValidateNodeNoGhosting</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure nodes do not have ghosting enabled.</p> <p>If one would publish towards a non-Maya format it's likely that stats like ghosting won't be exported, eg. exporting to Alembic.</p> <p>Instead of creating many micro-managing checks (like this one) to ensure attributes have not been changed from their default it could be more efficient to export to a format that will never hold such data anyway.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_node_no_ghosting.py</code> <pre><code>class ValidateNodeNoGhosting(plugin.MayaInstancePlugin,\n                             OptionalPyblishPluginMixin):\n    \"\"\"Ensure nodes do not have ghosting enabled.\n\n    If one would publish towards a non-Maya format it's likely that stats\n    like ghosting won't be exported, eg. exporting to Alembic.\n\n    Instead of creating many micro-managing checks (like this one) to ensure\n    attributes have not been changed from their default it could be more\n    efficient to export to a format that will never hold such data anyway.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = ['model', 'rig']\n    label = \"No Ghosting\"\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = False\n\n    _attributes = {'ghosting': 0}\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        # Transforms and shapes seem to have ghosting\n        nodes = cmds.ls(instance, long=True, type=['transform', 'shape'])\n        invalid = []\n        for node in nodes:\n            _iteritems = getattr(\n                cls._attributes, \"iteritems\", cls._attributes.items\n            )\n            for attr, required_value in _iteritems():\n                if cmds.attributeQuery(attr, node=node, exists=True):\n\n                    value = cmds.getAttr('{0}.{1}'.format(node, attr))\n                    if value != required_value:\n                        invalid.append(node)\n\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n\n        if invalid:\n            raise PublishValidationError(\n                \"Nodes with ghosting enabled found: {0}\".format(invalid))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_ornatrix_cache_content.html","title":"validate_ornatrix_cache_content","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_ornatrix_cache_content.html#client.ayon_maya.plugins.publish.validate_ornatrix_cache_content.ValidateOrnatrixCacheContent","title":"<code>ValidateOrnatrixCacheContent</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Adheres to the content of 'oxcache' product type</p> <p>See <code>get_description</code> for more details.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_ornatrix_cache_content.py</code> <pre><code>class ValidateOrnatrixCacheContent(plugin.MayaInstancePlugin,\n                                   OptionalPyblishPluginMixin):\n    \"\"\"Adheres to the content of 'oxcache' product type\n\n    See `get_description` for more details.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"oxcache\", \"oxrig\"]\n    label = \"Validate Ornatrix Cache Content\"\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n\n    optional = False\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        nodes = list(instance[:])\n        ox_hair_shapes = cmds.ls(nodes, type=\"HairShape\")\n        invalid = []\n        if len(ox_hair_shapes) == 0:\n            cls.log.warning(\"No Ornatrix Hair shapes found to cache from.\")\n            invalid.append(nodes)\n\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n\n        if invalid:\n            raise PublishValidationError(\n                title=\"Ornatrix cache content is invalid\",\n                message=\"Ornatrix cache content is invalid. \"\n                        \"See log for more details.\",\n                description=self.get_description()\n            )\n\n    @classmethod\n    def get_description(self):\n        return inspect.cleandoc(\"\"\"\n            ### Ornatrix cache content is invalid\n\n            Your oxrig or oxcache instance does not adhere to the rules of an\n            oxcache product type:\n\n            - Must have a Ornatrix `HairShape` nodes to cache.\n\n            Using the *Select Invalid* action will select all nodes that do\n            not adhere to these rules.\n        \"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_ornatrix_rig_content.html","title":"validate_ornatrix_rig_content","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_ornatrix_rig_content.html#client.ayon_maya.plugins.publish.validate_ornatrix_rig_content.ValidateOrnatrixRigContent","title":"<code>ValidateOrnatrixRigContent</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Adheres to the content of 'oxrig' product type</p> <p>See <code>get_description</code> for more details.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_ornatrix_rig_content.py</code> <pre><code>class ValidateOrnatrixRigContent(plugin.MayaInstancePlugin,\n                                 OptionalPyblishPluginMixin):\n    \"\"\"Adheres to the content of 'oxrig' product type\n\n    See `get_description` for more details.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"oxrig\"]\n    label = \"Validate Ornatrix Rig Content\"\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n\n    optional = False\n\n    @classmethod\n    def get_invalid(cls, instance):\n        invalid = []\n        nodes = instance.data[\"setMembers\"]\n        for node in nodes:\n            # Members must have shapes\n            node_shapes = cmds.listRelatives(node, shapes=True, fullPath=True)\n            if not node_shapes:\n                invalid.append(node)\n\n            # Shapes must have a connection to ornatrix nodes\n            ox_nodes = cmds.ls(cmds.listConnections(\n                node_shapes, destination=True) or [], type=ORNATRIX_NODES)\n            if not ox_nodes:\n                invalid.append(node)\n\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n\n        if invalid:\n            raise PublishValidationError(\n                title=\"Ornatrix rig content is invalid\",\n                message=\"Ornatrix rig content is invalid. \"\n                        \"See log for more details.\",\n                description=self.get_description()\n            )\n\n    @classmethod\n    def get_description(self):\n        return inspect.cleandoc(\"\"\"\n            ### Ornatrix content is invalid\n\n            Your oxrig instance does not adhere to the rules of an\n            oxrig product type:\n\n            - Must have the Ornatrix nodes connected to the shape\n            of the mesh\n            - May only have members that have shapes.\n\n            Using the *Select Invalid* action will select all nodes that do\n            not adhere to these rules.\n        \"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_plugin_path_attributes.html","title":"validate_plugin_path_attributes","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_plugin_path_attributes.html#client.ayon_maya.plugins.publish.validate_plugin_path_attributes.ValidatePluginPathAttributes","title":"<code>ValidatePluginPathAttributes</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate plug-in path attributes point to existing file paths.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_plugin_path_attributes.py</code> <pre><code>class ValidatePluginPathAttributes(plugin.MayaInstancePlugin,\n                                   OptionalPyblishPluginMixin):\n    \"\"\"\n    Validate plug-in path attributes point to existing file paths.\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"workfile\"]\n    label = \"Plug-in Path Attributes\"\n    actions = [SelectInvalidAction]\n    optional = False\n\n    # Attributes are defined in project settings\n    attribute = []\n\n    @classmethod\n    def get_invalid(cls, instance):\n        invalid = list()\n\n        file_attrs = {\n            item[\"name\"]: item[\"value\"]\n            for item in cls.attribute\n        }\n        if not file_attrs:\n            return invalid\n\n        # Consider only valid node types to avoid \"Unknown object type\" warning\n        all_node_types = set(cmds.allNodeTypes())\n        node_types = [\n            key\n            for key in file_attrs.keys()\n            if key in all_node_types\n        ]\n\n        for node, node_type in pairwise(cmds.ls(type=node_types,\n                                                showType=True)):\n            # get the filepath\n            file_attr = \"{}.{}\".format(node, file_attrs[node_type])\n            filepath = cmds.getAttr(file_attr)\n\n            if filepath and not os.path.exists(filepath):\n                cls.log.error(\"{} '{}' uses non-existing filepath: {}\"\n                              .format(node_type, node, filepath))\n                invalid.append(node)\n\n        return invalid\n\n    def process(self, instance):\n        \"\"\"Process all directories Set as Filenames in Non-Maya Nodes\"\"\"\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                title=\"Plug-in Path Attributes\",\n                message=\"Non-existent filepath found on nodes: {}\".format(\n                    \", \".join(invalid)\n                ),\n                description=(\n                    \"## Plug-in nodes use invalid filepaths\\n\"\n                    \"The workfile contains nodes from plug-ins that use \"\n                    \"filepaths which do not exist.\\n\\n\"\n                    \"Please make sure their filepaths are correct and the \"\n                    \"files exist on disk.\"\n                )\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_plugin_path_attributes.html#client.ayon_maya.plugins.publish.validate_plugin_path_attributes.ValidatePluginPathAttributes.process","title":"<code>process(instance)</code>","text":"<p>Process all directories Set as Filenames in Non-Maya Nodes</p> Source code in <code>client/ayon_maya/plugins/publish/validate_plugin_path_attributes.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all directories Set as Filenames in Non-Maya Nodes\"\"\"\n    if not self.is_active(instance.data):\n        return\n    invalid = self.get_invalid(instance)\n    if invalid:\n        raise PublishValidationError(\n            title=\"Plug-in Path Attributes\",\n            message=\"Non-existent filepath found on nodes: {}\".format(\n                \", \".join(invalid)\n            ),\n            description=(\n                \"## Plug-in nodes use invalid filepaths\\n\"\n                \"The workfile contains nodes from plug-ins that use \"\n                \"filepaths which do not exist.\\n\\n\"\n                \"Please make sure their filepaths are correct and the \"\n                \"files exist on disk.\"\n            )\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_render_image_rule.html","title":"validate_render_image_rule","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_render_image_rule.html#client.ayon_maya.plugins.publish.validate_render_image_rule.ValidateRenderImageRule","title":"<code>ValidateRenderImageRule</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates Maya Workpace \"images\" file rule matches project settings.</p> This validates against the configured default render image folder <p>Studio Settings &gt; Project &gt; Maya &gt; Render Settings &gt; Default render image folder.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_render_image_rule.py</code> <pre><code>class ValidateRenderImageRule(plugin.MayaInstancePlugin,\n                              OptionalPyblishPluginMixin):\n    \"\"\"Validates Maya Workpace \"images\" file rule matches project settings.\n\n    This validates against the configured default render image folder:\n        Studio Settings &gt; Project &gt; Maya &gt;\n        Render Settings &gt; Default render image folder.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    label = \"Images File Rule (Workspace)\"\n    families = [\"renderlayer\"]\n    actions = [RepairAction]\n    optional = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        required_images_rule = os.path.normpath(\n            self.get_default_render_image_folder(instance)\n        )\n        current_images_rule = os.path.normpath(\n            cmds.workspace(fileRuleEntry=\"images\")\n        )\n\n        if current_images_rule != required_images_rule:\n            raise PublishValidationError(\n                (\n                    \"Invalid workspace `images` file rule value: '{}'. \"\n                    \"Must be set to: '{}'\"\n                ).format(current_images_rule, required_images_rule))\n\n    @classmethod\n    def repair(cls, instance):\n\n        required_images_rule = cls.get_default_render_image_folder(instance)\n        current_images_rule = cmds.workspace(fileRuleEntry=\"images\")\n\n        if current_images_rule != required_images_rule:\n            cmds.workspace(fileRule=(\"images\", required_images_rule))\n            cmds.workspace(saveWorkspace=True)\n\n    @classmethod\n    def get_default_render_image_folder(cls, instance):\n        # Allow custom staging dir to override the expected output directory\n        # of the renders\n        if instance.data.get(\"stagingDir_is_custom\", False):\n            staging_dir = instance.data.get(\"stagingDir\")\n            if staging_dir:\n                cls.log.debug(\n                    \"Staging dir found: \\\"{}\\\". Ignoring setting from \"\n                    \"`project_settings/maya/render_settings/\"\n                    \"default_render_image_folder`.\".format(staging_dir)\n                )\n                return staging_dir\n\n        return (\n            instance.context.data\n            [\"project_settings\"]\n            [\"maya\"]\n            [\"render_settings\"]\n            [\"default_render_image_folder\"]\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_render_no_default_cameras.html","title":"validate_render_no_default_cameras","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_render_no_default_cameras.html#client.ayon_maya.plugins.publish.validate_render_no_default_cameras.ValidateRenderNoDefaultCameras","title":"<code>ValidateRenderNoDefaultCameras</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure no default (startup) cameras are to be rendered.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_render_no_default_cameras.py</code> <pre><code>class ValidateRenderNoDefaultCameras(plugin.MayaInstancePlugin,\n                                     OptionalPyblishPluginMixin):\n    \"\"\"Ensure no default (startup) cameras are to be rendered.\"\"\"\n\n    order = ValidateContentsOrder\n    families = ['renderlayer']\n    label = \"No Default Cameras Renderable\"\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = False\n\n    @staticmethod\n    def get_invalid(instance):\n\n        renderable = set(instance.data[\"cameras\"])\n\n        # Collect default cameras\n        cameras = cmds.ls(type='camera', long=True)\n        defaults = set(cam for cam in cameras if\n                       cmds.camera(cam, query=True, startupCamera=True))\n\n        return [cam for cam in renderable if cam in defaults]\n\n    def process(self, instance):\n        \"\"\"Process all the cameras in the instance\"\"\"\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                title=\"Rendering default cameras\",\n                message=\"Renderable default cameras \"\n                        \"found: {0}\".format(invalid))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_render_no_default_cameras.html#client.ayon_maya.plugins.publish.validate_render_no_default_cameras.ValidateRenderNoDefaultCameras.process","title":"<code>process(instance)</code>","text":"<p>Process all the cameras in the instance</p> Source code in <code>client/ayon_maya/plugins/publish/validate_render_no_default_cameras.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the cameras in the instance\"\"\"\n    if not self.is_active(instance.data):\n        return\n    invalid = self.get_invalid(instance)\n    if invalid:\n        raise PublishValidationError(\n            title=\"Rendering default cameras\",\n            message=\"Renderable default cameras \"\n                    \"found: {0}\".format(invalid))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_render_single_camera.html","title":"validate_render_single_camera","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_render_single_camera.html#client.ayon_maya.plugins.publish.validate_render_single_camera.ValidateRenderSingleCamera","title":"<code>ValidateRenderSingleCamera</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate renderable camera count for layer and  token. <p>Pipeline is supporting multiple renderable cameras per layer, but image prefix must contain  token. Source code in <code>client/ayon_maya/plugins/publish/validate_render_single_camera.py</code> <pre><code>class ValidateRenderSingleCamera(plugin.MayaInstancePlugin,\n                                 OptionalPyblishPluginMixin):\n    \"\"\"Validate renderable camera count for layer and &lt;Camera&gt; token.\n\n    Pipeline is supporting multiple renderable cameras per layer, but image\n    prefix must contain &lt;Camera&gt; token.\n    \"\"\"\n\n    order = ValidateContentsOrder\n    label = \"Render Single Camera\"\n    families = [\"renderlayer\",\n                \"vrayscene\"]\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = False\n\n    R_CAMERA_TOKEN = re.compile(r'%c|&lt;camera&gt;', re.IGNORECASE)\n\n    def process(self, instance):\n        \"\"\"Process all the cameras in the instance\"\"\"\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Invalid render cameras.\",\n                description=self.get_description()\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        cameras = instance.data.get(\"cameras\", [])\n        renderer = cmds.getAttr('defaultRenderGlobals.currentRenderer').lower()\n        # handle various renderman names\n        if renderer.startswith('renderman'):\n            renderer = 'renderman'\n\n        file_prefix = cmds.getAttr(\n            RenderSettings.get_image_prefix_attr(renderer)\n        )\n\n        renderlayer = instance.data[\"renderlayer\"]\n        if len(cameras) &gt; 1:\n            if re.search(cls.R_CAMERA_TOKEN, file_prefix):\n                # if there is &lt;Camera&gt; token in prefix and we have more then\n                # 1 camera, all is ok.\n                return\n            cls.log.error(\n                \"Multiple renderable cameras found for %s: %s \",\n                renderlayer, \", \".join(cameras))\n            return [renderlayer] + cameras\n\n        elif len(cameras) &lt; 1:\n            cls.log.error(\"No renderable cameras found for %s \", renderlayer)\n            return [renderlayer]\n\n    def get_description(self):\n        return inspect.cleandoc(\n            \"\"\"### Render Cameras Invalid\n\n            Your render cameras are misconfigured. You may have no render\n            camera set or have multiple cameras with a render filename\n            prefix that does not include the `&lt;Camera&gt;` token.\n\n            See the logs for more details about the cameras.\n\n            \"\"\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_render_single_camera.html#client.ayon_maya.plugins.publish.validate_render_single_camera.ValidateRenderSingleCamera.process","title":"<code>process(instance)</code>","text":"<p>Process all the cameras in the instance</p> Source code in <code>client/ayon_maya/plugins/publish/validate_render_single_camera.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the cameras in the instance\"\"\"\n    if not self.is_active(instance.data):\n        return\n    invalid = self.get_invalid(instance)\n    if invalid:\n        raise PublishValidationError(\n            \"Invalid render cameras.\",\n            description=self.get_description()\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_renderlayer_aovs.html","title":"validate_renderlayer_aovs","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_renderlayer_aovs.html#client.ayon_maya.plugins.publish.validate_renderlayer_aovs.ValidateRenderLayerAOVs","title":"<code>ValidateRenderLayerAOVs</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate created AOVs / RenderElement is registered in the database</p> <p>Each render element is registered as a product which is formatted based on the render layer and the render element, example:</p> <pre><code>&lt;render layer&gt;.&lt;render element&gt;\n</code></pre> <p>This translates to something like this:</p> <pre><code>CHAR.diffuse\n</code></pre> <p>This check is needed to ensure the render output is still complete</p> Source code in <code>client/ayon_maya/plugins/publish/validate_renderlayer_aovs.py</code> <pre><code>class ValidateRenderLayerAOVs(plugin.MayaInstancePlugin,\n                              OptionalPyblishPluginMixin):\n    \"\"\"Validate created AOVs / RenderElement is registered in the database\n\n    Each render element is registered as a product which is formatted based on\n    the render layer and the render element, example:\n\n        &lt;render layer&gt;.&lt;render element&gt;\n\n    This translates to something like this:\n\n        CHAR.diffuse\n\n    This check is needed to ensure the render output is still complete\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder + 0.1\n    label = \"Render Passes / AOVs Are Registered\"\n    families = [\"renderlayer\"]\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Found unregistered products: {}\".format(invalid))\n\n    def get_invalid(self, instance):\n        invalid = []\n\n        project_name = instance.context.data[\"projectName\"]\n        folder_entity = instance.data[\"folderEntity\"]\n        render_passes = instance.data.get(\"renderPasses\", [])\n        for render_pass in render_passes:\n            is_valid = self.validate_product_registered(\n                project_name, folder_entity, render_pass\n            )\n            if not is_valid:\n                invalid.append(render_pass)\n\n        return invalid\n\n    def validate_product_registered(\n        self, project_name, folder_entity, product_name\n    ):\n        \"\"\"Check if product is registered in the database under the folder\"\"\"\n\n        return ayon_api.get_product_by_name(\n            project_name, product_name, folder_entity[\"id\"], fields={\"id\"}\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_renderlayer_aovs.html#client.ayon_maya.plugins.publish.validate_renderlayer_aovs.ValidateRenderLayerAOVs.validate_product_registered","title":"<code>validate_product_registered(project_name, folder_entity, product_name)</code>","text":"<p>Check if product is registered in the database under the folder</p> Source code in <code>client/ayon_maya/plugins/publish/validate_renderlayer_aovs.py</code> <pre><code>def validate_product_registered(\n    self, project_name, folder_entity, product_name\n):\n    \"\"\"Check if product is registered in the database under the folder\"\"\"\n\n    return ayon_api.get_product_by_name(\n        project_name, product_name, folder_entity[\"id\"], fields={\"id\"}\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rendersettings.html","title":"validate_rendersettings","text":"<p>Maya validator for render settings.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rendersettings.html#client.ayon_maya.plugins.publish.validate_rendersettings.ValidateRenderSettings","title":"<code>ValidateRenderSettings</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates the global render settings</p> <ul> <li> <p>File Name Prefix must start with: <code>&lt;Scene&gt;</code>     all other token are customizable but sane values for Arnold are:</p> <p><code>&lt;Scene&gt;/&lt;RenderLayer&gt;/&lt;RenderLayer&gt;_&lt;RenderPass&gt;</code></p> <p> token is supported also, useful for multiple renderable cameras per render layer. <p>For Redshift omit  token. Redshift will append it automatically if AOVs are enabled and if you user Multipart EXR it doesn't make much sense. <li> <p>Frame Padding must be:</p> <ul> <li>default: 4</li> </ul> </li> <li> <p>Animation must be toggled on, in Render Settings - Common tab:</p> <ul> <li>vray: Animation on standard of specific</li> <li>arnold: Frame / Animation ext: Any choice without \"(Single Frame)\"</li> <li>redshift: Animation toggled on</li> </ul> </li> NOTE <p>The repair function of this plugin does not repair the animation setting of the render settings due to multiple possibilities.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rendersettings.py</code> <pre><code>class ValidateRenderSettings(plugin.MayaInstancePlugin,\n                             OptionalPyblishPluginMixin):\n    \"\"\"Validates the global render settings\n\n    * File Name Prefix must start with: `&lt;Scene&gt;`\n        all other token are customizable but sane values for Arnold are:\n\n        `&lt;Scene&gt;/&lt;RenderLayer&gt;/&lt;RenderLayer&gt;_&lt;RenderPass&gt;`\n\n        &lt;Camera&gt; token is supported also, useful for multiple renderable\n        cameras per render layer.\n\n        For Redshift omit &lt;RenderPass&gt; token. Redshift will append it\n        automatically if AOVs are enabled and if you user Multipart EXR\n        it doesn't make much sense.\n\n    * Frame Padding must be:\n        * default: 4\n\n    * Animation must be toggled on, in Render Settings - Common tab:\n        * vray: Animation on standard of specific\n        * arnold: Frame / Animation ext: Any choice without \"(Single Frame)\"\n        * redshift: Animation toggled on\n\n    NOTE:\n        The repair function of this plugin does not repair the animation\n        setting of the render settings due to multiple possibilities.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    label = \"Validate Render Settings\"\n    hosts = [\"maya\"]\n    families = [\"renderlayer\"]\n    actions = [RepairAction]\n    optional = True\n\n    ImagePrefixes = {\n        'mentalray': 'defaultRenderGlobals.imageFilePrefix',\n        'vray': 'vraySettings.fileNamePrefix',\n        'arnold': 'defaultRenderGlobals.imageFilePrefix',\n        'renderman': 'rmanGlobals.imageFileFormat',\n        'redshift': 'defaultRenderGlobals.imageFilePrefix',\n        'mayahardware2': 'defaultRenderGlobals.imageFilePrefix',\n    }\n\n    ImagePrefixTokens = {\n        'mentalray': '&lt;Scene&gt;/&lt;RenderLayer&gt;/&lt;RenderLayer&gt;{aov_separator}&lt;RenderPass&gt;',  # noqa: E501\n        'arnold': '&lt;Scene&gt;/&lt;RenderLayer&gt;/&lt;RenderLayer&gt;{aov_separator}&lt;RenderPass&gt;',  # noqa: E501\n        'redshift': '&lt;Scene&gt;/&lt;RenderLayer&gt;/&lt;RenderLayer&gt;',\n        'vray': '&lt;Scene&gt;/&lt;Layer&gt;/&lt;Layer&gt;',\n        'renderman': '&lt;layer&gt;{aov_separator}&lt;aov&gt;.&lt;f4&gt;.&lt;ext&gt;',\n        'mayahardware2': '&lt;Scene&gt;/&lt;RenderLayer&gt;/&lt;RenderLayer&gt;',\n    }\n\n    _aov_chars = {\n        \"dot\": \".\",\n        \"dash\": \"-\",\n        \"underscore\": \"_\"\n    }\n\n    redshift_AOV_prefix = \"&lt;BeautyPath&gt;/&lt;BeautyFile&gt;{aov_separator}&lt;RenderPass&gt;\"  # noqa: E501\n\n    renderman_dir_prefix = \"&lt;scene&gt;/&lt;layer&gt;\"\n\n    R_AOV_TOKEN = re.compile(\n        r'%a|&lt;aov&gt;|&lt;renderpass&gt;', re.IGNORECASE)\n    R_LAYER_TOKEN = re.compile(\n        r'%l|&lt;layer&gt;|&lt;renderlayer&gt;', re.IGNORECASE)\n    R_CAMERA_TOKEN = re.compile(r'%c|Camera&gt;')\n    R_SCENE_TOKEN = re.compile(r'%s|&lt;scene&gt;', re.IGNORECASE)\n\n    DEFAULT_PADDING = 4\n    VRAY_PREFIX = \"&lt;Scene&gt;/&lt;Layer&gt;/&lt;Layer&gt;\"\n    DEFAULT_PREFIX = \"&lt;Scene&gt;/&lt;RenderLayer&gt;/&lt;RenderLayer&gt;_&lt;RenderPass&gt;\"\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                title=\"Invalid Render Settings\",\n                message=(\"Invalid render settings found \"\n                         \"for '{}'!\".format(instance.name))\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        invalid = False\n\n        renderer = instance.data['renderer']\n        layer = instance.data['renderlayer']\n        cameras = instance.data.get(\"cameras\", [])\n\n        # Prefix attribute can return None when a value was never set\n        prefix = lib.get_attr_in_layer(cls.ImagePrefixes[renderer],\n                                       layer=layer) or \"\"\n        padding = lib.get_attr_in_layer(\n            attr=RenderSettings.get_padding_attr(renderer),\n            layer=layer\n        )\n\n        anim_override = lib.get_attr_in_layer(\"defaultRenderGlobals.animation\",\n                                              layer=layer)\n\n        prefix = prefix.replace(\n            \"{aov_separator}\", instance.data.get(\"aovSeparator\", \"_\"))\n\n        default_prefix = cls.ImagePrefixTokens[renderer]\n\n        if not anim_override:\n            invalid = True\n            cls.log.error(\"Animation needs to be enabled. Use the same \"\n                          \"frame for start and end to render single frame\")\n\n        if not re.search(cls.R_LAYER_TOKEN, prefix):\n            invalid = True\n            cls.log.error(\"Wrong image prefix [ {} ] - \"\n                          \"doesn't have: '&lt;renderlayer&gt;' or \"\n                          \"'&lt;layer&gt;' token\".format(prefix))\n\n        if len(cameras) &gt; 1 and not re.search(cls.R_CAMERA_TOKEN, prefix):\n            invalid = True\n            cls.log.error(\"Wrong image prefix [ {} ] - \"\n                          \"doesn't have: '&lt;Camera&gt;' token\".format(prefix))\n            cls.log.error(\n                \"Note that to needs to have capital 'C' at the beginning\")\n\n        # renderer specific checks\n        if renderer == \"vray\":\n            vray_settings = cmds.ls(type=\"VRaySettingsNode\")\n            if not vray_settings:\n                node = cmds.createNode(\"VRaySettingsNode\")\n            else:\n                node = vray_settings[0]\n\n            scene_sep = cmds.getAttr(\n                \"{}.fileNameRenderElementSeparator\".format(node))\n            if scene_sep != instance.data.get(\"aovSeparator\", \"_\"):\n                cls.log.error(\"AOV separator is not set correctly.\")\n                invalid = True\n\n        if renderer == \"redshift\":\n            redshift_AOV_prefix = cls.redshift_AOV_prefix.replace(\n                \"{aov_separator}\", instance.data.get(\"aovSeparator\", \"_\")\n            )\n            if re.search(cls.R_AOV_TOKEN, prefix):\n                invalid = True\n                cls.log.error((\"Do not use AOV token [ {} ] - \"\n                               \"Redshift is using image prefixes per AOV so \"\n                               \"it doesn't make much sense using it in global\"\n                               \"image prefix\").format(prefix))\n            # get redshift AOVs\n            rs_aovs = cmds.ls(type=\"RedshiftAOV\", referencedNodes=False)\n            for aov in rs_aovs:\n                aov_prefix = cmds.getAttr(\"{}.filePrefix\".format(aov))\n                # check their image prefix\n                if aov_prefix != redshift_AOV_prefix:\n                    cls.log.error((\"AOV ({}) image prefix is not set \"\n                                   \"correctly {} != {}\").format(\n                        cmds.getAttr(\"{}.name\".format(aov)),\n                        aov_prefix,\n                        redshift_AOV_prefix\n                    ))\n                    invalid = True\n\n                # check aov file format\n                aov_ext = cmds.getAttr(\"{}.fileFormat\".format(aov))\n                default_ext = cmds.getAttr(\"redshiftOptions.imageFormat\")\n                aov_type = cmds.getAttr(\"{}.aovType\".format(aov))\n                if aov_type == \"Cryptomatte\":\n                    # redshift Cryptomatte AOV always uses \"Cryptomatte (EXR)\"\n                    # so we ignore validating file format for it.\n                    pass\n\n                elif default_ext != aov_ext:\n                    labels = get_redshift_image_format_labels()\n                    cls.log.error(\n                        \"AOV file format {} does not match global file format \"\n                        \"{}\".format(labels[aov_ext], labels[default_ext])\n                    )\n                    invalid = True\n\n        if renderer == \"renderman\":\n            file_prefix = cmds.getAttr(\"rmanGlobals.imageFileFormat\")\n            dir_prefix = cmds.getAttr(\"rmanGlobals.imageOutputDir\")\n\n            if file_prefix.lower() != prefix.lower():\n                invalid = True\n                cls.log.error(\"Wrong image prefix [ {} ]\".format(file_prefix))\n\n            if dir_prefix.lower() != cls.renderman_dir_prefix.lower():\n                invalid = True\n                cls.log.error(\"Wrong directory prefix [ {} ]\".format(\n                    dir_prefix))\n\n        if renderer == \"arnold\":\n            multipart = cmds.getAttr(\"defaultArnoldDriver.mergeAOVs\")\n            if multipart:\n                if re.search(cls.R_AOV_TOKEN, prefix):\n                    invalid = True\n                    cls.log.error(\"Wrong image prefix [ {} ] - \"\n                                  \"You can't use '&lt;renderpass&gt;' token \"\n                                  \"with merge AOVs turned on\".format(prefix))\n                default_prefix = re.sub(\n                    cls.R_AOV_TOKEN, \"\", default_prefix)\n                # remove aov token from prefix to pass validation\n                default_prefix = default_prefix.split(\"{aov_separator}\")[0]\n            elif not re.search(cls.R_AOV_TOKEN, prefix):\n                invalid = True\n                cls.log.error(\"Wrong image prefix [ {} ] - \"\n                              \"doesn't have: '&lt;renderpass&gt;' or \"\n                              \"token\".format(prefix))\n\n        default_prefix = default_prefix.replace(\n            \"{aov_separator}\", instance.data.get(\"aovSeparator\", \"_\"))\n        if prefix.lower() != default_prefix.lower():\n            cls.log.warning(\"warning: prefix differs from \"\n                            \"recommended {}\".format(\n                                default_prefix))\n\n        if padding != cls.DEFAULT_PADDING:\n            invalid = True\n            cls.log.error(\"Expecting padding of {} ( {} )\".format(\n                cls.DEFAULT_PADDING, \"0\" * cls.DEFAULT_PADDING))\n\n        # load validation definitions from settings\n        settings_lights_flag = instance.context.data[\"project_settings\"].get(\n            \"maya\", {}).get(\n            \"render_settings\", {}).get(\n            \"enable_all_lights\", False)\n\n        instance_lights_flag = instance.data.get(\"renderSetupIncludeLights\")\n        if settings_lights_flag != instance_lights_flag:\n            cls.log.warning(\n                \"Instance flag for \\\"Render Setup Include Lights\\\" is set to \"\n                \"{} and Settings flag is set to {}\".format(\n                    instance_lights_flag, settings_lights_flag\n                )\n            )\n\n        # go through definitions and test if such node.attribute exists.\n        # if so, compare its value from the one required.\n        for data in cls.get_nodes(instance, renderer):\n            for node in data[\"nodes\"]:\n                # Why is captured 'PublishValidationError'? How it can be\n                #   raised by 'cmds.getAttr(...)'?\n                try:\n                    render_value = cmds.getAttr(\n                        \"{}.{}\".format(node, data[\"attribute\"])\n                    )\n                except PublishValidationError:\n                    invalid = True\n                    cls.log.error(\n                        \"Cannot get value of {}.{}\".format(\n                            node, data[\"attribute\"]\n                        )\n                    )\n                else:\n                    if render_value not in data[\"values\"]:\n                        invalid = True\n                        cls.log.error(\n                            \"Invalid value {} set on {}.{}. Expecting \"\n                            \"{}\".format(\n                                render_value,\n                                node,\n                                data[\"attribute\"],\n                                data[\"values\"]\n                            )\n                        )\n\n        return invalid\n\n    @classmethod\n    def get_nodes(cls, instance, renderer):\n        maya_settings = instance.context.data[\"project_settings\"][\"maya\"]\n        renderer_key = \"{}_render_attributes\".format(renderer)\n        validation_settings = (\n            maya_settings[\"publish\"][\"ValidateRenderSettings\"].get(\n                renderer_key\n            )\n        ) or []\n        validation_settings = [\n            (item[\"type\"], item[\"value\"])\n            for item in validation_settings\n        ]\n        result = []\n        for attr, values in OrderedDict(validation_settings).items():\n            values = [convert_to_int_or_float(v) for v in values if v]\n\n            # Validate the settings has values.\n            if not values:\n                cls.log.error(\n                    \"Settings for {} is missing values.\".format(attr)\n                )\n                continue\n\n            cls.log.debug(\"{}: {}\".format(attr, values))\n            if \".\" not in attr:\n                cls.log.warning(\n                    \"Skipping invalid attribute defined in validation \"\n                    \"settings: \\\"{}\\\"\".format(attr)\n                )\n                continue\n\n            node_type, attribute_name = attr.split(\".\", 1)\n\n            # first get node of that type\n            nodes = cmds.ls(type=node_type)\n\n            if not nodes:\n                cls.log.warning(\n                    \"No nodes of type \\\"{}\\\" found.\".format(node_type)\n                )\n                continue\n\n            result.append(\n                {\n                    \"attribute\": attribute_name,\n                    \"nodes\": nodes,\n                    \"values\": values\n                }\n            )\n\n        return result\n\n    @classmethod\n    def repair(cls, instance):\n        renderer = instance.data['renderer']\n        layer_node = instance.data['setMembers']\n        redshift_AOV_prefix = cls.redshift_AOV_prefix.replace(\n            \"{aov_separator}\", instance.data.get(\"aovSeparator\", \"_\")\n        )\n        default_prefix = cls.ImagePrefixTokens[renderer].replace(\n            \"{aov_separator}\", instance.data.get(\"aovSeparator\", \"_\")\n        )\n\n        for data in cls.get_nodes(instance, renderer):\n            if not data[\"values\"]:\n                continue\n            for node in data[\"nodes\"]:\n                lib.set_attribute(data[\"attribute\"], data[\"values\"][0], node)\n        with lib.renderlayer(layer_node):\n\n            # Repair animation must be enabled\n            cmds.setAttr(\"defaultRenderGlobals.animation\", True)\n\n            # Repair prefix\n            if renderer == \"arnold\":\n                multipart = cmds.getAttr(\"defaultArnoldDriver.mergeAOVs\")\n                if multipart:\n                    separator_variations = [\n                        \"_&lt;RenderPass&gt;\",\n                        \"&lt;RenderPass&gt;_\",\n                        \"&lt;RenderPass&gt;\",\n                    ]\n                    for variant in separator_variations:\n                        default_prefix = default_prefix.replace(variant, \"\")\n\n            if renderer != \"renderman\":\n                prefix_attr = RenderSettings.get_image_prefix_attr(renderer)\n                fname_prefix = default_prefix\n                cmds.setAttr(prefix_attr, fname_prefix, type=\"string\")\n\n                # Repair padding\n                padding_attr = RenderSettings.get_padding_attr(renderer)\n                cmds.setAttr(padding_attr, cls.DEFAULT_PADDING)\n            else:\n                # renderman handles stuff differently\n                cmds.setAttr(\"rmanGlobals.imageFileFormat\",\n                             default_prefix,\n                             type=\"string\")\n                cmds.setAttr(\"rmanGlobals.imageOutputDir\",\n                             cls.renderman_dir_prefix,\n                             type=\"string\")\n\n            if renderer == \"vray\":\n                vray_settings = cmds.ls(type=\"VRaySettingsNode\")\n                if not vray_settings:\n                    node = cmds.createNode(\"VRaySettingsNode\")\n                else:\n                    node = vray_settings[0]\n\n                cmds.optionMenuGrp(\"vrayRenderElementSeparator\",\n                                   v=instance.data.get(\"aovSeparator\", \"_\"))\n                cmds.setAttr(\n                    \"{}.fileNameRenderElementSeparator\".format(node),\n                    instance.data.get(\"aovSeparator\", \"_\"),\n                    type=\"string\"\n                )\n\n            if renderer == \"redshift\":\n                # get redshift AOVs\n                rs_aovs = cmds.ls(type=\"RedshiftAOV\", referencedNodes=False)\n                for aov in rs_aovs:\n                    # fix AOV prefixes\n                    cmds.setAttr(\n                        \"{}.filePrefix\".format(aov),\n                        redshift_AOV_prefix, type=\"string\")\n                    # fix AOV file format\n                    default_ext = cmds.getAttr(\n                        \"redshiftOptions.imageFormat\", asString=True)\n                    cmds.setAttr(\n                        \"{}.fileFormat\".format(aov), default_ext)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rendersettings.html#client.ayon_maya.plugins.publish.validate_rendersettings.get_redshift_image_format_labels","title":"<code>get_redshift_image_format_labels()</code>","text":"<p>Return nice labels for Redshift image formats.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rendersettings.py</code> <pre><code>def get_redshift_image_format_labels():\n    \"\"\"Return nice labels for Redshift image formats.\"\"\"\n    var = \"$g_redshiftImageFormatLabels\"\n    return mel.eval(\"{0}={0}\".format(var))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_resolution.html","title":"validate_resolution","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_resolution.html#client.ayon_maya.plugins.publish.validate_resolution.ValidateResolution","title":"<code>ValidateResolution</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate the render resolution setting aligned with DB</p> Source code in <code>client/ayon_maya/plugins/publish/validate_resolution.py</code> <pre><code>class ValidateResolution(plugin.MayaInstancePlugin,\n                         OptionalPyblishPluginMixin):\n    \"\"\"Validate the render resolution setting aligned with DB\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"renderlayer\"]\n    label = \"Validate Resolution\"\n    actions = [RepairAction]\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid_resolution(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Render resolution is invalid. See log for details.\",\n                description=(\n                    \"Wrong render resolution setting. \"\n                    \"Please use repair button to fix it.\\n\\n\"\n                    \"If current renderer is V-Ray, \"\n                    \"make sure vraySettings node has been created.\"\n                )\n            )\n\n    @classmethod\n    def get_invalid_resolution(cls, instance):\n        width, height, pixelAspect = cls.get_folder_resolution(instance)\n        current_renderer = instance.data[\"renderer\"]\n        layer = instance.data[\"renderlayer\"]\n        invalid = False\n        if current_renderer == \"vray\":\n            vray_node = \"vraySettings\"\n            if cmds.objExists(vray_node):\n                current_width = lib.get_attr_in_layer(\n                    \"{}.width\".format(vray_node), layer=layer)\n                current_height = lib.get_attr_in_layer(\n                    \"{}.height\".format(vray_node), layer=layer)\n                current_pixelAspect = lib.get_attr_in_layer(\n                    \"{}.pixelAspect\".format(vray_node), layer=layer\n                )\n            else:\n                cls.log.error(\n                    \"Can't detect VRay resolution because there is no node \"\n                    \"named: `{}`\".format(vray_node)\n                )\n                return True\n        else:\n            current_width = lib.get_attr_in_layer(\n                \"defaultResolution.width\", layer=layer)\n            current_height = lib.get_attr_in_layer(\n                \"defaultResolution.height\", layer=layer)\n            current_pixelAspect = lib.get_attr_in_layer(\n                \"defaultResolution.pixelAspect\", layer=layer\n            )\n        if current_width != width or current_height != height:\n            cls.log.error(\n                \"Render resolution {}x{} does not match \"\n                \"folder resolution {}x{}\".format(\n                    current_width, current_height,\n                    width, height\n                ))\n            invalid = True\n        if current_pixelAspect != pixelAspect:\n            cls.log.error(\n                \"Render pixel aspect {} does not match \"\n                \"folder pixel aspect {}\".format(\n                    current_pixelAspect, pixelAspect\n                ))\n            invalid = True\n        return invalid\n\n    @classmethod\n    def get_folder_resolution(cls, instance):\n        task_attributes = instance.data[\"taskEntity\"][\"attrib\"]\n        width = task_attributes[\"resolutionWidth\"]\n        height = task_attributes[\"resolutionHeight\"]\n        pixel_aspect = task_attributes[\"pixelAspect\"]\n        return int(width), int(height), float(pixel_aspect)\n\n    @classmethod\n    def repair(cls, instance):\n        # Usually without renderlayer overrides the renderlayers\n        # all share the same resolution value - so fixing the first\n        # will have fixed all the others too. It's much faster to\n        # check whether it's invalid first instead of switching\n        # into all layers individually\n        if not cls.get_invalid_resolution(instance):\n            cls.log.debug(\n                \"Nothing to repair on instance: {}\".format(instance)\n            )\n            return\n        layer_node = instance.data['setMembers']\n        with lib.renderlayer(layer_node):\n            reset_scene_resolution()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_review.html","title":"validate_review","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_review.html#client.ayon_maya.plugins.publish.validate_review.ValidateReview","title":"<code>ValidateReview</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validate review.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_review.py</code> <pre><code>class ValidateReview(plugin.MayaInstancePlugin):\n    \"\"\"Validate review.\"\"\"\n\n    order = ValidateContentsOrder\n    label = \"Validate Review\"\n    families = [\"review\"]\n\n    def process(self, instance):\n        cameras = instance.data[\"cameras\"]\n\n        # validate required settings\n        if len(cameras) == 0:\n            raise PublishValidationError(\n                \"No camera found in review instance: {}\".format(instance)\n            )\n        elif len(cameras) &gt; 2:\n            raise PublishValidationError(\n                \"Only a single camera is allowed for a review instance but \"\n                \"more than one camera found in review instance: {}. \"\n                \"Cameras found: {}\".format(instance, \", \".join(cameras))\n            )\n\n        self.log.debug('camera: {}'.format(instance.data[\"review_camera\"]))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_contents.html","title":"validate_rig_contents","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_contents.html#client.ayon_maya.plugins.publish.validate_rig_contents.ValidateRigContents","title":"<code>ValidateRigContents</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure rig contains pipeline-critical content</p> Every rig must contain at least two object sets <p>\"controls_SET\" - Set of all animatable controls \"out_SET\" - Set of all cacheable meshes</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_contents.py</code> <pre><code>class ValidateRigContents(plugin.MayaInstancePlugin,\n                          OptionalPyblishPluginMixin):\n    \"\"\"Ensure rig contains pipeline-critical content\n\n    Every rig must contain at least two object sets:\n        \"controls_SET\" - Set of all animatable controls\n        \"out_SET\" - Set of all cacheable meshes\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    label = \"Rig Contents\"\n    families = [\"rig\"]\n    action = [ayon_maya.api.action.SelectInvalidAction]\n    optional = True\n\n    accepted_output = [\"mesh\", \"transform\"]\n    accepted_controllers = [\"transform\"]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Invalid rig content. See log for details.\")\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        # Find required sets by suffix\n        required, rig_sets = cls.get_nodes(instance)\n\n        cls.validate_missing_objectsets(instance, required, rig_sets)\n\n        controls_set = rig_sets[\"controls_SET\"]\n        out_set = rig_sets[\"out_SET\"]\n\n        # Ensure contents in sets and retrieve long path for all objects\n        output_content = cmds.sets(out_set, query=True) or []\n        if not output_content:\n            raise PublishValidationError(\"Must have members in rig out_SET\")\n        output_content = cmds.ls(output_content, long=True)\n\n        controls_content = cmds.sets(controls_set, query=True) or []\n        if not controls_content:\n            raise PublishValidationError(\n                \"Must have members in rig controls_SET\"\n            )\n        controls_content = cmds.ls(controls_content, long=True)\n\n        rig_content = output_content + controls_content\n        invalid_hierarchy = cls.invalid_hierarchy(instance, rig_content)\n\n        # Additional validations\n        invalid_geometry = cls.validate_geometry(output_content)\n        invalid_controls = cls.validate_controls(controls_content)\n\n        error = False\n        if invalid_hierarchy:\n            cls.log.error(\"Found nodes which reside outside of root group \"\n                           \"while they are set up for publishing.\"\n                           \"\\n%s\" % invalid_hierarchy)\n            error = True\n\n        if invalid_controls:\n            cls.log.error(\"Only transforms can be part of the controls_SET.\"\n                           \"\\n%s\" % invalid_controls)\n            error = True\n\n        if invalid_geometry:\n            cls.log.error(\"Only meshes can be part of the out_SET\\n%s\"\n                           % invalid_geometry)\n            error = True\n        if error:\n            return invalid_hierarchy + invalid_controls + invalid_geometry\n\n    @classmethod\n    def validate_missing_objectsets(cls, instance,\n                                    required_objsets, rig_sets):\n        \"\"\"Validate missing objectsets in rig sets\n\n        Args:\n            instance (pyblish.api.Instance): instance\n            required_objsets (list[str]): list of objectset names\n            rig_sets (list[str]): list of rig sets\n\n        Raises:\n            PublishValidationError: When the error is raised, it will show\n                which instance has the missing object sets\n        \"\"\"\n        missing = [\n            key for key in required_objsets if key not in rig_sets\n        ]\n        if missing:\n            raise PublishValidationError(\n                \"%s is missing sets: %s\" % (instance, \", \".join(missing))\n            )\n\n    @classmethod\n    def invalid_hierarchy(cls, instance, content):\n        \"\"\"\n        Check if all rig set members are within the hierarchy of the rig root\n\n        Args:\n            instance (pyblish.api.Instance): instance\n            content (list[str]): list of content from rig sets\n\n        Raises:\n            PublishValidationError: It means no dag nodes in\n                the rig instance\n\n        Returns:\n            List[str]: invalid hierarchy\n        \"\"\"\n        # Ensure there are at least some transforms or dag nodes\n        # in the rig instance\n        set_members = instance.data['setMembers']\n        if not cmds.ls(set_members, type=\"dagNode\", long=True):\n            raise PublishValidationError(\n                \"No dag nodes in the rig instance. \"\n                \"(Empty instance?)\"\n            )\n        # Validate members are inside the hierarchy from root node\n        root_nodes = cmds.ls(set_members, assemblies=True, long=True)\n        hierarchy = cmds.listRelatives(root_nodes, allDescendents=True,\n                                       fullPath=True) + root_nodes\n        hierarchy = set(hierarchy)\n        invalid_hierarchy = []\n        for node in content:\n            if node not in hierarchy:\n                invalid_hierarchy.append(node)\n        return invalid_hierarchy\n\n    @classmethod\n    def validate_geometry(cls, set_members):\n        \"\"\"Checks if the node types of the set members valid\n\n        Args:\n            set_members (list[str]): nodes of the out_set\n\n        Returns:\n            list[str]: Nodes of invalid types.\n        \"\"\"\n\n        # Validate all shape types\n        invalid = []\n        shapes = cmds.listRelatives(set_members,\n                                    allDescendents=True,\n                                    shapes=True,\n                                    fullPath=True) or []\n        all_shapes = cmds.ls(set_members + shapes, long=True, shapes=True)\n        for shape in all_shapes:\n            if cmds.nodeType(shape) not in cls.accepted_output:\n                invalid.append(shape)\n\n        return invalid\n\n    @classmethod\n    def validate_controls(cls, set_members):\n        \"\"\"Checks if the node types of the set members are valid for controls.\n\n        Args:\n            set_members (list[str]): list of nodes of the controls_set\n\n        Returns:\n            list: Controls of disallowed node types.\n        \"\"\"\n\n        # Validate control types\n        invalid = []\n        for node in set_members:\n            if cmds.nodeType(node) not in cls.accepted_controllers:\n                invalid.append(node)\n\n        return invalid\n\n    @classmethod\n    def get_nodes(cls, instance):\n        \"\"\"Get the target objectsets and rig sets nodes\n\n        Args:\n            instance (pyblish.api.Instance): instance\n\n        Returns:\n            tuple: 2-tuple of list of objectsets,\n                list of rig sets nodes\n        \"\"\"\n        objectsets = [\"controls_SET\", \"out_SET\"]\n        rig_sets_nodes = instance.data.get(\"rig_sets\", [])\n        return objectsets, rig_sets_nodes\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_contents.html#client.ayon_maya.plugins.publish.validate_rig_contents.ValidateRigContents.get_nodes","title":"<code>get_nodes(instance)</code>  <code>classmethod</code>","text":"<p>Get the target objectsets and rig sets nodes</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>instance</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>2-tuple of list of objectsets, list of rig sets nodes</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_contents.py</code> <pre><code>@classmethod\ndef get_nodes(cls, instance):\n    \"\"\"Get the target objectsets and rig sets nodes\n\n    Args:\n        instance (pyblish.api.Instance): instance\n\n    Returns:\n        tuple: 2-tuple of list of objectsets,\n            list of rig sets nodes\n    \"\"\"\n    objectsets = [\"controls_SET\", \"out_SET\"]\n    rig_sets_nodes = instance.data.get(\"rig_sets\", [])\n    return objectsets, rig_sets_nodes\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_contents.html#client.ayon_maya.plugins.publish.validate_rig_contents.ValidateRigContents.invalid_hierarchy","title":"<code>invalid_hierarchy(instance, content)</code>  <code>classmethod</code>","text":"<p>Check if all rig set members are within the hierarchy of the rig root</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>instance</p> required <code>content</code> <code>list[str]</code> <p>list of content from rig sets</p> required <p>Raises:</p> Type Description <code>PublishValidationError</code> <p>It means no dag nodes in the rig instance</p> <p>Returns:</p> Type Description <p>List[str]: invalid hierarchy</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_contents.py</code> <pre><code>@classmethod\ndef invalid_hierarchy(cls, instance, content):\n    \"\"\"\n    Check if all rig set members are within the hierarchy of the rig root\n\n    Args:\n        instance (pyblish.api.Instance): instance\n        content (list[str]): list of content from rig sets\n\n    Raises:\n        PublishValidationError: It means no dag nodes in\n            the rig instance\n\n    Returns:\n        List[str]: invalid hierarchy\n    \"\"\"\n    # Ensure there are at least some transforms or dag nodes\n    # in the rig instance\n    set_members = instance.data['setMembers']\n    if not cmds.ls(set_members, type=\"dagNode\", long=True):\n        raise PublishValidationError(\n            \"No dag nodes in the rig instance. \"\n            \"(Empty instance?)\"\n        )\n    # Validate members are inside the hierarchy from root node\n    root_nodes = cmds.ls(set_members, assemblies=True, long=True)\n    hierarchy = cmds.listRelatives(root_nodes, allDescendents=True,\n                                   fullPath=True) + root_nodes\n    hierarchy = set(hierarchy)\n    invalid_hierarchy = []\n    for node in content:\n        if node not in hierarchy:\n            invalid_hierarchy.append(node)\n    return invalid_hierarchy\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_contents.html#client.ayon_maya.plugins.publish.validate_rig_contents.ValidateRigContents.validate_controls","title":"<code>validate_controls(set_members)</code>  <code>classmethod</code>","text":"<p>Checks if the node types of the set members are valid for controls.</p> <p>Parameters:</p> Name Type Description Default <code>set_members</code> <code>list[str]</code> <p>list of nodes of the controls_set</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Controls of disallowed node types.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_contents.py</code> <pre><code>@classmethod\ndef validate_controls(cls, set_members):\n    \"\"\"Checks if the node types of the set members are valid for controls.\n\n    Args:\n        set_members (list[str]): list of nodes of the controls_set\n\n    Returns:\n        list: Controls of disallowed node types.\n    \"\"\"\n\n    # Validate control types\n    invalid = []\n    for node in set_members:\n        if cmds.nodeType(node) not in cls.accepted_controllers:\n            invalid.append(node)\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_contents.html#client.ayon_maya.plugins.publish.validate_rig_contents.ValidateRigContents.validate_geometry","title":"<code>validate_geometry(set_members)</code>  <code>classmethod</code>","text":"<p>Checks if the node types of the set members valid</p> <p>Parameters:</p> Name Type Description Default <code>set_members</code> <code>list[str]</code> <p>nodes of the out_set</p> required <p>Returns:</p> Type Description <p>list[str]: Nodes of invalid types.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_contents.py</code> <pre><code>@classmethod\ndef validate_geometry(cls, set_members):\n    \"\"\"Checks if the node types of the set members valid\n\n    Args:\n        set_members (list[str]): nodes of the out_set\n\n    Returns:\n        list[str]: Nodes of invalid types.\n    \"\"\"\n\n    # Validate all shape types\n    invalid = []\n    shapes = cmds.listRelatives(set_members,\n                                allDescendents=True,\n                                shapes=True,\n                                fullPath=True) or []\n    all_shapes = cmds.ls(set_members + shapes, long=True, shapes=True)\n    for shape in all_shapes:\n        if cmds.nodeType(shape) not in cls.accepted_output:\n            invalid.append(shape)\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_contents.html#client.ayon_maya.plugins.publish.validate_rig_contents.ValidateRigContents.validate_missing_objectsets","title":"<code>validate_missing_objectsets(instance, required_objsets, rig_sets)</code>  <code>classmethod</code>","text":"<p>Validate missing objectsets in rig sets</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>instance</p> required <code>required_objsets</code> <code>list[str]</code> <p>list of objectset names</p> required <code>rig_sets</code> <code>list[str]</code> <p>list of rig sets</p> required <p>Raises:</p> Type Description <code>PublishValidationError</code> <p>When the error is raised, it will show which instance has the missing object sets</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_contents.py</code> <pre><code>@classmethod\ndef validate_missing_objectsets(cls, instance,\n                                required_objsets, rig_sets):\n    \"\"\"Validate missing objectsets in rig sets\n\n    Args:\n        instance (pyblish.api.Instance): instance\n        required_objsets (list[str]): list of objectset names\n        rig_sets (list[str]): list of rig sets\n\n    Raises:\n        PublishValidationError: When the error is raised, it will show\n            which instance has the missing object sets\n    \"\"\"\n    missing = [\n        key for key in required_objsets if key not in rig_sets\n    ]\n    if missing:\n        raise PublishValidationError(\n            \"%s is missing sets: %s\" % (instance, \", \".join(missing))\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_contents.html#client.ayon_maya.plugins.publish.validate_rig_contents.ValidateSkeletonRigContents","title":"<code>ValidateSkeletonRigContents</code>","text":"<p>               Bases: <code>ValidateRigContents</code></p> <p>Ensure skeleton rigs contains pipeline-critical content</p> The rigs optionally contain at least two object sets <p>\"skeletonMesh_SET\" - Set of the skinned meshes                      with bone hierarchies</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_contents.py</code> <pre><code>class ValidateSkeletonRigContents(ValidateRigContents):\n    \"\"\"Ensure skeleton rigs contains pipeline-critical content\n\n    The rigs optionally contain at least two object sets:\n        \"skeletonMesh_SET\" - Set of the skinned meshes\n                             with bone hierarchies\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    label = \"Skeleton Rig Contents\"\n    hosts = [\"maya\"]\n    families = [\"rig.fbx\"]\n    optional = True\n\n    @classmethod\n    def get_invalid(cls, instance):\n        objectsets, skeleton_mesh_nodes = cls.get_nodes(instance)\n        cls.validate_missing_objectsets(\n            instance, objectsets, instance.data[\"rig_sets\"])\n\n        # Ensure contents in sets and retrieve long path for all objects\n        output_content = instance.data.get(\"skeleton_mesh\", [])\n        output_content = cmds.ls(skeleton_mesh_nodes, long=True)\n\n        invalid_hierarchy = cls.invalid_hierarchy(\n            instance, output_content)\n        invalid_geometry = cls.validate_geometry(output_content)\n\n        error = False\n        if invalid_hierarchy:\n            cls.log.error(\"Found nodes which reside outside of root group \"\n                          \"while they are set up for publishing.\"\n                          \"\\n%s\" % invalid_hierarchy)\n            error = True\n        if invalid_geometry:\n            cls.log.error(\"Found nodes which reside outside of root group \"\n                          \"while they are set up for publishing.\"\n                          \"\\n%s\" % invalid_hierarchy)\n            error = True\n        if error:\n            return invalid_hierarchy + invalid_geometry\n\n    @classmethod\n    def get_nodes(cls, instance):\n        \"\"\"Get the target objectsets and rig sets nodes\n\n        Args:\n            instance (pyblish.api.Instance): instance\n\n        Returns:\n            tuple: 2-tuple of list of objectsets, list of rig sets nodes\n        \"\"\"\n        objectsets = [\"skeletonMesh_SET\"]\n        skeleton_mesh_nodes = instance.data.get(\"skeleton_mesh\", [])\n        return objectsets, skeleton_mesh_nodes\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_contents.html#client.ayon_maya.plugins.publish.validate_rig_contents.ValidateSkeletonRigContents.get_nodes","title":"<code>get_nodes(instance)</code>  <code>classmethod</code>","text":"<p>Get the target objectsets and rig sets nodes</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>instance</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>2-tuple of list of objectsets, list of rig sets nodes</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_contents.py</code> <pre><code>@classmethod\ndef get_nodes(cls, instance):\n    \"\"\"Get the target objectsets and rig sets nodes\n\n    Args:\n        instance (pyblish.api.Instance): instance\n\n    Returns:\n        tuple: 2-tuple of list of objectsets, list of rig sets nodes\n    \"\"\"\n    objectsets = [\"skeletonMesh_SET\"]\n    skeleton_mesh_nodes = instance.data.get(\"skeleton_mesh\", [])\n    return objectsets, skeleton_mesh_nodes\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_controllers.html","title":"validate_rig_controllers","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_controllers.html#client.ayon_maya.plugins.publish.validate_rig_controllers.ValidateRigControllers","title":"<code>ValidateRigControllers</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate rig controllers.</p> <p>Controls must have the transformation attributes on their default values of translate zero, rotate zero and scale one when they are unlocked attributes.</p> <p>Unlocked keyable attributes may not have any incoming connections. If these connections are required for the rig then lock the attributes.</p> <p>The visibility attribute must be locked.</p> <p>Note that <code>repair</code> will:     - Lock all visibility attributes     - Reset all default values for translate, rotate, scale     - Break all incoming connections to keyable attributes</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_controllers.py</code> <pre><code>class ValidateRigControllers(plugin.MayaInstancePlugin,\n                             OptionalPyblishPluginMixin):\n    \"\"\"Validate rig controllers.\n\n    Controls must have the transformation attributes on their default\n    values of translate zero, rotate zero and scale one when they are\n    unlocked attributes.\n\n    Unlocked keyable attributes may not have any incoming connections. If\n    these connections are required for the rig then lock the attributes.\n\n    The visibility attribute must be locked.\n\n    Note that `repair` will:\n        - Lock all visibility attributes\n        - Reset all default values for translate, rotate, scale\n        - Break all incoming connections to keyable attributes\n\n    \"\"\"\n    order = ValidateContentsOrder + 0.05\n    label = \"Rig Controllers\"\n    families = [\"rig\"]\n    optional = True\n    actions = [RepairAction,\n               ayon_maya.api.action.SelectInvalidAction]\n\n    # Default controller values\n    CONTROLLER_DEFAULTS = {\n        \"translateX\": 0,\n        \"translateY\": 0,\n        \"translateZ\": 0,\n        \"rotateX\": 0,\n        \"rotateY\": 0,\n        \"rotateZ\": 0,\n        \"scaleX\": 1,\n        \"scaleY\": 1,\n        \"scaleZ\": 1\n    }\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                '{} failed, see log information'.format(self.label)\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        controls_set = cls.get_node(instance)\n        if not controls_set:\n            cls.log.error(\n                \"Must have 'controls_SET' in rig instance\"\n            )\n            return [instance.data[\"instance_node\"]]\n\n        controls = cmds.sets(controls_set, query=True)\n\n        # Ensure all controls are within the top group\n        lookup = set(instance[:])\n        if not all(control in lookup for control in cmds.ls(controls,\n                                                            long=True)):\n            cls.log.error(\n                \"All controls must be inside the rig's group.\"\n            )\n            return [controls_set]\n\n        # Validate all controls\n        has_connections = list()\n        has_unlocked_visibility = list()\n        has_non_default_values = list()\n        for control in controls:\n            if cls.get_connected_attributes(control):\n                has_connections.append(control)\n\n            # check if visibility is locked\n            attribute = \"{}.visibility\".format(control)\n            locked = cmds.getAttr(attribute, lock=True)\n            if not locked:\n                has_unlocked_visibility.append(control)\n\n            if cls.get_non_default_attributes(control):\n                has_non_default_values.append(control)\n\n        if has_connections:\n            cls.log.error(\"Controls have input connections: \"\n                          \"%s\" % has_connections)\n\n        if has_non_default_values:\n            cls.log.error(\"Controls have non-default values: \"\n                          \"%s\" % has_non_default_values)\n\n        if has_unlocked_visibility:\n            cls.log.error(\"Controls have unlocked visibility \"\n                          \"attribute: %s\" % has_unlocked_visibility)\n\n        invalid = []\n        if (has_connections or\n                has_unlocked_visibility or\n                has_non_default_values):\n            invalid = set()\n            invalid.update(has_connections)\n            invalid.update(has_non_default_values)\n            invalid.update(has_unlocked_visibility)\n            invalid = list(invalid)\n            cls.log.error(\"Invalid rig controllers. See log for details.\")\n\n        return invalid\n\n    @classmethod\n    def get_non_default_attributes(cls, control):\n        \"\"\"Return attribute plugs with non-default values\n\n        Args:\n            control (str): Name of control node.\n\n        Returns:\n            list: The invalid plugs\n\n        \"\"\"\n\n        invalid = []\n        for attr, default in cls.CONTROLLER_DEFAULTS.items():\n            if cmds.attributeQuery(attr, node=control, exists=True):\n                plug = \"{}.{}\".format(control, attr)\n\n                # Ignore locked attributes\n                locked = cmds.getAttr(plug, lock=True)\n                if locked:\n                    continue\n\n                value = cmds.getAttr(plug)\n                if value != default:\n                    cls.log.warning(\"Control non-default value: \"\n                                    \"%s = %s\" % (plug, value))\n                    invalid.append(plug)\n\n        return invalid\n\n    @staticmethod\n    def get_connected_attributes(control):\n        \"\"\"Return attribute plugs with incoming connections.\n\n        This will also ensure no (driven) keys on unlocked keyable attributes.\n\n        Args:\n            control (str): Name of control node.\n\n        Returns:\n            list: The invalid plugs\n\n        \"\"\"\n        import maya.cmds as mc\n\n        # Support controls without any attributes returning None\n        attributes = mc.listAttr(control, keyable=True, scalar=True) or []\n        invalid = []\n        for attr in attributes:\n            plug = \"{}.{}\".format(control, attr)\n\n            # Ignore locked attributes\n            locked = cmds.getAttr(plug, lock=True)\n            if locked:\n                continue\n\n            # Ignore proxy connections.\n            if (cmds.addAttr(plug, query=True, exists=True) and\n                    cmds.addAttr(plug, query=True, usedAsProxy=True)):\n                continue\n\n            # Check for incoming connections\n            if cmds.listConnections(plug, source=True, destination=False):\n                invalid.append(plug)\n\n        return invalid\n\n    @classmethod\n    def repair(cls, instance):\n\n        controls_set = cls.get_node(instance)\n        if not controls_set:\n            cls.log.error(\n                \"Unable to repair because no 'controls_SET' found in rig \"\n                \"instance: {}\".format(instance)\n            )\n            return\n\n        # Use a single undo chunk\n        with undo_chunk():\n            controls = cmds.sets(controls_set, query=True)\n            for control in controls:\n\n                # Lock visibility\n                attr = \"{}.visibility\".format(control)\n                locked = cmds.getAttr(attr, lock=True)\n                if not locked:\n                    cls.log.info(\"Locking visibility for %s\" % control)\n                    cmds.setAttr(attr, lock=True)\n\n                # Remove incoming connections\n                invalid_plugs = cls.get_connected_attributes(control)\n                if invalid_plugs:\n                    for plug in invalid_plugs:\n                        cls.log.info(\"Breaking input connection to %s\" % plug)\n                        source = cmds.listConnections(plug,\n                                                      source=True,\n                                                      destination=False,\n                                                      plugs=True)[0]\n                        cmds.disconnectAttr(source, plug)\n\n                # Reset non-default values\n                invalid_plugs = cls.get_non_default_attributes(control)\n                if invalid_plugs:\n                    for plug in invalid_plugs:\n                        attr = plug.split(\".\")[-1]\n                        default = cls.CONTROLLER_DEFAULTS[attr]\n                        cls.log.info(\"Setting %s to %s\" % (plug, default))\n                        cmds.setAttr(plug, default)\n\n    @classmethod\n    def get_node(cls, instance):\n        \"\"\"Get target object nodes from controls_SET\n\n        Args:\n            instance (str): instance\n\n        Returns:\n            list: list of object nodes from controls_SET\n        \"\"\"\n        return instance.data[\"rig_sets\"].get(\"controls_SET\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_controllers.html#client.ayon_maya.plugins.publish.validate_rig_controllers.ValidateRigControllers.get_connected_attributes","title":"<code>get_connected_attributes(control)</code>  <code>staticmethod</code>","text":"<p>Return attribute plugs with incoming connections.</p> <p>This will also ensure no (driven) keys on unlocked keyable attributes.</p> <p>Parameters:</p> Name Type Description Default <code>control</code> <code>str</code> <p>Name of control node.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>The invalid plugs</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_controllers.py</code> <pre><code>@staticmethod\ndef get_connected_attributes(control):\n    \"\"\"Return attribute plugs with incoming connections.\n\n    This will also ensure no (driven) keys on unlocked keyable attributes.\n\n    Args:\n        control (str): Name of control node.\n\n    Returns:\n        list: The invalid plugs\n\n    \"\"\"\n    import maya.cmds as mc\n\n    # Support controls without any attributes returning None\n    attributes = mc.listAttr(control, keyable=True, scalar=True) or []\n    invalid = []\n    for attr in attributes:\n        plug = \"{}.{}\".format(control, attr)\n\n        # Ignore locked attributes\n        locked = cmds.getAttr(plug, lock=True)\n        if locked:\n            continue\n\n        # Ignore proxy connections.\n        if (cmds.addAttr(plug, query=True, exists=True) and\n                cmds.addAttr(plug, query=True, usedAsProxy=True)):\n            continue\n\n        # Check for incoming connections\n        if cmds.listConnections(plug, source=True, destination=False):\n            invalid.append(plug)\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_controllers.html#client.ayon_maya.plugins.publish.validate_rig_controllers.ValidateRigControllers.get_node","title":"<code>get_node(instance)</code>  <code>classmethod</code>","text":"<p>Get target object nodes from controls_SET</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>str</code> <p>instance</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>list of object nodes from controls_SET</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_controllers.py</code> <pre><code>@classmethod\ndef get_node(cls, instance):\n    \"\"\"Get target object nodes from controls_SET\n\n    Args:\n        instance (str): instance\n\n    Returns:\n        list: list of object nodes from controls_SET\n    \"\"\"\n    return instance.data[\"rig_sets\"].get(\"controls_SET\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_controllers.html#client.ayon_maya.plugins.publish.validate_rig_controllers.ValidateRigControllers.get_non_default_attributes","title":"<code>get_non_default_attributes(control)</code>  <code>classmethod</code>","text":"<p>Return attribute plugs with non-default values</p> <p>Parameters:</p> Name Type Description Default <code>control</code> <code>str</code> <p>Name of control node.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>The invalid plugs</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_controllers.py</code> <pre><code>@classmethod\ndef get_non_default_attributes(cls, control):\n    \"\"\"Return attribute plugs with non-default values\n\n    Args:\n        control (str): Name of control node.\n\n    Returns:\n        list: The invalid plugs\n\n    \"\"\"\n\n    invalid = []\n    for attr, default in cls.CONTROLLER_DEFAULTS.items():\n        if cmds.attributeQuery(attr, node=control, exists=True):\n            plug = \"{}.{}\".format(control, attr)\n\n            # Ignore locked attributes\n            locked = cmds.getAttr(plug, lock=True)\n            if locked:\n                continue\n\n            value = cmds.getAttr(plug)\n            if value != default:\n                cls.log.warning(\"Control non-default value: \"\n                                \"%s = %s\" % (plug, value))\n                invalid.append(plug)\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_controllers.html#client.ayon_maya.plugins.publish.validate_rig_controllers.ValidateSkeletonRigControllers","title":"<code>ValidateSkeletonRigControllers</code>","text":"<p>               Bases: <code>ValidateRigControllers</code></p> <p>Validate rig controller for skeletonAnim_SET</p> <p>Controls must have the transformation attributes on their default values of translate zero, rotate zero and scale one when they are unlocked attributes.</p> <p>Unlocked keyable attributes may not have any incoming connections. If these connections are required for the rig then lock the attributes.</p> <p>The visibility attribute must be locked.</p> <p>Note that <code>repair</code> will:     - Lock all visibility attributes     - Reset all default values for translate, rotate, scale     - Break all incoming connections to keyable attributes</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_controllers.py</code> <pre><code>class ValidateSkeletonRigControllers(ValidateRigControllers):\n    \"\"\"Validate rig controller for skeletonAnim_SET\n\n    Controls must have the transformation attributes on their default\n    values of translate zero, rotate zero and scale one when they are\n    unlocked attributes.\n\n    Unlocked keyable attributes may not have any incoming connections. If\n    these connections are required for the rig then lock the attributes.\n\n    The visibility attribute must be locked.\n\n    Note that `repair` will:\n        - Lock all visibility attributes\n        - Reset all default values for translate, rotate, scale\n        - Break all incoming connections to keyable attributes\n\n    \"\"\"\n    order = ValidateContentsOrder + 0.05\n    label = \"Skeleton Rig Controllers\"\n    hosts = [\"maya\"]\n    families = [\"rig.fbx\"]\n\n    # Default controller values\n    CONTROLLER_DEFAULTS = {\n        \"translateX\": 0,\n        \"translateY\": 0,\n        \"translateZ\": 0,\n        \"rotateX\": 0,\n        \"rotateY\": 0,\n        \"rotateZ\": 0,\n        \"scaleX\": 1,\n        \"scaleY\": 1,\n        \"scaleZ\": 1\n    }\n\n    @classmethod\n    def get_node(cls, instance):\n        \"\"\"Get target object nodes from skeletonMesh_SET\n\n        Args:\n            instance (str): instance\n\n        Returns:\n            list: list of object nodes from skeletonMesh_SET\n        \"\"\"\n        return instance.data[\"rig_sets\"].get(\"skeletonMesh_SET\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_controllers.html#client.ayon_maya.plugins.publish.validate_rig_controllers.ValidateSkeletonRigControllers.get_node","title":"<code>get_node(instance)</code>  <code>classmethod</code>","text":"<p>Get target object nodes from skeletonMesh_SET</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>str</code> <p>instance</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>list of object nodes from skeletonMesh_SET</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_controllers.py</code> <pre><code>@classmethod\ndef get_node(cls, instance):\n    \"\"\"Get target object nodes from skeletonMesh_SET\n\n    Args:\n        instance (str): instance\n\n    Returns:\n        list: list of object nodes from skeletonMesh_SET\n    \"\"\"\n    return instance.data[\"rig_sets\"].get(\"skeletonMesh_SET\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_controllers_arnold_attributes.html","title":"validate_rig_controllers_arnold_attributes","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_controllers_arnold_attributes.html#client.ayon_maya.plugins.publish.validate_rig_controllers_arnold_attributes.ValidateRigControllersArnoldAttributes","title":"<code>ValidateRigControllersArnoldAttributes</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate rig control curves have no keyable arnold attributes.</p> The Arnold plug-in will create curve attributes like <ul> <li>aiRenderCurve</li> <li>aiCurveWidth</li> <li>aiSampleRate</li> <li>aiCurveShaderR</li> <li>aiCurveShaderG</li> <li>aiCurveShaderB</li> </ul> <p>Unfortunately these attributes visible in the channelBox are keyable by default and visible in the channelBox. As such pressing a regular \"S\" set key shortcut will set keys on these attributes too, thus cluttering the animator's scene.</p> <p>This validator will ensure they are hidden or unkeyable attributes.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_controllers_arnold_attributes.py</code> <pre><code>class ValidateRigControllersArnoldAttributes(plugin.MayaInstancePlugin,\n                                             OptionalPyblishPluginMixin):\n    \"\"\"Validate rig control curves have no keyable arnold attributes.\n\n    The Arnold plug-in will create curve attributes like:\n        - aiRenderCurve\n        - aiCurveWidth\n        - aiSampleRate\n        - aiCurveShaderR\n        - aiCurveShaderG\n        - aiCurveShaderB\n\n    Unfortunately these attributes visible in the channelBox are *keyable*\n    by default and visible in the channelBox. As such pressing a regular \"S\"\n    set key shortcut will set keys on these attributes too, thus cluttering\n    the animator's scene.\n\n    This validator will ensure they are hidden or unkeyable attributes.\n\n    \"\"\"\n    order = ValidateContentsOrder + 0.05\n    label = \"Rig Controllers (Arnold Attributes)\"\n    families = [\"rig\"]\n    optional = False\n    actions = [RepairAction,\n               ayon_maya.api.action.SelectInvalidAction]\n\n    attributes = [\n        \"rcurve\",\n        \"cwdth\",\n        \"srate\",\n        \"ai_curve_shaderr\",\n        \"ai_curve_shaderg\",\n        \"ai_curve_shaderb\"\n    ]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError('{} failed, see log '\n                               'information'.format(self.label))\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        controls_set = instance.data[\"rig_sets\"].get(\"controls_SET\")\n        if not controls_set:\n            return []\n\n        controls = cmds.sets(controls_set, query=True) or []\n        if not controls:\n            return []\n\n        shapes = cmds.ls(controls,\n                         dag=True,\n                         leaf=True,\n                         long=True,\n                         shapes=True,\n                         noIntermediate=True)\n        curves = cmds.ls(shapes, type=\"nurbsCurve\", long=True)\n\n        invalid = list()\n        for node in curves:\n\n            for attribute in cls.attributes:\n                if cmds.attributeQuery(attribute, node=node, exists=True):\n                    plug = \"{}.{}\".format(node, attribute)\n                    if cmds.getAttr(plug, keyable=True):\n                        invalid.append(node)\n                        break\n\n        return invalid\n\n    @classmethod\n    def repair(cls, instance):\n\n        invalid = cls.get_invalid(instance)\n        with lib.undo_chunk():\n            for node in invalid:\n                for attribute in cls.attributes:\n                    if cmds.attributeQuery(attribute, node=node, exists=True):\n                        plug = \"{}.{}\".format(node, attribute)\n                        cmds.setAttr(plug, channelBox=False, keyable=False)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_joints_hidden.html","title":"validate_rig_joints_hidden","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_joints_hidden.html#client.ayon_maya.plugins.publish.validate_rig_joints_hidden.ValidateRigJointsHidden","title":"<code>ValidateRigJointsHidden</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate all joints are hidden visually.</p> This includes being hidden <ul> <li>visibility off,</li> <li>in a display layer that has visibility off,</li> <li>having hidden parents or</li> <li>being an intermediate object.</li> </ul> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_joints_hidden.py</code> <pre><code>class ValidateRigJointsHidden(plugin.MayaInstancePlugin,\n                              OptionalPyblishPluginMixin):\n    \"\"\"Validate all joints are hidden visually.\n\n    This includes being hidden:\n        - visibility off,\n        - in a display layer that has visibility off,\n        - having hidden parents or\n        - being an intermediate object.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = ['rig']\n    label = \"Joints Hidden\"\n    actions = [ayon_maya.api.action.SelectInvalidAction,\n               RepairAction]\n    optional = True\n\n    @staticmethod\n    def get_invalid(instance):\n        joints = cmds.ls(instance, type='joint', long=True)\n        return [j for j in joints if lib.is_visible(j, displayLayer=True)]\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance 'objectSet'\"\"\"\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n\n        if invalid:\n            raise PublishValidationError(\n                \"Visible joints found: {0}\".format(invalid))\n\n    @classmethod\n    def repair(cls, instance):\n        import maya.mel as mel\n        mel.eval(\"HideJoints\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_joints_hidden.html#client.ayon_maya.plugins.publish.validate_rig_joints_hidden.ValidateRigJointsHidden.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance 'objectSet'</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_joints_hidden.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance 'objectSet'\"\"\"\n    if not self.is_active(instance.data):\n        return\n    invalid = self.get_invalid(instance)\n\n    if invalid:\n        raise PublishValidationError(\n            \"Visible joints found: {0}\".format(invalid))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_out_set_node_ids.html","title":"validate_rig_out_set_node_ids","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_out_set_node_ids.html#client.ayon_maya.plugins.publish.validate_rig_out_set_node_ids.ValidateRigOutSetNodeIds","title":"<code>ValidateRigOutSetNodeIds</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate if deformed shapes have related IDs to the original shapes.</p> <p>When a deformer is applied in the scene on a referenced mesh that already had deformers then Maya will create a new shape node for the mesh that does not have the original id. This validator checks whether the ids are valid on all the shape nodes in the instance.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_out_set_node_ids.py</code> <pre><code>class ValidateRigOutSetNodeIds(plugin.MayaInstancePlugin,\n                               OptionalPyblishPluginMixin):\n    \"\"\"Validate if deformed shapes have related IDs to the original shapes.\n\n    When a deformer is applied in the scene on a referenced mesh that already\n    had deformers then Maya will create a new shape node for the mesh that\n    does not have the original id. This validator checks whether the ids are\n    valid on all the shape nodes in the instance.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"rig\"]\n    label = 'Rig Out Set Node Ids'\n    actions = [\n        ayon_maya.api.action.SelectInvalidAction,\n        RepairAction\n    ]\n    allow_history_only = False\n    optional = False\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        # Preserve automatic settings applying logic\n        settings = get_plugin_settings(plugin=cls,\n                                       project_settings=project_settings,\n                                       log=cls.log,\n                                       category=\"maya\")\n        apply_plugin_settings_automatically(cls, settings, logger=cls.log)\n\n        # Disable plug-in if cbId workflow is disabled\n        if not project_settings[\"maya\"].get(\"use_cbid_workflow\", True):\n            cls.enabled = False\n            return\n\n    def process(self, instance):\n        \"\"\"Process all meshes\"\"\"\n        if not self.is_active(instance.data):\n            return\n        # Ensure all nodes have a cbId and a related ID to the original shapes\n        # if a deformer has been created on the shape\n        invalid = self.get_invalid(instance)\n        if invalid:\n\n            # Use the short names\n            invalid = cmds.ls(invalid)\n            invalid.sort()\n\n            # Construct a human-readable list\n            invalid = \"\\n\".join(\"- {}\".format(node) for node in invalid)\n\n            raise PublishXmlValidationError(\n                plugin=ValidateRigOutSetNodeIds,\n                message=(\n                    \"Rig nodes have different IDs than their input \"\n                    \"history: \\n{0}\".format(invalid)\n                )\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n        \"\"\"Get all nodes which do not match the criteria\"\"\"\n\n        out_set = cls.get_node(instance)\n        if not out_set:\n            return []\n\n        invalid = []\n        members = cmds.sets(out_set, query=True)\n        shapes = cmds.ls(members,\n                         dag=True,\n                         leaf=True,\n                         shapes=True,\n                         long=True,\n                         noIntermediate=True)\n\n        for shape in shapes:\n            sibling_id = lib.get_id_from_sibling(\n                shape,\n                history_only=cls.allow_history_only\n            )\n            if sibling_id:\n                current_id = lib.get_id(shape)\n                if current_id != sibling_id:\n                    invalid.append(shape)\n\n        return invalid\n\n    @classmethod\n    def repair(cls, instance):\n\n        for node in cls.get_invalid(instance):\n            # Get the original id from sibling\n            sibling_id = lib.get_id_from_sibling(\n                node,\n                history_only=cls.allow_history_only\n            )\n            if not sibling_id:\n                cls.log.error(\"Could not find ID in siblings for '%s'\", node)\n                continue\n\n            lib.set_id(node, sibling_id, overwrite=True)\n\n    @classmethod\n    def get_node(cls, instance):\n        \"\"\"Get target object nodes from out_SET\n\n        Args:\n            instance (str): instance\n\n        Returns:\n            list: list of object nodes from out_SET\n        \"\"\"\n        return instance.data[\"rig_sets\"].get(\"out_SET\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_out_set_node_ids.html#client.ayon_maya.plugins.publish.validate_rig_out_set_node_ids.ValidateRigOutSetNodeIds.get_invalid","title":"<code>get_invalid(instance)</code>  <code>classmethod</code>","text":"<p>Get all nodes which do not match the criteria</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_out_set_node_ids.py</code> <pre><code>@classmethod\ndef get_invalid(cls, instance):\n    \"\"\"Get all nodes which do not match the criteria\"\"\"\n\n    out_set = cls.get_node(instance)\n    if not out_set:\n        return []\n\n    invalid = []\n    members = cmds.sets(out_set, query=True)\n    shapes = cmds.ls(members,\n                     dag=True,\n                     leaf=True,\n                     shapes=True,\n                     long=True,\n                     noIntermediate=True)\n\n    for shape in shapes:\n        sibling_id = lib.get_id_from_sibling(\n            shape,\n            history_only=cls.allow_history_only\n        )\n        if sibling_id:\n            current_id = lib.get_id(shape)\n            if current_id != sibling_id:\n                invalid.append(shape)\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_out_set_node_ids.html#client.ayon_maya.plugins.publish.validate_rig_out_set_node_ids.ValidateRigOutSetNodeIds.get_node","title":"<code>get_node(instance)</code>  <code>classmethod</code>","text":"<p>Get target object nodes from out_SET</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>str</code> <p>instance</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>list of object nodes from out_SET</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_out_set_node_ids.py</code> <pre><code>@classmethod\ndef get_node(cls, instance):\n    \"\"\"Get target object nodes from out_SET\n\n    Args:\n        instance (str): instance\n\n    Returns:\n        list: list of object nodes from out_SET\n    \"\"\"\n    return instance.data[\"rig_sets\"].get(\"out_SET\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_out_set_node_ids.html#client.ayon_maya.plugins.publish.validate_rig_out_set_node_ids.ValidateRigOutSetNodeIds.process","title":"<code>process(instance)</code>","text":"<p>Process all meshes</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_out_set_node_ids.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all meshes\"\"\"\n    if not self.is_active(instance.data):\n        return\n    # Ensure all nodes have a cbId and a related ID to the original shapes\n    # if a deformer has been created on the shape\n    invalid = self.get_invalid(instance)\n    if invalid:\n\n        # Use the short names\n        invalid = cmds.ls(invalid)\n        invalid.sort()\n\n        # Construct a human-readable list\n        invalid = \"\\n\".join(\"- {}\".format(node) for node in invalid)\n\n        raise PublishXmlValidationError(\n            plugin=ValidateRigOutSetNodeIds,\n            message=(\n                \"Rig nodes have different IDs than their input \"\n                \"history: \\n{0}\".format(invalid)\n            )\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_out_set_node_ids.html#client.ayon_maya.plugins.publish.validate_rig_out_set_node_ids.ValidateSkeletonRigOutSetNodeIds","title":"<code>ValidateSkeletonRigOutSetNodeIds</code>","text":"<p>               Bases: <code>ValidateRigOutSetNodeIds</code></p> <p>Validate if deformed shapes have related IDs to the original shapes from skeleton set.</p> <p>When a deformer is applied in the scene on a referenced mesh that already had deformers then Maya will create a new shape node for the mesh that does not have the original id. This validator checks whether the ids are valid on all the shape nodes in the instance.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_out_set_node_ids.py</code> <pre><code>class ValidateSkeletonRigOutSetNodeIds(ValidateRigOutSetNodeIds):\n    \"\"\"Validate if deformed shapes have related IDs to the original shapes\n    from skeleton set.\n\n    When a deformer is applied in the scene on a referenced mesh that already\n    had deformers then Maya will create a new shape node for the mesh that\n    does not have the original id. This validator checks whether the ids are\n    valid on all the shape nodes in the instance.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"rig.fbx\"]\n    hosts = ['maya']\n    label = 'Skeleton Rig Out Set Node Ids'\n    optional = False\n\n    @classmethod\n    def get_node(cls, instance):\n        \"\"\"Get target object nodes from skeletonMesh_SET\n\n        Args:\n            instance (str): instance\n\n        Returns:\n            list: list of object nodes from skeletonMesh_SET\n        \"\"\"\n        return instance.data[\"rig_sets\"].get(\n            \"skeletonMesh_SET\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_out_set_node_ids.html#client.ayon_maya.plugins.publish.validate_rig_out_set_node_ids.ValidateSkeletonRigOutSetNodeIds.get_node","title":"<code>get_node(instance)</code>  <code>classmethod</code>","text":"<p>Get target object nodes from skeletonMesh_SET</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>str</code> <p>instance</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>list of object nodes from skeletonMesh_SET</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_out_set_node_ids.py</code> <pre><code>@classmethod\ndef get_node(cls, instance):\n    \"\"\"Get target object nodes from skeletonMesh_SET\n\n    Args:\n        instance (str): instance\n\n    Returns:\n        list: list of object nodes from skeletonMesh_SET\n    \"\"\"\n    return instance.data[\"rig_sets\"].get(\n        \"skeletonMesh_SET\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_output_ids.html","title":"validate_rig_output_ids","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_output_ids.html#client.ayon_maya.plugins.publish.validate_rig_output_ids.ValidateRigOutputIds","title":"<code>ValidateRigOutputIds</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validate rig output ids.</p> <p>Ids must share the same id as similarly named nodes in the scene. This is to ensure the id from the model is preserved through animation.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_output_ids.py</code> <pre><code>class ValidateRigOutputIds(plugin.MayaInstancePlugin):\n    \"\"\"Validate rig output ids.\n\n    Ids must share the same id as similarly named nodes in the scene. This is\n    to ensure the id from the model is preserved through animation.\n\n    \"\"\"\n    order = ValidateContentsOrder + 0.05\n    label = \"Rig Output Ids\"\n    families = [\"rig\"]\n    actions = [RepairAction,\n               ayon_maya.api.action.SelectInvalidAction]\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        # Disable plug-in if cbId workflow is disabled\n        if not project_settings[\"maya\"].get(\"use_cbid_workflow\", True):\n            cls.enabled = False\n            return\n\n    def process(self, instance):\n        invalid = self.get_invalid(instance, compute=True)\n        if invalid:\n            raise PublishValidationError(\"Found nodes with mismatched IDs.\")\n\n    @classmethod\n    def get_invalid(cls, instance, compute=False):\n        invalid_matches = cls.get_invalid_matches(instance, compute=compute)\n        return list(invalid_matches.keys())\n\n    @classmethod\n    def get_invalid_matches(cls, instance, compute=False):\n        invalid = {}\n\n        if compute:\n            out_set = cls.get_node(instance)\n            if not out_set:\n                instance.data[\"mismatched_output_ids\"] = invalid\n                return invalid\n\n            instance_nodes = cmds.sets(out_set, query=True, nodesOnly=True)\n            instance_nodes = cmds.ls(instance_nodes, long=True)\n            for node in instance_nodes:\n                shapes = cmds.listRelatives(node, shapes=True, fullPath=True)\n                if shapes:\n                    instance_nodes.extend(shapes)\n\n            scene_nodes = cmds.ls(type=\"transform\", long=True)\n            scene_nodes += cmds.ls(type=\"mesh\", long=True)\n            scene_nodes = set(scene_nodes) - set(instance_nodes)\n\n            scene_nodes_by_basename = defaultdict(list)\n            for node in scene_nodes:\n                basename = get_basename(node)\n                scene_nodes_by_basename[basename].append(node)\n\n            for instance_node in instance_nodes:\n                basename = get_basename(instance_node)\n                if basename not in scene_nodes_by_basename:\n                    continue\n\n                matches = scene_nodes_by_basename[basename]\n\n                ids = set(get_id(node) for node in matches)\n                ids.add(get_id(instance_node))\n\n                if len(ids) &gt; 1:\n                    cls.log.error(\n                        \"\\\"{}\\\" id mismatch to: {}\".format(\n                            instance_node, matches\n                        )\n                    )\n                    invalid[instance_node] = matches\n\n            instance.data[\"mismatched_output_ids\"] = invalid\n        else:\n            invalid = instance.data[\"mismatched_output_ids\"]\n\n        return invalid\n\n    @classmethod\n    def repair(cls, instance):\n        invalid_matches = cls.get_invalid_matches(instance)\n\n        multiple_ids_match = []\n        for instance_node, matches in invalid_matches.items():\n            ids = set(get_id(node) for node in matches)\n\n            # If there are multiple scene ids matched, and error needs to be\n            # raised for manual correction.\n            if len(ids) &gt; 1:\n                multiple_ids_match.append({\"node\": instance_node,\n                                           \"matches\": matches})\n                continue\n\n            id_to_set = next(iter(ids))\n            set_id(instance_node, id_to_set, overwrite=True)\n\n        if multiple_ids_match:\n            raise PublishValidationError(\n                \"Multiple matched ids found. Please repair manually: \"\n                \"{}\".format(multiple_ids_match)\n            )\n\n    @classmethod\n    def get_node(cls, instance):\n        \"\"\"Get target object nodes from out_SET\n\n        Args:\n            instance (str): instance\n\n        Returns:\n            list: list of object nodes from out_SET\n        \"\"\"\n        return instance.data[\"rig_sets\"].get(\"out_SET\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_output_ids.html#client.ayon_maya.plugins.publish.validate_rig_output_ids.ValidateRigOutputIds.get_node","title":"<code>get_node(instance)</code>  <code>classmethod</code>","text":"<p>Get target object nodes from out_SET</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>str</code> <p>instance</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>list of object nodes from out_SET</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_output_ids.py</code> <pre><code>@classmethod\ndef get_node(cls, instance):\n    \"\"\"Get target object nodes from out_SET\n\n    Args:\n        instance (str): instance\n\n    Returns:\n        list: list of object nodes from out_SET\n    \"\"\"\n    return instance.data[\"rig_sets\"].get(\"out_SET\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_output_ids.html#client.ayon_maya.plugins.publish.validate_rig_output_ids.ValidateSkeletonRigOutputIds","title":"<code>ValidateSkeletonRigOutputIds</code>","text":"<p>               Bases: <code>ValidateRigOutputIds</code></p> <p>Validate rig output ids from the skeleton sets.</p> <p>Ids must share the same id as similarly named nodes in the scene. This is to ensure the id from the model is preserved through animation.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_output_ids.py</code> <pre><code>class ValidateSkeletonRigOutputIds(ValidateRigOutputIds):\n    \"\"\"Validate rig output ids from the skeleton sets.\n\n    Ids must share the same id as similarly named nodes in the scene. This is\n    to ensure the id from the model is preserved through animation.\n\n    \"\"\"\n    order = ValidateContentsOrder + 0.05\n    label = \"Skeleton Rig Output Ids\"\n    hosts = [\"maya\"]\n    families = [\"rig.fbx\"]\n\n    @classmethod\n    def get_node(cls, instance):\n        \"\"\"Get target object nodes from skeletonMesh_SET\n\n        Args:\n            instance (str): instance\n\n        Returns:\n            list: list of object nodes from skeletonMesh_SET\n        \"\"\"\n        return instance.data[\"rig_sets\"].get(\"skeletonMesh_SET\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_output_ids.html#client.ayon_maya.plugins.publish.validate_rig_output_ids.ValidateSkeletonRigOutputIds.get_node","title":"<code>get_node(instance)</code>  <code>classmethod</code>","text":"<p>Get target object nodes from skeletonMesh_SET</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>str</code> <p>instance</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>list of object nodes from skeletonMesh_SET</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_output_ids.py</code> <pre><code>@classmethod\ndef get_node(cls, instance):\n    \"\"\"Get target object nodes from skeletonMesh_SET\n\n    Args:\n        instance (str): instance\n\n    Returns:\n        list: list of object nodes from skeletonMesh_SET\n    \"\"\"\n    return instance.data[\"rig_sets\"].get(\"skeletonMesh_SET\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_rig_output_ids.html#client.ayon_maya.plugins.publish.validate_rig_output_ids.get_basename","title":"<code>get_basename(node)</code>","text":"<p>Return node short name without namespace</p> Source code in <code>client/ayon_maya/plugins/publish/validate_rig_output_ids.py</code> <pre><code>def get_basename(node):\n    \"\"\"Return node short name without namespace\"\"\"\n    return node.rsplit(\"|\", 1)[-1].rsplit(\":\", 1)[-1]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_scene_set_workspace.html","title":"validate_scene_set_workspace","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_scene_set_workspace.html#client.ayon_maya.plugins.publish.validate_scene_set_workspace.ValidateSceneSetWorkspace","title":"<code>ValidateSceneSetWorkspace</code>","text":"<p>               Bases: <code>MayaContextPlugin</code></p> <p>Validate the scene is inside the currently set Maya workspace</p> Source code in <code>client/ayon_maya/plugins/publish/validate_scene_set_workspace.py</code> <pre><code>class ValidateSceneSetWorkspace(plugin.MayaContextPlugin):\n    \"\"\"Validate the scene is inside the currently set Maya workspace\"\"\"\n\n    order = ValidatePipelineOrder\n    label = 'Maya Workspace Set'\n\n    def process(self, context):\n\n        scene_name = cmds.file(query=True, sceneName=True)\n        if not scene_name:\n            raise PublishValidationError(\n                \"Scene hasn't been saved. Workspace can't be validated.\")\n\n        root_dir = cmds.workspace(query=True, rootDirectory=True)\n\n        if not is_subdir(scene_name, root_dir):\n            raise PublishValidationError(\n                \"Maya workspace is not set correctly.\\n\\n\"\n                f\"Current workfile `{scene_name}` is not inside the \"\n                f\"current Maya project root directory `{root_dir}`.\\n\\n\"\n                \"Please use Workfile app to re-save.\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_scene_set_workspace.html#client.ayon_maya.plugins.publish.validate_scene_set_workspace.is_subdir","title":"<code>is_subdir(path, root_dir)</code>","text":"<p>Returns whether path is a subdirectory (or file) within root_dir</p> Source code in <code>client/ayon_maya/plugins/publish/validate_scene_set_workspace.py</code> <pre><code>def is_subdir(path, root_dir):\n    \"\"\" Returns whether path is a subdirectory (or file) within root_dir \"\"\"\n    path = os.path.realpath(path)\n    root_dir = os.path.realpath(root_dir)\n\n    # If not on same drive\n    if os.path.splitdrive(path)[0].lower() != os.path.splitdrive(root_dir)[0].lower():  # noqa: E501\n        return False\n\n    # Get 'relative path' (can contain ../ which means going up)\n    relative = os.path.relpath(path, root_dir)\n\n    # Check if the path starts by going up, if so it's not a subdirectory. :)\n    if relative.startswith(os.pardir) or relative == os.curdir:\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_setdress_root.html","title":"validate_setdress_root","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_setdress_root.html#client.ayon_maya.plugins.publish.validate_setdress_root.ValidateSetdressRoot","title":"<code>ValidateSetdressRoot</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validate if set dress top root node is published.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_setdress_root.py</code> <pre><code>class ValidateSetdressRoot(plugin.MayaInstancePlugin):\n    \"\"\"Validate if set dress top root node is published.\"\"\"\n\n    order = ValidateContentsOrder\n    label = \"SetDress Root\"\n    families = [\"setdress\"]\n\n    def process(self, instance):\n        from maya import cmds\n\n        if instance.data.get(\"exactSetMembersOnly\"):\n            return\n\n        set_member = instance.data[\"setMembers\"]\n        root = cmds.ls(set_member, assemblies=True, long=True)\n\n        if not root or root[0] not in set_member:\n            raise PublishValidationError(\n                \"Setdress top root node is not being published.\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_shader_name.html","title":"validate_shader_name","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_shader_name.html#client.ayon_maya.plugins.publish.validate_shader_name.ValidateShaderName","title":"<code>ValidateShaderName</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate shader name assigned.</p> <p>It should be _&lt;*&gt;_SHD Source code in <code>client/ayon_maya/plugins/publish/validate_shader_name.py</code> <pre><code>class ValidateShaderName(plugin.MayaInstancePlugin,\n                         OptionalPyblishPluginMixin):\n    \"\"\"Validate shader name assigned.\n\n       It should be &lt;assetName&gt;_&lt;*&gt;_SHD\n\n    \"\"\"\n    optional = True\n    order = ValidateContentsOrder\n    families = [\"look\"]\n    label = 'Validate Shaders Name'\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    regex = r'(?P&lt;asset&gt;.*)_(.*)_SHD'\n\n    # The default connections to check\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                (\"Found shapes with invalid shader names \"\n                 \"assigned:\\n{}\").format(invalid))\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        invalid = []\n\n        # Get all shapes from the instance\n        content_instance = instance.data.get(\"setMembers\", None)\n        if not content_instance:\n            cls.log.error(\"Instance has no nodes!\")\n            return True\n        pass\n        descendants = cmds.listRelatives(content_instance,\n                                         allDescendents=True,\n                                         fullPath=True) or []\n\n        descendants = cmds.ls(descendants, noIntermediate=True, long=True)\n        shapes = cmds.ls(descendants, type=[\"nurbsSurface\", \"mesh\"], long=True)\n        folder_path = instance.data.get(\"folderPath\")\n\n        # Check the number of connected shadingEngines per shape\n        regex_compile = re.compile(cls.regex)\n        error_message = \"object {0} has invalid shader name {1}\"\n        for shape in shapes:\n            shading_engines = cmds.listConnections(shape,\n                                                   destination=True,\n                                                   type=\"shadingEngine\") or []\n            shaders = cmds.ls(\n                cmds.listConnections(shading_engines), materials=1\n            )\n\n            for shader in shaders:\n                m = regex_compile.match(shader)\n                if m is None:\n                    invalid.append(shape)\n                    cls.log.error(error_message.format(shape, shader))\n                else:\n                    if 'asset' in regex_compile.groupindex:\n                        if m.group('asset') != folder_path:\n                            invalid.append(shape)\n                            message = error_message\n                            message += \" with missing folder path \\\"{2}\\\"\"\n                            cls.log.error(\n                                message.format(shape, shader, folder_path)\n                            )\n\n        return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_shape_default_names.html","title":"validate_shape_default_names","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_shape_default_names.html#client.ayon_maya.plugins.publish.validate_shape_default_names.ValidateShapeDefaultNames","title":"<code>ValidateShapeDefaultNames</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates that Shape names are using Maya's default format.</p> <p>When you create a new polygon cube Maya will name the transform and shape respectively: - ['pCube1', 'pCubeShape1'] If you rename it to <code>bar1</code> it will become: - ['bar1', 'barShape1'] Then if you rename it to <code>bar</code> it will become: - ['bar', 'barShape'] Rename it again to <code>bar1</code> it will differ as opposed to before: - ['bar1', 'bar1Shape'] Note that bar1Shape != barShape1 Thus the suffix number can be either in front of Shape or behind it. Then it becomes harder to define where what number should be when a node contains multiple shapes, for example with many controls in rigs existing of multiple curves.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_shape_default_names.py</code> <pre><code>class ValidateShapeDefaultNames(plugin.MayaInstancePlugin,\n                                OptionalPyblishPluginMixin):\n    \"\"\"Validates that Shape names are using Maya's default format.\n\n    When you create a new polygon cube Maya will name the transform\n    and shape respectively:\n    - ['pCube1', 'pCubeShape1']\n    If you rename it to `bar1` it will become:\n    - ['bar1', 'barShape1']\n    Then if you rename it to `bar` it will become:\n    - ['bar', 'barShape']\n    Rename it again to `bar1` it will differ as opposed to before:\n    - ['bar1', 'bar1Shape']\n    Note that bar1Shape != barShape1\n    Thus the suffix number can be either in front of Shape or behind it.\n    Then it becomes harder to define where what number should be when a\n    node contains multiple shapes, for example with many controls in\n    rigs existing of multiple curves.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    hosts = ['maya']\n    families = ['model']\n    optional = True\n    label = \"Shape Default Naming\"\n    actions = [ayon_maya.api.action.SelectInvalidAction,\n               RepairAction]\n\n    @staticmethod\n    def _define_default_name(shape):\n        parent = cmds.listRelatives(shape, parent=True, fullPath=True)[0]\n        transform = short_name(parent)\n        return '{0}Shape'.format(transform)\n\n    @staticmethod\n    def _is_valid(shape):\n        \"\"\" Return whether the shape's name is similar to Maya's default. \"\"\"\n        transform = cmds.listRelatives(shape, parent=True, fullPath=True)[0]\n\n        transform_name = short_name(transform)\n        shape_name = short_name(shape)\n\n        # A Shape's name can be either {transform}{numSuffix}\n        # Shape or {transform}Shape{numSuffix}\n        # Upon renaming nodes in Maya that is\n        # the pattern Maya will act towards.\n        transform_no_num = transform_name.rstrip(\"0123456789\")\n        pattern = '^{transform}[0-9]*Shape[0-9]*$'.format(\n            transform=transform_no_num)\n\n        if re.match(pattern, shape_name):\n            return True\n        else:\n            return False\n\n    @classmethod\n    def get_invalid(cls, instance):\n        shapes = cmds.ls(instance, shapes=True, long=True)\n        return [shape for shape in shapes if not cls._is_valid(shape)]\n\n    def process(self, instance):\n        \"\"\"Process all the shape nodes in the instance\"\"\"\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Incorrectly named shapes found: {0}\".format(invalid))\n\n    @classmethod\n    def repair(cls, instance):\n        \"\"\"Process all the shape nodes in the instance\"\"\"\n        for shape in cls.get_invalid(instance):\n            correct_shape_name = cls._define_default_name(shape)\n            cmds.rename(shape, correct_shape_name)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_shape_default_names.html#client.ayon_maya.plugins.publish.validate_shape_default_names.ValidateShapeDefaultNames.process","title":"<code>process(instance)</code>","text":"<p>Process all the shape nodes in the instance</p> Source code in <code>client/ayon_maya/plugins/publish/validate_shape_default_names.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the shape nodes in the instance\"\"\"\n    if not self.is_active(instance.data):\n        return\n\n    invalid = self.get_invalid(instance)\n    if invalid:\n        raise PublishValidationError(\n            \"Incorrectly named shapes found: {0}\".format(invalid))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_shape_default_names.html#client.ayon_maya.plugins.publish.validate_shape_default_names.ValidateShapeDefaultNames.repair","title":"<code>repair(instance)</code>  <code>classmethod</code>","text":"<p>Process all the shape nodes in the instance</p> Source code in <code>client/ayon_maya/plugins/publish/validate_shape_default_names.py</code> <pre><code>@classmethod\ndef repair(cls, instance):\n    \"\"\"Process all the shape nodes in the instance\"\"\"\n    for shape in cls.get_invalid(instance):\n        correct_shape_name = cls._define_default_name(shape)\n        cmds.rename(shape, correct_shape_name)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_shape_render_stats.html","title":"validate_shape_render_stats","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_shape_render_stats.html#client.ayon_maya.plugins.publish.validate_shape_render_stats.ValidateShapeRenderStats","title":"<code>ValidateShapeRenderStats</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure all render stats are set to the default values.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_shape_render_stats.py</code> <pre><code>class ValidateShapeRenderStats(plugin.MayaInstancePlugin,\n                               OptionalPyblishPluginMixin):\n    \"\"\"Ensure all render stats are set to the default values.\"\"\"\n\n    order = ValidateMeshOrder\n    families = ['model']\n    label = 'Shape Default Render Stats'\n    actions = [ayon_maya.api.action.SelectInvalidAction,\n               RepairAction]\n\n    defaults = {'castsShadows': 1,\n                'receiveShadows': 1,\n                'motionBlur': 1,\n                'primaryVisibility': 1,\n                'smoothShading': 1,\n                'visibleInReflections': 1,\n                'visibleInRefractions': 1,\n                'doubleSided': 1,\n                'opposite': 0}\n\n    @classmethod\n    def get_invalid(cls, instance):\n        # It seems the \"surfaceShape\" and those derived from it have\n        # `renderStat` attributes.\n        shapes = cmds.ls(instance, long=True, type='surfaceShape')\n        invalid = set()\n        for shape in shapes:\n            for attr, default_value in cls.defaults.items():\n                if cmds.attributeQuery(attr, node=shape, exists=True):\n                    value = cmds.getAttr('{}.{}'.format(shape, attr))\n                    if value != default_value:\n                        invalid.add(shape)\n\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if not invalid:\n            return\n\n        defaults_str = \"\\n\".join(\n            \"- {}: {}\\n\".format(key, value)\n            for key, value in self.defaults.items()\n        )\n        description = (\n            \"## Shape Default Render Stats\\n\"\n            \"Shapes are detected with non-default render stats.\\n\\n\"\n            \"To ensure a model's shapes behave like a shape would by default \"\n            \"we require the render stats to have not been altered in \"\n            \"the published models.\\n\\n\"\n            \"### How to repair?\\n\"\n            \"You can reset the default values on the shapes by using the \"\n            \"repair action.\"\n        )\n\n        raise PublishValidationError(\n            \"Shapes with non-default renderStats \"\n            \"found: {0}\".format(\", \".join(sorted(invalid))),\n            description=description,\n            detail=\"The expected default values \"\n                   \"are:\\n\\n{}\".format(defaults_str)\n        )\n\n    @classmethod\n    def repair(cls, instance):\n        for shape in cls.get_invalid(instance):\n            for attr, default_value in cls.defaults.items():\n                if cmds.attributeQuery(attr, node=shape, exists=True):\n                    plug = '{0}.{1}'.format(shape, attr)\n                    value = cmds.getAttr(plug)\n                    if value != default_value:\n                        cmds.setAttr(plug, default_value)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_shape_zero.html","title":"validate_shape_zero","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_shape_zero.html#client.ayon_maya.plugins.publish.validate_shape_zero.ValidateShapeZero","title":"<code>ValidateShapeZero</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Shape components may not have any \"tweak\" values</p> <p>To solve this issue, try freezing the shapes.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_shape_zero.py</code> <pre><code>class ValidateShapeZero(plugin.MayaInstancePlugin,\n                        OptionalPyblishPluginMixin):\n    \"\"\"Shape components may not have any \"tweak\" values\n\n    To solve this issue, try freezing the shapes.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"model\"]\n    label = \"Shape Zero (Freeze)\"\n    actions = [\n        ayon_maya.api.action.SelectInvalidAction,\n        RepairAction\n    ]\n    optional = True\n\n    @staticmethod\n    def get_invalid(instance):\n        \"\"\"Returns the invalid shapes in the instance.\n\n        This is the same as checking:\n        - all(pnt == [0,0,0] for pnt in shape.pnts[:])\n\n        Returns:\n            list: Shape with non freezed vertex\n\n        \"\"\"\n\n        shapes = cmds.ls(instance, type=\"shape\")\n\n        invalid = []\n        for shape in shapes:\n            if cmds.polyCollapseTweaks(shape, q=True, hasVertexTweaks=True):\n                invalid.append(shape)\n\n        return invalid\n\n    @classmethod\n    def repair(cls, instance):\n        invalid_shapes = cls.get_invalid(instance)\n        if not invalid_shapes:\n            return\n\n        with lib.maintained_selection():\n            with lib.tool(\"selectSuperContext\"):\n                for shape in invalid_shapes:\n                    cmds.polyCollapseTweaks(shape)\n                    # cmds.polyCollapseTweaks keeps selecting the geometry\n                    # after each command. When running on many meshes\n                    # after one another this tends to get really heavy\n                    cmds.select(clear=True)\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance \"objectSet\"\"\"\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                title=\"Shape Component Tweaks\",\n                message=\"Shapes found with non-zero component tweaks: '{}'\"\n                        \"\".format(\", \".join(invalid)),\n                description=(\n                    \"## Shapes found with component tweaks\\n\"\n                    \"Shapes were detected that have component tweaks on their \"\n                    \"components. Please remove the component tweaks to \"\n                    \"continue.\\n\\n\"\n                    \"### Repair\\n\"\n                    \"The repair action will try to *freeze* the component \"\n                    \"tweaks into the shapes, which is usually the correct fix \"\n                    \"if the mesh has no construction history (= has its \"\n                    \"history deleted).\"),\n                detail=(\n                    \"Maya allows to store component tweaks within shape nodes \"\n                    \"which are applied between its `inMesh` and `outMesh` \"\n                    \"connections resulting in the output of a shape node \"\n                    \"differing from the input. We usually want to avoid this \"\n                    \"for published meshes (in particular for Maya scenes) as \"\n                    \"it can have unintended results when using these meshes \"\n                    \"as intermediate meshes since it applies positional \"\n                    \"differences without being visible edits in the node \"\n                    \"graph.\\n\\n\"\n                    \"These tweaks are traditionally stored in the `.pnts` \"\n                    \"attribute of shapes.\")\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_shape_zero.html#client.ayon_maya.plugins.publish.validate_shape_zero.ValidateShapeZero.get_invalid","title":"<code>get_invalid(instance)</code>  <code>staticmethod</code>","text":"<p>Returns the invalid shapes in the instance.</p> <p>This is the same as checking: - all(pnt == [0,0,0] for pnt in shape.pnts[:])</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Shape with non freezed vertex</p> Source code in <code>client/ayon_maya/plugins/publish/validate_shape_zero.py</code> <pre><code>@staticmethod\ndef get_invalid(instance):\n    \"\"\"Returns the invalid shapes in the instance.\n\n    This is the same as checking:\n    - all(pnt == [0,0,0] for pnt in shape.pnts[:])\n\n    Returns:\n        list: Shape with non freezed vertex\n\n    \"\"\"\n\n    shapes = cmds.ls(instance, type=\"shape\")\n\n    invalid = []\n    for shape in shapes:\n        if cmds.polyCollapseTweaks(shape, q=True, hasVertexTweaks=True):\n            invalid.append(shape)\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_shape_zero.html#client.ayon_maya.plugins.publish.validate_shape_zero.ValidateShapeZero.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance \"objectSet</p> Source code in <code>client/ayon_maya/plugins/publish/validate_shape_zero.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance \"objectSet\"\"\"\n    if not self.is_active(instance.data):\n        return\n\n    invalid = self.get_invalid(instance)\n    if invalid:\n        raise PublishValidationError(\n            title=\"Shape Component Tweaks\",\n            message=\"Shapes found with non-zero component tweaks: '{}'\"\n                    \"\".format(\", \".join(invalid)),\n            description=(\n                \"## Shapes found with component tweaks\\n\"\n                \"Shapes were detected that have component tweaks on their \"\n                \"components. Please remove the component tweaks to \"\n                \"continue.\\n\\n\"\n                \"### Repair\\n\"\n                \"The repair action will try to *freeze* the component \"\n                \"tweaks into the shapes, which is usually the correct fix \"\n                \"if the mesh has no construction history (= has its \"\n                \"history deleted).\"),\n            detail=(\n                \"Maya allows to store component tweaks within shape nodes \"\n                \"which are applied between its `inMesh` and `outMesh` \"\n                \"connections resulting in the output of a shape node \"\n                \"differing from the input. We usually want to avoid this \"\n                \"for published meshes (in particular for Maya scenes) as \"\n                \"it can have unintended results when using these meshes \"\n                \"as intermediate meshes since it applies positional \"\n                \"differences without being visible edits in the node \"\n                \"graph.\\n\\n\"\n                \"These tweaks are traditionally stored in the `.pnts` \"\n                \"attribute of shapes.\")\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_single_assembly.html","title":"validate_single_assembly","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_single_assembly.html#client.ayon_maya.plugins.publish.validate_single_assembly.ValidateSingleAssembly","title":"<code>ValidateSingleAssembly</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure the content of the instance is grouped in a single hierarchy</p> <p>The instance must have a single root node containing all the content. This root node must be a top group in the outliner.</p> Example outliner <p>root_GRP     -- geometry_GRP        -- mesh_GEO     -- controls_GRP        -- control_CTL</p> Source code in <code>client/ayon_maya/plugins/publish/validate_single_assembly.py</code> <pre><code>class ValidateSingleAssembly(plugin.MayaInstancePlugin,\n                             OptionalPyblishPluginMixin):\n    \"\"\"Ensure the content of the instance is grouped in a single hierarchy\n\n    The instance must have a single root node containing all the content.\n    This root node *must* be a top group in the outliner.\n\n    Example outliner:\n        root_GRP\n            -- geometry_GRP\n               -- mesh_GEO\n            -- controls_GRP\n               -- control_CTL\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = ['rig']\n    label = 'Single Assembly'\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        from maya import cmds\n\n        assemblies = cmds.ls(instance, assemblies=True)\n\n        # ensure unique (somehow `maya.cmds.ls` doesn't manage that)\n        assemblies = set(assemblies)\n\n        if len(assemblies) == 0:\n            raise PublishValidationError(\n                \"One assembly required for: %s (currently empty?)\" % instance\n            )\n        elif len(assemblies) &gt; 1:\n            raise PublishValidationError(\n                'Multiple assemblies found: %s' % assemblies\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_skeletalmesh_hierarchy.html","title":"validate_skeletalmesh_hierarchy","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_skeletalmesh_hierarchy.html#client.ayon_maya.plugins.publish.validate_skeletalmesh_hierarchy.ValidateSkeletalMeshHierarchy","title":"<code>ValidateSkeletalMeshHierarchy</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates that nodes has common root.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_skeletalmesh_hierarchy.py</code> <pre><code>class ValidateSkeletalMeshHierarchy(plugin.MayaInstancePlugin,\n                                    OptionalPyblishPluginMixin):\n    \"\"\"Validates that nodes has common root.\"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"skeletalMesh\"]\n    label = \"Skeletal Mesh Top Node\"\n    optional = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        geo = instance.data.get(\"geometry\")\n        joints = instance.data.get(\"joints\")\n\n        joints_parents = cmds.ls(joints, long=True)\n        geo_parents = cmds.ls(geo, long=True)\n\n        parents_set = {\n            parent.split(\"|\")[1] for parent in (joints_parents + geo_parents)\n        }\n\n        self.log.debug(parents_set)\n\n        if len(set(parents_set)) &gt; 2:\n            raise PublishXmlValidationError(\n                self,\n                \"Multiple roots on geometry or joints.\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_skeletalmesh_triangulated.html","title":"validate_skeletalmesh_triangulated","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_skeletalmesh_triangulated.html#client.ayon_maya.plugins.publish.validate_skeletalmesh_triangulated.ValidateSkeletalMeshTriangulated","title":"<code>ValidateSkeletalMeshTriangulated</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validates that the geometry has been triangulated.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_skeletalmesh_triangulated.py</code> <pre><code>class ValidateSkeletalMeshTriangulated(plugin.MayaInstancePlugin):\n    \"\"\"Validates that the geometry has been triangulated.\"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"skeletalMesh\"]\n    label = \"Skeletal Mesh Triangulated\"\n    optional = True\n    actions = [\n        SelectInvalidAction,\n        RepairAction\n    ]\n\n    def process(self, instance):\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"The following objects needs to be triangulated: \"\n                \"{}\".format(invalid))\n\n    @classmethod\n    def get_invalid(cls, instance):\n        geo = instance.data.get(\"geometry\")\n\n        invalid = []\n\n        for obj in cmds.listRelatives(\n                cmds.ls(geo), allDescendents=True, fullPath=True):\n            n_triangles = cmds.polyEvaluate(obj, triangle=True)\n            n_faces = cmds.polyEvaluate(obj, face=True)\n\n            if not (isinstance(n_triangles, int) and isinstance(n_faces, int)):\n                continue\n\n            # We check if the number of triangles is equal to the number of\n            # faces for each transform node.\n            # If it is, the object is triangulated.\n            if cmds.objectType(obj, i=\"transform\") and n_triangles != n_faces:\n                invalid.append(obj)\n\n        return invalid\n\n    @classmethod\n    def repair(cls, instance):\n        for node in cls.get_invalid(instance):\n            cmds.polyTriangulate(node)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_skeleton_top_group_hierarchy.html","title":"validate_skeleton_top_group_hierarchy","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_skeleton_top_group_hierarchy.html#client.ayon_maya.plugins.publish.validate_skeleton_top_group_hierarchy.ValidateSkeletonTopGroupHierarchy","title":"<code>ValidateSkeletonTopGroupHierarchy</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates top group hierarchy in the SETs Make sure the object inside the SETs are always top group of the hierarchy</p> Source code in <code>client/ayon_maya/plugins/publish/validate_skeleton_top_group_hierarchy.py</code> <pre><code>class ValidateSkeletonTopGroupHierarchy(plugin.MayaInstancePlugin,\n                                        OptionalPyblishPluginMixin):\n    \"\"\"Validates top group hierarchy in the SETs\n    Make sure the object inside the SETs are always top\n    group of the hierarchy\n    \"\"\"\n    order = ValidateContentsOrder + 0.05\n    label = \"Skeleton Rig Top Group Hierarchy\"\n    families = [\"rig.fbx\"]\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        skeleton_mesh_nodes = instance.data(\"skeleton_mesh\", [])\n        if not skeleton_mesh_nodes:\n            return\n\n        invalid = get_non_root_nodes(skeleton_mesh_nodes)\n        if invalid:\n            raise PublishValidationError(\n                \"The skeletonMesh_SET includes the object which \"\n                \"is not at the top hierarchy: {}\".format(invalid))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_skeleton_top_group_hierarchy.html#client.ayon_maya.plugins.publish.validate_skeleton_top_group_hierarchy.get_non_root_nodes","title":"<code>get_non_root_nodes(nodes)</code>","text":"<p>Return all nodes that are not root nodes (they have parents)</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list[str]</code> <p>Maya nodes.</p> required <p>Returns:</p> Type Description <p>list[str]: Non-root maya node (long names)</p> Source code in <code>client/ayon_maya/plugins/publish/validate_skeleton_top_group_hierarchy.py</code> <pre><code>def get_non_root_nodes(nodes):\n    \"\"\"Return all nodes that are not root nodes (they have parents)\n\n    Arguments:\n        nodes (list[str]): Maya nodes.\n\n    Returns:\n        list[str]: Non-root maya node (long names)\n    \"\"\"\n    nodes = cmds.ls(nodes, long=True)  # ensure long names\n    return [\n        node for node in nodes if node.count(\"|\") &gt; 2\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_skinCluster_deformer_set.html","title":"validate_skinCluster_deformer_set","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_skinCluster_deformer_set.html#client.ayon_maya.plugins.publish.validate_skinCluster_deformer_set.ValidateSkinclusterDeformerSet","title":"<code>ValidateSkinclusterDeformerSet</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate skinClusters on meshes have valid member relationships.</p> <p>In rare cases it can happen that a mesh has a skinCluster in its history but it is not included in the deformer relationship history. If this is the case then FBX will not export the skinning.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_skinCluster_deformer_set.py</code> <pre><code>class ValidateSkinclusterDeformerSet(plugin.MayaInstancePlugin,\n                                     OptionalPyblishPluginMixin):\n    \"\"\"Validate skinClusters on meshes have valid member relationships.\n\n    In rare cases it can happen that a mesh has a skinCluster in its history\n    but it is *not* included in the deformer relationship history. If this is\n    the case then FBX will not export the skinning.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = ['fbx']\n    label = \"Skincluster Deformer Relationships\"\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = False\n\n    def process(self, instance):\n        \"\"\"Process all the transform nodes in the instance\"\"\"\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n\n        if invalid:\n            raise PublishValidationError(\n                \"Invalid skinCluster relationships found on meshes: {0}\"\n                .format(invalid)\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        meshes = cmds.ls(instance, type=\"mesh\", noIntermediate=True, long=True)\n        invalid = list()\n\n        for mesh in meshes:\n            history = cmds.listHistory(mesh) or []\n            skins = cmds.ls(history, type=\"skinCluster\")\n\n            # Ensure at most one skinCluster\n            assert len(skins) &lt;= 1, \"Cannot have more than one skinCluster\"\n\n            if skins:\n                skin = skins[0]\n\n                # Ensure the mesh is also in the skinCluster set\n                # otherwise the skin will not be exported correctly\n                # by the FBX Exporter.\n                deformer_sets = cmds.listSets(object=mesh, type=2)\n                for deformer_set in deformer_sets:\n                    used_by = cmds.listConnections(deformer_set + \".usedBy\",\n                                                   source=True,\n                                                   destination=False)\n\n                    # Ignore those that don't seem to have a usedBy connection\n                    if not used_by:\n                        continue\n\n                    # We have a matching deformer set relationship\n                    if skin in set(used_by):\n                        break\n\n                else:\n                    invalid.append(mesh)\n                    cls.log.warning(\n                        \"Mesh has skinCluster in history but is not included \"\n                        \"in its deformer relationship set: \"\n                        \"{0} (skinCluster: {1})\".format(mesh, skin)\n                    )\n\n        return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_skinCluster_deformer_set.html#client.ayon_maya.plugins.publish.validate_skinCluster_deformer_set.ValidateSkinclusterDeformerSet.process","title":"<code>process(instance)</code>","text":"<p>Process all the transform nodes in the instance</p> Source code in <code>client/ayon_maya/plugins/publish/validate_skinCluster_deformer_set.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the transform nodes in the instance\"\"\"\n    if not self.is_active(instance.data):\n        return\n    invalid = self.get_invalid(instance)\n\n    if invalid:\n        raise PublishValidationError(\n            \"Invalid skinCluster relationships found on meshes: {0}\"\n            .format(invalid)\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_step_size.html","title":"validate_step_size","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_step_size.html#client.ayon_maya.plugins.publish.validate_step_size.ValidateStepSize","title":"<code>ValidateStepSize</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates the step size for the instance is in a valid range.</p> <p>For example the <code>step</code> size should never be lower or equal to zero.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_step_size.py</code> <pre><code>class ValidateStepSize(plugin.MayaInstancePlugin,\n                       OptionalPyblishPluginMixin):\n    \"\"\"Validates the step size for the instance is in a valid range.\n\n    For example the `step` size should never be lower or equal to zero.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    label = 'Step size'\n    families = ['camera',\n                'pointcache',\n                'animation']\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = False\n    MIN = 0.01\n    MAX = 1.0\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        objset = instance.data['instance_node']\n        step = instance.data.get(\"step\", 1.0)\n\n        if step &lt; cls.MIN or step &gt; cls.MAX:\n            cls.log.warning(\"Step size is outside of valid range: {0} \"\n                            \"(valid: {1} to {2})\".format(step,\n                                                         cls.MIN,\n                                                         cls.MAX))\n            return objset\n\n        return []\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Instance found with invalid step size: {0}\".format(invalid))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_transform_naming_suffix.html","title":"validate_transform_naming_suffix","text":"<p>Plugin for validating naming conventions.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_transform_naming_suffix.html#client.ayon_maya.plugins.publish.validate_transform_naming_suffix.ValidateTransformNamingSuffix","title":"<code>ValidateTransformNamingSuffix</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates transform suffix based on the type of its children shapes.</p> Suffices must be <ul> <li>mesh:     _GEO (regular geometry)     _GES (geometry to be smoothed at render)     _GEP (proxy geometry; usually not to be rendered)     _OSD (open subdiv smooth at rendertime)</li> <li>nurbsCurve: _CRV</li> <li>nurbsSurface: _NRB</li> <li>locator: _LOC</li> <li>null/group: _GRP</li> </ul> <p>Suffices can also be overridden by project settings.</p> <p>.. warning::     This grabs the first child shape as a reference and doesn't use the     others in the check.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_transform_naming_suffix.py</code> <pre><code>class ValidateTransformNamingSuffix(plugin.MayaInstancePlugin,\n                                    OptionalPyblishPluginMixin):\n    \"\"\"Validates transform suffix based on the type of its children shapes.\n\n    Suffices must be:\n        - mesh:\n            _GEO (regular geometry)\n            _GES (geometry to be smoothed at render)\n            _GEP (proxy geometry; usually not to be rendered)\n            _OSD (open subdiv smooth at rendertime)\n        - nurbsCurve: _CRV\n        - nurbsSurface: _NRB\n        - locator: _LOC\n        - null/group: _GRP\n    Suffices can also be overridden by project settings.\n\n    .. warning::\n        This grabs the first child shape as a reference and doesn't use the\n        others in the check.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"model\"]\n    optional = True\n    label = \"Suffix Naming Conventions\"\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    SUFFIX_NAMING_TABLE = json.dumps({\n        \"mesh\": [\"_GEO\", \"_GES\", \"_GEP\", \"_OSD\"],\n        \"nurbsCurve\": [\"_CRV\"],\n        \"nurbsSurface\": [\"_NRB\"],\n        \"locator\": [\"_LOC\"],\n        \"group\": [\"_GRP\"]\n    })\n\n    ALLOW_IF_NOT_IN_SUFFIX_TABLE = True\n\n    @classmethod\n    def get_table_for_invalid(cls, markdown=False):\n        suffix_naming_table = json.loads(cls.SUFFIX_NAMING_TABLE)\n        if markdown:\n            ss = [\n                \"- **{}**: {}\".format(k, \", \".join(v))\n                for k, v in suffix_naming_table.items()\n            ]\n        else:\n            ss = [\n                \"- {}: {}\".format(k, \", \".join(v))\n                for k, v in suffix_naming_table.items()\n            ]\n        return \"\\n\".join(ss)\n\n    @staticmethod\n    def is_valid_name(\n        node_name,\n        shape_type,\n        suffix_naming_table,\n        allow_if_not_in_suffix_table\n    ):\n        \"\"\"Return whether node's name is correct.\n\n        The correctness for a transform's suffix is dependent on what\n        `shape_type` it holds. E.g. a transform with a mesh might need and\n        `_GEO` suffix.\n\n        When `shape_type` is None the transform doesn't have any direct\n        children shapes.\n\n        Args:\n            node_name (str): Node name.\n            shape_type (str): Type of node.\n            suffix_naming_table (dict): Mapping dict for suffixes.\n            allow_if_not_in_suffix_table (bool): Default output.\n\n        \"\"\"\n        if shape_type not in suffix_naming_table:\n            return allow_if_not_in_suffix_table\n\n        suffices = suffix_naming_table[shape_type]\n        for suffix in suffices:\n            if node_name.endswith(suffix):\n                return True\n        return False\n\n    @classmethod\n    def get_invalid(cls, instance):\n        \"\"\"Get invalid nodes in instance.\n\n        Args:\n            instance (:class:`pyblish.api.Instance`): published instance.\n\n        \"\"\"\n        transforms = cmds.ls(instance, type=\"transform\", long=True)\n\n        invalid = []\n        suffix_naming_table = json.loads(cls.SUFFIX_NAMING_TABLE)\n        for transform in transforms:\n            shapes = cmds.listRelatives(transform,\n                                        shapes=True,\n                                        fullPath=True,\n                                        noIntermediate=True)\n\n            shape_type = cmds.nodeType(shapes[0]) if shapes else \"group\"\n            if not cls.is_valid_name(\n                transform,\n                shape_type,\n                suffix_naming_table,\n                cls.ALLOW_IF_NOT_IN_SUFFIX_TABLE\n            ):\n                invalid.append(transform)\n\n        return invalid\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance.\n\n        Args:\n            instance (:class:`pyblish.api.Instance`): published instance.\n\n        \"\"\"\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            valid = self.get_table_for_invalid()\n\n            names = \"\\n\".join(\n                \" - {}\".format(node) for node in invalid\n            )\n\n            raise PublishValidationError(\n                title=\"Invalid naming suffix\",\n                message=\"Valid suffixes are:\\n{0}\\n\\n\"\n                        \"Incorrectly named geometry transforms:\\n{1}\"\n                        \"\".format(valid, names),\n                description=self.get_description())\n\n    def get_description(self) -&gt; str:\n        \"\"\"Get description for the plugin.\"\"\"\n        table = self.get_table_for_invalid(markdown=True)\n        return (\n            \"### Invalid naming suffix\\n\"\n            \"Valid suffixes are:\\n\"\n            f\"{table}\\n\"\n            \"\\n\\\\\\n\"  # force extra line breaks in the resulting markdown\n            \"Use the *Select Invalid* action to identify the invalid nodes.\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_transform_naming_suffix.html#client.ayon_maya.plugins.publish.validate_transform_naming_suffix.ValidateTransformNamingSuffix.get_description","title":"<code>get_description()</code>","text":"<p>Get description for the plugin.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_transform_naming_suffix.py</code> <pre><code>def get_description(self) -&gt; str:\n    \"\"\"Get description for the plugin.\"\"\"\n    table = self.get_table_for_invalid(markdown=True)\n    return (\n        \"### Invalid naming suffix\\n\"\n        \"Valid suffixes are:\\n\"\n        f\"{table}\\n\"\n        \"\\n\\\\\\n\"  # force extra line breaks in the resulting markdown\n        \"Use the *Select Invalid* action to identify the invalid nodes.\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_transform_naming_suffix.html#client.ayon_maya.plugins.publish.validate_transform_naming_suffix.ValidateTransformNamingSuffix.get_invalid","title":"<code>get_invalid(instance)</code>  <code>classmethod</code>","text":"<p>Get invalid nodes in instance.</p> <p>Parameters:</p> Name Type Description Default <code>instance (</code> <p>class:<code>pyblish.api.Instance</code>): published instance.</p> required Source code in <code>client/ayon_maya/plugins/publish/validate_transform_naming_suffix.py</code> <pre><code>@classmethod\ndef get_invalid(cls, instance):\n    \"\"\"Get invalid nodes in instance.\n\n    Args:\n        instance (:class:`pyblish.api.Instance`): published instance.\n\n    \"\"\"\n    transforms = cmds.ls(instance, type=\"transform\", long=True)\n\n    invalid = []\n    suffix_naming_table = json.loads(cls.SUFFIX_NAMING_TABLE)\n    for transform in transforms:\n        shapes = cmds.listRelatives(transform,\n                                    shapes=True,\n                                    fullPath=True,\n                                    noIntermediate=True)\n\n        shape_type = cmds.nodeType(shapes[0]) if shapes else \"group\"\n        if not cls.is_valid_name(\n            transform,\n            shape_type,\n            suffix_naming_table,\n            cls.ALLOW_IF_NOT_IN_SUFFIX_TABLE\n        ):\n            invalid.append(transform)\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_transform_naming_suffix.html#client.ayon_maya.plugins.publish.validate_transform_naming_suffix.ValidateTransformNamingSuffix.is_valid_name","title":"<code>is_valid_name(node_name, shape_type, suffix_naming_table, allow_if_not_in_suffix_table)</code>  <code>staticmethod</code>","text":"<p>Return whether node's name is correct.</p> <p>The correctness for a transform's suffix is dependent on what <code>shape_type</code> it holds. E.g. a transform with a mesh might need and <code>_GEO</code> suffix.</p> <p>When <code>shape_type</code> is None the transform doesn't have any direct children shapes.</p> <p>Parameters:</p> Name Type Description Default <code>node_name</code> <code>str</code> <p>Node name.</p> required <code>shape_type</code> <code>str</code> <p>Type of node.</p> required <code>suffix_naming_table</code> <code>dict</code> <p>Mapping dict for suffixes.</p> required <code>allow_if_not_in_suffix_table</code> <code>bool</code> <p>Default output.</p> required Source code in <code>client/ayon_maya/plugins/publish/validate_transform_naming_suffix.py</code> <pre><code>@staticmethod\ndef is_valid_name(\n    node_name,\n    shape_type,\n    suffix_naming_table,\n    allow_if_not_in_suffix_table\n):\n    \"\"\"Return whether node's name is correct.\n\n    The correctness for a transform's suffix is dependent on what\n    `shape_type` it holds. E.g. a transform with a mesh might need and\n    `_GEO` suffix.\n\n    When `shape_type` is None the transform doesn't have any direct\n    children shapes.\n\n    Args:\n        node_name (str): Node name.\n        shape_type (str): Type of node.\n        suffix_naming_table (dict): Mapping dict for suffixes.\n        allow_if_not_in_suffix_table (bool): Default output.\n\n    \"\"\"\n    if shape_type not in suffix_naming_table:\n        return allow_if_not_in_suffix_table\n\n    suffices = suffix_naming_table[shape_type]\n    for suffix in suffices:\n        if node_name.endswith(suffix):\n            return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_transform_naming_suffix.html#client.ayon_maya.plugins.publish.validate_transform_naming_suffix.ValidateTransformNamingSuffix.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance.</p> <p>Parameters:</p> Name Type Description Default <code>instance (</code> <p>class:<code>pyblish.api.Instance</code>): published instance.</p> required Source code in <code>client/ayon_maya/plugins/publish/validate_transform_naming_suffix.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance.\n\n    Args:\n        instance (:class:`pyblish.api.Instance`): published instance.\n\n    \"\"\"\n    if not self.is_active(instance.data):\n        return\n\n    invalid = self.get_invalid(instance)\n    if invalid:\n        valid = self.get_table_for_invalid()\n\n        names = \"\\n\".join(\n            \" - {}\".format(node) for node in invalid\n        )\n\n        raise PublishValidationError(\n            title=\"Invalid naming suffix\",\n            message=\"Valid suffixes are:\\n{0}\\n\\n\"\n                    \"Incorrectly named geometry transforms:\\n{1}\"\n                    \"\".format(valid, names),\n            description=self.get_description())\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_transform_zero.html","title":"validate_transform_zero","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_transform_zero.html#client.ayon_maya.plugins.publish.validate_transform_zero.ValidateTransformZero","title":"<code>ValidateTransformZero</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Transforms can't have any values</p> <p>To solve this issue, try freezing the transforms. So long as the transforms, rotation and scale values are zero, you're all good.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_transform_zero.py</code> <pre><code>class ValidateTransformZero(plugin.MayaInstancePlugin,\n                            OptionalPyblishPluginMixin):\n    \"\"\"Transforms can't have any values\n\n    To solve this issue, try freezing the transforms. So long\n    as the transforms, rotation and scale values are zero,\n    you're all good.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"model\"]\n    label = \"Transform Zero (Freeze)\"\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n\n    _identity = [1.0, 0.0, 0.0, 0.0,\n                 0.0, 1.0, 0.0, 0.0,\n                 0.0, 0.0, 1.0, 0.0,\n                 0.0, 0.0, 0.0, 1.0]\n    _tolerance = 1e-30\n    optional = True\n\n    @classmethod\n    def get_invalid(cls, instance):\n        \"\"\"Returns the invalid transforms in the instance.\n\n        This is the same as checking:\n        - translate == [0, 0, 0] and rotate == [0, 0, 0] and\n          scale == [1, 1, 1] and shear == [0, 0, 0]\n\n        .. note::\n            This will also catch camera transforms if those\n            are in the instances.\n\n        Returns:\n            list: Transforms that are not identity matrix\n\n        \"\"\"\n\n        transforms = cmds.ls(instance, type=\"transform\")\n\n        invalid = []\n        for transform in transforms:\n            if ('_LOC' in transform) or ('_loc' in transform):\n                continue\n            mat = cmds.xform(transform, q=1, matrix=True, objectSpace=True)\n            if not all(abs(x - y) &lt; cls._tolerance\n                       for x, y in zip(cls._identity, mat)):\n                invalid.append(transform)\n\n        return invalid\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance \"objectSet\"\"\"\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            names = \"\\n\".join(\n                \" - {}\".format(node) for node in invalid\n            )\n\n            raise PublishValidationError(\n                title=\"Transform Zero\",\n                description=self.get_description(),\n                message=\"The model publish allows no transformations. You must\"\n                        \" 'freeze transformations'. to continue.\\n\\n\"\n                        \"Nodes found with transform values:\\n\"\n                        \"{0}\".format(names))\n\n    @staticmethod\n    def get_description():\n        return inspect.cleandoc(\"\"\"### Transform can't have any values\n\n        The model publish allows no transformations.\n\n        You must **freeze transformations** to continue.\n\n        \"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_transform_zero.html#client.ayon_maya.plugins.publish.validate_transform_zero.ValidateTransformZero.get_invalid","title":"<code>get_invalid(instance)</code>  <code>classmethod</code>","text":"<p>Returns the invalid transforms in the instance.</p> <p>This is the same as checking: - translate == [0, 0, 0] and rotate == [0, 0, 0] and   scale == [1, 1, 1] and shear == [0, 0, 0]</p> <p>.. note::     This will also catch camera transforms if those     are in the instances.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Transforms that are not identity matrix</p> Source code in <code>client/ayon_maya/plugins/publish/validate_transform_zero.py</code> <pre><code>@classmethod\ndef get_invalid(cls, instance):\n    \"\"\"Returns the invalid transforms in the instance.\n\n    This is the same as checking:\n    - translate == [0, 0, 0] and rotate == [0, 0, 0] and\n      scale == [1, 1, 1] and shear == [0, 0, 0]\n\n    .. note::\n        This will also catch camera transforms if those\n        are in the instances.\n\n    Returns:\n        list: Transforms that are not identity matrix\n\n    \"\"\"\n\n    transforms = cmds.ls(instance, type=\"transform\")\n\n    invalid = []\n    for transform in transforms:\n        if ('_LOC' in transform) or ('_loc' in transform):\n            continue\n        mat = cmds.xform(transform, q=1, matrix=True, objectSpace=True)\n        if not all(abs(x - y) &lt; cls._tolerance\n                   for x, y in zip(cls._identity, mat)):\n            invalid.append(transform)\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_transform_zero.html#client.ayon_maya.plugins.publish.validate_transform_zero.ValidateTransformZero.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance \"objectSet</p> Source code in <code>client/ayon_maya/plugins/publish/validate_transform_zero.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance \"objectSet\"\"\"\n    if not self.is_active(instance.data):\n        return\n    invalid = self.get_invalid(instance)\n    if invalid:\n        names = \"\\n\".join(\n            \" - {}\".format(node) for node in invalid\n        )\n\n        raise PublishValidationError(\n            title=\"Transform Zero\",\n            description=self.get_description(),\n            message=\"The model publish allows no transformations. You must\"\n                    \" 'freeze transformations'. to continue.\\n\\n\"\n                    \"Nodes found with transform values:\\n\"\n                    \"{0}\".format(names))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_unique_names.html","title":"validate_unique_names","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_unique_names.html#client.ayon_maya.plugins.publish.validate_unique_names.ValidateUniqueNames","title":"<code>ValidateUniqueNames</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>transform names should be unique</p> <p>ie: using cmds.ls(someNodeName) should always return shortname</p> Source code in <code>client/ayon_maya/plugins/publish/validate_unique_names.py</code> <pre><code>class ValidateUniqueNames(plugin.MayaInstancePlugin,\n                          OptionalPyblishPluginMixin):\n    \"\"\"transform names should be unique\n\n    ie: using cmds.ls(someNodeName) should always return shortname\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"model\"]\n    label = \"Unique transform name\"\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = True\n\n    @staticmethod\n    def get_invalid(instance):\n        \"\"\"Returns the invalid transforms in the instance.\n\n        Returns:\n            list: Non-unique name transforms.\n\n        \"\"\"\n        # Check whether Maya's 'short name' includes a longer path than just\n        # the node name to check whether it's unique in the full scene.\n        non_unique_transforms_in_instance = [\n            tr for tr in cmds.ls(instance, type=\"transform\")\n            if '|' in tr\n        ]\n\n        # Only invalidate if the clash is within the current instance\n        count = Counter()\n        for transform in non_unique_transforms_in_instance:\n            short_name = transform.rsplit(\"|\", 1)[-1]\n            count[short_name] += 1\n\n        invalid = []\n        for transform in non_unique_transforms_in_instance:\n            short_name = transform.rsplit(\"|\", 1)[-1]\n            if count[short_name] &gt;= 2:\n                invalid.append(transform)\n\n        return invalid\n\n    def process(self, instance):\n        \"\"\"Process all the nodes in the instance \"objectSet\"\"\"\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Nodes found with non-unique names:\\n{0}\".format(invalid))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_unique_names.html#client.ayon_maya.plugins.publish.validate_unique_names.ValidateUniqueNames.get_invalid","title":"<code>get_invalid(instance)</code>  <code>staticmethod</code>","text":"<p>Returns the invalid transforms in the instance.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Non-unique name transforms.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_unique_names.py</code> <pre><code>@staticmethod\ndef get_invalid(instance):\n    \"\"\"Returns the invalid transforms in the instance.\n\n    Returns:\n        list: Non-unique name transforms.\n\n    \"\"\"\n    # Check whether Maya's 'short name' includes a longer path than just\n    # the node name to check whether it's unique in the full scene.\n    non_unique_transforms_in_instance = [\n        tr for tr in cmds.ls(instance, type=\"transform\")\n        if '|' in tr\n    ]\n\n    # Only invalidate if the clash is within the current instance\n    count = Counter()\n    for transform in non_unique_transforms_in_instance:\n        short_name = transform.rsplit(\"|\", 1)[-1]\n        count[short_name] += 1\n\n    invalid = []\n    for transform in non_unique_transforms_in_instance:\n        short_name = transform.rsplit(\"|\", 1)[-1]\n        if count[short_name] &gt;= 2:\n            invalid.append(transform)\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_unique_names.html#client.ayon_maya.plugins.publish.validate_unique_names.ValidateUniqueNames.process","title":"<code>process(instance)</code>","text":"<p>Process all the nodes in the instance \"objectSet</p> Source code in <code>client/ayon_maya/plugins/publish/validate_unique_names.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process all the nodes in the instance \"objectSet\"\"\"\n    if not self.is_active(instance.data):\n        return\n    invalid = self.get_invalid(instance)\n    if invalid:\n        raise PublishValidationError(\n            \"Nodes found with non-unique names:\\n{0}\".format(invalid))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_unreal_mesh_triangulated.html","title":"validate_unreal_mesh_triangulated","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_unreal_mesh_triangulated.html#client.ayon_maya.plugins.publish.validate_unreal_mesh_triangulated.ValidateUnrealMeshTriangulated","title":"<code>ValidateUnrealMeshTriangulated</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate if mesh is made of triangles for Unreal Engine</p> Source code in <code>client/ayon_maya/plugins/publish/validate_unreal_mesh_triangulated.py</code> <pre><code>class ValidateUnrealMeshTriangulated(plugin.MayaInstancePlugin,\n                                     OptionalPyblishPluginMixin):\n    \"\"\"Validate if mesh is made of triangles for Unreal Engine\"\"\"\n\n    order = ValidateMeshOrder\n    families = [\"staticMesh\"]\n    label = \"Mesh is Triangulated\"\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    active = False\n\n    @classmethod\n    def get_invalid(cls, instance):\n        invalid = []\n        meshes = cmds.ls(instance, type=\"mesh\", long=True)\n        for mesh in meshes:\n            faces = cmds.polyEvaluate(mesh, face=True)\n            tris = cmds.polyEvaluate(mesh, triangle=True)\n            if faces != tris:\n                invalid.append(mesh)\n\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\"Found meshes without triangles\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_unreal_staticmesh_naming.html","title":"validate_unreal_staticmesh_naming","text":"<p>Validator for correct naming of Static Meshes.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_unreal_staticmesh_naming.html#client.ayon_maya.plugins.publish.validate_unreal_staticmesh_naming.ValidateUnrealStaticMeshName","title":"<code>ValidateUnrealStaticMeshName</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate name of Unreal Static Mesh</p> <p>Unreals naming convention states that staticMesh should start with <code>SM</code> prefix - SM_[Name]_## (Eg. SM_sube_01).These prefixes can be configured in Settings UI. This plugin also validates other types of meshes - collision meshes:</p> <p>UBX_[RenderMeshName]*:                          Boxes are created with the Box objects type in                          Max or with the Cube polygonal primitive in Maya.                          You cannot move the vertices around or deform it                          in any way to make it something other than a                          rectangular prism, or else it will not work.</p> <p>UCP_[RenderMeshName]*:                          Capsules are created with the Capsule object type.                          The capsule does not need to have many segments                          (8 is a good number) at all because it is                          converted into a true capsule for collision. Like                          boxes, you should not move the individual                          vertices around.</p> <p>USP_[RenderMeshName]*:                          Spheres are created with the Sphere object type.                          The sphere does not need to have many segments                          (8 is a good number) at all because it is                          converted into a true sphere for collision. Like                          boxes, you should not move the individual                          vertices around.</p> <p>UCX_[RenderMeshName]*:                          Convex objects can be any completely closed                          convex 3D shape. For example, a box can also be                          a convex object</p> <p>This validator also checks if collision mesh [RenderMeshName] matches one of SM_[RenderMeshName].</p> Source code in <code>client/ayon_maya/plugins/publish/validate_unreal_staticmesh_naming.py</code> <pre><code>class ValidateUnrealStaticMeshName(plugin.MayaInstancePlugin,\n                                   OptionalPyblishPluginMixin):\n    \"\"\"Validate name of Unreal Static Mesh\n\n    Unreals naming convention states that staticMesh should start with `SM`\n    prefix - SM_[Name]_## (Eg. SM_sube_01).These prefixes can be configured\n    in Settings UI. This plugin also validates other types of\n    meshes - collision meshes:\n\n    UBX_[RenderMeshName]*:\n                             Boxes are created with the Box objects type in\n                             Max or with the Cube polygonal primitive in Maya.\n                             You cannot move the vertices around or deform it\n                             in any way to make it something other than a\n                             rectangular prism, or else it will not work.\n\n    UCP_[RenderMeshName]*:\n                             Capsules are created with the Capsule object type.\n                             The capsule does not need to have many segments\n                             (8 is a good number) at all because it is\n                             converted into a true capsule for collision. Like\n                             boxes, you should not move the individual\n                             vertices around.\n\n    USP_[RenderMeshName]*:\n                             Spheres are created with the Sphere object type.\n                             The sphere does not need to have many segments\n                             (8 is a good number) at all because it is\n                             converted into a true sphere for collision. Like\n                             boxes, you should not move the individual\n                             vertices around.\n\n    UCX_[RenderMeshName]*:\n                             Convex objects can be any completely closed\n                             convex 3D shape. For example, a box can also be\n                             a convex object\n\n    This validator also checks if collision mesh [RenderMeshName] matches one\n    of SM_[RenderMeshName].\n\n    \"\"\"\n    optional = True\n    order = ValidateContentsOrder\n    families = [\"staticMesh\"]\n    label = \"Unreal Static Mesh Name\"\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    regex_mesh = r\"(?P&lt;renderName&gt;.*))\"\n    regex_collision = r\"(?P&lt;renderName&gt;.*)\"\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        invalid = []\n\n        collision_prefixes = (\n            instance.context.data[\"project_settings\"]\n            [\"maya\"]\n            [\"create\"]\n            [\"CreateUnrealStaticMesh\"]\n            [\"collision_prefixes\"]\n        )\n\n        if cls.validate_mesh:\n            # compile regex for testing names\n            regex_mesh = \"{}{}\".format(\n                (\"_\" + cls.static_mesh_prefix) or \"\", cls.regex_mesh\n            )\n            sm_r = re.compile(regex_mesh)\n            if not sm_r.match(instance.data.get(\"productName\")):\n                cls.log.error(\"Mesh doesn't comply with name validation.\")\n                return True\n\n        if cls.validate_collision:\n            collision_set = instance.data.get(\"collisionMembers\", None)\n            # soft-fail is there are no collision objects\n            if not collision_set:\n                cls.log.warning(\"No collision objects to validate.\")\n                return False\n\n            regex_collision = \"{}{}_(\\\\d+)\".format(\n                \"(?P&lt;prefix&gt;({}))_\".format(\n                    \"|\".join(\"{0}\".format(p) for p in collision_prefixes)\n                ) or \"\", cls.regex_collision\n            )\n\n            cl_r = re.compile(regex_collision)\n\n            folder_name = instance.data[\"folderEntity\"][\"name\"]\n            mesh_name = \"{}{}\".format(folder_name,\n                                      instance.data.get(\"variant\", []))\n\n            for obj in collision_set:\n                cl_m = cl_r.match(obj)\n                if not cl_m:\n                    cls.log.error(\"{} is invalid\".format(obj))\n                    invalid.append(obj)\n                else:\n                    expected_collision = \"{}_{}\".format(\n                        cl_m.group(\"prefix\"),\n                        mesh_name\n                    )\n\n                    if not obj.startswith(expected_collision):\n\n                        cls.log.error(\n                            \"Collision object name doesn't match \"\n                            \"static mesh name\"\n                        )\n                        cls.log.error(\"{}_{} != {}_{}*\".format(\n                            cl_m.group(\"prefix\"),\n                            cl_m.group(\"renderName\"),\n                            cl_m.group(\"prefix\"),\n                            mesh_name,\n                        ))\n                        invalid.append(obj)\n\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        if not self.validate_mesh and not self.validate_collision:\n            self.log.debug(\"Validation of both mesh and collision names\"\n                           \"is disabled.\")\n            return\n\n        if not instance.data.get(\"collisionMembers\", None):\n            self.log.debug(\"There are no collision objects to validate\")\n            return\n\n        invalid = self.get_invalid(instance)\n\n        if invalid:\n            raise PublishValidationError(\"Model naming is invalid. See log.\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_unreal_up_axis.html","title":"validate_unreal_up_axis","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_unreal_up_axis.html#client.ayon_maya.plugins.publish.validate_unreal_up_axis.ValidateUnrealUpAxis","title":"<code>ValidateUnrealUpAxis</code>","text":"<p>               Bases: <code>MayaContextPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate if Z is set as up axis in Maya</p> Source code in <code>client/ayon_maya/plugins/publish/validate_unreal_up_axis.py</code> <pre><code>class ValidateUnrealUpAxis(plugin.MayaContextPlugin,\n                           OptionalPyblishPluginMixin):\n    \"\"\"Validate if Z is set as up axis in Maya\"\"\"\n\n    optional = True\n    active = False\n    order = ValidateContentsOrder\n    families = [\"staticMesh\"]\n    label = \"Unreal Up-Axis check\"\n    actions = [RepairAction]\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            return\n\n        if cmds.upAxis(q=True, axis=True) != \"z\":\n            raise PublishValidationError(\n                \"Invalid axis set as up axis\"\n            )\n\n    @classmethod\n    def repair(cls, instance):\n        cmds.upAxis(axis=\"z\", rotateView=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_visible_only.html","title":"validate_visible_only","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_visible_only.html#client.ayon_maya.plugins.publish.validate_visible_only.ValidateAlembicVisibleOnly","title":"<code>ValidateAlembicVisibleOnly</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates at least a single node is visible in frame range.</p> <p>This validation only validates if the <code>visibleOnly</code> flag is enabled on the instance - otherwise the validation is skipped.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_visible_only.py</code> <pre><code>class ValidateAlembicVisibleOnly(plugin.MayaInstancePlugin,\n                                 OptionalPyblishPluginMixin):\n    \"\"\"Validates at least a single node is visible in frame range.\n\n    This validation only validates if the `visibleOnly` flag is enabled\n    on the instance - otherwise the validation is skipped.\n\n    \"\"\"\n    order = ValidateContentsOrder + 0.05\n    label = \"Alembic Visible Only\"\n    families = [\"pointcache\", \"animation\"]\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        if not instance.data.get(\"visibleOnly\", False):\n            self.log.debug(\"Visible only is disabled. Validation skipped..\")\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            start, end = self.get_frame_range(instance)\n            raise PublishValidationError(\n                f\"No visible nodes found in frame range {start}-{end}.\"\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        if instance.data[\"productType\"] == \"animation\":\n            # Special behavior to use the nodes in out_SET\n            nodes = instance.data[\"out_hierarchy\"]\n        else:\n            nodes = instance[:]\n\n        start, end = cls.get_frame_range(instance)\n        if not any(iter_visible_nodes_in_range(nodes, start, end)):\n            # Return the nodes we have considered so the user can identify\n            # them with the select invalid action\n            return nodes\n\n    @staticmethod\n    def get_frame_range(instance):\n        data = instance.data\n        return data[\"frameStartHandle\"], data[\"frameEndHandle\"]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_vray.html","title":"validate_vray","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_vray.html#client.ayon_maya.plugins.publish.validate_vray.ValidateVray","title":"<code>ValidateVray</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validate general Vray setup.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_vray.py</code> <pre><code>class ValidateVray(plugin.MayaInstancePlugin):\n    \"\"\"Validate general Vray setup.\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = 'VRay'\n    families = [\"vrayproxy\"]\n\n    def process(self, instance):\n        # Validate vray plugin is loaded.\n        if not cmds.pluginInfo(\"vrayformaya\", query=True, loaded=True):\n            raise PublishValidationError(\"Vray plugin is not loaded.\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_vray_distributed_rendering.html","title":"validate_vray_distributed_rendering","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_vray_distributed_rendering.html#client.ayon_maya.plugins.publish.validate_vray_distributed_rendering.ValidateVRayDistributedRendering","title":"<code>ValidateVRayDistributedRendering</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate V-Ray Distributed Rendering is ignored in batch mode.</p> <p>Whenever Distributed Rendering is enabled for V-Ray in the render settings ensure that the \"Ignore in batch mode\" is enabled so the submitted job won't try to render each frame with all machines resulting in faulty errors.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_vray_distributed_rendering.py</code> <pre><code>class ValidateVRayDistributedRendering(plugin.MayaInstancePlugin,\n                                       OptionalPyblishPluginMixin):\n    \"\"\"Validate V-Ray Distributed Rendering is ignored in batch mode.\n\n    Whenever Distributed Rendering is enabled for V-Ray in the render settings\n    ensure that the \"Ignore in batch mode\" is enabled so the submitted job\n    won't try to render each frame with all machines resulting in faulty\n    errors.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    label = \"VRay Distributed Rendering\"\n    families = [\"renderlayer\"]\n    actions = [RepairAction]\n    optional = False\n\n    # V-Ray attribute names\n    enabled_attr = \"vraySettings.sys_distributed_rendering_on\"\n    ignored_attr = \"vraySettings.sys_distributed_rendering_ignore_batch\"\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        if instance.data.get(\"renderer\") != \"vray\":\n            # If not V-Ray, ignore\n            return\n\n        vray_settings = cmds.ls(\"vraySettings\", type=\"VRaySettingsNode\")\n        if not vray_settings:\n            raise KnownPublishError(\n                \"Please ensure a VRay Settings Node is present\"\n            )\n\n        renderlayer = instance.data['renderlayer']\n\n        if not lib.get_attr_in_layer(self.enabled_attr, layer=renderlayer):\n            # If not distributed rendering enabled, ignore..\n            return\n\n        # If distributed rendering is enabled but it is *not* set to ignore\n        # during batch mode we invalidate the instance\n        if not lib.get_attr_in_layer(self.ignored_attr, layer=renderlayer):\n            raise PublishValidationError(\n                \"Renderlayer has distributed rendering enabled \"\n                \"but is not set to ignore in batch mode.\")\n\n    @classmethod\n    def repair(cls, instance):\n\n        renderlayer = instance.data.get(\"renderlayer\")\n        with lib.renderlayer(renderlayer):\n            cls.log.debug(\"Enabling Distributed Rendering \"\n                          \"ignore in batch mode..\")\n            cmds.setAttr(cls.ignored_attr, True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_vray_referenced_aovs.html","title":"validate_vray_referenced_aovs","text":"<p>Validate if there are AOVs pulled from references.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_vray_referenced_aovs.html#client.ayon_maya.plugins.publish.validate_vray_referenced_aovs.ValidateVrayReferencedAOVs","title":"<code>ValidateVrayReferencedAOVs</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate whether the V-Ray Render Elements (AOVs) include references.</p> <p>This will check if there are AOVs pulled from references. If <code>Vray Use Referenced Aovs</code> is checked on render instance, u must add those manually to Render Elements as Pype will expect them to be rendered.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_vray_referenced_aovs.py</code> <pre><code>class ValidateVrayReferencedAOVs(plugin.MayaInstancePlugin,\n                                 OptionalPyblishPluginMixin):\n    \"\"\"Validate whether the V-Ray Render Elements (AOVs) include references.\n\n    This will check if there are AOVs pulled from references. If\n    `Vray Use Referenced Aovs` is checked on render instance, u must add those\n    manually to Render Elements as Pype will expect them to be rendered.\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = 'VRay Referenced AOVs'\n    families = ['renderlayer']\n    actions = [RepairContextAction]\n    optional = False\n\n    def process(self, instance):\n        \"\"\"Plugin main entry point.\"\"\"\n        if not self.is_active(instance.data):\n            return\n        if instance.data.get(\"renderer\") != \"vray\":\n            # If not V-Ray ignore..\n            return\n\n        ref_aovs = cmds.ls(\n            type=[\"VRayRenderElement\", \"VRayRenderElementSet\"],\n            referencedNodes=True)\n        ref_aovs_enabled = ValidateVrayReferencedAOVs.maya_is_true(\n            cmds.getAttr(\"vraySettings.relements_usereferenced\"))\n\n        if not instance.data.get(\"vrayUseReferencedAovs\"):\n            if ref_aovs_enabled and ref_aovs:\n                self.log.warning((\n                    \"Referenced AOVs are enabled in Vray \"\n                    \"Render Settings and are detected in scene, but \"\n                    \"AYON render instance option for referenced AOVs is \"\n                    \"disabled. Those AOVs will be rendered but not published \"\n                    \"by Pype.\"\n                ))\n                self.log.warning(\", \".join(ref_aovs))\n        else:\n            if not ref_aovs:\n                self.log.warning((\n                    \"Use of referenced AOVs enabled but there are none \"\n                    \"in the scene.\"\n                ))\n            if not ref_aovs_enabled:\n                self.log.error((\n                    \"'Use referenced' not enabled in Vray Render Settings.\"\n                ))\n                raise PublishValidationError(\"Invalid render settings\")\n\n    @classmethod\n    def repair(cls, context):\n        \"\"\"Repair action.\"\"\"\n        vray_settings = cmds.ls(type=\"VRaySettingsNode\")\n        if not vray_settings:\n            node = cmds.createNode(\"VRaySettingsNode\")\n        else:\n            node = vray_settings[0]\n\n        cmds.setAttr(\"{}.relements_usereferenced\".format(node), True)\n\n    @staticmethod\n    def maya_is_true(attr_val):\n        \"\"\"Whether a Maya attr evaluates to True.\n\n        When querying an attribute value from an ambiguous object the\n        Maya API will return a list of values, which need to be properly\n        handled to evaluate properly.\n\n        Args:\n            attr_val (mixed): Maya attribute to be evaluated as bool.\n\n        Returns:\n            bool: cast Maya attribute to Pythons boolean value.\n\n        \"\"\"\n        if isinstance(attr_val, bool):\n            return attr_val\n        elif isinstance(attr_val, (list, types.GeneratorType)):\n            return any(attr_val)\n        else:\n            return bool(attr_val)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_vray_referenced_aovs.html#client.ayon_maya.plugins.publish.validate_vray_referenced_aovs.ValidateVrayReferencedAOVs.maya_is_true","title":"<code>maya_is_true(attr_val)</code>  <code>staticmethod</code>","text":"<p>Whether a Maya attr evaluates to True.</p> <p>When querying an attribute value from an ambiguous object the Maya API will return a list of values, which need to be properly handled to evaluate properly.</p> <p>Parameters:</p> Name Type Description Default <code>attr_val</code> <code>mixed</code> <p>Maya attribute to be evaluated as bool.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>cast Maya attribute to Pythons boolean value.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_vray_referenced_aovs.py</code> <pre><code>@staticmethod\ndef maya_is_true(attr_val):\n    \"\"\"Whether a Maya attr evaluates to True.\n\n    When querying an attribute value from an ambiguous object the\n    Maya API will return a list of values, which need to be properly\n    handled to evaluate properly.\n\n    Args:\n        attr_val (mixed): Maya attribute to be evaluated as bool.\n\n    Returns:\n        bool: cast Maya attribute to Pythons boolean value.\n\n    \"\"\"\n    if isinstance(attr_val, bool):\n        return attr_val\n    elif isinstance(attr_val, (list, types.GeneratorType)):\n        return any(attr_val)\n    else:\n        return bool(attr_val)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_vray_referenced_aovs.html#client.ayon_maya.plugins.publish.validate_vray_referenced_aovs.ValidateVrayReferencedAOVs.process","title":"<code>process(instance)</code>","text":"<p>Plugin main entry point.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_vray_referenced_aovs.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin main entry point.\"\"\"\n    if not self.is_active(instance.data):\n        return\n    if instance.data.get(\"renderer\") != \"vray\":\n        # If not V-Ray ignore..\n        return\n\n    ref_aovs = cmds.ls(\n        type=[\"VRayRenderElement\", \"VRayRenderElementSet\"],\n        referencedNodes=True)\n    ref_aovs_enabled = ValidateVrayReferencedAOVs.maya_is_true(\n        cmds.getAttr(\"vraySettings.relements_usereferenced\"))\n\n    if not instance.data.get(\"vrayUseReferencedAovs\"):\n        if ref_aovs_enabled and ref_aovs:\n            self.log.warning((\n                \"Referenced AOVs are enabled in Vray \"\n                \"Render Settings and are detected in scene, but \"\n                \"AYON render instance option for referenced AOVs is \"\n                \"disabled. Those AOVs will be rendered but not published \"\n                \"by Pype.\"\n            ))\n            self.log.warning(\", \".join(ref_aovs))\n    else:\n        if not ref_aovs:\n            self.log.warning((\n                \"Use of referenced AOVs enabled but there are none \"\n                \"in the scene.\"\n            ))\n        if not ref_aovs_enabled:\n            self.log.error((\n                \"'Use referenced' not enabled in Vray Render Settings.\"\n            ))\n            raise PublishValidationError(\"Invalid render settings\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_vray_referenced_aovs.html#client.ayon_maya.plugins.publish.validate_vray_referenced_aovs.ValidateVrayReferencedAOVs.repair","title":"<code>repair(context)</code>  <code>classmethod</code>","text":"<p>Repair action.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_vray_referenced_aovs.py</code> <pre><code>@classmethod\ndef repair(cls, context):\n    \"\"\"Repair action.\"\"\"\n    vray_settings = cmds.ls(type=\"VRaySettingsNode\")\n    if not vray_settings:\n        node = cmds.createNode(\"VRaySettingsNode\")\n    else:\n        node = vray_settings[0]\n\n    cmds.setAttr(\"{}.relements_usereferenced\".format(node), True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_vray_translator_settings.html","title":"validate_vray_translator_settings","text":"<p>Validate VRay Translator settings.</p>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_vray_translator_settings.html#client.ayon_maya.plugins.publish.validate_vray_translator_settings.ValidateVRayTranslatorEnabled","title":"<code>ValidateVRayTranslatorEnabled</code>","text":"<p>               Bases: <code>MayaContextPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate VRay Translator settings for extracting vrscenes.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_vray_translator_settings.py</code> <pre><code>class ValidateVRayTranslatorEnabled(plugin.MayaContextPlugin,\n                                    OptionalPyblishPluginMixin):\n    \"\"\"Validate VRay Translator settings for extracting vrscenes.\"\"\"\n\n    order = ValidateContentsOrder\n    label = \"VRay Translator Settings\"\n    families = [\"vrayscene_layer\"]\n    actions = [RepairContextAction]\n    optional = False\n\n    def process(self, context):\n        \"\"\"Plugin entry point.\"\"\"\n        if not self.is_active(context.data):\n            return\n        # Workaround bug pyblish-base#250\n        if not context_plugin_should_run(self, context):\n            return\n\n        invalid = self.get_invalid(context)\n        if invalid:\n            raise PublishValidationError(\n                message=\"Found invalid VRay Translator settings\",\n                title=self.label\n            )\n\n    @classmethod\n    def get_invalid(cls, context):\n        \"\"\"Get invalid instances.\"\"\"\n        invalid = False\n\n        # Get vraySettings node\n        vray_settings = cmds.ls(type=\"VRaySettingsNode\")\n        if not vray_settings:\n            raise PublishValidationError(\n                \"Please ensure a VRay Settings Node is present\",\n                title=cls.label\n            )\n\n        node = vray_settings[0]\n\n        if cmds.setAttr(\"{}.vrscene_render_on\".format(node)):\n            cls.log.error(\n                \"Render is enabled, for export it should be disabled\")\n            invalid = True\n\n        if not cmds.getAttr(\"{}.vrscene_on\".format(node)):\n            cls.log.error(\"Export vrscene not enabled\")\n            invalid = True\n\n        for instance in context:\n            if \"vrayscene_layer\" not in instance.data.get(\"families\"):\n                continue\n\n            if instance.data.get(\"vraySceneMultipleFiles\"):\n                if not cmds.getAttr(\"{}.misc_eachFrameInFile\".format(node)):\n                    cls.log.error(\"Each Frame in File not enabled\")\n                    invalid = True\n            else:\n                if cmds.getAttr(\"{}.misc_eachFrameInFile\".format(node)):\n                    cls.log.error(\"Each Frame in File is enabled\")\n                    invalid = True\n\n        vrscene_filename = cmds.getAttr(\"{}.vrscene_filename\".format(node))\n        if vrscene_filename != \"vrayscene/&lt;Scene&gt;/&lt;Layer&gt;/&lt;Layer&gt;\":\n            cls.log.error(\"Template for file name is wrong\")\n            invalid = True\n\n        return invalid\n\n    @classmethod\n    def repair(cls, context):\n        \"\"\"Repair invalid settings.\"\"\"\n        vray_settings = cmds.ls(type=\"VRaySettingsNode\")\n        if not vray_settings:\n            node = cmds.createNode(\"VRaySettingsNode\")\n        else:\n            node = vray_settings[0]\n\n        cmds.setAttr(\"{}.vrscene_render_on\".format(node), False)\n        cmds.setAttr(\"{}.vrscene_on\".format(node), True)\n        for instance in context:\n            if \"vrayscene\" not in instance.data.get(\"families\"):\n                continue\n\n            if instance.data.get(\"vraySceneMultipleFiles\"):\n                cmds.setAttr(\"{}.misc_eachFrameInFile\".format(node), True)\n            else:\n                cmds.setAttr(\"{}.misc_eachFrameInFile\".format(node), False)\n        cmds.setAttr(\"{}.vrscene_filename\".format(node),\n                     \"vrayscene/&lt;Scene&gt;/&lt;Layer&gt;/&lt;Layer&gt;\",\n                     type=\"string\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_vray_translator_settings.html#client.ayon_maya.plugins.publish.validate_vray_translator_settings.ValidateVRayTranslatorEnabled.get_invalid","title":"<code>get_invalid(context)</code>  <code>classmethod</code>","text":"<p>Get invalid instances.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_vray_translator_settings.py</code> <pre><code>@classmethod\ndef get_invalid(cls, context):\n    \"\"\"Get invalid instances.\"\"\"\n    invalid = False\n\n    # Get vraySettings node\n    vray_settings = cmds.ls(type=\"VRaySettingsNode\")\n    if not vray_settings:\n        raise PublishValidationError(\n            \"Please ensure a VRay Settings Node is present\",\n            title=cls.label\n        )\n\n    node = vray_settings[0]\n\n    if cmds.setAttr(\"{}.vrscene_render_on\".format(node)):\n        cls.log.error(\n            \"Render is enabled, for export it should be disabled\")\n        invalid = True\n\n    if not cmds.getAttr(\"{}.vrscene_on\".format(node)):\n        cls.log.error(\"Export vrscene not enabled\")\n        invalid = True\n\n    for instance in context:\n        if \"vrayscene_layer\" not in instance.data.get(\"families\"):\n            continue\n\n        if instance.data.get(\"vraySceneMultipleFiles\"):\n            if not cmds.getAttr(\"{}.misc_eachFrameInFile\".format(node)):\n                cls.log.error(\"Each Frame in File not enabled\")\n                invalid = True\n        else:\n            if cmds.getAttr(\"{}.misc_eachFrameInFile\".format(node)):\n                cls.log.error(\"Each Frame in File is enabled\")\n                invalid = True\n\n    vrscene_filename = cmds.getAttr(\"{}.vrscene_filename\".format(node))\n    if vrscene_filename != \"vrayscene/&lt;Scene&gt;/&lt;Layer&gt;/&lt;Layer&gt;\":\n        cls.log.error(\"Template for file name is wrong\")\n        invalid = True\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_vray_translator_settings.html#client.ayon_maya.plugins.publish.validate_vray_translator_settings.ValidateVRayTranslatorEnabled.process","title":"<code>process(context)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_vray_translator_settings.py</code> <pre><code>def process(self, context):\n    \"\"\"Plugin entry point.\"\"\"\n    if not self.is_active(context.data):\n        return\n    # Workaround bug pyblish-base#250\n    if not context_plugin_should_run(self, context):\n        return\n\n    invalid = self.get_invalid(context)\n    if invalid:\n        raise PublishValidationError(\n            message=\"Found invalid VRay Translator settings\",\n            title=self.label\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_vray_translator_settings.html#client.ayon_maya.plugins.publish.validate_vray_translator_settings.ValidateVRayTranslatorEnabled.repair","title":"<code>repair(context)</code>  <code>classmethod</code>","text":"<p>Repair invalid settings.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_vray_translator_settings.py</code> <pre><code>@classmethod\ndef repair(cls, context):\n    \"\"\"Repair invalid settings.\"\"\"\n    vray_settings = cmds.ls(type=\"VRaySettingsNode\")\n    if not vray_settings:\n        node = cmds.createNode(\"VRaySettingsNode\")\n    else:\n        node = vray_settings[0]\n\n    cmds.setAttr(\"{}.vrscene_render_on\".format(node), False)\n    cmds.setAttr(\"{}.vrscene_on\".format(node), True)\n    for instance in context:\n        if \"vrayscene\" not in instance.data.get(\"families\"):\n            continue\n\n        if instance.data.get(\"vraySceneMultipleFiles\"):\n            cmds.setAttr(\"{}.misc_eachFrameInFile\".format(node), True)\n        else:\n            cmds.setAttr(\"{}.misc_eachFrameInFile\".format(node), False)\n    cmds.setAttr(\"{}.vrscene_filename\".format(node),\n                 \"vrayscene/&lt;Scene&gt;/&lt;Layer&gt;/&lt;Layer&gt;\",\n                 type=\"string\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_vrayproxy.html","title":"validate_vrayproxy","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_vrayproxy_members.html","title":"validate_vrayproxy_members","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_vrayproxy_members.html#client.ayon_maya.plugins.publish.validate_vrayproxy_members.ValidateVrayProxyMembers","title":"<code>ValidateVrayProxyMembers</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate whether the V-Ray Proxy instance has shape members</p> Source code in <code>client/ayon_maya/plugins/publish/validate_vrayproxy_members.py</code> <pre><code>class ValidateVrayProxyMembers(plugin.MayaInstancePlugin,\n                               OptionalPyblishPluginMixin):\n    \"\"\"Validate whether the V-Ray Proxy instance has shape members\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = 'VRay Proxy Members'\n    families = ['vrayproxy']\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n\n        if invalid:\n            raise PublishValidationError(\"'%s' is invalid VRay Proxy for \"\n                               \"export!\" % instance.name)\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        shapes = cmds.ls(instance,\n                         shapes=True,\n                         noIntermediate=True,\n                         long=True)\n\n        if not shapes:\n            cls.log.error(\"'%s' contains no shapes.\" % instance.name)\n\n            # Return the instance itself\n            return [instance.name]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_xgen.html","title":"validate_xgen","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_xgen.html#client.ayon_maya.plugins.publish.validate_xgen.ValidateXgen","title":"<code>ValidateXgen</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code></p> <p>Validate Xgen data.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_xgen.py</code> <pre><code>class ValidateXgen(plugin.MayaInstancePlugin):\n    \"\"\"Validate Xgen data.\"\"\"\n\n    label = \"Validate Xgen\"\n    order = pyblish.api.ValidatorOrder\n    families = [\"xgen\"]\n\n    def process(self, instance):\n        set_members = instance.data.get(\"setMembers\")\n\n        # Only 1 collection/node per instance.\n        if len(set_members) != 1:\n            raise PublishValidationError(\n                \"Only one collection per instance is allowed.\"\n                \" Found:\\n{}\".format(set_members)\n            )\n\n        # Only xgen palette node is allowed.\n        node_type = cmds.nodeType(set_members[0])\n        if node_type != \"xgmPalette\":\n            raise PublishValidationError(\n                \"Only node of type \\\"xgmPalette\\\" are allowed. Referred to as\"\n                \" \\\"collection\\\" in the Maya UI.\"\n                \" Node type found: {}\".format(node_type)\n            )\n\n        # Can't have inactive modifiers in collection cause Xgen will try and\n        # look for them when loading.\n        palette = instance.data[\"xgmPalette\"].replace(\"|\", \"\")\n        inactive_modifiers = {}\n        for description in instance.data[\"xgmDescriptions\"]:\n            description = description.split(\"|\")[-2]\n            modifier_names = xgenm.fxModules(palette, description)\n            for name in modifier_names:\n                attr = xgenm.getAttr(\"active\", palette, description, name)\n                # Attribute value are lowercase strings of false/true.\n                if attr == \"false\":\n                    try:\n                        inactive_modifiers[description].append(name)\n                    except KeyError:\n                        inactive_modifiers[description] = [name]\n\n        if inactive_modifiers:\n            raise PublishValidationError(\n                \"There are inactive modifiers on the collection. \"\n                \"Please delete these:\\n{}\".format(\n                    json.dumps(inactive_modifiers, indent=4, sort_keys=True)\n                )\n            )\n\n        # We need a namespace else there will be a naming conflict when\n        # extracting because of stripping namespaces and parenting to world.\n        node_names = [instance.data[\"xgmPalette\"]]\n        node_names.extend(instance.data[\"xgenConnections\"])\n        non_namespaced_nodes = [n for n in node_names if \":\" not in n]\n        if non_namespaced_nodes:\n            raise PublishValidationError(\n                \"Could not find namespace on {}. Namespace is required for\"\n                \" xgen publishing.\".format(non_namespaced_nodes)\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_yeti_renderscript_callbacks.html","title":"validate_yeti_renderscript_callbacks","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_yeti_renderscript_callbacks.html#client.ayon_maya.plugins.publish.validate_yeti_renderscript_callbacks.ValidateYetiRenderScriptCallbacks","title":"<code>ValidateYetiRenderScriptCallbacks</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Check if the render script callbacks will be used during the rendering</p> <p>In order to ensure the render tasks are executed properly we need to check if the pre and post render callbacks are actually used.</p> For example <p>Yeti is not loaded but its callback scripts are still set in the render settings. This will cause an error because Maya tries to find and execute the callbacks.</p> Developer note <p>The pre and post render callbacks cannot be overridden</p> Source code in <code>client/ayon_maya/plugins/publish/validate_yeti_renderscript_callbacks.py</code> <pre><code>class ValidateYetiRenderScriptCallbacks(plugin.MayaInstancePlugin,\n                                        OptionalPyblishPluginMixin):\n    \"\"\"Check if the render script callbacks will be used during the rendering\n\n    In order to ensure the render tasks are executed properly we need to check\n    if the pre and post render callbacks are actually used.\n\n    For example:\n        Yeti is not loaded but its callback scripts are still set in the\n        render settings. This will cause an error because Maya tries to find\n        and execute the callbacks.\n\n    Developer note:\n         The pre and post render callbacks cannot be overridden\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    label = \"Yeti Render Script Callbacks\"\n    families = [\"renderlayer\"]\n    optional = False\n\n    # Settings per renderer\n    callbacks = {\n        \"vray\": {\n            \"pre\": \"catch(`pgYetiVRayPreRender`)\",\n            \"post\": \"catch(`pgYetiVRayPostRender`)\"\n        },\n        \"arnold\": {\n            \"pre\": \"pgYetiPreRender\"\n        }\n    }\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                f\"Invalid render callbacks found for '{instance.name}'.\")\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        yeti_loaded = cmds.pluginInfo(\"pgYetiMaya\", query=True, loaded=True)\n\n        if not yeti_loaded and not cmds.ls(type=\"pgYetiMaya\"):\n            # The yeti plug-in is available and loaded so at\n            # this point we don't really care whether the scene\n            # has any yeti callback set or not since if the callback\n            # is there it wouldn't error and if it weren't then\n            # nothing happens because there are no yeti nodes.\n            cls.log.debug(\n                \"Yeti is loaded but no yeti nodes were found. \"\n                \"Callback validation skipped..\"\n            )\n            return False\n\n        renderer = instance.data[\"renderer\"]\n        if renderer == \"redshift\":\n            cls.log.debug(\"Redshift ignores any pre and post render callbacks\")\n            return False\n\n        callback_lookup = cls.callbacks.get(renderer, {})\n        if not callback_lookup:\n            cls.log.warning(\"Renderer '%s' is not supported in this plugin\"\n                            % renderer)\n            return False\n\n        pre_mel = cmds.getAttr(\"defaultRenderGlobals.preMel\") or \"\"\n        post_mel = cmds.getAttr(\"defaultRenderGlobals.postMel\") or \"\"\n\n        if pre_mel.strip():\n            cls.log.debug(\"Found pre mel: `%s`\" % pre_mel)\n\n        if post_mel.strip():\n            cls.log.debug(\"Found post mel: `%s`\" % post_mel)\n\n        # Strip callbacks and turn into a set for quick lookup\n        pre_callbacks = {cmd.strip() for cmd in pre_mel.split(\";\")}\n        post_callbacks = {cmd.strip() for cmd in post_mel.split(\";\")}\n\n        pre_script = callback_lookup.get(\"pre\", \"\")\n        post_script = callback_lookup.get(\"post\", \"\")\n\n        # If Yeti is not loaded\n        invalid = False\n        if not yeti_loaded:\n            if pre_script and pre_script in pre_callbacks:\n                cls.log.error(\"Found pre render callback '%s' which is not \"\n                              \"uses!\" % pre_script)\n                invalid = True\n\n            if post_script and post_script in post_callbacks:\n                cls.log.error(\"Found post render callback '%s which is \"\n                              \"not used!\" % post_script)\n                invalid = True\n\n        # If Yeti is loaded\n        else:\n            if pre_script and pre_script not in pre_callbacks:\n                cls.log.error(\n                    \"Could not find required pre render callback \"\n                    \"`%s`\" % pre_script)\n                invalid = True\n\n            if post_script and post_script not in post_callbacks:\n                cls.log.error(\n                    \"Could not find required post render callback\"\n                    \" `%s`\" % post_script)\n                invalid = True\n\n        return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_yeti_rig_cache_state.html","title":"validate_yeti_rig_cache_state","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_yeti_rig_cache_state.html#client.ayon_maya.plugins.publish.validate_yeti_rig_cache_state.ValidateYetiRigCacheState","title":"<code>ValidateYetiRigCacheState</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate the I/O attributes of the node</p> Every pgYetiMaya cache node per instance should have <ol> <li>Input Mode is set to <code>None</code></li> <li>Input Cache File Name is empty</li> </ol> Source code in <code>client/ayon_maya/plugins/publish/validate_yeti_rig_cache_state.py</code> <pre><code>class ValidateYetiRigCacheState(plugin.MayaInstancePlugin,\n                                OptionalPyblishPluginMixin):\n    \"\"\"Validate the I/O attributes of the node\n\n    Every pgYetiMaya cache node per instance should have:\n        1. Input Mode is set to `None`\n        2. Input Cache File Name is empty\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Yeti Rig Cache State\"\n    families = [\"yetiRig\"]\n    actions = [RepairAction,\n               ayon_maya.api.action.SelectInvalidAction]\n    optional = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Nodes have incorrect I/O settings\",\n                description=inspect.getdoc(self)\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        invalid = []\n\n        yeti_nodes = cmds.ls(instance, type=\"pgYetiMaya\")\n        for node in yeti_nodes:\n            # Check reading state\n            state = cmds.getAttr(\"%s.fileMode\" % node)\n            if state == 1:\n                cls.log.error(\"Node `%s` is set to mode `cache`\" % node)\n                invalid.append(node)\n                continue\n\n            # Check reading state\n            has_cache = cmds.getAttr(\"%s.cacheFileName\" % node)\n            if has_cache:\n                cls.log.error(\"Node `%s` has a cache file set\" % node)\n                invalid.append(node)\n                continue\n\n        return invalid\n\n    @classmethod\n    def repair(cls, instance):\n        \"\"\"Repair all errors\"\"\"\n\n        # Create set to ensure all nodes only pass once\n        invalid = cls.get_invalid(instance)\n        for node in invalid:\n            cmds.setAttr(\"%s.fileMode\" % node, 0)\n            cmds.setAttr(\"%s.cacheFileName\" % node, \"\", type=\"string\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_yeti_rig_cache_state.html#client.ayon_maya.plugins.publish.validate_yeti_rig_cache_state.ValidateYetiRigCacheState.repair","title":"<code>repair(instance)</code>  <code>classmethod</code>","text":"<p>Repair all errors</p> Source code in <code>client/ayon_maya/plugins/publish/validate_yeti_rig_cache_state.py</code> <pre><code>@classmethod\ndef repair(cls, instance):\n    \"\"\"Repair all errors\"\"\"\n\n    # Create set to ensure all nodes only pass once\n    invalid = cls.get_invalid(instance)\n    for node in invalid:\n        cmds.setAttr(\"%s.fileMode\" % node, 0)\n        cmds.setAttr(\"%s.cacheFileName\" % node, \"\", type=\"string\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_yeti_rig_input_in_instance.html","title":"validate_yeti_rig_input_in_instance","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_yeti_rig_input_in_instance.html#client.ayon_maya.plugins.publish.validate_yeti_rig_input_in_instance.ValidateYetiRigInputShapesInInstance","title":"<code>ValidateYetiRigInputShapesInInstance</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate if all input nodes are part of the instance's hierarchy</p> Source code in <code>client/ayon_maya/plugins/publish/validate_yeti_rig_input_in_instance.py</code> <pre><code>class ValidateYetiRigInputShapesInInstance(plugin.MayaInstancePlugin,\n                                           OptionalPyblishPluginMixin):\n    \"\"\"Validate if all input nodes are part of the instance's hierarchy\"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"yetiRig\"]\n    label = \"Yeti Rig Input Shapes In Instance\"\n    actions = [ayon_maya.api.action.SelectInvalidAction]\n    optional = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\"Yeti Rig has invalid input meshes\")\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        input_set = next((i for i in instance if i == \"input_SET\"), None)\n        assert input_set, \"Current %s instance has no `input_SET`\" % instance\n\n        # Get all children, we do not care about intermediates\n        input_nodes = cmds.ls(cmds.sets(input_set, query=True), long=True)\n        dag = cmds.ls(input_nodes, dag=True, long=True)\n        shapes = cmds.ls(dag, long=True, shapes=True, noIntermediate=True)\n\n        # Allow publish without input meshes.\n        if not shapes:\n            cls.log.debug(\"Found no input meshes for %s, skipping ...\"\n                          % instance)\n            return []\n\n        # check if input node is part of groomRig instance\n        instance_lookup = set(instance[:])\n        invalid = [s for s in shapes if s not in instance_lookup]\n\n        return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_yeti_rig_settings.html","title":"validate_yeti_rig_settings","text":""},{"location":"autoapi/client/ayon_maya/plugins/publish/validate_yeti_rig_settings.html#client.ayon_maya.plugins.publish.validate_yeti_rig_settings.ValidateYetiRigSettings","title":"<code>ValidateYetiRigSettings</code>","text":"<p>               Bases: <code>MayaInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate Yeti Rig Settings have collected input connections.</p> <p>The input connections are collected for the nodes in the <code>input_SET</code>. When no input connections are found a warning is logged but it is allowed to pass validation.</p> Source code in <code>client/ayon_maya/plugins/publish/validate_yeti_rig_settings.py</code> <pre><code>class ValidateYetiRigSettings(plugin.MayaInstancePlugin,\n                              OptionalPyblishPluginMixin):\n    \"\"\"Validate Yeti Rig Settings have collected input connections.\n\n    The input connections are collected for the nodes in the `input_SET`.\n    When no input connections are found a warning is logged but it is allowed\n    to pass validation.\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Yeti Rig Settings\"\n    families = [\"yetiRig\"]\n    optional = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                (\"Detected invalid Yeti Rig data. (See log) \"\n                 \"Tip: Save the scene\"))\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        rigsettings = instance.data.get(\"rigsettings\", None)\n        if rigsettings is None:\n            cls.log.error(\"MAJOR ERROR: No rig settings found!\")\n            return True\n\n        # Get inputs\n        inputs = rigsettings.get(\"inputs\", [])\n        if not inputs:\n            # Empty rig settings dictionary\n            cls.log.warning(\"No rig inputs found. This can happen when \"\n                            \"the rig has no inputs from outside the rig.\")\n            return False\n\n        for input in inputs:\n            source_id = input[\"sourceID\"]\n            if source_id is None:\n                cls.log.error(\"Discovered source with 'None' as ID, please \"\n                              \"check if the input shape has a cbId\")\n                return True\n\n            destination_id = input[\"destinationID\"]\n            if destination_id is None:\n                cls.log.error(\"Discovered None as destination ID value\")\n                return True\n\n        return False\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/workfile_build/index.html","title":"workfile_build","text":""},{"location":"autoapi/client/ayon_maya/plugins/workfile_build/assign_look_placeholder.html","title":"assign_look_placeholder","text":""},{"location":"autoapi/client/ayon_maya/plugins/workfile_build/assign_look_placeholder.html#client.ayon_maya.plugins.workfile_build.assign_look_placeholder.AssignLookPlaceholderPlugin","title":"<code>AssignLookPlaceholderPlugin</code>","text":"<p>               Bases: <code>MayaPlaceholderPlugin</code></p> <p>Assign a look product to members of the placeholder set.</p> <p>Creates an objectSet. Any members will get the look assigned with the given product name if it exists.</p> <p>Any containers loaded from other template placeholders will get the look assigned to their loaded containers.</p> Source code in <code>client/ayon_maya/plugins/workfile_build/assign_look_placeholder.py</code> <pre><code>class AssignLookPlaceholderPlugin(MayaPlaceholderPlugin):\n    \"\"\"Assign a look product to members of the placeholder set.\n\n    Creates an objectSet. Any members will get the look assigned with the given\n    product name if it exists.\n\n    Any containers loaded from other template placeholders will get the look\n    assigned to their loaded containers.\n\n    \"\"\"\n\n    identifier = \"maya.assignlook\"\n    label = \"Assign Look\"\n\n    def get_placeholder_options(self, options=None):\n        options = options or {}\n        return [\n            UISeparatorDef(),\n            UILabelDef(label=\"&lt;b&gt;Description&lt;/b&gt;\"),\n            UISeparatorDef(),\n            UILabelDef(\n                label=(\n                    \"Creates an objectSet. Any members will get the look\\n\"\n                    \"assigned with the given product name if it exists.\\n\\n\"\n                    \"Any containers loaded from other template placeholders\\n\"\n                    \"will get the look assigned to their loaded containers.\"\n                    \"\"\n                )\n            ),\n            UISeparatorDef(),\n            UILabelDef(label=\"&lt;b&gt;Settings&lt;/b&gt;\"),\n            UISeparatorDef(),\n            TextDef(\n                \"product_name\",\n                label=\"Product Name\",\n                tooltip=\"Look product to assign to containers loaded by \"\n                        \"contained placeholders\",\n                multiline=False,\n                default=options.get(\"product_name\", \"lookMain\")\n            ),\n            BoolDef(\n                \"recurse\",\n                label=\"Recursive\",\n                tooltip=\"Assign look also to potential sub containers / \"\n                        \"placeholders loaded from the load placeholder.\\n\"\n                        \"This will make sure that any placeholder contained \"\n                        \"that itself loaded new geometry will recursively \"\n                        \"also get the look assignment triggered.\",\n                default=options.get(\"recurse\", False)\n            ),\n        ]\n\n    def create_placeholder(self, placeholder_data):\n        placeholder_data[\"plugin_identifier\"] = self.identifier\n\n        # Create maya objectSet on selection\n        selection = cmds.ls(selection=True, long=True)\n        product_name = placeholder_data[\"product_name\"]\n        name = \"AssignLook_{}\".format(product_name)\n        node = cmds.sets(selection, name=name)\n\n        self.imprint(node, placeholder_data)\n\n    def populate_placeholder(self, placeholder):\n        callback = weakref_partial(self.assign_look, placeholder)\n        self.builder.add_on_depth_processed_callback(\n            callback, order=placeholder.order)\n\n        # If placeholder should be deleted, delete it after finish\n        if not placeholder.data.get(\"keep_placeholder\", True):\n            delete_callback = weakref_partial(self.delete_placeholder,\n                                              placeholder)\n            self.builder.add_on_finished_callback(\n                delete_callback, order=placeholder.order)\n\n    def assign_look(self, placeholder):\n        if placeholder.data.get(\"finished\", False):\n            # If not recursive we mark it finished after the first depth\n            # iteration - otherwise run it again to find any new members\n            return\n\n        product_name = placeholder.data[\"product_name\"]\n        assert product_name, \"Must have defined look product name to assign\"\n\n        members = cmds.ls(\n            cmds.sets(placeholder.scene_identifier, query=True), long=True\n        )\n        if not members:\n            return\n\n        # Allow any children of members in the set to get assignments,\n        # e.g. when a group is included there. Whenever a load placeholder\n        # finishes it also adds loaded content into the object set the\n        # placeholder was in, so this will also assign to loaded content\n        # during this build.\n        assign_nodes = set(members)\n        assign_nodes.update(get_all_children(members))\n\n        processed = placeholder.data.setdefault(\"processed\", set())\n        assign_nodes.difference_update(processed)\n        processed.update(assign_nodes)\n\n        if assign_nodes:\n            self.log.info(\n                \"Assigning look {} for placeholder: {}\".format(product_name,\n                                                               placeholder)\n            )\n            assign_nodes = list(assign_nodes)\n            assign_look(assign_nodes, product_name=product_name)\n\n        if not placeholder.data.get(\"recurse\", False):\n            placeholder.data[\"finished\"] = True\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/workfile_build/load_placeholder.html","title":"load_placeholder","text":""},{"location":"autoapi/client/ayon_maya/plugins/workfile_build/load_placeholder.html#client.ayon_maya.plugins.workfile_build.load_placeholder.MayaPlaceholderLoadPlugin","title":"<code>MayaPlaceholderLoadPlugin</code>","text":"<p>               Bases: <code>MayaPlaceholderPlugin</code>, <code>PlaceholderLoadMixin</code></p> Source code in <code>client/ayon_maya/plugins/workfile_build/load_placeholder.py</code> <pre><code>class MayaPlaceholderLoadPlugin(MayaPlaceholderPlugin, PlaceholderLoadMixin):\n    identifier = \"maya.load\"\n    label = \"Maya load\"\n\n    item_class = LoadPlaceholderItem\n\n    def _create_placeholder_name(self, placeholder_data):\n\n        # Split builder type: context_assets, linked_assets, all_assets\n        prefix, suffix = placeholder_data[\"builder_type\"].split(\"_\", 1)\n        parts = [prefix]\n\n        # add family if any\n        placeholder_product_type = placeholder_data.get(\"product_type\")\n        if placeholder_product_type is None:\n            placeholder_product_type = placeholder_data.get(\"family\")\n\n        if placeholder_product_type:\n            parts.append(placeholder_product_type)\n\n        # add loader arguments if any\n        loader_args = placeholder_data[\"loader_args\"]\n        if loader_args:\n            loader_args = eval(loader_args)\n            for value in loader_args.values():\n                parts.append(str(value))\n\n        parts.append(suffix)\n        placeholder_name = \"_\".join(parts)\n\n        return placeholder_name.capitalize()\n\n    def _get_loaded_repre_ids(self):\n        loaded_representation_ids = self.builder.get_shared_populate_data(\n            \"loaded_representation_ids\"\n        )\n        if loaded_representation_ids is None:\n            try:\n                containers = cmds.sets(\"AVALON_CONTAINERS\", q=True)\n            except ValueError:\n                containers = []\n\n            loaded_representation_ids = {\n                cmds.getAttr(container + \".representation\")\n                for container in containers\n            }\n            self.builder.set_shared_populate_data(\n                \"loaded_representation_ids\", loaded_representation_ids\n            )\n        return loaded_representation_ids\n\n    def populate_placeholder(self, placeholder):\n        self.populate_load_placeholder(placeholder)\n\n    def repopulate_placeholder(self, placeholder):\n        repre_ids = self._get_loaded_repre_ids()\n        self.populate_load_placeholder(placeholder, repre_ids)\n\n    def get_placeholder_options(self, options=None):\n        return self.get_load_plugin_options(options)\n\n    def load_succeed(self, placeholder, container):\n        self._parent_in_hierarchy(placeholder, container)\n\n    def _parent_in_hierarchy(self, placeholder, container):\n        \"\"\"Parent loaded container to placeholder's parent.\n\n        ie : Set loaded content as placeholder's sibling\n\n        Args:\n            container (str): Placeholder loaded containers\n        \"\"\"\n\n        if not container:\n            return\n\n        # TODO: This currently returns only a single root but a loaded scene\n        #   could technically load more than a single root\n        container_root = get_container_transforms(container, root=True)\n\n        # Bugfix: The get_container_transforms does not recognize the load\n        # reference group currently\n        # TODO: Remove this when it does\n        parent = get_node_parent(container_root)\n        if parent:\n            container_root = parent\n        roots = [container_root]\n\n        # Add the loaded roots to the holding sets if they exist\n        holding_sets = cmds.listSets(object=placeholder.scene_identifier) or []\n        for holding_set in holding_sets:\n            cmds.sets(roots, forceElement=holding_set)\n\n        # Parent the roots to the place of the placeholder locator and match\n        # its matrix\n        placeholder_form = cmds.xform(\n            placeholder.scene_identifier,\n            query=True,\n            matrix=True,\n            worldSpace=True\n        )\n        scene_parent = get_node_parent(placeholder.scene_identifier)\n        for node in set(roots):\n            cmds.xform(node, matrix=placeholder_form, worldSpace=True)\n\n            if scene_parent != get_node_parent(node):\n                if scene_parent:\n                    node = cmds.parent(node, scene_parent)[0]\n                else:\n                    node = cmds.parent(node, world=True)[0]\n\n            # Move loaded nodes in index order next to their placeholder node\n            cmds.reorder(node, back=True)\n            index = get_node_index_under_parent(placeholder.scene_identifier)\n            cmds.reorder(node, front=True)\n            cmds.reorder(node, relative=index + 1)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/workfile_build/script_placeholder.html","title":"script_placeholder","text":""},{"location":"autoapi/client/ayon_maya/plugins/workfile_build/script_placeholder.html#client.ayon_maya.plugins.workfile_build.script_placeholder.MayaPlaceholderScriptPlugin","title":"<code>MayaPlaceholderScriptPlugin</code>","text":"<p>               Bases: <code>MayaPlaceholderPlugin</code></p> <p>Execute a script at the given <code>order</code> during workfile build.</p> <p>This is a very low-level placeholder to run Python scripts at a given point in time during the workfile template build.</p> <p>It can create either a locator or an objectSet as placeholder node. It defaults to an objectSet, since allowing to run on e.g. other placeholder node members can be useful, e.g. using:</p> <p>members = cmds.sets(placeholder.scene_identifier, query=True)</p> Source code in <code>client/ayon_maya/plugins/workfile_build/script_placeholder.py</code> <pre><code>class MayaPlaceholderScriptPlugin(MayaPlaceholderPlugin):\n    \"\"\"Execute a script at the given `order` during workfile build.\n\n    This is a very low-level placeholder to run Python scripts at a given\n    point in time during the workfile template build.\n\n    It can create either a locator or an objectSet as placeholder node.\n    It defaults to an objectSet, since allowing to run on e.g. other\n    placeholder node members can be useful, e.g. using:\n\n    &gt;&gt;&gt; members = cmds.sets(placeholder.scene_identifier, query=True)\n\n    \"\"\"\n\n    identifier = \"maya.runscript\"\n    label = \"Run Python Script\"\n\n    use_selection_as_parent = False\n\n    def get_placeholder_options(self, options=None):\n        options = options or {}\n        return [\n            NumberDef(\n                \"order\",\n                label=\"Order\",\n                default=options.get(\"order\") or 0,\n                decimals=0,\n                minimum=0,\n                maximum=999,\n                tooltip=(\n                    \"Order\"\n                    \"\\nOrder defines asset loading priority (0 to 999)\"\n                    \"\\nPriority rule is : \\\"lowest is first to load\\\".\"\n                )\n            ),\n            TextDef(\n                \"prepare_script\",\n                label=\"Run at\\nprepare\",\n                tooltip=\"Run before populate at prepare order\",\n                multiline=True,\n                default=options.get(\"prepare_script\", \"\")\n            ),\n            TextDef(\n                \"populate_script\",\n                label=\"Run at\\npopulate\",\n                tooltip=\"Run script at populate node order&lt;br&gt;\"\n                        \"This is the &lt;b&gt;default&lt;/b&gt; behavior\",\n                multiline=True,\n                default=options.get(\"populate_script\", EXAMPLE_SCRIPT)\n            ),\n            TextDef(\n                \"depth_processed_script\",\n                label=\"Run after\\ndepth\\niteration\",\n                tooltip=\"Run script after every build depth iteration\",\n                multiline=True,\n                default=options.get(\"depth_processed_script\", \"\")\n            ),\n            TextDef(\n                \"finished_script\",\n                label=\"Run after\\nbuild\",\n                tooltip=(\n                    \"Run script at build finished.&lt;br&gt;\"\n                    \"&lt;b&gt;Note&lt;/b&gt;: this even runs if other placeholders had \"\n                    \"errors during the build\"\n                ),\n                multiline=True,\n                default=options.get(\"finished_script\", \"\")\n            ),\n            EnumDef(\n                \"create_nodetype\",\n                label=\"Nodetype\",\n                items={\n                    \"spaceLocator\": \"Locator\",\n                    \"objectSet\": \"ObjectSet\"\n                },\n                tooltip=(\n                    \"The placeholder's node type to be created.&lt;br&gt;\"\n                    \"&lt;b&gt;Note&lt;/b&gt; this only works on create, not on update\"\n                ),\n                default=options.get(\"create_nodetype\", \"objectSet\")\n            ),\n        ]\n\n    def create_placeholder(self, placeholder_data):\n        nodetype = placeholder_data.get(\"create_nodetype\", \"objectSet\")\n\n        if nodetype == \"spaceLocator\":\n            super(MayaPlaceholderScriptPlugin, self).create_placeholder(\n                placeholder_data\n            )\n        elif nodetype == \"objectSet\":\n            placeholder_data[\"plugin_identifier\"] = self.identifier\n\n            # Create maya objectSet on selection\n            selection = cmds.ls(selection=True, long=True)\n            name = self._create_placeholder_name(placeholder_data)\n            node = cmds.sets(selection, name=name)\n\n            self.imprint(node, placeholder_data)\n\n    def prepare_placeholders(self, placeholders):\n        super(MayaPlaceholderScriptPlugin, self).prepare_placeholders(\n            placeholders\n        )\n        for placeholder in placeholders:\n            prepare_script = placeholder.data.get(\"prepare_script\")\n            if not prepare_script:\n                continue\n\n            self.run_script(placeholder, prepare_script)\n\n    def populate_placeholder(self, placeholder):\n\n        populate_script = placeholder.data.get(\"populate_script\")\n        depth_script = placeholder.data.get(\"depth_processed_script\")\n        finished_script = placeholder.data.get(\"finished_script\")\n\n        # Run now\n        if populate_script:\n            self.run_script(placeholder, populate_script)\n\n        if not any([depth_script, finished_script]):\n            # No callback scripts to run\n            if not placeholder.data.get(\"keep_placeholder\", True):\n                self.delete_placeholder(placeholder)\n            return\n\n        # Run at each depth processed\n        if depth_script:\n            callback = weakref_partial(\n                self.run_script, placeholder, depth_script)\n            self.builder.add_on_depth_processed_callback(\n                callback, order=placeholder.order)\n\n        # Run at build finish\n        if finished_script:\n            callback = weakref_partial(\n                self.run_script, placeholder, finished_script)\n            self.builder.add_on_finished_callback(\n                callback, order=placeholder.order)\n\n        # If placeholder should be deleted, delete it after finish so\n        # the scripts have access to it up to the last run\n        if not placeholder.data.get(\"keep_placeholder\", True):\n            delete_callback = weakref_partial(\n                self.delete_placeholder, placeholder)\n            self.builder.add_on_finished_callback(\n                delete_callback, order=placeholder.order + 1)\n\n    def run_script(self, placeholder, script, event=None):\n        \"\"\"Run script\n\n        Even though `placeholder` is an unused arguments by exposing it as\n        an input argument it means it makes it available through\n        globals()/locals() in the `exec` call, giving the script access\n        to the placeholder.\n\n        For example:\n        &gt;&gt;&gt; node = placeholder.scene_identifier\n\n        In the case the script is running at a callback level (not during\n        populate) then it has access to the `event` as well, otherwise the\n        value is None if it runs during `populate_placeholder` directly.\n\n        For example adding this as the callback script:\n        &gt;&gt;&gt; if event is not None:\n        &gt;&gt;&gt;     if event.topic == \"on_depth_processed\":\n        &gt;&gt;&gt;         print(f\"Processed depth: {event.get('depth')}\")\n        &gt;&gt;&gt;     elif event.topic == \"on_finished\":\n        &gt;&gt;&gt;         print(\"Build finished.\")\n\n        \"\"\"\n        self.log.debug(f\"Running script at event: {event}\")\n        exec(script, locals())\n</code></pre>"},{"location":"autoapi/client/ayon_maya/plugins/workfile_build/script_placeholder.html#client.ayon_maya.plugins.workfile_build.script_placeholder.MayaPlaceholderScriptPlugin.run_script","title":"<code>run_script(placeholder, script, event=None)</code>","text":"<p>Run script</p> <p>Even though <code>placeholder</code> is an unused arguments by exposing it as an input argument it means it makes it available through globals()/locals() in the <code>exec</code> call, giving the script access to the placeholder.</p> <p>For example:</p> <p>node = placeholder.scene_identifier</p> <p>In the case the script is running at a callback level (not during populate) then it has access to the <code>event</code> as well, otherwise the value is None if it runs during <code>populate_placeholder</code> directly.</p> <p>For example adding this as the callback script:</p> <p>if event is not None:     if event.topic == \"on_depth_processed\":         print(f\"Processed depth: {event.get('depth')}\")     elif event.topic == \"on_finished\":         print(\"Build finished.\")</p> Source code in <code>client/ayon_maya/plugins/workfile_build/script_placeholder.py</code> <pre><code>def run_script(self, placeholder, script, event=None):\n    \"\"\"Run script\n\n    Even though `placeholder` is an unused arguments by exposing it as\n    an input argument it means it makes it available through\n    globals()/locals() in the `exec` call, giving the script access\n    to the placeholder.\n\n    For example:\n    &gt;&gt;&gt; node = placeholder.scene_identifier\n\n    In the case the script is running at a callback level (not during\n    populate) then it has access to the `event` as well, otherwise the\n    value is None if it runs during `populate_placeholder` directly.\n\n    For example adding this as the callback script:\n    &gt;&gt;&gt; if event is not None:\n    &gt;&gt;&gt;     if event.topic == \"on_depth_processed\":\n    &gt;&gt;&gt;         print(f\"Processed depth: {event.get('depth')}\")\n    &gt;&gt;&gt;     elif event.topic == \"on_finished\":\n    &gt;&gt;&gt;         print(\"Build finished.\")\n\n    \"\"\"\n    self.log.debug(f\"Running script at event: {event}\")\n    exec(script, locals())\n</code></pre>"},{"location":"autoapi/client/ayon_maya/startup/index.html","title":"startup","text":""},{"location":"autoapi/client/ayon_maya/startup/userSetup.html","title":"userSetup","text":""},{"location":"autoapi/client/ayon_maya/tools/index.html","title":"tools","text":""},{"location":"autoapi/client/ayon_maya/tools/index.html#client.ayon_maya.tools.get_look_assigner_tool","title":"<code>get_look_assigner_tool(parent)</code>","text":"<p>Create, cache and return look assigner tool window.</p> Source code in <code>client/ayon_maya/tools/__init__.py</code> <pre><code>def get_look_assigner_tool(parent):\n    \"\"\"Create, cache and return look assigner tool window.\"\"\"\n    if MayaToolsSingleton._look_assigner is None:\n        from .mayalookassigner import MayaLookAssignerWindow\n        mayalookassigner_window = MayaLookAssignerWindow(parent)\n        MayaToolsSingleton._look_assigner = mayalookassigner_window\n    return MayaToolsSingleton._look_assigner\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/index.html#client.ayon_maya.tools.show_look_assigner","title":"<code>show_look_assigner(parent=None)</code>","text":"<p>Look manager is Maya specific tool for look management.</p> Source code in <code>client/ayon_maya/tools/__init__.py</code> <pre><code>def show_look_assigner(parent=None):\n    \"\"\"Look manager is Maya specific tool for look management.\"\"\"\n\n    with qt_app_context():\n        look_assigner_tool = get_look_assigner_tool(parent)\n        look_assigner_tool.show()\n\n        # Pull window to the front.\n        look_assigner_tool.raise_()\n        look_assigner_tool.activateWindow()\n        look_assigner_tool.showNormal()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/index.html","title":"mayalookassigner","text":""},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/index.html#client.ayon_maya.tools.mayalookassigner.MayaLookAssignerWindow","title":"<code>MayaLookAssignerWindow</code>","text":"<p>               Bases: <code>QWidget</code></p> Source code in <code>client/ayon_maya/tools/mayalookassigner/app.py</code> <pre><code>class MayaLookAssignerWindow(QtWidgets.QWidget):\n\n    def __init__(self, parent=None):\n        super(MayaLookAssignerWindow, self).__init__(parent=parent)\n\n        self.log = logging.getLogger(__name__)\n\n        # Store callback references\n        self._callbacks = []\n        self._connections_set_up = False\n\n        filename = get_workfile()\n\n        self.setObjectName(\"lookManager\")\n        self.setWindowTitle(\"Look Manager 1.4.0 - [{}]\".format(filename))\n        self.setWindowFlags(QtCore.Qt.Window)\n        self.setParent(parent)\n\n        self.resize(750, 500)\n\n        self.setup_ui()\n\n        # Force refresh check on initialization\n        self._on_renderlayer_switch()\n\n    def setup_ui(self):\n        \"\"\"Build the UI\"\"\"\n\n        main_splitter = QtWidgets.QSplitter(self)\n\n        # Assets (left)\n        asset_outliner = AssetOutliner(main_splitter)\n\n        # Looks (right)\n        looks_widget = QtWidgets.QWidget(main_splitter)\n\n        look_outliner = LookOutliner(looks_widget)  # Database look overview\n\n        assign_selected = QtWidgets.QCheckBox(\n            \"Assign to selected only\", looks_widget\n        )\n        assign_selected.setToolTip(\"Whether to assign only to selected nodes \"\n                                   \"or to the full asset\")\n        remove_unused_btn = QtWidgets.QPushButton(\n            \"Remove Unused Looks\", looks_widget\n        )\n\n        looks_layout = QtWidgets.QVBoxLayout(looks_widget)\n        looks_layout.addWidget(look_outliner)\n        looks_layout.addWidget(assign_selected)\n        looks_layout.addWidget(remove_unused_btn)\n\n        main_splitter.addWidget(asset_outliner)\n        main_splitter.addWidget(looks_widget)\n        main_splitter.setSizes([350, 200])\n\n        # Footer\n        status = QtWidgets.QStatusBar(self)\n        status.setSizeGripEnabled(False)\n        status.setFixedHeight(25)\n        warn_layer = QtWidgets.QLabel(\n            \"Current Layer is not defaultRenderLayer\", self\n        )\n        warn_layer.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)\n        warn_layer.setStyleSheet(\"color: #DD5555; font-weight: bold;\")\n        warn_layer.setFixedHeight(25)\n\n        footer = QtWidgets.QHBoxLayout()\n        footer.setContentsMargins(0, 0, 0, 0)\n        footer.addWidget(status)\n        footer.addWidget(warn_layer)\n\n        # Build up widgets\n        main_layout = QtWidgets.QVBoxLayout(self)\n        main_layout.setSpacing(0)\n        main_layout.addWidget(main_splitter)\n        main_layout.addLayout(footer)\n\n        # Set column width\n        asset_outliner.view.setColumnWidth(0, 200)\n        look_outliner.view.setColumnWidth(0, 150)\n\n        asset_outliner.selection_changed.connect(\n            self.on_asset_selection_changed)\n\n        asset_outliner.refreshed.connect(\n            lambda: self.echo(\"Loaded assets..\")\n        )\n\n        look_outliner.menu_apply_action.connect(self.on_process_selected)\n        remove_unused_btn.clicked.connect(remove_unused_looks)\n\n        # Open widgets\n        self.asset_outliner = asset_outliner\n        self.look_outliner = look_outliner\n        self.status = status\n        self.warn_layer = warn_layer\n\n        # Buttons\n        self.remove_unused = remove_unused_btn\n        self.assign_selected = assign_selected\n\n        self._first_show = True\n\n    def setup_connections(self):\n        \"\"\"Connect interactive widgets with actions\"\"\"\n        if self._connections_set_up:\n            return\n\n        # Maya renderlayer switch callback\n        callback = om.MEventMessage.addEventCallback(\n            \"renderLayerManagerChange\",\n            self._on_renderlayer_switch\n        )\n        self._callbacks.append(callback)\n        self._connections_set_up = True\n\n    def remove_connection(self):\n        # Delete callbacks\n        for callback in self._callbacks:\n            om.MMessage.removeCallback(callback)\n\n        self._callbacks = []\n        self._connections_set_up = False\n\n    def showEvent(self, event):\n        self.setup_connections()\n        super(MayaLookAssignerWindow, self).showEvent(event)\n        if self._first_show:\n            self._first_show = False\n            self.setStyleSheet(style.load_stylesheet())\n\n    def closeEvent(self, event):\n        self.remove_connection()\n        super(MayaLookAssignerWindow, self).closeEvent(event)\n\n    def _on_renderlayer_switch(self, *args):\n        \"\"\"Callback that updates on Maya renderlayer switch\"\"\"\n\n        if maya.OpenMaya.MFileIO.isNewingFile():\n            # Don't perform a check during file open or file new as\n            # the renderlayers will not be in a valid state yet.\n            return\n\n        layer = cmds.editRenderLayerGlobals(query=True,\n                                            currentRenderLayer=True)\n        if layer != \"defaultRenderLayer\":\n            self.warn_layer.show()\n        else:\n            self.warn_layer.hide()\n\n    def echo(self, message):\n        self.status.showMessage(message, 1500)\n\n    def refresh(self):\n        \"\"\"Refresh the content\"\"\"\n\n        # Get all containers and information\n        self.asset_outliner.clear()\n        found_items = self.asset_outliner.get_all_assets()\n        if not found_items:\n            self.look_outliner.clear()\n\n    def on_asset_selection_changed(self):\n        \"\"\"Get selected items from asset loader and fill look outliner\"\"\"\n\n        items = self.asset_outliner.get_selected_items()\n        self.look_outliner.clear()\n        self.look_outliner.add_items(items)\n\n    def on_process_selected(self):\n        \"\"\"Process all selected looks for the selected assets\"\"\"\n\n        assets = self.asset_outliner.get_selected_items()\n        assert assets, \"No asset selected\"\n\n        # Collect the looks we want to apply (by name)\n        look_items = self.look_outliner.get_selected_items()\n        looks = {look[\"product\"] for look in look_items}\n\n        selection = self.assign_selected.isChecked()\n        asset_nodes = self.asset_outliner.get_nodes(selection=selection)\n\n        project_name = get_current_project_name()\n        start = time.time()\n        for i, (asset, item) in enumerate(asset_nodes.items()):\n\n            # Label prefix\n            prefix = \"({}/{})\".format(i + 1, len(asset_nodes))\n\n            # Assign the first matching look relevant for this asset\n            # (since assigning multiple to the same nodes makes no sense)\n            assign_look = next(\n                (\n                    product_entity\n                    for product_entity in item[\"looks\"]\n                    if product_entity[\"name\"] in looks\n                ),\n                None\n            )\n            if not assign_look:\n                self.echo(\n                    \"{} No matching selected look for {}\".format(prefix, asset)\n                )\n                continue\n\n            # Get the latest version of this asset's look product\n            version_entity = ayon_api.get_last_version_by_product_id(\n                project_name, assign_look[\"id\"], fields={\"id\"}\n            )\n\n            product_name = assign_look[\"name\"]\n            self.echo(\"{} Assigning {} to {}\\t\".format(\n                prefix, product_name, asset\n            ))\n            nodes = item[\"nodes\"]\n\n            # Assign Vray Proxy look.\n            if cmds.pluginInfo('vrayformaya', query=True, loaded=True):\n                self.echo(\"Getting vray proxy nodes ...\")\n                vray_proxies = set(cmds.ls(type=\"VRayProxy\", long=True))\n\n                for vp in vray_proxies:\n                    if vp in nodes:\n                        vrayproxy_assign_look(vp, product_name)\n\n                nodes = list(set(nodes).difference(vray_proxies))\n            else:\n                self.echo(\n                    \"Could not assign to VRayProxy because vrayformaya plugin \"\n                    \"is not loaded.\"\n                )\n\n            # Assign Arnold Standin look.\n            if cmds.pluginInfo(\"mtoa\", query=True, loaded=True):\n                types = arnold_standin.get_supported_node_types()\n                # If the current renderer is Arnold we also allow assigning\n                # to gpuCache nodes. If not, then we skip it because Arnold may\n                # be loaded even if unused as renderer in current project.\n                renderer = cmds.getAttr(\"defaultRenderGlobals.currentRenderer\")\n                if renderer != \"arnold\":\n                    types.discard(\"gpuCache\")\n\n                if types:\n                    arnold_standins = cmds.ls(\n                        nodes, type=list(types), long=True\n                    )\n                    for standin in arnold_standins:\n                        arnold_standin.assign_look_by_version(\n                            standin, version_id=version_entity[\"id\"])\n\n                nodes = list(set(nodes).difference(arnold_standins))\n            else:\n                self.echo(\n                    \"Could not assign to aiStandIn because mtoa plugin is not \"\n                    \"loaded.\"\n                )\n\n            # Assign look\n            if nodes:\n                assign_look_by_version(\n                    nodes, version_id=version_entity[\"id\"]\n                )\n\n        end = time.time()\n\n        self.echo(\"Finished assigning.. ({0:.3f}s)\".format(end - start))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/index.html#client.ayon_maya.tools.mayalookassigner.MayaLookAssignerWindow.on_asset_selection_changed","title":"<code>on_asset_selection_changed()</code>","text":"<p>Get selected items from asset loader and fill look outliner</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/app.py</code> <pre><code>def on_asset_selection_changed(self):\n    \"\"\"Get selected items from asset loader and fill look outliner\"\"\"\n\n    items = self.asset_outliner.get_selected_items()\n    self.look_outliner.clear()\n    self.look_outliner.add_items(items)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/index.html#client.ayon_maya.tools.mayalookassigner.MayaLookAssignerWindow.on_process_selected","title":"<code>on_process_selected()</code>","text":"<p>Process all selected looks for the selected assets</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/app.py</code> <pre><code>def on_process_selected(self):\n    \"\"\"Process all selected looks for the selected assets\"\"\"\n\n    assets = self.asset_outliner.get_selected_items()\n    assert assets, \"No asset selected\"\n\n    # Collect the looks we want to apply (by name)\n    look_items = self.look_outliner.get_selected_items()\n    looks = {look[\"product\"] for look in look_items}\n\n    selection = self.assign_selected.isChecked()\n    asset_nodes = self.asset_outliner.get_nodes(selection=selection)\n\n    project_name = get_current_project_name()\n    start = time.time()\n    for i, (asset, item) in enumerate(asset_nodes.items()):\n\n        # Label prefix\n        prefix = \"({}/{})\".format(i + 1, len(asset_nodes))\n\n        # Assign the first matching look relevant for this asset\n        # (since assigning multiple to the same nodes makes no sense)\n        assign_look = next(\n            (\n                product_entity\n                for product_entity in item[\"looks\"]\n                if product_entity[\"name\"] in looks\n            ),\n            None\n        )\n        if not assign_look:\n            self.echo(\n                \"{} No matching selected look for {}\".format(prefix, asset)\n            )\n            continue\n\n        # Get the latest version of this asset's look product\n        version_entity = ayon_api.get_last_version_by_product_id(\n            project_name, assign_look[\"id\"], fields={\"id\"}\n        )\n\n        product_name = assign_look[\"name\"]\n        self.echo(\"{} Assigning {} to {}\\t\".format(\n            prefix, product_name, asset\n        ))\n        nodes = item[\"nodes\"]\n\n        # Assign Vray Proxy look.\n        if cmds.pluginInfo('vrayformaya', query=True, loaded=True):\n            self.echo(\"Getting vray proxy nodes ...\")\n            vray_proxies = set(cmds.ls(type=\"VRayProxy\", long=True))\n\n            for vp in vray_proxies:\n                if vp in nodes:\n                    vrayproxy_assign_look(vp, product_name)\n\n            nodes = list(set(nodes).difference(vray_proxies))\n        else:\n            self.echo(\n                \"Could not assign to VRayProxy because vrayformaya plugin \"\n                \"is not loaded.\"\n            )\n\n        # Assign Arnold Standin look.\n        if cmds.pluginInfo(\"mtoa\", query=True, loaded=True):\n            types = arnold_standin.get_supported_node_types()\n            # If the current renderer is Arnold we also allow assigning\n            # to gpuCache nodes. If not, then we skip it because Arnold may\n            # be loaded even if unused as renderer in current project.\n            renderer = cmds.getAttr(\"defaultRenderGlobals.currentRenderer\")\n            if renderer != \"arnold\":\n                types.discard(\"gpuCache\")\n\n            if types:\n                arnold_standins = cmds.ls(\n                    nodes, type=list(types), long=True\n                )\n                for standin in arnold_standins:\n                    arnold_standin.assign_look_by_version(\n                        standin, version_id=version_entity[\"id\"])\n\n            nodes = list(set(nodes).difference(arnold_standins))\n        else:\n            self.echo(\n                \"Could not assign to aiStandIn because mtoa plugin is not \"\n                \"loaded.\"\n            )\n\n        # Assign look\n        if nodes:\n            assign_look_by_version(\n                nodes, version_id=version_entity[\"id\"]\n            )\n\n    end = time.time()\n\n    self.echo(\"Finished assigning.. ({0:.3f}s)\".format(end - start))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/index.html#client.ayon_maya.tools.mayalookassigner.MayaLookAssignerWindow.refresh","title":"<code>refresh()</code>","text":"<p>Refresh the content</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/app.py</code> <pre><code>def refresh(self):\n    \"\"\"Refresh the content\"\"\"\n\n    # Get all containers and information\n    self.asset_outliner.clear()\n    found_items = self.asset_outliner.get_all_assets()\n    if not found_items:\n        self.look_outliner.clear()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/index.html#client.ayon_maya.tools.mayalookassigner.MayaLookAssignerWindow.setup_connections","title":"<code>setup_connections()</code>","text":"<p>Connect interactive widgets with actions</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/app.py</code> <pre><code>def setup_connections(self):\n    \"\"\"Connect interactive widgets with actions\"\"\"\n    if self._connections_set_up:\n        return\n\n    # Maya renderlayer switch callback\n    callback = om.MEventMessage.addEventCallback(\n        \"renderLayerManagerChange\",\n        self._on_renderlayer_switch\n    )\n    self._callbacks.append(callback)\n    self._connections_set_up = True\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/index.html#client.ayon_maya.tools.mayalookassigner.MayaLookAssignerWindow.setup_ui","title":"<code>setup_ui()</code>","text":"<p>Build the UI</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/app.py</code> <pre><code>def setup_ui(self):\n    \"\"\"Build the UI\"\"\"\n\n    main_splitter = QtWidgets.QSplitter(self)\n\n    # Assets (left)\n    asset_outliner = AssetOutliner(main_splitter)\n\n    # Looks (right)\n    looks_widget = QtWidgets.QWidget(main_splitter)\n\n    look_outliner = LookOutliner(looks_widget)  # Database look overview\n\n    assign_selected = QtWidgets.QCheckBox(\n        \"Assign to selected only\", looks_widget\n    )\n    assign_selected.setToolTip(\"Whether to assign only to selected nodes \"\n                               \"or to the full asset\")\n    remove_unused_btn = QtWidgets.QPushButton(\n        \"Remove Unused Looks\", looks_widget\n    )\n\n    looks_layout = QtWidgets.QVBoxLayout(looks_widget)\n    looks_layout.addWidget(look_outliner)\n    looks_layout.addWidget(assign_selected)\n    looks_layout.addWidget(remove_unused_btn)\n\n    main_splitter.addWidget(asset_outliner)\n    main_splitter.addWidget(looks_widget)\n    main_splitter.setSizes([350, 200])\n\n    # Footer\n    status = QtWidgets.QStatusBar(self)\n    status.setSizeGripEnabled(False)\n    status.setFixedHeight(25)\n    warn_layer = QtWidgets.QLabel(\n        \"Current Layer is not defaultRenderLayer\", self\n    )\n    warn_layer.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)\n    warn_layer.setStyleSheet(\"color: #DD5555; font-weight: bold;\")\n    warn_layer.setFixedHeight(25)\n\n    footer = QtWidgets.QHBoxLayout()\n    footer.setContentsMargins(0, 0, 0, 0)\n    footer.addWidget(status)\n    footer.addWidget(warn_layer)\n\n    # Build up widgets\n    main_layout = QtWidgets.QVBoxLayout(self)\n    main_layout.setSpacing(0)\n    main_layout.addWidget(main_splitter)\n    main_layout.addLayout(footer)\n\n    # Set column width\n    asset_outliner.view.setColumnWidth(0, 200)\n    look_outliner.view.setColumnWidth(0, 150)\n\n    asset_outliner.selection_changed.connect(\n        self.on_asset_selection_changed)\n\n    asset_outliner.refreshed.connect(\n        lambda: self.echo(\"Loaded assets..\")\n    )\n\n    look_outliner.menu_apply_action.connect(self.on_process_selected)\n    remove_unused_btn.clicked.connect(remove_unused_looks)\n\n    # Open widgets\n    self.asset_outliner = asset_outliner\n    self.look_outliner = look_outliner\n    self.status = status\n    self.warn_layer = warn_layer\n\n    # Buttons\n    self.remove_unused = remove_unused_btn\n    self.assign_selected = assign_selected\n\n    self._first_show = True\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/index.html#client.ayon_maya.tools.mayalookassigner.show","title":"<code>show()</code>","text":"<p>Display Loader GUI</p> <p>Parameters:</p> Name Type Description Default <code>debug</code> <code>bool</code> <p>Run loader in debug-mode, defaults to False</p> required Source code in <code>client/ayon_maya/tools/mayalookassigner/app.py</code> <pre><code>def show():\n    \"\"\"Display Loader GUI\n\n    Arguments:\n        debug (bool, optional): Run loader in debug-mode,\n            defaults to False\n\n    \"\"\"\n\n    try:\n        module.window.close()\n        del module.window\n    except (RuntimeError, AttributeError):\n        pass\n\n    # Get Maya main window\n    mainwindow = get_main_window()\n\n    with qt_app_context():\n        window = MayaLookAssignerWindow(parent=mainwindow)\n        window.show()\n\n        module.window = window\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/alembic.html","title":"alembic","text":"<p>Tools for loading looks to vray proxies.</p>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/alembic.html#client.ayon_maya.tools.mayalookassigner.alembic.get_alembic_ids_cache","title":"<code>get_alembic_ids_cache(path)</code>","text":"<p>Build a id to node mapping in Alembic file.</p> <p>Nodes without IDs are ignored.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Mapping of id to nodes in the Alembic.</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/alembic.py</code> <pre><code>def get_alembic_ids_cache(path: str) -&gt; dict:\n    \"\"\"Build a id to node mapping in Alembic file.\n\n    Nodes without IDs are ignored.\n\n    Returns:\n        dict: Mapping of id to nodes in the Alembic.\n\n    \"\"\"\n    node_ids = get_alembic_paths_by_property(path, attr=\"cbId\")\n    id_nodes = defaultdict(list)\n    for node, _id in node_ids.items():\n        id_nodes[_id].append(node)\n\n    return dict(id_nodes.items())\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/alembic.html#client.ayon_maya.tools.mayalookassigner.alembic.get_alembic_paths_by_property","title":"<code>get_alembic_paths_by_property(filename, attr, verbose=False)</code>","text":"<p>Return attribute value per objects in the Alembic file.</p> <p>Reads an Alembic archive hierarchy and retrieves the value from the <code>attr</code> properties on the objects.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Full path to Alembic archive to read.</p> required <code>attr</code> <code>str</code> <p>Id attribute.</p> required <code>verbose</code> <code>bool</code> <p>Whether to verbosely log missing attributes.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Mapping of node full path with its id</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/alembic.py</code> <pre><code>def get_alembic_paths_by_property(filename, attr, verbose=False):\n    # type: (str, str, bool) -&gt; dict\n    \"\"\"Return attribute value per objects in the Alembic file.\n\n    Reads an Alembic archive hierarchy and retrieves the\n    value from the `attr` properties on the objects.\n\n    Args:\n        filename (str): Full path to Alembic archive to read.\n        attr (str): Id attribute.\n        verbose (bool): Whether to verbosely log missing attributes.\n\n    Returns:\n        dict: Mapping of node full path with its id\n\n    \"\"\"\n    # Normalize alembic path\n    filename = os.path.normpath(filename)\n    filename = filename.replace(\"\\\\\", \"/\")\n    filename = str(filename)  # path must be string\n\n    try:\n        archive = alembic.Abc.IArchive(filename)\n    except RuntimeError:\n        # invalid alembic file - probably vrmesh\n        log.warning(\"{} is not an alembic file\".format(filename))\n        return {}\n    root = archive.getTop()\n\n    iterator = list(root.children)\n    obj_ids = {}\n\n    for obj in iterator:\n        name = obj.getFullName()\n\n        # include children for coming iterations\n        iterator.extend(obj.children)\n\n        props = obj.getProperties()\n        if props.getNumProperties() == 0:\n            # Skip those without properties, e.g. '/materials' in a gpuCache\n            continue\n\n        # THe custom attribute is under the properties' first container under\n        # the \".arbGeomParams\"\n        prop = props.getProperty(0)  # get base property\n\n        _property = None\n        try:\n            geo_params = prop.getProperty('.arbGeomParams')\n            _property = geo_params.getProperty(attr)\n        except KeyError:\n            if verbose:\n                log.debug(\"Missing attr on: {0}\".format(name))\n            continue\n\n        if not _property.isConstant():\n            log.warning(\"Id not constant on: {0}\".format(name))\n\n        # Maya alembic export seems to export `cbId` string as array property\n        # whereas Houdini primitive `cbId` attribute comes through as a\n        # scalar property (which still holds the string?)\n        if isinstance(_property, alembic.Abc.IArrayProperty):\n            # Get first value sample\n            value = _property.getValue()[0]\n        else:\n            value = _property.getValue()\n\n        obj_ids[name] = value\n\n    return obj_ids\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/app.html","title":"app","text":""},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/app.html#client.ayon_maya.tools.mayalookassigner.app.MayaLookAssignerWindow","title":"<code>MayaLookAssignerWindow</code>","text":"<p>               Bases: <code>QWidget</code></p> Source code in <code>client/ayon_maya/tools/mayalookassigner/app.py</code> <pre><code>class MayaLookAssignerWindow(QtWidgets.QWidget):\n\n    def __init__(self, parent=None):\n        super(MayaLookAssignerWindow, self).__init__(parent=parent)\n\n        self.log = logging.getLogger(__name__)\n\n        # Store callback references\n        self._callbacks = []\n        self._connections_set_up = False\n\n        filename = get_workfile()\n\n        self.setObjectName(\"lookManager\")\n        self.setWindowTitle(\"Look Manager 1.4.0 - [{}]\".format(filename))\n        self.setWindowFlags(QtCore.Qt.Window)\n        self.setParent(parent)\n\n        self.resize(750, 500)\n\n        self.setup_ui()\n\n        # Force refresh check on initialization\n        self._on_renderlayer_switch()\n\n    def setup_ui(self):\n        \"\"\"Build the UI\"\"\"\n\n        main_splitter = QtWidgets.QSplitter(self)\n\n        # Assets (left)\n        asset_outliner = AssetOutliner(main_splitter)\n\n        # Looks (right)\n        looks_widget = QtWidgets.QWidget(main_splitter)\n\n        look_outliner = LookOutliner(looks_widget)  # Database look overview\n\n        assign_selected = QtWidgets.QCheckBox(\n            \"Assign to selected only\", looks_widget\n        )\n        assign_selected.setToolTip(\"Whether to assign only to selected nodes \"\n                                   \"or to the full asset\")\n        remove_unused_btn = QtWidgets.QPushButton(\n            \"Remove Unused Looks\", looks_widget\n        )\n\n        looks_layout = QtWidgets.QVBoxLayout(looks_widget)\n        looks_layout.addWidget(look_outliner)\n        looks_layout.addWidget(assign_selected)\n        looks_layout.addWidget(remove_unused_btn)\n\n        main_splitter.addWidget(asset_outliner)\n        main_splitter.addWidget(looks_widget)\n        main_splitter.setSizes([350, 200])\n\n        # Footer\n        status = QtWidgets.QStatusBar(self)\n        status.setSizeGripEnabled(False)\n        status.setFixedHeight(25)\n        warn_layer = QtWidgets.QLabel(\n            \"Current Layer is not defaultRenderLayer\", self\n        )\n        warn_layer.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)\n        warn_layer.setStyleSheet(\"color: #DD5555; font-weight: bold;\")\n        warn_layer.setFixedHeight(25)\n\n        footer = QtWidgets.QHBoxLayout()\n        footer.setContentsMargins(0, 0, 0, 0)\n        footer.addWidget(status)\n        footer.addWidget(warn_layer)\n\n        # Build up widgets\n        main_layout = QtWidgets.QVBoxLayout(self)\n        main_layout.setSpacing(0)\n        main_layout.addWidget(main_splitter)\n        main_layout.addLayout(footer)\n\n        # Set column width\n        asset_outliner.view.setColumnWidth(0, 200)\n        look_outliner.view.setColumnWidth(0, 150)\n\n        asset_outliner.selection_changed.connect(\n            self.on_asset_selection_changed)\n\n        asset_outliner.refreshed.connect(\n            lambda: self.echo(\"Loaded assets..\")\n        )\n\n        look_outliner.menu_apply_action.connect(self.on_process_selected)\n        remove_unused_btn.clicked.connect(remove_unused_looks)\n\n        # Open widgets\n        self.asset_outliner = asset_outliner\n        self.look_outliner = look_outliner\n        self.status = status\n        self.warn_layer = warn_layer\n\n        # Buttons\n        self.remove_unused = remove_unused_btn\n        self.assign_selected = assign_selected\n\n        self._first_show = True\n\n    def setup_connections(self):\n        \"\"\"Connect interactive widgets with actions\"\"\"\n        if self._connections_set_up:\n            return\n\n        # Maya renderlayer switch callback\n        callback = om.MEventMessage.addEventCallback(\n            \"renderLayerManagerChange\",\n            self._on_renderlayer_switch\n        )\n        self._callbacks.append(callback)\n        self._connections_set_up = True\n\n    def remove_connection(self):\n        # Delete callbacks\n        for callback in self._callbacks:\n            om.MMessage.removeCallback(callback)\n\n        self._callbacks = []\n        self._connections_set_up = False\n\n    def showEvent(self, event):\n        self.setup_connections()\n        super(MayaLookAssignerWindow, self).showEvent(event)\n        if self._first_show:\n            self._first_show = False\n            self.setStyleSheet(style.load_stylesheet())\n\n    def closeEvent(self, event):\n        self.remove_connection()\n        super(MayaLookAssignerWindow, self).closeEvent(event)\n\n    def _on_renderlayer_switch(self, *args):\n        \"\"\"Callback that updates on Maya renderlayer switch\"\"\"\n\n        if maya.OpenMaya.MFileIO.isNewingFile():\n            # Don't perform a check during file open or file new as\n            # the renderlayers will not be in a valid state yet.\n            return\n\n        layer = cmds.editRenderLayerGlobals(query=True,\n                                            currentRenderLayer=True)\n        if layer != \"defaultRenderLayer\":\n            self.warn_layer.show()\n        else:\n            self.warn_layer.hide()\n\n    def echo(self, message):\n        self.status.showMessage(message, 1500)\n\n    def refresh(self):\n        \"\"\"Refresh the content\"\"\"\n\n        # Get all containers and information\n        self.asset_outliner.clear()\n        found_items = self.asset_outliner.get_all_assets()\n        if not found_items:\n            self.look_outliner.clear()\n\n    def on_asset_selection_changed(self):\n        \"\"\"Get selected items from asset loader and fill look outliner\"\"\"\n\n        items = self.asset_outliner.get_selected_items()\n        self.look_outliner.clear()\n        self.look_outliner.add_items(items)\n\n    def on_process_selected(self):\n        \"\"\"Process all selected looks for the selected assets\"\"\"\n\n        assets = self.asset_outliner.get_selected_items()\n        assert assets, \"No asset selected\"\n\n        # Collect the looks we want to apply (by name)\n        look_items = self.look_outliner.get_selected_items()\n        looks = {look[\"product\"] for look in look_items}\n\n        selection = self.assign_selected.isChecked()\n        asset_nodes = self.asset_outliner.get_nodes(selection=selection)\n\n        project_name = get_current_project_name()\n        start = time.time()\n        for i, (asset, item) in enumerate(asset_nodes.items()):\n\n            # Label prefix\n            prefix = \"({}/{})\".format(i + 1, len(asset_nodes))\n\n            # Assign the first matching look relevant for this asset\n            # (since assigning multiple to the same nodes makes no sense)\n            assign_look = next(\n                (\n                    product_entity\n                    for product_entity in item[\"looks\"]\n                    if product_entity[\"name\"] in looks\n                ),\n                None\n            )\n            if not assign_look:\n                self.echo(\n                    \"{} No matching selected look for {}\".format(prefix, asset)\n                )\n                continue\n\n            # Get the latest version of this asset's look product\n            version_entity = ayon_api.get_last_version_by_product_id(\n                project_name, assign_look[\"id\"], fields={\"id\"}\n            )\n\n            product_name = assign_look[\"name\"]\n            self.echo(\"{} Assigning {} to {}\\t\".format(\n                prefix, product_name, asset\n            ))\n            nodes = item[\"nodes\"]\n\n            # Assign Vray Proxy look.\n            if cmds.pluginInfo('vrayformaya', query=True, loaded=True):\n                self.echo(\"Getting vray proxy nodes ...\")\n                vray_proxies = set(cmds.ls(type=\"VRayProxy\", long=True))\n\n                for vp in vray_proxies:\n                    if vp in nodes:\n                        vrayproxy_assign_look(vp, product_name)\n\n                nodes = list(set(nodes).difference(vray_proxies))\n            else:\n                self.echo(\n                    \"Could not assign to VRayProxy because vrayformaya plugin \"\n                    \"is not loaded.\"\n                )\n\n            # Assign Arnold Standin look.\n            if cmds.pluginInfo(\"mtoa\", query=True, loaded=True):\n                types = arnold_standin.get_supported_node_types()\n                # If the current renderer is Arnold we also allow assigning\n                # to gpuCache nodes. If not, then we skip it because Arnold may\n                # be loaded even if unused as renderer in current project.\n                renderer = cmds.getAttr(\"defaultRenderGlobals.currentRenderer\")\n                if renderer != \"arnold\":\n                    types.discard(\"gpuCache\")\n\n                if types:\n                    arnold_standins = cmds.ls(\n                        nodes, type=list(types), long=True\n                    )\n                    for standin in arnold_standins:\n                        arnold_standin.assign_look_by_version(\n                            standin, version_id=version_entity[\"id\"])\n\n                nodes = list(set(nodes).difference(arnold_standins))\n            else:\n                self.echo(\n                    \"Could not assign to aiStandIn because mtoa plugin is not \"\n                    \"loaded.\"\n                )\n\n            # Assign look\n            if nodes:\n                assign_look_by_version(\n                    nodes, version_id=version_entity[\"id\"]\n                )\n\n        end = time.time()\n\n        self.echo(\"Finished assigning.. ({0:.3f}s)\".format(end - start))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/app.html#client.ayon_maya.tools.mayalookassigner.app.MayaLookAssignerWindow.on_asset_selection_changed","title":"<code>on_asset_selection_changed()</code>","text":"<p>Get selected items from asset loader and fill look outliner</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/app.py</code> <pre><code>def on_asset_selection_changed(self):\n    \"\"\"Get selected items from asset loader and fill look outliner\"\"\"\n\n    items = self.asset_outliner.get_selected_items()\n    self.look_outliner.clear()\n    self.look_outliner.add_items(items)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/app.html#client.ayon_maya.tools.mayalookassigner.app.MayaLookAssignerWindow.on_process_selected","title":"<code>on_process_selected()</code>","text":"<p>Process all selected looks for the selected assets</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/app.py</code> <pre><code>def on_process_selected(self):\n    \"\"\"Process all selected looks for the selected assets\"\"\"\n\n    assets = self.asset_outliner.get_selected_items()\n    assert assets, \"No asset selected\"\n\n    # Collect the looks we want to apply (by name)\n    look_items = self.look_outliner.get_selected_items()\n    looks = {look[\"product\"] for look in look_items}\n\n    selection = self.assign_selected.isChecked()\n    asset_nodes = self.asset_outliner.get_nodes(selection=selection)\n\n    project_name = get_current_project_name()\n    start = time.time()\n    for i, (asset, item) in enumerate(asset_nodes.items()):\n\n        # Label prefix\n        prefix = \"({}/{})\".format(i + 1, len(asset_nodes))\n\n        # Assign the first matching look relevant for this asset\n        # (since assigning multiple to the same nodes makes no sense)\n        assign_look = next(\n            (\n                product_entity\n                for product_entity in item[\"looks\"]\n                if product_entity[\"name\"] in looks\n            ),\n            None\n        )\n        if not assign_look:\n            self.echo(\n                \"{} No matching selected look for {}\".format(prefix, asset)\n            )\n            continue\n\n        # Get the latest version of this asset's look product\n        version_entity = ayon_api.get_last_version_by_product_id(\n            project_name, assign_look[\"id\"], fields={\"id\"}\n        )\n\n        product_name = assign_look[\"name\"]\n        self.echo(\"{} Assigning {} to {}\\t\".format(\n            prefix, product_name, asset\n        ))\n        nodes = item[\"nodes\"]\n\n        # Assign Vray Proxy look.\n        if cmds.pluginInfo('vrayformaya', query=True, loaded=True):\n            self.echo(\"Getting vray proxy nodes ...\")\n            vray_proxies = set(cmds.ls(type=\"VRayProxy\", long=True))\n\n            for vp in vray_proxies:\n                if vp in nodes:\n                    vrayproxy_assign_look(vp, product_name)\n\n            nodes = list(set(nodes).difference(vray_proxies))\n        else:\n            self.echo(\n                \"Could not assign to VRayProxy because vrayformaya plugin \"\n                \"is not loaded.\"\n            )\n\n        # Assign Arnold Standin look.\n        if cmds.pluginInfo(\"mtoa\", query=True, loaded=True):\n            types = arnold_standin.get_supported_node_types()\n            # If the current renderer is Arnold we also allow assigning\n            # to gpuCache nodes. If not, then we skip it because Arnold may\n            # be loaded even if unused as renderer in current project.\n            renderer = cmds.getAttr(\"defaultRenderGlobals.currentRenderer\")\n            if renderer != \"arnold\":\n                types.discard(\"gpuCache\")\n\n            if types:\n                arnold_standins = cmds.ls(\n                    nodes, type=list(types), long=True\n                )\n                for standin in arnold_standins:\n                    arnold_standin.assign_look_by_version(\n                        standin, version_id=version_entity[\"id\"])\n\n            nodes = list(set(nodes).difference(arnold_standins))\n        else:\n            self.echo(\n                \"Could not assign to aiStandIn because mtoa plugin is not \"\n                \"loaded.\"\n            )\n\n        # Assign look\n        if nodes:\n            assign_look_by_version(\n                nodes, version_id=version_entity[\"id\"]\n            )\n\n    end = time.time()\n\n    self.echo(\"Finished assigning.. ({0:.3f}s)\".format(end - start))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/app.html#client.ayon_maya.tools.mayalookassigner.app.MayaLookAssignerWindow.refresh","title":"<code>refresh()</code>","text":"<p>Refresh the content</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/app.py</code> <pre><code>def refresh(self):\n    \"\"\"Refresh the content\"\"\"\n\n    # Get all containers and information\n    self.asset_outliner.clear()\n    found_items = self.asset_outliner.get_all_assets()\n    if not found_items:\n        self.look_outliner.clear()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/app.html#client.ayon_maya.tools.mayalookassigner.app.MayaLookAssignerWindow.setup_connections","title":"<code>setup_connections()</code>","text":"<p>Connect interactive widgets with actions</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/app.py</code> <pre><code>def setup_connections(self):\n    \"\"\"Connect interactive widgets with actions\"\"\"\n    if self._connections_set_up:\n        return\n\n    # Maya renderlayer switch callback\n    callback = om.MEventMessage.addEventCallback(\n        \"renderLayerManagerChange\",\n        self._on_renderlayer_switch\n    )\n    self._callbacks.append(callback)\n    self._connections_set_up = True\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/app.html#client.ayon_maya.tools.mayalookassigner.app.MayaLookAssignerWindow.setup_ui","title":"<code>setup_ui()</code>","text":"<p>Build the UI</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/app.py</code> <pre><code>def setup_ui(self):\n    \"\"\"Build the UI\"\"\"\n\n    main_splitter = QtWidgets.QSplitter(self)\n\n    # Assets (left)\n    asset_outliner = AssetOutliner(main_splitter)\n\n    # Looks (right)\n    looks_widget = QtWidgets.QWidget(main_splitter)\n\n    look_outliner = LookOutliner(looks_widget)  # Database look overview\n\n    assign_selected = QtWidgets.QCheckBox(\n        \"Assign to selected only\", looks_widget\n    )\n    assign_selected.setToolTip(\"Whether to assign only to selected nodes \"\n                               \"or to the full asset\")\n    remove_unused_btn = QtWidgets.QPushButton(\n        \"Remove Unused Looks\", looks_widget\n    )\n\n    looks_layout = QtWidgets.QVBoxLayout(looks_widget)\n    looks_layout.addWidget(look_outliner)\n    looks_layout.addWidget(assign_selected)\n    looks_layout.addWidget(remove_unused_btn)\n\n    main_splitter.addWidget(asset_outliner)\n    main_splitter.addWidget(looks_widget)\n    main_splitter.setSizes([350, 200])\n\n    # Footer\n    status = QtWidgets.QStatusBar(self)\n    status.setSizeGripEnabled(False)\n    status.setFixedHeight(25)\n    warn_layer = QtWidgets.QLabel(\n        \"Current Layer is not defaultRenderLayer\", self\n    )\n    warn_layer.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)\n    warn_layer.setStyleSheet(\"color: #DD5555; font-weight: bold;\")\n    warn_layer.setFixedHeight(25)\n\n    footer = QtWidgets.QHBoxLayout()\n    footer.setContentsMargins(0, 0, 0, 0)\n    footer.addWidget(status)\n    footer.addWidget(warn_layer)\n\n    # Build up widgets\n    main_layout = QtWidgets.QVBoxLayout(self)\n    main_layout.setSpacing(0)\n    main_layout.addWidget(main_splitter)\n    main_layout.addLayout(footer)\n\n    # Set column width\n    asset_outliner.view.setColumnWidth(0, 200)\n    look_outliner.view.setColumnWidth(0, 150)\n\n    asset_outliner.selection_changed.connect(\n        self.on_asset_selection_changed)\n\n    asset_outliner.refreshed.connect(\n        lambda: self.echo(\"Loaded assets..\")\n    )\n\n    look_outliner.menu_apply_action.connect(self.on_process_selected)\n    remove_unused_btn.clicked.connect(remove_unused_looks)\n\n    # Open widgets\n    self.asset_outliner = asset_outliner\n    self.look_outliner = look_outliner\n    self.status = status\n    self.warn_layer = warn_layer\n\n    # Buttons\n    self.remove_unused = remove_unused_btn\n    self.assign_selected = assign_selected\n\n    self._first_show = True\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/app.html#client.ayon_maya.tools.mayalookassigner.app.show","title":"<code>show()</code>","text":"<p>Display Loader GUI</p> <p>Parameters:</p> Name Type Description Default <code>debug</code> <code>bool</code> <p>Run loader in debug-mode, defaults to False</p> required Source code in <code>client/ayon_maya/tools/mayalookassigner/app.py</code> <pre><code>def show():\n    \"\"\"Display Loader GUI\n\n    Arguments:\n        debug (bool, optional): Run loader in debug-mode,\n            defaults to False\n\n    \"\"\"\n\n    try:\n        module.window.close()\n        del module.window\n    except (RuntimeError, AttributeError):\n        pass\n\n    # Get Maya main window\n    mainwindow = get_main_window()\n\n    with qt_app_context():\n        window = MayaLookAssignerWindow(parent=mainwindow)\n        window.show()\n\n        module.window = window\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/arnold_standin.html","title":"arnold_standin","text":""},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/arnold_standin.html#client.ayon_maya.tools.mayalookassigner.arnold_standin.SetParameter","title":"<code>SetParameter</code>","text":"<p>Simple class to manage aiSetParameter nodes</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/arnold_standin.py</code> <pre><code>@attr.s\nclass SetParameter:\n    \"\"\"Simple class to manage aiSetParameter nodes\"\"\"\n    selection: str = attr.ib()\n    assignments: List[str] = attr.ib()\n    node: Optional[str] = attr.ib(default=None)\n\n    def create(self, name=None) -&gt; str:\n        operator: str = cmds.createNode(\"aiSetParameter\",\n                                        skipSelect=True,\n                                        name=name)\n        self.node = operator\n        self.update()\n        return operator\n\n    def update(self):\n        operator = self.node\n        cmds.setAttr(f\"{operator}.selection\", self.selection, type=\"string\")\n\n        # Remove any existing assignments\n        for i in reversed(\n            range(cmds.getAttr(f\"{operator}.assignment\", size=True))\n        ):\n            cmds.removeMultiInstance(f\"{operator}.assignment[{i}]\", b=True)\n\n        # Set the new assignments\n        for i, assignment in enumerate(self.assignments):\n            cmds.setAttr(\n                f\"{operator}.assignment[{i}]\",\n                assignment,\n                type=\"string\"\n            )\n\n    def delete(self):\n        if self.node and cmds.objExists(self.node):\n            cmds.delete(self.node)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/arnold_standin.html#client.ayon_maya.tools.mayalookassigner.arnold_standin.assign_look","title":"<code>assign_look(standin, product_name, include_selection_prefixes=None)</code>","text":"<p>Assign a look to an aiStandIn node.</p> <p>Parameters:</p> Name Type Description Default <code>standin</code> <code>str</code> <p>The aiStandIn proxy shape.</p> required <code>product_name</code> <code>str</code> <p>The product name to load.</p> required <code>include_selection_prefixes</code> <code>Optional[list[str]]</code> <p>If provided, only children to these object path prefixes will be considered. The paths are the full path from the root of the Alembic file, e.g. <code>/parent/child1/child2</code></p> <code>None</code> Source code in <code>client/ayon_maya/tools/mayalookassigner/arnold_standin.py</code> <pre><code>def assign_look(\n        standin: str,\n        product_name: str,\n        include_selection_prefixes: Optional[list[str]] = None):\n    \"\"\"Assign a look to an aiStandIn node.\n\n    Arguments:\n        standin (str): The aiStandIn proxy shape.\n        product_name (str): The product name to load.\n        include_selection_prefixes (Optional[list[str]]): If provided,\n            only children to these object path prefixes will be considered.\n            The paths are the full path from the root of the Alembic file,\n            e.g. `/parent/child1/child2`\n    \"\"\"\n    nodes_by_id = get_nodes_by_id_filtered(\n        standin, include_selection_prefixes=include_selection_prefixes)\n\n    folder_ids = set()\n    for node_id in nodes_by_id:\n        folder_id = node_id.split(\":\", 1)[0]\n\n        # Skip invalid folder ids\n        if not is_valid_uuid(folder_id):\n            nodes = nodes_by_id[node_id]\n            log.warning(\n                f\"Skipping invalid folder id {folder_id} for nodes: {nodes}\")\n            continue\n\n        folder_ids.add(folder_id)\n\n    project_name = get_current_project_name()\n    for folder_id in folder_ids:\n        # Get latest look version\n        version_entity = ayon_api.get_last_version_by_product_name(\n            project_name,\n            product_name,\n            folder_id,\n            fields={\"id\"}\n        )\n        if not version_entity:\n            log.info(\"Didn't find last version for product name {}\".format(\n                product_name\n            ))\n            continue\n\n        assign_look_by_version(\n            standin,\n            version_id=version_entity[\"id\"],\n            nodes_by_id=nodes_by_id)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/arnold_standin.html#client.ayon_maya.tools.mayalookassigner.arnold_standin.assign_look_by_version","title":"<code>assign_look_by_version(standin, version_id, nodes_by_id=None)</code>","text":"<p>Assign a look to an aiStandIn node by look version id.</p> <p>Parameters:</p> Name Type Description Default <code>standin</code> <code>str</code> <p>aiStandIn node.</p> required <code>version_id</code> <code>str</code> <p>Look product version id. </p> required <code>nodes_by_id</code> <code>Optional[Dict[str, list[str]]]</code> <p>Pre-computed dictionary with node ids and paths, as optimization or as filter to only consider a subset of the nodes using e.g.  <code>get_nodes_by_id_filtered</code>.</p> <code>None</code> Source code in <code>client/ayon_maya/tools/mayalookassigner/arnold_standin.py</code> <pre><code>def assign_look_by_version(\n        standin,\n        version_id,\n        nodes_by_id=None):\n    \"\"\"Assign a look to an aiStandIn node by look version id.\n\n    Args:\n        standin (str): aiStandIn node.\n        version_id (str): Look product version id. \n        nodes_by_id (Optional[Dict[str, list[str]]]): Pre-computed dictionary\n            with node ids and paths, as optimization or as filter to only\n            consider a subset of the nodes using e.g. \n            `get_nodes_by_id_filtered`.\n    \"\"\"\n    if nodes_by_id is None:\n        nodes_by_id = get_nodes_by_id(standin)\n\n    if not nodes_by_id:\n        # Nothing to do - opt out early\n        log.debug(f\"No ids found in standin '{standin}'. \"\n                  \"Skipping assignment...\")\n        return\n\n    # Get current active operators\n    operators = get_current_set_parameter_operators(standin)\n    operators_by_node = {\n        cmds.getAttr(f\"{op.node}.selection\"): op for op in operators\n    }\n\n    # Get look data to assign\n    relationships = lib.get_look_relationships(version_id)\n    shader_nodes, container_node = lib.load_look(version_id)\n    namespace = shader_nodes[0].split(\":\")[0]\n\n    edits = list(\n        api.lib.iter_shader_edits(\n            relationships, shader_nodes, nodes_by_id\n        )\n    )\n\n    # Define the assignment operators needed for this look\n    node_assignments = {}\n    for edit in edits:\n        for node in edit[\"nodes\"]:\n            if node not in node_assignments:\n                node_assignments[node] = []\n\n        if edit[\"action\"] == \"assign\":\n            if not cmds.ls(edit[\"shader\"], type=\"shadingEngine\"):\n                log.info(\"Skipping non-shader: %s\" % edit[\"shader\"])\n                continue\n\n            shading_engine_assignments(\n                shading_engine=edit[\"shader\"],\n                attribute=\"surfaceShader\",\n                nodes=edit[\"nodes\"],\n                assignments=node_assignments\n            )\n            shading_engine_assignments(\n                shading_engine=edit[\"shader\"],\n                attribute=\"displacementShader\",\n                nodes=edit[\"nodes\"],\n                assignments=node_assignments\n            )\n\n        if edit[\"action\"] == \"setattr\":\n            visibility = False\n            for attr_name, value in edit[\"attributes\"].items():\n                if attr_name not in ATTRIBUTE_MAPPING:\n                    log.warning(\n                        \"Skipping setting attribute {} on {} because it is\"\n                        \" not recognized.\".format(attr_name, edit[\"nodes\"])\n                    )\n                    continue\n\n                if isinstance(value, str):\n                    value = \"'{}'\".format(value)\n\n                mapped_attr_name = ATTRIBUTE_MAPPING[attr_name]\n                if mapped_attr_name == \"visibility\":\n                    visibility = True\n                    continue\n\n                assignment = f\"{mapped_attr_name}={value}\"\n                for node in edit[\"nodes\"]:\n                    node_assignments[node].append(assignment)\n\n            if visibility:\n                mask = calculate_visibility_mask(edit[\"attributes\"])\n                assignment = \"visibility={}\".format(mask)\n\n                for node in edit[\"nodes\"]:\n                    node_assignments[node].append(assignment)\n\n    # Cleanup: remove any empty operator slots\n    plug = standin + \".operators\"\n    num = cmds.getAttr(plug, size=True)\n    for i in reversed(range(num)):\n        index_plug = f\"{plug}[{i}]\"\n        if not cmds.listConnections(index_plug,\n                                    source=True,\n                                    destination=False):\n            cmds.removeMultiInstance(index_plug, b=True)\n\n    # Update the node assignments on the standin\n    for node, assignments in node_assignments.items():\n        if not assignments:\n            continue\n\n        # If this node has an existing assignment, update it\n        if node in operators_by_node:\n            set_parameter = operators_by_node[node]\n            set_parameter.assignments[:] = assignments\n            set_parameter.update()\n\n        # Create a new assignment\n        else:\n            set_parameter = SetParameter(\n                selection=node,\n                assignments=assignments\n            )\n            operators_by_node[node] = set_parameter\n\n            # Create the `aiSetParameter` node\n            label = node.rsplit(\":\", 1)[-1].rsplit(\"/\", 1)[-1]\n            name = f\"{namespace}:set_parameter_{label}\"\n            operator = set_parameter.create(name=name)\n\n            # Connect to next available index\n            size = cmds.getAttr(plug, size=True)\n            cmds.connectAttr(\n                f\"{operator}.out\",\n                f\"{plug}[{size}]\",\n                force=True\n            )\n\n            # Add it to the looks container so it is removed along\n            # with it if needed.\n            cmds.sets(operator, edit=True, addElement=container_node)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/arnold_standin.html#client.ayon_maya.tools.mayalookassigner.arnold_standin.get_current_set_parameter_operators","title":"<code>get_current_set_parameter_operators(standin)</code>","text":"<p>Return SetParameter operators for a aiStandIn node.</p> <p>Parameters:</p> Name Type Description Default <code>standin</code> <code>str</code> <p>The <code>aiStandIn</code> node to get the assignments from.</p> required <p>Returns:</p> Type Description <code>list[SetParameter]</code> <p>The list of <code>SetParameter</code> objects that represent the assignments.</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/arnold_standin.py</code> <pre><code>def get_current_set_parameter_operators(standin: str) -&gt; list[SetParameter]:\n    \"\"\"Return SetParameter operators for a aiStandIn node.\n\n    Args:\n        standin: The `aiStandIn` node to get the assignments from.\n\n    Returns:\n        The list of `SetParameter` objects that represent the assignments.\n\n    \"\"\"\n    plug = standin + \".operators\"\n    num = cmds.getAttr(plug, size=True)\n\n    set_parameters = []\n    for i in range(num):\n\n        index_plug = f\"{plug}[{i}]\"\n\n        inputs = cmds.listConnections(\n            index_plug, source=True, destination=False)\n        if not inputs:\n            continue\n\n        # We only consider `aiSetParameter` nodes for now because that is what\n        # the look assignment logic creates.\n        input_node = inputs[0]\n        if cmds.nodeType(input_node) != \"aiSetParameter\":\n            continue\n\n        selection = cmds.getAttr(f\"{input_node}.selection\")\n        assignment_plug = f\"{input_node}.assignment\"\n        assignments = []\n        for j in range(cmds.getAttr(assignment_plug, size=True)):\n            assignment_index_plug = f\"{assignment_plug}[{j}]\"\n            assignment = cmds.getAttr(assignment_index_plug)\n            assignments.append(assignment)\n\n        parameter = SetParameter(\n            selection=selection,\n            assignments=assignments,\n            node=input_node)\n        set_parameters.append(parameter)\n    return set_parameters\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/arnold_standin.html#client.ayon_maya.tools.mayalookassigner.arnold_standin.get_nodes_by_id","title":"<code>get_nodes_by_id(standin)</code>","text":"<p>Get node id from aiStandIn via json sidecar.</p> <p>Parameters:</p> Name Type Description Default <code>standin</code> <code>string</code> <p>aiStandIn node.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with node full name/path and id.</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/arnold_standin.py</code> <pre><code>def get_nodes_by_id(standin):\n    \"\"\"Get node id from aiStandIn via json sidecar.\n\n    Args:\n        standin (string): aiStandIn node.\n\n    Returns:\n        (dict): Dictionary with node full name/path and id.\n    \"\"\"\n\n    # Transform to shape if not shape\n    if not cmds.objectType(standin, isAType=\"shape\"):\n        shapes = cmds.listRelatives(\n            standin,\n            shapes=True,\n            noIntermediate=True,\n            type=list(get_supported_node_types()),\n            fullPath=True)\n        if not shapes:\n            return {}\n        standin = shapes[0]\n\n    attr = \"dso\"  # aiStandIn\n    if cmds.nodeType(standin) == \"gpuCache\":\n        attr = \"cacheFileName\"\n\n    path = cmds.getAttr(f\"{standin}.{attr}\")\n\n    if path.endswith(\".abc\"):\n        # Support alembic files directly\n        return get_alembic_ids_cache(path)\n\n    elif (\n        is_usd_lib_supported and\n        any(path.endswith(ext) for ext in [\".usd\", \".usda\", \".usdc\"])\n    ):\n        # Support usd files directly\n        return get_usd_ids_cache(path)\n\n    json_path = None\n    for f in os.listdir(os.path.dirname(path)):\n        if f.endswith(\".json\"):\n            json_path = os.path.join(os.path.dirname(path), f)\n            break\n\n    if not json_path:\n        log.warning(\"Could not find json file for {}.\".format(standin))\n        return {}\n\n    with open(json_path, \"r\") as f:\n        return json.load(f)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/arnold_standin.html#client.ayon_maya.tools.mayalookassigner.arnold_standin.get_nodes_by_id_filtered","title":"<code>get_nodes_by_id_filtered(standin, include_selection_prefixes)</code>","text":"<p>Get aiStandIn object paths by <code>cbId</code> via Alembic or JSON sidecar.</p> <p>Parameters:</p> Name Type Description Default <code>standin</code> <code>string</code> <p>aiStandIn node.</p> required <code>include_selection_prefixes</code> <code>list[str] | None</code> <p>If not None, only children to these object path prefixes will be considered. The paths are the full path from the root of the Alembic file, e.g. <code>/parent/child1/child2</code>.</p> required <p>Returns:</p> Type Description <p>dict[str, list[str]]: Dictionary with <code>cbId</code> and object paths.</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/arnold_standin.py</code> <pre><code>def get_nodes_by_id_filtered(standin, include_selection_prefixes):\n    \"\"\"Get aiStandIn object paths by `cbId` via Alembic or JSON sidecar.\n\n    Args:\n        standin (string): aiStandIn node.\n        include_selection_prefixes (list[str] | None): If not None,\n            only children to these object path prefixes will be considered.\n            The paths are the full path from the root of the Alembic file,\n            e.g. `/parent/child1/child2`.\n\n    Returns:\n        dict[str, list[str]]: Dictionary with `cbId` and object paths.\n    \"\"\"\n    nodes_by_id = get_nodes_by_id(standin)\n\n    # If any inclusion selection prefixes are set we allow assigning only\n    # to those paths or any children\n    if include_selection_prefixes:\n        prefixes = tuple(f\"{prefix}/\" for prefix in include_selection_prefixes)\n        for node_id, nodes in dict(nodes_by_id).items():\n            nodes = [node for node in nodes if node.startswith(prefixes)]\n            if nodes:\n                nodes_by_id[node_id] = nodes\n            else:\n                nodes_by_id.pop(node_id)\n\n    return nodes_by_id\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/arnold_standin.html#client.ayon_maya.tools.mayalookassigner.arnold_standin.get_supported_node_types","title":"<code>get_supported_node_types()</code>","text":"<p>Get supported node types for look assignment.</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/arnold_standin.py</code> <pre><code>def get_supported_node_types() -&gt; set[str]:\n    \"\"\"Get supported node types for look assignment.\"\"\"\n    node_types: set[str] = {\"aiStandIn\", \"gpuCache\"}\n    # Return only the node types that exist in the current Maya session\n    # so that we can safely use these as node types to query for without\n    # Maya raising errors on unknown node types.\n    return {\n        node_type for node_type in node_types\n        if api.lib.nodetype_exists(node_type)\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/arnold_standin.html#client.ayon_maya.tools.mayalookassigner.arnold_standin.is_valid_uuid","title":"<code>is_valid_uuid(value)</code>","text":"<p>Return whether value is a valid UUID</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/arnold_standin.py</code> <pre><code>def is_valid_uuid(value) -&gt; bool:\n    \"\"\"Return whether value is a valid UUID\"\"\"\n    try:\n        uuid.UUID(value)\n    except ValueError:\n        return False\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/arnold_standin.html#client.ayon_maya.tools.mayalookassigner.arnold_standin.shading_engine_assignments","title":"<code>shading_engine_assignments(shading_engine, attribute, nodes, assignments)</code>","text":"<p>Full assignments with shader or disp_map.</p> <p>Parameters:</p> Name Type Description Default <code>shading_engine</code> <code>string</code> <p>Shading engine for material.</p> required <code>attribute</code> <code>string</code> <p>\"surfaceShader\" or \"displacementShader\"</p> required <code>nodes</code> <p>(list): Nodes paths relative to aiStandIn.</p> required <code>assignments</code> <code>dict</code> <p>Assignments by nodes.</p> required <p>Returns:</p> Type Description <p>dict[str, list[str]]: The operator <code>aiSetParameter</code> assignments needed per node to assign the shading engine.</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/arnold_standin.py</code> <pre><code>def shading_engine_assignments(shading_engine, attribute, nodes, assignments):\n    \"\"\"Full assignments with shader or disp_map.\n\n    Args:\n        shading_engine (string): Shading engine for material.\n        attribute (string): \"surfaceShader\" or \"displacementShader\"\n        nodes: (list): Nodes paths relative to aiStandIn.\n        assignments (dict): Assignments by nodes.\n\n    Returns:\n        dict[str, list[str]]: The operator `aiSetParameter` assignments\n          needed per node to assign the shading engine.\n\n    \"\"\"\n    shader_inputs = cmds.listConnections(\n        shading_engine + \".\" + attribute, source=True\n    )\n    if not shader_inputs:\n        log.info(\n            \"Shading engine \\\"{}\\\" missing input \\\"{}\\\"\".format(\n                shading_engine, attribute\n            )\n        )\n        return\n\n    # Strip off component assignments\n    for i, node in enumerate(nodes):\n        if \".\" in node:\n            log.warning(\n                \"Converting face assignment to full object assignment. This \"\n                \"conversion can be lossy: {}\".format(node)\n            )\n            nodes[i] = node.split(\".\")[0]\n\n    shader_type = \"shader\" if attribute == \"surfaceShader\" else \"disp_map\"\n    assignment = \"{}='{}'\".format(shader_type, shader_inputs[0])\n    for node in nodes:\n        assignments[node].append(assignment)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/commands.html","title":"commands","text":""},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/commands.html#client.ayon_maya.tools.mayalookassigner.commands.create_folder_id_hash","title":"<code>create_folder_id_hash(nodes)</code>","text":"<p>Create a hash based on cbId attribute value Args:     nodes (list): a list of nodes</p> <p>Returns:</p> Type Description <p>dict</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/commands.py</code> <pre><code>def create_folder_id_hash(nodes):\n    \"\"\"Create a hash based on cbId attribute value\n    Args:\n        nodes (list): a list of nodes\n\n    Returns:\n        dict\n    \"\"\"\n    node_id_hash = defaultdict(list)\n    for node in nodes:\n        # iterate over content of reference node\n        if cmds.nodeType(node) == \"reference\":\n            ref_hashes = create_folder_id_hash(\n                list(set(cmds.referenceQuery(node, nodes=True, dp=True))))\n            for folder_id, ref_nodes in ref_hashes.items():\n                node_id_hash[folder_id] += ref_nodes\n        elif cmds.pluginInfo('vrayformaya', query=True,\n                             loaded=True) and cmds.nodeType(\n                node) == \"VRayProxy\":\n            path = cmds.getAttr(\"{}.fileName\".format(node))\n            ids = get_alembic_ids_cache(path)\n            for k, _ in ids.items():\n                id = k.split(\":\")[0]\n                node_id_hash[id].append(node)\n        elif cmds.nodeType(node) in {\"aiStandIn\", \"gpuCache\"}:\n            for id, _ in arnold_standin.get_nodes_by_id(node).items():\n                id = id.split(\":\")[0]\n                node_id_hash[id].append(node)\n        else:\n            value = lib.get_id(node)\n            if value is None:\n                continue\n\n            folder_id = value.split(\":\")[0]\n            node_id_hash[folder_id].append(node)\n\n    return dict(node_id_hash)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/commands.html#client.ayon_maya.tools.mayalookassigner.commands.create_items_from_nodes","title":"<code>create_items_from_nodes(nodes)</code>","text":"<p>Create an item for the view based the container and content of it</p> <p>It fetches the look document based on the folder id found in the content. The item will contain all important information for the tool to work.</p> <p>If there is an folder id which is not registered in the project's collection it will log a warning message.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list</code> <p>list of maya nodes</p> required <p>Returns:</p> Type Description <p>list of dicts</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/commands.py</code> <pre><code>def create_items_from_nodes(nodes):\n    \"\"\"Create an item for the view based the container and content of it\n\n    It fetches the look document based on the folder id found in the content.\n    The item will contain all important information for the tool to work.\n\n    If there is an folder id which is not registered in the project's collection\n    it will log a warning message.\n\n    Args:\n        nodes (list): list of maya nodes\n\n    Returns:\n        list of dicts\n\n    \"\"\"\n\n    folder_view_items = []\n\n    id_hashes = create_folder_id_hash(nodes)\n\n    if not id_hashes:\n        log.warning(\"No id hashes\")\n        return folder_view_items\n\n    project_name = get_current_project_name()\n    folder_ids = set(id_hashes.keys())\n\n    # Ignore invalid ids\n    folder_ids = {\n        folder_id for folder_id in folder_ids\n        if ayon_api.utils.convert_entity_id(folder_id)\n    }\n\n    folder_entities = ayon_api.get_folders(\n        project_name, folder_ids, fields={\"id\", \"path\"}\n    )\n    folder_entities_by_id = {\n        folder_entity[\"id\"]: folder_entity\n        for folder_entity in folder_entities\n    }\n\n    for folder_id, id_nodes in id_hashes.items():\n        folder_entity = folder_entities_by_id.get(folder_id)\n        # Skip if folder id is not found\n        if not folder_entity:\n            log.warning(\n                \"Id found on {num} nodes for which no folder is found database,\"\n                \" skipping '{folder_id}'\".format(\n                    num=len(nodes),\n                    folder_id=folder_id\n                )\n            )\n            continue\n\n        # Collect available look products for this folder\n        looks = lib.list_looks(project_name, folder_entity[\"id\"])\n\n        # Collect namespaces the folder is found in\n        namespaces = set()\n        for node in id_nodes:\n            namespace = get_namespace_from_node(node)\n            namespaces.add(namespace)\n\n        folder_view_items.append({\n            \"label\": folder_entity[\"path\"],\n            \"folder_entity\": folder_entity,\n            \"looks\": looks,\n            \"namespaces\": namespaces\n        })\n\n    return folder_view_items\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/commands.html#client.ayon_maya.tools.mayalookassigner.commands.get_all_asset_nodes","title":"<code>get_all_asset_nodes()</code>","text":"<p>Get all assets from the scene, container based</p> <p>Returns:</p> Name Type Description <code>list</code> <p>list of dictionaries</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/commands.py</code> <pre><code>def get_all_asset_nodes():\n    \"\"\"Get all assets from the scene, container based\n\n    Returns:\n        list: list of dictionaries\n    \"\"\"\n    return cmds.ls(dag=True, noIntermediate=True, long=True)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/commands.html#client.ayon_maya.tools.mayalookassigner.commands.get_namespace_from_node","title":"<code>get_namespace_from_node(node)</code>","text":"<p>Get the namespace from the given node</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>name of the node</p> required <p>Returns:</p> Type Description <p>namespace (str)</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/commands.py</code> <pre><code>def get_namespace_from_node(node):\n    \"\"\"Get the namespace from the given node\n\n    Args:\n        node (str): name of the node\n\n    Returns:\n        namespace (str)\n\n    \"\"\"\n    parts = node.rsplit(\"|\", 1)[-1].rsplit(\":\", 1)\n    return parts[0] if len(parts) &gt; 1 else u\":\"\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/commands.html#client.ayon_maya.tools.mayalookassigner.commands.get_selected_nodes","title":"<code>get_selected_nodes()</code>","text":"<p>Get information from current selection</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/commands.py</code> <pre><code>def get_selected_nodes():\n    \"\"\"Get information from current selection\"\"\"\n\n    selection = cmds.ls(selection=True, long=True)\n    hierarchy = lib.get_all_children(selection,\n                                     ignore_intermediate_objects=True)\n    return list(hierarchy.union(selection))\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/commands.html#client.ayon_maya.tools.mayalookassigner.commands.remove_unused_looks","title":"<code>remove_unused_looks()</code>","text":"<p>Removes all loaded looks for which none of the shaders are used.</p> <p>This will cleanup all loaded \"LookLoader\" containers that are unused in the current scene.</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/commands.py</code> <pre><code>def remove_unused_looks():\n    \"\"\"Removes all loaded looks for which none of the shaders are used.\n\n    This will cleanup all loaded \"LookLoader\" containers that are unused in\n    the current scene.\n\n    \"\"\"\n\n    host = registered_host()\n\n    unused = []\n    for container in host.ls():\n        if container['loader'] == \"LookLoader\":\n            members = lib.get_container_members(container['objectName'])\n            look_sets = cmds.ls(members, type=\"objectSet\")\n            for look_set in look_sets:\n                # If the set is used than we consider this look *in use*\n                if cmds.sets(look_set, query=True):\n                    break\n            else:\n                unused.append(container)\n\n    for container in unused:\n        log.info(\"Removing unused look container: %s\", container['objectName'])\n        remove_container(container)\n\n    log.info(\"Finished removing unused looks. (see log for details)\")\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/lib.html","title":"lib","text":""},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/lib.html#client.ayon_maya.tools.mayalookassigner.lib.get_look_relationships","title":"<code>get_look_relationships(version_id)</code>","text":"<p>Get relations for the look.</p> <p>Parameters:</p> Name Type Description Default <code>version_id</code> <code>str</code> <p>Parent version Id.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of relations.</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/lib.py</code> <pre><code>def get_look_relationships(version_id: str) -&gt; dict:\n    \"\"\"Get relations for the look.\n\n    Args:\n        version_id (str): Parent version Id.\n\n    Returns:\n        dict: Dictionary of relations.\n    \"\"\"\n\n    project_name = get_current_project_name()\n    json_representation = get_representation_by_name(\n        project_name, \"json\", version_id\n    )\n\n    # Load relationships\n    shader_relation = lib.get_representation_path_by_project(\n        project_name, json_representation\n    )\n    with open(shader_relation, \"r\") as f:\n        relationships = json.load(f)\n\n    return relationships\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/lib.html#client.ayon_maya.tools.mayalookassigner.lib.load_look","title":"<code>load_look(version_id)</code>","text":"<p>Load look from version.</p> <p>Get look from version and invoke Loader for it.</p> <p>Parameters:</p> Name Type Description Default <code>version_id</code> <code>str</code> <p>Version ID</p> required <p>Returns:</p> Type Description <code>tuple[list[str], str]</code> <p>tuple[list[str], str]: List of loaded nodes and container node name.</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/lib.py</code> <pre><code>def load_look(version_id: str) -&gt; tuple[list[str], str]:\n    \"\"\"Load look from version.\n\n    Get look from version and invoke Loader for it.\n\n    Args:\n        version_id (str): Version ID\n\n    Returns:\n        tuple[list[str], str]: List of loaded nodes and container node name.\n\n    \"\"\"\n\n    project_name = get_current_project_name()\n    # Get representations of shader file and relationships\n    look_representation = get_representation_by_name(\n        project_name, \"ma\", version_id\n    )\n\n    # See if representation is already loaded, if so reuse it.\n    host = registered_host()\n    representation_id = look_representation[\"id\"]\n    for container in host.ls():\n        if (container['loader'] == \"LookLoader\" and\n                container['representation'] == representation_id):\n            log.info(\"Reusing loaded look ...\")\n            container_node = container['objectName']\n            break\n    else:\n        log.info(\"Using look for the first time ...\")\n\n        # Load file\n        all_loaders = discover_loader_plugins()\n        loaders = loaders_from_representation(all_loaders, representation_id)\n        loader = next(\n            (i for i in loaders if i.__name__ == \"LookLoader\"), None)\n        if loader is None:\n            raise RuntimeError(\"Could not find LookLoader, this is a bug\")\n\n        # Reference the look file\n        with lib.maintained_selection():\n            container_node = load_container(loader, look_representation)[0]\n\n    return lib.get_container_members(container_node), container_node\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/models.html","title":"models","text":""},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/models.html#client.ayon_maya.tools.mayalookassigner.models.AssetModel","title":"<code>AssetModel</code>","text":"<p>               Bases: <code>TreeModel</code></p> Source code in <code>client/ayon_maya/tools/mayalookassigner/models.py</code> <pre><code>class AssetModel(models.TreeModel):\n\n    Columns = [\"label\"]\n\n    def __init__(self, *args, **kwargs):\n        super(AssetModel, self).__init__(*args, **kwargs)\n\n        self._icon_color = get_default_entity_icon_color()\n\n    def add_items(self, items):\n        \"\"\"\n        Add items to model with needed data\n        Args:\n            items(list): collection of item data\n\n        Returns:\n            None\n        \"\"\"\n\n        self.beginResetModel()\n\n        # Add the items sorted by label\n        def sorter(x):\n            return x[\"label\"]\n\n        for item in sorted(items, key=sorter):\n\n            asset_item = models.Item()\n            asset_item.update(item)\n            asset_item[\"icon\"] = \"folder\"\n\n            # Add namespace children\n            namespaces = item[\"namespaces\"]\n            for namespace in sorted(namespaces):\n                child = models.Item()\n                child.update(item)\n                child.update({\n                    \"label\": (namespace if namespace != \":\"\n                              else \"(no namespace)\"),\n                    \"namespace\": namespace,\n                    \"looks\": item[\"looks\"],\n                    \"icon\": \"folder-o\"\n                })\n                asset_item.add_child(child)\n\n            self.add_child(asset_item)\n\n        self.endResetModel()\n\n    def data(self, index, role):\n\n        if not index.isValid():\n            return\n\n        if role == models.TreeModel.ItemRole:\n            node = index.internalPointer()\n            return node\n\n        # Add icon\n        if role == QtCore.Qt.DecorationRole:\n            if index.column() == 0:\n                node = index.internalPointer()\n                icon = node.get(\"icon\")\n                if icon:\n                    return qtawesome.icon(\n                        \"fa.{0}\".format(icon),\n                        color=self._icon_color\n                    )\n\n        return super(AssetModel, self).data(index, role)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/models.html#client.ayon_maya.tools.mayalookassigner.models.AssetModel.add_items","title":"<code>add_items(items)</code>","text":"<p>Add items to model with needed data Args:     items(list): collection of item data</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/models.py</code> <pre><code>def add_items(self, items):\n    \"\"\"\n    Add items to model with needed data\n    Args:\n        items(list): collection of item data\n\n    Returns:\n        None\n    \"\"\"\n\n    self.beginResetModel()\n\n    # Add the items sorted by label\n    def sorter(x):\n        return x[\"label\"]\n\n    for item in sorted(items, key=sorter):\n\n        asset_item = models.Item()\n        asset_item.update(item)\n        asset_item[\"icon\"] = \"folder\"\n\n        # Add namespace children\n        namespaces = item[\"namespaces\"]\n        for namespace in sorted(namespaces):\n            child = models.Item()\n            child.update(item)\n            child.update({\n                \"label\": (namespace if namespace != \":\"\n                          else \"(no namespace)\"),\n                \"namespace\": namespace,\n                \"looks\": item[\"looks\"],\n                \"icon\": \"folder-o\"\n            })\n            asset_item.add_child(child)\n\n        self.add_child(asset_item)\n\n    self.endResetModel()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/models.html#client.ayon_maya.tools.mayalookassigner.models.LookModel","title":"<code>LookModel</code>","text":"<p>               Bases: <code>TreeModel</code></p> <p>Model displaying a list of looks and matches for assets</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/models.py</code> <pre><code>class LookModel(models.TreeModel):\n    \"\"\"Model displaying a list of looks and matches for assets\"\"\"\n\n    Columns = [\"label\", \"match\"]\n\n    def add_items(self, items):\n        \"\"\"Add items to model with needed data\n\n        An item exists of:\n            {\n                \"product\": 'name of product',\n                \"asset\": asset_document\n            }\n\n        Args:\n            items(list): collection of item data\n\n        Returns:\n            None\n        \"\"\"\n\n        self.beginResetModel()\n\n        # Collect the assets per look name (from the items of the AssetModel)\n        look_products = defaultdict(list)\n        for asset_item in items:\n            folder_entity = asset_item[\"folder_entity\"]\n            for look in asset_item[\"looks\"]:\n                look_products[look[\"name\"]].append(folder_entity)\n\n        for product_name in sorted(look_products.keys()):\n            folder_entities = look_products[product_name]\n\n            # Define nice label without \"look\" prefix for readability\n            label = (\n                product_name\n                if not product_name.startswith(\"look\")\n                else product_name[4:]\n            )\n\n            item_node = models.Item()\n            item_node[\"label\"] = label\n            item_node[\"product\"] = product_name\n\n            # Amount of matching assets for this look\n            item_node[\"match\"] = len(folder_entities)\n\n            # Store the assets that have this product available\n            item_node[\"folder_entities\"] = folder_entities\n\n            self.add_child(item_node)\n\n        self.endResetModel()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/models.html#client.ayon_maya.tools.mayalookassigner.models.LookModel.add_items","title":"<code>add_items(items)</code>","text":"<p>Add items to model with needed data</p> An item exists of <p>{     \"product\": 'name of product',     \"asset\": asset_document }</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list</code> <p>collection of item data</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/models.py</code> <pre><code>def add_items(self, items):\n    \"\"\"Add items to model with needed data\n\n    An item exists of:\n        {\n            \"product\": 'name of product',\n            \"asset\": asset_document\n        }\n\n    Args:\n        items(list): collection of item data\n\n    Returns:\n        None\n    \"\"\"\n\n    self.beginResetModel()\n\n    # Collect the assets per look name (from the items of the AssetModel)\n    look_products = defaultdict(list)\n    for asset_item in items:\n        folder_entity = asset_item[\"folder_entity\"]\n        for look in asset_item[\"looks\"]:\n            look_products[look[\"name\"]].append(folder_entity)\n\n    for product_name in sorted(look_products.keys()):\n        folder_entities = look_products[product_name]\n\n        # Define nice label without \"look\" prefix for readability\n        label = (\n            product_name\n            if not product_name.startswith(\"look\")\n            else product_name[4:]\n        )\n\n        item_node = models.Item()\n        item_node[\"label\"] = label\n        item_node[\"product\"] = product_name\n\n        # Amount of matching assets for this look\n        item_node[\"match\"] = len(folder_entities)\n\n        # Store the assets that have this product available\n        item_node[\"folder_entities\"] = folder_entities\n\n        self.add_child(item_node)\n\n    self.endResetModel()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/usd.html","title":"usd","text":""},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/usd.html#client.ayon_maya.tools.mayalookassigner.usd.get_usd_ids_cache","title":"<code>get_usd_ids_cache(path)</code>","text":"<p>Build a id to node mapping in a USD file.</p> <p>Nodes without IDs are ignored.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Mapping of id to nodes in the USD file.</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/usd.py</code> <pre><code>def get_usd_ids_cache(path):\n    # type: (str) -&gt; dict\n    \"\"\"Build a id to node mapping in a USD file.\n\n    Nodes without IDs are ignored.\n\n    Returns:\n        dict: Mapping of id to nodes in the USD file.\n\n    \"\"\"\n    if not is_usd_lib_supported:\n        raise RuntimeError(\"No pxr.Usd python library available.\")\n\n    stage = Usd.Stage.Open(path)\n    ids = {}\n    for prim in stage.Traverse():\n        attr = prim.GetAttribute(\"userProperties:cbId\")\n        if not attr.IsValid():\n            continue\n        value = attr.Get()\n        if not value:\n            continue\n        path = str(prim.GetPath())\n        ids[path] = value\n\n    cache = defaultdict(list)\n    for path, value in ids.items():\n        cache[value].append(path)\n    return dict(cache)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/views.html","title":"views","text":""},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/views.html#client.ayon_maya.tools.mayalookassigner.views.View","title":"<code>View</code>","text":"<p>               Bases: <code>QTreeView</code></p> Source code in <code>client/ayon_maya/tools/mayalookassigner/views.py</code> <pre><code>class View(QtWidgets.QTreeView):\n    data_changed = QtCore.Signal()\n\n    def __init__(self, parent=None):\n        super(View, self).__init__(parent=parent)\n\n        # view settings\n        self.setAlternatingRowColors(False)\n        self.setSortingEnabled(True)\n        self.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)\n        self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)\n\n    def get_indices(self):\n        \"\"\"Get the selected rows\"\"\"\n        selection_model = self.selectionModel()\n        return selection_model.selectedRows()\n\n    def extend_to_children(self, indices):\n        \"\"\"Extend the indices to the children indices.\n\n        Top-level indices are extended to its children indices. Sub-items\n        are kept as is.\n\n        :param indices: The indices to extend.\n        :type indices: list\n\n        :return: The children indices\n        :rtype: list\n        \"\"\"\n\n        subitems = set()\n        for i in indices:\n            valid_parent = i.parent().isValid()\n            if valid_parent and i not in subitems:\n                subitems.add(i)\n            else:\n                # is top level node\n                model = i.model()\n                rows = model.rowCount(parent=i)\n                for row in range(rows):\n                    child = model.index(row, 0, parent=i)\n                    subitems.add(child)\n\n        return list(subitems)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/views.html#client.ayon_maya.tools.mayalookassigner.views.View.extend_to_children","title":"<code>extend_to_children(indices)</code>","text":"<p>Extend the indices to the children indices.</p> <p>Top-level indices are extended to its children indices. Sub-items are kept as is.</p> <p>:param indices: The indices to extend. :type indices: list</p> <p>:return: The children indices :rtype: list</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/views.py</code> <pre><code>def extend_to_children(self, indices):\n    \"\"\"Extend the indices to the children indices.\n\n    Top-level indices are extended to its children indices. Sub-items\n    are kept as is.\n\n    :param indices: The indices to extend.\n    :type indices: list\n\n    :return: The children indices\n    :rtype: list\n    \"\"\"\n\n    subitems = set()\n    for i in indices:\n        valid_parent = i.parent().isValid()\n        if valid_parent and i not in subitems:\n            subitems.add(i)\n        else:\n            # is top level node\n            model = i.model()\n            rows = model.rowCount(parent=i)\n            for row in range(rows):\n                child = model.index(row, 0, parent=i)\n                subitems.add(child)\n\n    return list(subitems)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/views.html#client.ayon_maya.tools.mayalookassigner.views.View.get_indices","title":"<code>get_indices()</code>","text":"<p>Get the selected rows</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/views.py</code> <pre><code>def get_indices(self):\n    \"\"\"Get the selected rows\"\"\"\n    selection_model = self.selectionModel()\n    return selection_model.selectedRows()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/vray_proxies.html","title":"vray_proxies","text":"<p>Tools for loading looks to vray proxies.</p>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/vray_proxies.html#client.ayon_maya.tools.mayalookassigner.vray_proxies.assign_vrayproxy_shaders","title":"<code>assign_vrayproxy_shaders(vrayproxy, assignments)</code>","text":"<p>Assign shaders to content of Vray Proxy.</p> <p>This will create shader overrides on Vray Proxy to assign shaders to its content.</p> Todo <p>Allow to optimize and assign a single shader to multiple shapes at once or maybe even set it to the highest available path?</p> <p>Parameters:</p> Name Type Description Default <code>vrayproxy</code> <code>str</code> <p>Name of Vray Proxy</p> required <code>assignments</code> <code>dict</code> <p>Mapping of shader assignments.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/vray_proxies.py</code> <pre><code>def assign_vrayproxy_shaders(vrayproxy, assignments):\n    # type: (str, dict) -&gt; None\n    \"\"\"Assign shaders to content of Vray Proxy.\n\n    This will create shader overrides on Vray Proxy to assign shaders to its\n    content.\n\n    Todo:\n        Allow to optimize and assign a single shader to multiple shapes at\n        once or maybe even set it to the highest available path?\n\n    Args:\n        vrayproxy (str): Name of Vray Proxy\n        assignments (dict): Mapping of shader assignments.\n\n    Returns:\n        None\n\n    \"\"\"\n    # Clear all current shader assignments\n    plug = vrayproxy + \".shaders\"\n    num = cmds.getAttr(plug, size=True)\n    for i in reversed(range(num)):\n        cmds.removeMultiInstance(\"{}[{}]\".format(plug, i), b=True)\n\n    # Create new assignment overrides\n    index = 0\n    for material, paths in assignments.items():\n        for path in paths:\n            plug = \"{}.shaders[{}]\".format(vrayproxy, index)\n            cmds.setAttr(plug + \".shadersNames\", path, type=\"string\")\n            cmds.connectAttr(material + \".outColor\",\n                             plug + \".shadersConnections\", force=True)\n            index += 1\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/vray_proxies.html#client.ayon_maya.tools.mayalookassigner.vray_proxies.vrayproxy_assign_look","title":"<code>vrayproxy_assign_look(vrayproxy, product_name='lookMain')</code>","text":"<p>Assign look to vray proxy.</p> <p>Parameters:</p> Name Type Description Default <code>vrayproxy</code> <code>str</code> <p>Name of vrayproxy to apply look to.</p> required <code>product_name</code> <code>str</code> <p>Name of look product.</p> <code>'lookMain'</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/vray_proxies.py</code> <pre><code>def vrayproxy_assign_look(vrayproxy, product_name=\"lookMain\"):\n    # type: (str, str) -&gt; None\n    \"\"\"Assign look to vray proxy.\n\n    Args:\n        vrayproxy (str): Name of vrayproxy to apply look to.\n        product_name (str): Name of look product.\n\n    Returns:\n        None\n\n    \"\"\"\n    path = cmds.getAttr(vrayproxy + \".fileName\")\n\n    nodes_by_id = get_alembic_ids_cache(path)\n    if not nodes_by_id:\n        log.warning(\"Alembic file has no cbId attributes: %s\" % path)\n        return\n\n    # Group by asset id so we run over the look per asset\n    node_ids_by_asset_id = defaultdict(set)\n    for node_id in nodes_by_id:\n        folder_id = node_id.split(\":\", 1)[0]\n        node_ids_by_asset_id[folder_id].add(node_id)\n\n    project_name = get_current_project_name()\n    for folder_id, node_ids in node_ids_by_asset_id.items():\n\n        # Get latest look version\n        version_entity = ayon_api.get_last_version_by_product_name(\n            project_name,\n            product_name,\n            folder_id,\n            fields={\"id\"}\n        )\n        if not version_entity:\n            print(\"Didn't find last version for product name {}\".format(\n                product_name\n            ))\n            continue\n        version_id = version_entity[\"id\"]\n\n        relationships = lib.get_look_relationships(version_id)\n        shadernodes, _ = lib.load_look(version_id)\n\n        # Get only the node ids and paths related to this asset\n        # And get the shader edits the look supplies\n        asset_nodes_by_id = {\n            node_id: nodes_by_id[node_id] for node_id in node_ids\n        }\n        edits = list(\n            maya_lib.iter_shader_edits(\n                relationships, shadernodes, asset_nodes_by_id\n            )\n        )\n\n        # Create assignments\n        assignments = {}\n        for edit in edits:\n            if edit[\"action\"] == \"assign\":\n                nodes = edit[\"nodes\"]\n                shader = edit[\"shader\"]\n                if not cmds.ls(shader, type=\"shadingEngine\"):\n                    print(\"Skipping non-shader: %s\" % shader)\n                    continue\n\n                inputs = cmds.listConnections(\n                    shader + \".surfaceShader\", source=True)\n                if not inputs:\n                    print(\"Shading engine missing material: %s\" % shader)\n\n                # Strip off component assignments\n                for i, node in enumerate(nodes):\n                    if \".\" in node:\n                        log.warning(\n                            (\"Converting face assignment to full object \"\n                             \"assignment. This conversion can be lossy: \"\n                             \"{}\").format(node))\n                        nodes[i] = node.split(\".\")[0]\n\n                material = inputs[0]\n                assignments[material] = nodes\n\n        assign_vrayproxy_shaders(vrayproxy, assignments)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/widgets.html","title":"widgets","text":""},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/widgets.html#client.ayon_maya.tools.mayalookassigner.widgets.AssetOutliner","title":"<code>AssetOutliner</code>","text":"<p>               Bases: <code>QWidget</code></p> Source code in <code>client/ayon_maya/tools/mayalookassigner/widgets.py</code> <pre><code>class AssetOutliner(QtWidgets.QWidget):\n    refreshed = QtCore.Signal()\n    selection_changed = QtCore.Signal()\n\n    def __init__(self, parent=None):\n        super(AssetOutliner, self).__init__(parent)\n\n        title = QtWidgets.QLabel(\"Assets\", self)\n        title.setAlignment(QtCore.Qt.AlignCenter)\n        title.setStyleSheet(\"font-weight: bold; font-size: 12px\")\n\n        model = AssetModel()\n        view = View(self)\n        view.setModel(model)\n        view.customContextMenuRequested.connect(self.right_mouse_menu)\n        view.setSortingEnabled(False)\n        view.setHeaderHidden(True)\n        view.setIndentation(10)\n\n        from_all_asset_btn = QtWidgets.QPushButton(\n            \"Get All Assets\", self\n        )\n        from_selection_btn = QtWidgets.QPushButton(\n            \"Get Assets From Selection\", self\n        )\n\n        layout = QtWidgets.QVBoxLayout(self)\n        layout.addWidget(title)\n        layout.addWidget(from_all_asset_btn)\n        layout.addWidget(from_selection_btn)\n        layout.addWidget(view)\n\n        # Build connections\n        from_selection_btn.clicked.connect(self.get_selected_assets)\n        from_all_asset_btn.clicked.connect(self.get_all_assets)\n\n        selection_model = view.selectionModel()\n        selection_model.selectionChanged.connect(self.selection_changed)\n\n        self.view = view\n        self.model = model\n\n        self.log = logging.getLogger(__name__)\n\n    def clear(self):\n        self.model.clear()\n\n        # fix looks remaining visible when no items present after \"refresh\"\n        # todo: figure out why this workaround is needed.\n        self.selection_changed.emit()\n\n    def add_items(self, items):\n        \"\"\"Add new items to the outliner\"\"\"\n\n        self.model.add_items(items)\n        self.refreshed.emit()\n\n    def get_selected_items(self):\n        \"\"\"Get current selected items from view\n\n        Returns:\n            list: list of dictionaries\n        \"\"\"\n\n        selection_model = self.view.selectionModel()\n        return [row.data(TreeModel.ItemRole)\n                for row in selection_model.selectedRows(0)]\n\n    def get_all_assets(self):\n        \"\"\"Add all items from the current scene\"\"\"\n\n        with preserve_expanded_rows(self.view):\n            with preserve_selection(self.view):\n                self.clear()\n                nodes = commands.get_all_asset_nodes()\n                items = commands.create_items_from_nodes(nodes)\n                self.add_items(items)\n                return len(items) &gt; 0\n\n    def get_selected_assets(self):\n        \"\"\"Add all selected items from the current scene\"\"\"\n\n        with preserve_expanded_rows(self.view):\n            with preserve_selection(self.view):\n                self.clear()\n                nodes = commands.get_selected_nodes()\n                items = commands.create_items_from_nodes(nodes)\n                self.add_items(items)\n\n    def get_nodes(self, selection=False):\n        \"\"\"Find the nodes in the current scene per folder.\"\"\"\n\n        items = self.get_selected_items()\n\n        # Collect all nodes by hash (optimization)\n        if not selection:\n            nodes = cmds.ls(dag=True, long=True)\n        else:\n            nodes = commands.get_selected_nodes()\n        id_nodes = commands.create_folder_id_hash(nodes)\n\n        # Collect the asset item entries per folder\n        # and collect the namespaces we'd like to apply\n        folder_items = {}\n        namespaces_by_folder_path = defaultdict(set)\n        for item in items:\n            folder_entity = item[\"folder_entity\"]\n            folder_id = folder_entity[\"id\"]\n            folder_path = folder_entity[\"path\"]\n            namespaces_by_folder_path[folder_path].add(item.get(\"namespace\"))\n\n            if folder_path in folder_items:\n                continue\n\n            folder_items[folder_path] = item\n            folder_items[folder_path][\"nodes\"] = id_nodes.get(folder_id, [])\n\n        # Filter nodes to namespace (if only namespaces were selected)\n        for folder_path in folder_items:\n            namespaces = namespaces_by_folder_path[folder_path]\n\n            # When None is present there should be no filtering\n            if None in namespaces:\n                continue\n\n            # Else only namespaces are selected and *not* the top entry so\n            # we should filter to only those namespaces.\n            nodes = folder_items[folder_path][\"nodes\"]\n            nodes = [node for node in nodes if\n                     commands.get_namespace_from_node(node) in namespaces]\n            folder_items[folder_path][\"nodes\"] = nodes\n\n        return folder_items\n\n    def select_asset_from_items(self):\n        \"\"\"Select nodes from listed asset\"\"\"\n\n        items = self.get_nodes(selection=False)\n        nodes = []\n        for item in items.values():\n            nodes.extend(item[\"nodes\"])\n\n        commands.select(nodes)\n\n    def right_mouse_menu(self, pos):\n        \"\"\"Build RMB menu for asset outliner\"\"\"\n\n        active = self.view.currentIndex()  # index under mouse\n        active = active.sibling(active.row(), 0)  # get first column\n        globalpos = self.view.viewport().mapToGlobal(pos)\n\n        menu = QtWidgets.QMenu(self.view)\n\n        # Direct assignment\n        apply_action = QtWidgets.QAction(menu, text=\"Select nodes\")\n        apply_action.triggered.connect(self.select_asset_from_items)\n\n        if not active.isValid():\n            apply_action.setEnabled(False)\n\n        menu.addAction(apply_action)\n\n        menu.exec_(globalpos)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/widgets.html#client.ayon_maya.tools.mayalookassigner.widgets.AssetOutliner.add_items","title":"<code>add_items(items)</code>","text":"<p>Add new items to the outliner</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/widgets.py</code> <pre><code>def add_items(self, items):\n    \"\"\"Add new items to the outliner\"\"\"\n\n    self.model.add_items(items)\n    self.refreshed.emit()\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/widgets.html#client.ayon_maya.tools.mayalookassigner.widgets.AssetOutliner.get_all_assets","title":"<code>get_all_assets()</code>","text":"<p>Add all items from the current scene</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/widgets.py</code> <pre><code>def get_all_assets(self):\n    \"\"\"Add all items from the current scene\"\"\"\n\n    with preserve_expanded_rows(self.view):\n        with preserve_selection(self.view):\n            self.clear()\n            nodes = commands.get_all_asset_nodes()\n            items = commands.create_items_from_nodes(nodes)\n            self.add_items(items)\n            return len(items) &gt; 0\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/widgets.html#client.ayon_maya.tools.mayalookassigner.widgets.AssetOutliner.get_nodes","title":"<code>get_nodes(selection=False)</code>","text":"<p>Find the nodes in the current scene per folder.</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/widgets.py</code> <pre><code>def get_nodes(self, selection=False):\n    \"\"\"Find the nodes in the current scene per folder.\"\"\"\n\n    items = self.get_selected_items()\n\n    # Collect all nodes by hash (optimization)\n    if not selection:\n        nodes = cmds.ls(dag=True, long=True)\n    else:\n        nodes = commands.get_selected_nodes()\n    id_nodes = commands.create_folder_id_hash(nodes)\n\n    # Collect the asset item entries per folder\n    # and collect the namespaces we'd like to apply\n    folder_items = {}\n    namespaces_by_folder_path = defaultdict(set)\n    for item in items:\n        folder_entity = item[\"folder_entity\"]\n        folder_id = folder_entity[\"id\"]\n        folder_path = folder_entity[\"path\"]\n        namespaces_by_folder_path[folder_path].add(item.get(\"namespace\"))\n\n        if folder_path in folder_items:\n            continue\n\n        folder_items[folder_path] = item\n        folder_items[folder_path][\"nodes\"] = id_nodes.get(folder_id, [])\n\n    # Filter nodes to namespace (if only namespaces were selected)\n    for folder_path in folder_items:\n        namespaces = namespaces_by_folder_path[folder_path]\n\n        # When None is present there should be no filtering\n        if None in namespaces:\n            continue\n\n        # Else only namespaces are selected and *not* the top entry so\n        # we should filter to only those namespaces.\n        nodes = folder_items[folder_path][\"nodes\"]\n        nodes = [node for node in nodes if\n                 commands.get_namespace_from_node(node) in namespaces]\n        folder_items[folder_path][\"nodes\"] = nodes\n\n    return folder_items\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/widgets.html#client.ayon_maya.tools.mayalookassigner.widgets.AssetOutliner.get_selected_assets","title":"<code>get_selected_assets()</code>","text":"<p>Add all selected items from the current scene</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/widgets.py</code> <pre><code>def get_selected_assets(self):\n    \"\"\"Add all selected items from the current scene\"\"\"\n\n    with preserve_expanded_rows(self.view):\n        with preserve_selection(self.view):\n            self.clear()\n            nodes = commands.get_selected_nodes()\n            items = commands.create_items_from_nodes(nodes)\n            self.add_items(items)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/widgets.html#client.ayon_maya.tools.mayalookassigner.widgets.AssetOutliner.get_selected_items","title":"<code>get_selected_items()</code>","text":"<p>Get current selected items from view</p> <p>Returns:</p> Name Type Description <code>list</code> <p>list of dictionaries</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/widgets.py</code> <pre><code>def get_selected_items(self):\n    \"\"\"Get current selected items from view\n\n    Returns:\n        list: list of dictionaries\n    \"\"\"\n\n    selection_model = self.view.selectionModel()\n    return [row.data(TreeModel.ItemRole)\n            for row in selection_model.selectedRows(0)]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/widgets.html#client.ayon_maya.tools.mayalookassigner.widgets.AssetOutliner.right_mouse_menu","title":"<code>right_mouse_menu(pos)</code>","text":"<p>Build RMB menu for asset outliner</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/widgets.py</code> <pre><code>def right_mouse_menu(self, pos):\n    \"\"\"Build RMB menu for asset outliner\"\"\"\n\n    active = self.view.currentIndex()  # index under mouse\n    active = active.sibling(active.row(), 0)  # get first column\n    globalpos = self.view.viewport().mapToGlobal(pos)\n\n    menu = QtWidgets.QMenu(self.view)\n\n    # Direct assignment\n    apply_action = QtWidgets.QAction(menu, text=\"Select nodes\")\n    apply_action.triggered.connect(self.select_asset_from_items)\n\n    if not active.isValid():\n        apply_action.setEnabled(False)\n\n    menu.addAction(apply_action)\n\n    menu.exec_(globalpos)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/widgets.html#client.ayon_maya.tools.mayalookassigner.widgets.AssetOutliner.select_asset_from_items","title":"<code>select_asset_from_items()</code>","text":"<p>Select nodes from listed asset</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/widgets.py</code> <pre><code>def select_asset_from_items(self):\n    \"\"\"Select nodes from listed asset\"\"\"\n\n    items = self.get_nodes(selection=False)\n    nodes = []\n    for item in items.values():\n        nodes.extend(item[\"nodes\"])\n\n    commands.select(nodes)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/widgets.html#client.ayon_maya.tools.mayalookassigner.widgets.LookOutliner","title":"<code>LookOutliner</code>","text":"<p>               Bases: <code>QWidget</code></p> Source code in <code>client/ayon_maya/tools/mayalookassigner/widgets.py</code> <pre><code>class LookOutliner(QtWidgets.QWidget):\n    menu_apply_action = QtCore.Signal()\n\n    def __init__(self, parent=None):\n        super(LookOutliner, self).__init__(parent)\n\n        # Looks from database\n        title = QtWidgets.QLabel(\"Looks\", self)\n        title.setAlignment(QtCore.Qt.AlignCenter)\n        title.setStyleSheet(\"font-weight: bold; font-size: 12px\")\n        title.setAlignment(QtCore.Qt.AlignCenter)\n\n        model = LookModel()\n\n        # Proxy for dynamic sorting\n        proxy = QtCore.QSortFilterProxyModel()\n        proxy.setSourceModel(model)\n\n        view = View(self)\n        view.setModel(proxy)\n        view.setMinimumHeight(180)\n        view.setToolTip(\"Use right mouse button menu for direct actions\")\n        view.customContextMenuRequested.connect(self.right_mouse_menu)\n        view.sortByColumn(0, QtCore.Qt.AscendingOrder)\n\n        # look manager layout\n        layout = QtWidgets.QVBoxLayout(self)\n        layout.setContentsMargins(0, 0, 0, 0)\n        layout.setSpacing(10)\n        layout.addWidget(title)\n        layout.addWidget(view)\n\n        self.view = view\n        self.model = model\n\n    def clear(self):\n        self.model.clear()\n\n    def add_items(self, items):\n        self.model.add_items(items)\n\n    def get_selected_items(self):\n        \"\"\"Get current selected items from view\n\n        Returns:\n            list: list of dictionaries\n        \"\"\"\n\n        items = [i.data(TreeModel.ItemRole) for i in self.view.get_indices()]\n        return [item for item in items if item is not None]\n\n    def right_mouse_menu(self, pos):\n        \"\"\"Build RMB menu for look view\"\"\"\n\n        active = self.view.currentIndex()  # index under mouse\n        active = active.sibling(active.row(), 0)  # get first column\n        globalpos = self.view.viewport().mapToGlobal(pos)\n\n        if not active.isValid():\n            return\n\n        menu = QtWidgets.QMenu(self.view)\n\n        # Direct assignment\n        apply_action = QtWidgets.QAction(menu, text=\"Assign looks..\")\n        apply_action.triggered.connect(self.menu_apply_action)\n\n        menu.addAction(apply_action)\n\n        menu.exec_(globalpos)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/widgets.html#client.ayon_maya.tools.mayalookassigner.widgets.LookOutliner.get_selected_items","title":"<code>get_selected_items()</code>","text":"<p>Get current selected items from view</p> <p>Returns:</p> Name Type Description <code>list</code> <p>list of dictionaries</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/widgets.py</code> <pre><code>def get_selected_items(self):\n    \"\"\"Get current selected items from view\n\n    Returns:\n        list: list of dictionaries\n    \"\"\"\n\n    items = [i.data(TreeModel.ItemRole) for i in self.view.get_indices()]\n    return [item for item in items if item is not None]\n</code></pre>"},{"location":"autoapi/client/ayon_maya/tools/mayalookassigner/widgets.html#client.ayon_maya.tools.mayalookassigner.widgets.LookOutliner.right_mouse_menu","title":"<code>right_mouse_menu(pos)</code>","text":"<p>Build RMB menu for look view</p> Source code in <code>client/ayon_maya/tools/mayalookassigner/widgets.py</code> <pre><code>def right_mouse_menu(self, pos):\n    \"\"\"Build RMB menu for look view\"\"\"\n\n    active = self.view.currentIndex()  # index under mouse\n    active = active.sibling(active.row(), 0)  # get first column\n    globalpos = self.view.viewport().mapToGlobal(pos)\n\n    if not active.isValid():\n        return\n\n    menu = QtWidgets.QMenu(self.view)\n\n    # Direct assignment\n    apply_action = QtWidgets.QAction(menu, text=\"Assign looks..\")\n    apply_action.triggered.connect(self.menu_apply_action)\n\n    menu.addAction(apply_action)\n\n    menu.exec_(globalpos)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/vendor/index.html","title":"vendor","text":""},{"location":"autoapi/client/ayon_maya/vendor/python/index.html","title":"python","text":""},{"location":"autoapi/client/ayon_maya/vendor/python/capture.html","title":"capture","text":"<p>Maya Capture</p> <p>Playblasting with independent viewport, camera and display options</p>"},{"location":"autoapi/client/ayon_maya/vendor/python/capture.html#client.ayon_maya.vendor.python.capture.apply_scene","title":"<code>apply_scene(**options)</code>","text":"<p>Apply options from scene</p> Example <p>apply_scene({\"start_frame\": 1009})</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>dict</code> <p>Scene options</p> <code>{}</code> Source code in <code>client/ayon_maya/vendor/python/capture.py</code> <pre><code>def apply_scene(**options):\n    \"\"\"Apply options from scene\n\n    Example:\n        &gt;&gt;&gt; apply_scene({\"start_frame\": 1009})\n\n    Arguments:\n        options (dict): Scene options\n\n    \"\"\"\n\n    if \"start_frame\" in options:\n        cmds.playbackOptions(minTime=options[\"start_frame\"])\n\n    if \"end_frame\" in options:\n        cmds.playbackOptions(maxTime=options[\"end_frame\"])\n\n    if \"width\" in options:\n        _safe_setAttr(\"defaultResolution.width\", options[\"width\"])\n\n    if \"height\" in options:\n        _safe_setAttr(\"defaultResolution.height\", options[\"height\"])\n\n    if \"compression\" in options:\n        cmds.optionVar(\n            stringValue=[\"playblastCompression\", options[\"compression\"]])\n\n    if \"filename\" in options:\n        cmds.optionVar(\n            stringValue=[\"playblastFile\", options[\"filename\"]])\n\n    if \"format\" in options:\n        cmds.optionVar(\n            stringValue=[\"playblastFormat\", options[\"format\"]])\n\n    if \"off_screen\" in options:\n        cmds.optionVar(\n            intValue=[\"playblastFormat\", options[\"off_screen\"]])\n\n    if \"show_ornaments\" in options:\n        cmds.optionVar(\n            intValue=[\"show_ornaments\", options[\"show_ornaments\"]])\n\n    if \"quality\" in options:\n        cmds.optionVar(\n            floatValue=[\"playblastQuality\", options[\"quality\"]])\n</code></pre>"},{"location":"autoapi/client/ayon_maya/vendor/python/capture.html#client.ayon_maya.vendor.python.capture.apply_view","title":"<code>apply_view(panel, **options)</code>","text":"<p>Apply options to panel</p> Source code in <code>client/ayon_maya/vendor/python/capture.py</code> <pre><code>def apply_view(panel, **options):\n    \"\"\"Apply options to panel\"\"\"\n\n    camera = cmds.modelPanel(panel, camera=True, query=True)\n\n    # Display options\n    display_options = options.get(\"display_options\", {})\n    _iteritems = getattr(display_options, \"iteritems\", display_options.items)\n    for key, value in _iteritems():\n        if key in _DisplayOptionsRGB:\n            cmds.displayRGBColor(key, *value)\n        else:\n            cmds.displayPref(**{key: value})\n\n    # Camera options\n    camera_options = options.get(\"camera_options\", {})\n    _iteritems = getattr(camera_options, \"iteritems\", camera_options.items)\n    for key, value in _iteritems:\n        _safe_setAttr(\"{0}.{1}\".format(camera, key), value)\n\n    # Viewport options\n    viewport_options = options.get(\"viewport_options\", {})\n    _iteritems = getattr(viewport_options, \"iteritems\", viewport_options.items)\n    for key, value in _iteritems():\n        cmds.modelEditor(panel, edit=True, **{key: value})\n\n    viewport2_options = options.get(\"viewport2_options\", {})\n    _iteritems = getattr(\n        viewport2_options, \"iteritems\", viewport2_options.items\n    )\n    for key, value in _iteritems():\n        attr = \"hardwareRenderingGlobals.{0}\".format(key)\n        _safe_setAttr(attr, value)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/vendor/python/capture.html#client.ayon_maya.vendor.python.capture.capture","title":"<code>capture(camera=None, width=None, height=None, filename=None, start_frame=None, end_frame=None, frame=None, format='qt', compression='H.264', quality=100, off_screen=False, viewer=True, show_ornaments=True, sound=None, isolate=None, maintain_aspect_ratio=True, overwrite=False, frame_padding=4, raw_frame_numbers=False, camera_options=None, display_options=None, viewport_options=None, viewport2_options=None, complete_filename=None, log=None)</code>","text":"<p>Playblast in an independent panel</p> <p>Parameters:</p> Name Type Description Default <code>camera</code> <code>str</code> <p>Name of camera, defaults to \"persp\"</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of output in pixels</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of output in pixels</p> <code>None</code> <code>filename</code> <code>str</code> <p>Name of output file. If none is specified, no files are saved.</p> <code>None</code> <code>start_frame</code> <code>float</code> <p>Defaults to current start frame.</p> <code>None</code> <code>end_frame</code> <code>float</code> <p>Defaults to current end frame.</p> <code>None</code> <code>frame</code> <code>float or tuple</code> <p>A single frame or list of frames. Use this to capture a single frame or an arbitrary sequence of frames.</p> <code>None</code> <code>format</code> <code>str</code> <p>Name of format, defaults to \"qt\".</p> <code>'qt'</code> <code>compression</code> <code>str</code> <p>Name of compression, defaults to \"H.264\"</p> <code>'H.264'</code> <code>quality</code> <code>int</code> <p>The quality of the output, defaults to 100</p> <code>100</code> <code>off_screen</code> <code>bool</code> <p>Whether or not to playblast off screen</p> <code>False</code> <code>viewer</code> <code>bool</code> <p>Display results in native player</p> <code>True</code> <code>show_ornaments</code> <code>bool</code> <p>Whether or not model view ornaments (e.g. axis icon, grid and HUD) should be displayed.</p> <code>True</code> <code>sound</code> <code>str</code> <p>Specify the sound node to be used during playblast. When None (default) no sound will be used.</p> <code>None</code> <code>isolate</code> <code>list</code> <p>List of nodes to isolate upon capturing</p> <code>None</code> <code>maintain_aspect_ratio</code> <code>bool</code> <p>Modify height in order to maintain aspect ratio.</p> <code>True</code> <code>overwrite</code> <code>bool</code> <p>Whether or not to overwrite if file already exists. If disabled and file exists and error will be raised.</p> <code>False</code> <code>frame_padding</code> <code>bool</code> <p>Number of zeros used to pad file name for image sequences.</p> <code>4</code> <code>raw_frame_numbers</code> <code>bool</code> <p>Whether or not to use the exact frame numbers from the scene or capture to a sequence starting at zero. Defaults to False. When set to True <code>viewer</code> can't be used and will be forced to False.</p> <code>False</code> <code>camera_options</code> <code>dict</code> <p>Supplied camera options, using <code>CameraOptions</code></p> <code>None</code> <code>display_options</code> <code>dict</code> <p>Supplied display options, using <code>DisplayOptions</code></p> <code>None</code> <code>viewport_options</code> <code>dict</code> <p>Supplied viewport options, using <code>ViewportOptions</code></p> <code>None</code> <code>viewport2_options</code> <code>dict</code> <p>Supplied display options, using <code>Viewport2Options</code></p> <code>None</code> <code>complete_filename</code> <code>str</code> <p>Exact name of output file. Use this to override the output of <code>filename</code> so it excludes frame padding.</p> <code>None</code> <code>log</code> <code>logger</code> <p>pass logger for logging messages.</p> <code>None</code> Example Source code in <code>client/ayon_maya/vendor/python/capture.py</code> <pre><code>def capture(camera=None,\n            width=None,\n            height=None,\n            filename=None,\n            start_frame=None,\n            end_frame=None,\n            frame=None,\n            format='qt',\n            compression='H.264',\n            quality=100,\n            off_screen=False,\n            viewer=True,\n            show_ornaments=True,\n            sound=None,\n            isolate=None,\n            maintain_aspect_ratio=True,\n            overwrite=False,\n            frame_padding=4,\n            raw_frame_numbers=False,\n            camera_options=None,\n            display_options=None,\n            viewport_options=None,\n            viewport2_options=None,\n            complete_filename=None,\n            log=None):\n    \"\"\"Playblast in an independent panel\n\n    Arguments:\n        camera (str, optional): Name of camera, defaults to \"persp\"\n        width (int, optional): Width of output in pixels\n        height (int, optional): Height of output in pixels\n        filename (str, optional): Name of output file. If\n            none is specified, no files are saved.\n        start_frame (float, optional): Defaults to current start frame.\n        end_frame (float, optional): Defaults to current end frame.\n        frame (float or tuple, optional): A single frame or list of frames.\n            Use this to capture a single frame or an arbitrary sequence of\n            frames.\n        format (str, optional): Name of format, defaults to \"qt\".\n        compression (str, optional): Name of compression, defaults to \"H.264\"\n        quality (int, optional): The quality of the output, defaults to 100\n        off_screen (bool, optional): Whether or not to playblast off screen\n        viewer (bool, optional): Display results in native player\n        show_ornaments (bool, optional): Whether or not model view ornaments\n            (e.g. axis icon, grid and HUD) should be displayed.\n        sound (str, optional):  Specify the sound node to be used during\n            playblast. When None (default) no sound will be used.\n        isolate (list): List of nodes to isolate upon capturing\n        maintain_aspect_ratio (bool, optional): Modify height in order to\n            maintain aspect ratio.\n        overwrite (bool, optional): Whether or not to overwrite if file\n            already exists. If disabled and file exists and error will be\n            raised.\n        frame_padding (bool, optional): Number of zeros used to pad file name\n            for image sequences.\n        raw_frame_numbers (bool, optional): Whether or not to use the exact\n            frame numbers from the scene or capture to a sequence starting at\n            zero. Defaults to False. When set to True `viewer` can't be used\n            and will be forced to False.\n        camera_options (dict, optional): Supplied camera options,\n            using `CameraOptions`\n        display_options (dict, optional): Supplied display\n            options, using `DisplayOptions`\n        viewport_options (dict, optional): Supplied viewport\n            options, using `ViewportOptions`\n        viewport2_options (dict, optional): Supplied display\n            options, using `Viewport2Options`\n        complete_filename (str, optional): Exact name of output file. Use this\n            to override the output of `filename` so it excludes frame padding.\n        log (logger, optional): pass logger for logging messages.\n\n    Example:\n        &gt;&gt;&gt; # Launch default capture\n        &gt;&gt;&gt; capture()\n        &gt;&gt;&gt; # Launch capture with custom viewport settings\n        &gt;&gt;&gt; capture('persp', 800, 600,\n        ...         viewport_options={\n        ...             \"displayAppearance\": \"wireframe\",\n        ...             \"grid\": False,\n        ...             \"polymeshes\": True,\n        ...         },\n        ...         camera_options={\n        ...             \"displayResolution\": True\n        ...         }\n        ... )\n\n\n    \"\"\"\n    global logger\n    if log:\n        logger = log\n    camera = camera or \"persp\"\n\n    # Ensure camera exists\n    if not cmds.objExists(camera):\n        raise RuntimeError(\"Camera does not exist: {0}\".format(camera))\n\n    if width and height :\n        maintain_aspect_ratio = False\n    width = width or cmds.getAttr(\"defaultResolution.width\")\n    height = height or cmds.getAttr(\"defaultResolution.height\")\n    if maintain_aspect_ratio:\n        ratio = cmds.getAttr(\"defaultResolution.deviceAspectRatio\")\n        height = round(width / ratio)\n\n    if start_frame is None:\n        start_frame = cmds.playbackOptions(minTime=True, query=True)\n    if end_frame is None:\n        end_frame = cmds.playbackOptions(maxTime=True, query=True)\n\n    # (#74) Bugfix: `maya.cmds.playblast` will raise an error when playblasting\n    # with `rawFrameNumbers` set to True but no explicit `frames` provided.\n    # Since we always know what frames will be included we can provide it\n    # explicitly\n    if raw_frame_numbers and frame is None:\n        frame = range(int(start_frame), int(end_frame) + 1)\n\n    # We need to wrap `completeFilename`, otherwise even when None is provided\n    # it will use filename as the exact name. Only when lacking as argument\n    # does it function correctly.\n    playblast_kwargs = dict()\n    if complete_filename:\n        playblast_kwargs['completeFilename'] = complete_filename\n    if frame is not None:\n        playblast_kwargs['frame'] = frame\n    if sound is not None:\n        playblast_kwargs['sound'] = sound\n\n    # We need to raise an error when the user gives a custom frame range with\n    # negative frames in combination with raw frame numbers. This will result\n    # in a minimal integer frame number : filename.-2147483648.png for any\n    # negative rendered frame\n    if frame and raw_frame_numbers:\n        check = frame if isinstance(frame, (list, tuple)) else [frame]\n        if any(f &lt; 0 for f in check):\n            raise RuntimeError(\"Negative frames are not supported with \"\n                               \"raw frame numbers and explicit frame numbers\")\n\n    # (#21) Bugfix: `maya.cmds.playblast` suffers from undo bug where it\n    # always sets the currentTime to frame 1. By setting currentTime before\n    # the playblast call it'll undo correctly.\n    cmds.currentTime(cmds.currentTime(query=True))\n\n    padding = 10  # Extend panel to accommodate for OS window manager\n\n    with _independent_panel(width=width + padding,\n                            height=height + padding,\n                            off_screen=off_screen) as panel:\n        cmds.setFocus(panel)\n\n        all_playblast_kwargs = {\n            \"compression\": compression,\n            \"format\": format,\n            \"percent\": 100,\n            \"quality\": quality,\n            \"viewer\": viewer,\n            \"startTime\": start_frame,\n            \"endTime\": end_frame,\n            \"offScreen\": off_screen,\n            \"showOrnaments\": show_ornaments,\n            \"forceOverwrite\": overwrite,\n            \"filename\": filename,\n            \"widthHeight\": [width, height],\n            \"rawFrameNumbers\": raw_frame_numbers,\n            \"framePadding\": frame_padding\n        }\n        all_playblast_kwargs.update(playblast_kwargs)\n\n        if getattr(contextlib, \"nested\", None):\n            with contextlib.nested(\n                _disabled_inview_messages(),\n                _maintain_camera(panel, camera),\n                _applied_viewport_options(viewport_options, panel),\n                _applied_camera_options(camera_options, panel),\n                _applied_display_options(display_options),\n                _applied_viewport2_options(viewport2_options),\n                _isolated_nodes(isolate, panel),\n                _maintained_time()\n            ):\n                output = cmds.playblast(**all_playblast_kwargs)\n        else:\n            with contextlib.ExitStack() as stack:\n                stack.enter_context(_disabled_inview_messages())\n                stack.enter_context(_maintain_camera(panel, camera))\n                stack.enter_context(\n                    _applied_viewport_options(viewport_options, panel)\n                )\n                stack.enter_context(\n                    _applied_camera_options(camera_options, panel)\n                )\n                stack.enter_context(\n                    _applied_display_options(display_options)\n                )\n                stack.enter_context(\n                    _applied_viewport2_options(viewport2_options)\n                )\n                stack.enter_context(_isolated_nodes(isolate, panel))\n                stack.enter_context(_maintained_time())\n\n                output = cmds.playblast(**all_playblast_kwargs)\n\n        return output\n</code></pre>"},{"location":"autoapi/client/ayon_maya/vendor/python/capture.html#client.ayon_maya.vendor.python.capture.capture--launch-default-capture","title":"Launch default capture","text":"<p>capture()</p>"},{"location":"autoapi/client/ayon_maya/vendor/python/capture.html#client.ayon_maya.vendor.python.capture.capture--launch-capture-with-custom-viewport-settings","title":"Launch capture with custom viewport settings","text":"<p>capture('persp', 800, 600, ...         viewport_options={ ...             \"displayAppearance\": \"wireframe\", ...             \"grid\": False, ...             \"polymeshes\": True, ...         }, ...         camera_options={ ...             \"displayResolution\": True ...         } ... )</p>"},{"location":"autoapi/client/ayon_maya/vendor/python/capture.html#client.ayon_maya.vendor.python.capture.parse_active_panel","title":"<code>parse_active_panel()</code>","text":"<p>Parse the active modelPanel.</p> <p>Raises     RuntimeError: When no active modelPanel an error is raised.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Name of modelPanel</p> Source code in <code>client/ayon_maya/vendor/python/capture.py</code> <pre><code>def parse_active_panel():\n    \"\"\"Parse the active modelPanel.\n\n    Raises\n        RuntimeError: When no active modelPanel an error is raised.\n\n    Returns:\n        str: Name of modelPanel\n\n    \"\"\"\n\n    panel = cmds.getPanel(withFocus=True)\n\n    # This happens when last focus was on panel\n    # that got deleted (e.g. `capture()` then `parse_active_view()`)\n    if not panel or \"modelPanel\" not in panel:\n        raise RuntimeError(\"No active model panel found\")\n\n    return panel\n</code></pre>"},{"location":"autoapi/client/ayon_maya/vendor/python/capture.html#client.ayon_maya.vendor.python.capture.parse_active_scene","title":"<code>parse_active_scene()</code>","text":"<p>Parse active scene for arguments for capture()</p> <p>*Resolution taken from render settings.</p> Source code in <code>client/ayon_maya/vendor/python/capture.py</code> <pre><code>def parse_active_scene():\n    \"\"\"Parse active scene for arguments for capture()\n\n    *Resolution taken from render settings.\n\n    \"\"\"\n\n    time_control = mel.eval(\"$gPlayBackSlider = $gPlayBackSlider\")\n\n    return {\n        \"start_frame\": cmds.playbackOptions(minTime=True, query=True),\n        \"end_frame\": cmds.playbackOptions(maxTime=True, query=True),\n        \"width\": cmds.getAttr(\"defaultResolution.width\"),\n        \"height\": cmds.getAttr(\"defaultResolution.height\"),\n        \"compression\": cmds.optionVar(query=\"playblastCompression\"),\n        \"filename\": (cmds.optionVar(query=\"playblastFile\")\n                     if cmds.optionVar(query=\"playblastSaveToFile\") else None),\n        \"format\": cmds.optionVar(query=\"playblastFormat\"),\n        \"off_screen\": (True if cmds.optionVar(query=\"playblastOffscreen\")\n                       else False),\n        \"show_ornaments\": (True if cmds.optionVar(query=\"playblastShowOrnaments\")\n                       else False),\n        \"quality\": cmds.optionVar(query=\"playblastQuality\"),\n        \"sound\": cmds.timeControl(time_control, q=True, sound=True) or None\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_maya/vendor/python/capture.html#client.ayon_maya.vendor.python.capture.parse_active_view","title":"<code>parse_active_view()</code>","text":"<p>Parse the current settings from the active view</p> Source code in <code>client/ayon_maya/vendor/python/capture.py</code> <pre><code>def parse_active_view():\n    \"\"\"Parse the current settings from the active view\"\"\"\n    panel = parse_active_panel()\n    return parse_view(panel)\n</code></pre>"},{"location":"autoapi/client/ayon_maya/vendor/python/capture.html#client.ayon_maya.vendor.python.capture.parse_view","title":"<code>parse_view(panel)</code>","text":"<p>Parse the scene, panel and camera for their current settings</p> Example <p>parse_view(\"modelPanel1\")</p> <p>Parameters:</p> Name Type Description Default <code>panel</code> <code>str</code> <p>Name of modelPanel</p> required Source code in <code>client/ayon_maya/vendor/python/capture.py</code> <pre><code>def parse_view(panel):\n    \"\"\"Parse the scene, panel and camera for their current settings\n\n    Example:\n        &gt;&gt;&gt; parse_view(\"modelPanel1\")\n\n    Arguments:\n        panel (str): Name of modelPanel\n\n    \"\"\"\n\n    camera = cmds.modelPanel(panel, query=True, camera=True)\n\n    # Display options\n    display_options = {}\n    for key in DisplayOptions:\n        if key in _DisplayOptionsRGB:\n            display_options[key] = cmds.displayRGBColor(key, query=True)\n        else:\n            display_options[key] = cmds.displayPref(query=True, **{key: True})\n\n    # Camera options\n    camera_options = {}\n    for key in CameraOptions:\n        camera_options[key] = cmds.getAttr(\"{0}.{1}\".format(camera, key))\n\n    # Viewport options\n    viewport_options = {}\n\n    # capture plugin display filters first to ensure we never override\n    # built-in arguments if ever possible a plugin has similarly named\n    # plugin display filters (which it shouldn't!)\n    plugins = cmds.pluginDisplayFilter(query=True, listFilters=True)\n    for plugin in plugins:\n        plugin = str(plugin)  # unicode-&gt;str for simplicity of the dict\n        state = cmds.modelEditor(panel, query=True, queryPluginObjects=plugin)\n        viewport_options[plugin] = state\n\n    for key in ViewportOptions:\n        viewport_options[key] = cmds.modelEditor(\n            panel, query=True, **{key: True})\n\n    viewport2_options = {}\n    for key in Viewport2Options.keys():\n        attr = \"hardwareRenderingGlobals.{0}\".format(key)\n        try:\n            viewport2_options[key] = cmds.getAttr(attr)\n        except ValueError:\n            continue\n\n    return {\n        \"camera\": camera,\n        \"display_options\": display_options,\n        \"camera_options\": camera_options,\n        \"viewport_options\": viewport_options,\n        \"viewport2_options\": viewport2_options\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_maya/vendor/python/capture.html#client.ayon_maya.vendor.python.capture.snap","title":"<code>snap(*args, **kwargs)</code>","text":"<p>Single frame playblast in an independent panel.</p> <p>The arguments of <code>capture</code> are all valid here as well, except for <code>start_frame</code> and <code>end_frame</code>.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>float</code> <p>The frame to snap. If not provided current frame is used.</p> required <code>clipboard</code> <code>bool</code> <p>Whether to add the output image to the global clipboard. This allows to easily paste the snapped image into another application, eg. into Photoshop.</p> required Keywords <p>See <code>capture</code>.</p> Source code in <code>client/ayon_maya/vendor/python/capture.py</code> <pre><code>def snap(*args, **kwargs):\n    \"\"\"Single frame playblast in an independent panel.\n\n    The arguments of `capture` are all valid here as well, except for\n    `start_frame` and `end_frame`.\n\n    Arguments:\n        frame (float, optional): The frame to snap. If not provided current\n            frame is used.\n        clipboard (bool, optional): Whether to add the output image to the\n            global clipboard. This allows to easily paste the snapped image\n            into another application, eg. into Photoshop.\n\n    Keywords:\n        See `capture`.\n\n    \"\"\"\n\n    # capture single frame\n    frame = kwargs.pop('frame', cmds.currentTime(q=1))\n    kwargs['start_frame'] = frame\n    kwargs['end_frame'] = frame\n    kwargs['frame'] = frame\n\n    if not isinstance(frame, (int, float)):\n        raise TypeError(\"frame must be a single frame (integer or float). \"\n                        \"Use `capture()` for sequences.\")\n\n    # override capture defaults\n    format = kwargs.pop('format', \"image\")\n    compression = kwargs.pop('compression', \"png\")\n    viewer = kwargs.pop('viewer', False)\n    raw_frame_numbers = kwargs.pop('raw_frame_numbers', True)\n    kwargs['compression'] = compression\n    kwargs['format'] = format\n    kwargs['viewer'] = viewer\n    kwargs['raw_frame_numbers'] = raw_frame_numbers\n\n    # pop snap only keyword arguments\n    clipboard = kwargs.pop('clipboard', False)\n\n    # perform capture\n    output = capture(*args, **kwargs)\n\n    def replace(m):\n        \"\"\"Substitute # with frame number\"\"\"\n        return str(int(frame)).zfill(len(m.group()))\n\n    output = re.sub(\"#+\", replace, output)\n\n    # add image to clipboard\n    if clipboard:\n        _image_to_clipboard(output)\n\n    return output\n</code></pre>"},{"location":"autoapi/server/index.html","title":"server","text":"<p>Maya Addon Module</p>"},{"location":"autoapi/server/settings/index.html","title":"settings","text":""},{"location":"autoapi/server/settings/conversion.html","title":"conversion","text":""},{"location":"autoapi/server/settings/creators.html","title":"creators","text":""},{"location":"autoapi/server/settings/dirmap.html","title":"dirmap","text":""},{"location":"autoapi/server/settings/dirmap.html#server.settings.dirmap.DirmapModel","title":"<code>DirmapModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Maya dirmap settings.</p> Source code in <code>server/settings/dirmap.py</code> <pre><code>class DirmapModel(BaseSettingsModel):\n    \"\"\"Maya dirmap settings.\"\"\"\n    # _layout = \"expanded\"\n    _isGroup: bool = True\n\n    enabled: bool = SettingsField(title=\"enabled\")\n    # Use ${} placeholder instead of absolute value of a root in\n    #   referenced filepaths.\n    use_env_var_as_root: bool = SettingsField(\n        title=\"Use env var placeholder in referenced paths\"\n    )\n    paths: DirmapPathsSubmodel = SettingsField(\n        default_factory=DirmapPathsSubmodel,\n        title=\"Dirmap Paths\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/explicit_plugins_loading.html","title":"explicit_plugins_loading","text":""},{"location":"autoapi/server/settings/explicit_plugins_loading.html#server.settings.explicit_plugins_loading.ExplicitPluginsLoadingModel","title":"<code>ExplicitPluginsLoadingModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Maya Explicit Plugins Loading.</p> Source code in <code>server/settings/explicit_plugins_loading.py</code> <pre><code>class ExplicitPluginsLoadingModel(BaseSettingsModel):\n    \"\"\"Maya Explicit Plugins Loading.\"\"\"\n    _isGroup: bool = True\n    enabled: bool = SettingsField(title=\"enabled\")\n    plugins_to_load: list[PluginsModel] = SettingsField(\n        default_factory=list, title=\"Plugins To Load\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/imageio.html","title":"imageio","text":"<p>Providing models and setting values for image IO in Maya.</p> <p>Note: Names were changed to get rid of the versions in class names.</p>"},{"location":"autoapi/server/settings/imageio.html#server.settings.imageio.ImageIOSettings","title":"<code>ImageIOSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Maya color management project settings.</p> Source code in <code>server/settings/imageio.py</code> <pre><code>class ImageIOSettings(BaseSettingsModel):\n    \"\"\"Maya color management project settings.\"\"\"\n\n    _isGroup: bool = True\n    activate_host_color_management: bool = SettingsField(\n        True, title=\"Enable Color Management\"\n    )\n    file_rules: ImageIOFileRulesModel = SettingsField(\n        default_factory=ImageIOFileRulesModel,\n        title=\"File Rules\"\n    )\n    workfile: WorkfileImageIOModel = SettingsField(\n        default_factory=WorkfileImageIOModel,\n        title=\"Workfile\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/include_handles.html","title":"include_handles","text":""},{"location":"autoapi/server/settings/include_handles.html#server.settings.include_handles.IncludeHandlesModel","title":"<code>IncludeHandlesModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Maya dirmap settings.</p> Source code in <code>server/settings/include_handles.py</code> <pre><code>class IncludeHandlesModel(BaseSettingsModel):\n    \"\"\"Maya dirmap settings.\"\"\"\n    # _layout = \"expanded\"\n    include_handles_default: bool = SettingsField(\n        True, title=\"Include handles by default\"\n    )\n    per_task_type: list[IncludeByTaskTypeModel] = SettingsField(\n        default_factory=list,\n        title=\"Include/exclude handles by task type\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/loaders.html","title":"loaders","text":""},{"location":"autoapi/server/settings/main.html","title":"main","text":""},{"location":"autoapi/server/settings/main.html#server.settings.main.MayaSettings","title":"<code>MayaSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Maya Project Settings.</p> Source code in <code>server/settings/main.py</code> <pre><code>class MayaSettings(BaseSettingsModel):\n    \"\"\"Maya Project Settings.\"\"\"\n\n    use_cbid_workflow: bool = SettingsField(\n        True, title=\"Use cbId workflow\",\n        description=(\n            \"When enabled, a per node `cbId` identifier will be created and \"\n            \"validated for many product types. This is then used for look \"\n            \"publishing and many others. By disabling this, the `cbId` \"\n            \"attribute will still be created on scene save but it will not \"\n            \"be validated.\"))\n\n    open_workfile_post_initialization: bool = SettingsField(\n        True, title=\"Open Workfile Post Initialization\")\n    explicit_plugins_loading: ExplicitPluginsLoadingModel = SettingsField(\n        default_factory=ExplicitPluginsLoadingModel,\n        title=\"Explicit Plugins Loading\")\n    imageio: ImageIOSettings = SettingsField(\n        default_factory=ImageIOSettings, title=\"Color Management (imageio)\")\n    mel_workspace: str = SettingsField(\n        title=\"Maya MEL Workspace\", widget=\"textarea\"\n    )\n    ext_mapping: list[ExtMappingItemModel] = SettingsField(\n        default_factory=list, title=\"Extension Mapping\")\n    scene_units: UnitScaleModel = SettingsField(\n        default_factory=UnitScaleModel,\n        title=\"Scene Units\",\n        description=\"Set preferred Maya Scene Units\"\n    )\n    dirmap: DirmapModel = SettingsField(\n        default_factory=DirmapModel, title=\"Maya dirmap Settings\")\n    include_handles: IncludeHandlesModel = SettingsField(\n        default_factory=IncludeHandlesModel,\n        title=\"Include/Exclude Handles in default playback &amp; render range\"\n    )\n    scriptsmenu: ScriptsmenuModel = SettingsField(\n        default_factory=ScriptsmenuModel,\n        title=\"Scriptsmenu Settings\"\n    )\n    render_settings: RenderSettingsModel = SettingsField(\n        default_factory=RenderSettingsModel, title=\"Render Settings\")\n    create: CreatorsModel = SettingsField(\n        default_factory=CreatorsModel, title=\"Creators\")\n    publish: PublishersModel = SettingsField(\n        default_factory=PublishersModel, title=\"Publishers\")\n    load: LoadersModel = SettingsField(\n        default_factory=LoadersModel, title=\"Loaders\")\n    workfile_build: ProfilesModel = SettingsField(\n        default_factory=ProfilesModel, title=\"Workfile Build Settings\")\n    templated_workfile_build: TemplatedProfilesModel = SettingsField(\n        default_factory=TemplatedProfilesModel,\n        title=\"Templated Workfile Build Settings\")\n\n    @validator(\"ext_mapping\")\n    def validate_unique_outputs(cls, value):\n        ensure_unique_names(value)\n        return value\n</code></pre>"},{"location":"autoapi/server/settings/main.html#server.settings.main.angular_unit_enum","title":"<code>angular_unit_enum()</code>","text":"<p>Get angular units enumerator.</p> Source code in <code>server/settings/main.py</code> <pre><code>def angular_unit_enum():\n    \"\"\"Get angular units enumerator.\"\"\"\n    return [\n        {\"label\": \"degree\", \"value\": \"deg\"},\n        {\"label\": \"radian\", \"value\": \"rad\"},\n    ]\n</code></pre>"},{"location":"autoapi/server/settings/main.html#server.settings.main.linear_unit_enum","title":"<code>linear_unit_enum()</code>","text":"<p>Get linear units enumerator.</p> Source code in <code>server/settings/main.py</code> <pre><code>def linear_unit_enum():\n    \"\"\"Get linear units enumerator.\"\"\"\n    return [\n        {\"label\": \"millimeter\", \"value\": \"mm\"},\n        {\"label\": \"centimeter\", \"value\": \"cm\"},\n        {\"label\": \"meter\", \"value\": \"m\"},\n        {\"label\": \"kilometer\", \"value\": \"km\"},\n        {\"label\": \"inch\", \"value\": \"in\"},\n        {\"label\": \"foot\", \"value\": \"ft\"},\n        {\"label\": \"yard\", \"value\": \"yd\"},\n        {\"label\": \"mile\", \"value\": \"mi\"}\n    ]\n</code></pre>"},{"location":"autoapi/server/settings/publish_playblast.html","title":"publish_playblast","text":""},{"location":"autoapi/server/settings/publishers.html","title":"publishers","text":""},{"location":"autoapi/server/settings/publishers.html#server.settings.publishers.ExtractMayaSceneRawModel","title":"<code>ExtractMayaSceneRawModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Add loaded instances to those published families:</p> Source code in <code>server/settings/publishers.py</code> <pre><code>class ExtractMayaSceneRawModel(BaseSettingsModel):\n    \"\"\"Add loaded instances to those published families:\"\"\"\n    enabled: bool = SettingsField(title=\"ExtractMayaSceneRaw\")\n    add_for_families: list[str] = SettingsField(\n        default_factory=list, title=\"Families\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/publishers.html#server.settings.publishers.ValidateMeshUVSetMap1Model","title":"<code>ValidateMeshUVSetMap1Model</code>","text":"<p>               Bases: <code>BasicValidateModel</code></p> <p>Validate model's default uv set exists and is named 'map1'.</p> Source code in <code>server/settings/publishers.py</code> <pre><code>class ValidateMeshUVSetMap1Model(BasicValidateModel):\n    \"\"\"Validate model's default uv set exists and is named 'map1'.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/server/settings/publishers.html#server.settings.publishers.ValidateNoAnimationModel","title":"<code>ValidateNoAnimationModel</code>","text":"<p>               Bases: <code>BasicValidateModel</code></p> <p>Ensure no keyframes on nodes in the Instance.</p> Source code in <code>server/settings/publishers.py</code> <pre><code>class ValidateNoAnimationModel(BasicValidateModel):\n    \"\"\"Ensure no keyframes on nodes in the Instance.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/server/settings/publishers.html#server.settings.publishers.ValidatePluginPathAttributesModel","title":"<code>ValidatePluginPathAttributesModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Fill in the node types and attributes you want to validate.</p> <p>e.g. AlembicNode.abc_file, the node type is AlembicNode and the node attribute is abc_file Source code in <code>server/settings/publishers.py</code> <pre><code>class ValidatePluginPathAttributesModel(BaseSettingsModel):\n    \"\"\"Fill in the node types and attributes you want to validate.\n\n    &lt;p&gt;e.g. &lt;b&gt;AlembicNode.abc_file&lt;/b&gt;, the node type is &lt;b&gt;AlembicNode&lt;/b&gt;\n    and the node attribute is &lt;b&gt;abc_file&lt;/b&gt;\n    \"\"\"\n\n    enabled: bool = SettingsField(title=\"Enabled\")\n    optional: bool = SettingsField(title=\"Optional\")\n    active: bool = SettingsField(title=\"Active\")\n    attribute: list[ValidatePluginPathAttributesAttrModel] = SettingsField(\n        default_factory=list,\n        title=\"File Attribute\"\n    )\n\n    @validator(\"attribute\")\n    def validate_unique_outputs(cls, value):\n        ensure_unique_names(value)\n        return value\n</code></pre>"},{"location":"autoapi/server/settings/publishers.html#server.settings.publishers.ValidateShaderNameModel","title":"<code>ValidateShaderNameModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Shader name regex can use named capture group asset to validate against current asset name.</p> Source code in <code>server/settings/publishers.py</code> <pre><code>class ValidateShaderNameModel(BaseSettingsModel):\n    \"\"\"\n    Shader name regex can use named capture group asset to validate against current asset name.\n    \"\"\"\n    enabled: bool = SettingsField(title=\"ValidateShaderName\")\n    optional: bool = SettingsField(title=\"Optional\")\n    active: bool = SettingsField(title=\"Active\")\n    regex: str = SettingsField(\n        \"(?P&lt;asset&gt;.*)_(.*)_SHD\",\n        title=\"Validation regex\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/publishers.html#server.settings.publishers.up_axis_enum","title":"<code>up_axis_enum()</code>","text":"<p>Get Up Axis enumerator.</p> Source code in <code>server/settings/publishers.py</code> <pre><code>def up_axis_enum():\n    \"\"\"Get Up Axis enumerator.\"\"\"\n    return [\n        {\"label\": \"y\", \"value\": \"y\"},\n        {\"label\": \"z\", \"value\": \"z\"},\n    ]\n</code></pre>"},{"location":"autoapi/server/settings/render_settings.html","title":"render_settings","text":"<p>Providing models and values for Maya Render Settings.</p>"},{"location":"autoapi/server/settings/render_settings.html#server.settings.render_settings.AdditionalOptionsModel","title":"<code>AdditionalOptionsModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Additional Option</p> Source code in <code>server/settings/render_settings.py</code> <pre><code>class AdditionalOptionsModel(BaseSettingsModel):\n    \"\"\"Additional Option\"\"\"\n    _layout = \"compact\"\n\n    attribute: str = SettingsField(\"\", title=\"Attribute name\")\n    value: str = SettingsField(\"\", title=\"Value\")\n</code></pre>"},{"location":"autoapi/server/settings/render_settings.html#server.settings.render_settings.arnold_aov_list_enum","title":"<code>arnold_aov_list_enum()</code>","text":"<p>Return enumerator for Arnold AOVs.</p> Key is value, Value in this case is Label. This <p>was taken from v3 settings.</p> Source code in <code>server/settings/render_settings.py</code> <pre><code>def arnold_aov_list_enum():\n    \"\"\"Return enumerator for Arnold AOVs.\n\n    Note: Key is value, Value in this case is Label. This\n        was taken from v3 settings.\n    \"\"\"\n    return [\n        {\"value\": \"empty\", \"label\": \"&lt; empty &gt;\"},\n        {\"value\": \"ID\", \"label\": \"ID\"},\n        {\"value\": \"N\", \"label\": \"N\"},\n        {\"value\": \"P\", \"label\": \"P\"},\n        {\"value\": \"Pref\", \"label\": \"Pref\"},\n        {\"value\": \"RGBA\", \"label\": \"RGBA\"},\n        {\"value\": \"Z\", \"label\": \"Z\"},\n        {\"value\": \"albedo\", \"label\": \"albedo\"},\n        {\"value\": \"background\", \"label\": \"background\"},\n        {\"value\": \"coat\", \"label\": \"coat\"},\n        {\"value\": \"coat_albedo\", \"label\": \"coat_albedo\"},\n        {\"value\": \"coat_direct\", \"label\": \"coat_direct\"},\n        {\"value\": \"coat_indirect\", \"label\": \"coat_indirect\"},\n        {\"value\": \"cputime\", \"label\": \"cputime\"},\n        {\"value\": \"crypto_asset\", \"label\": \"crypto_asset\"},\n        {\"value\": \"crypto_material\", \"label\": \"cypto_material\"},\n        {\"value\": \"crypto_object\", \"label\": \"crypto_object\"},\n        {\"value\": \"diffuse\", \"label\": \"diffuse\"},\n        {\"value\": \"diffuse_albedo\", \"label\": \"diffuse_albedo\"},\n        {\"value\": \"diffuse_direct\", \"label\": \"diffuse_direct\"},\n        {\"value\": \"diffuse_indirect\", \"label\": \"diffuse_indirect\"},\n        {\"value\": \"direct\", \"label\": \"direct\"},\n        {\"value\": \"emission\", \"label\": \"emission\"},\n        {\"value\": \"highlight\", \"label\": \"highlight\"},\n        {\"value\": \"indirect\", \"label\": \"indirect\"},\n        {\"value\": \"motionvector\", \"label\": \"motionvector\"},\n        {\"value\": \"opacity\", \"label\": \"opacity\"},\n        {\"value\": \"raycount\", \"label\": \"raycount\"},\n        {\"value\": \"rim_light\", \"label\": \"rim_light\"},\n        {\"value\": \"shadow\", \"label\": \"shadow\"},\n        {\"value\": \"shadow_diff\", \"label\": \"shadow_diff\"},\n        {\"value\": \"shadow_mask\", \"label\": \"shadow_mask\"},\n        {\"value\": \"shadow_matte\", \"label\": \"shadow_matte\"},\n        {\"value\": \"sheen\", \"label\": \"sheen\"},\n        {\"value\": \"sheen_albedo\", \"label\": \"sheen_albedo\"},\n        {\"value\": \"sheen_direct\", \"label\": \"sheen_direct\"},\n        {\"value\": \"sheen_indirect\", \"label\": \"sheen_indirect\"},\n        {\"value\": \"specular\", \"label\": \"specular\"},\n        {\"value\": \"specular_albedo\", \"label\": \"specular_albedo\"},\n        {\"value\": \"specular_direct\", \"label\": \"specular_direct\"},\n        {\"value\": \"specular_indirect\", \"label\": \"specular_indirect\"},\n        {\"value\": \"sss\", \"label\": \"sss\"},\n        {\"value\": \"sss_albedo\", \"label\": \"sss_albedo\"},\n        {\"value\": \"sss_direct\", \"label\": \"sss_direct\"},\n        {\"value\": \"sss_indirect\", \"label\": \"sss_indirect\"},\n        {\"value\": \"transmission\", \"label\": \"transmission\"},\n        {\"value\": \"transmission_albedo\", \"label\": \"transmission_albedo\"},\n        {\"value\": \"transmission_direct\", \"label\": \"transmission_direct\"},\n        {\"value\": \"transmission_indirect\", \"label\": \"transmission_indirect\"},\n        {\"value\": \"volume\", \"label\": \"volume\"},\n        {\"value\": \"volume_Z\", \"label\": \"volume_Z\"},\n        {\"value\": \"volume_albedo\", \"label\": \"volume_albedo\"},\n        {\"value\": \"volume_direct\", \"label\": \"volume_direct\"},\n        {\"value\": \"volume_indirect\", \"label\": \"volume_indirect\"},\n        {\"value\": \"volume_opacity\", \"label\": \"volume_opacity\"},\n    ]\n</code></pre>"},{"location":"autoapi/server/settings/render_settings.html#server.settings.render_settings.arnold_image_format_enum","title":"<code>arnold_image_format_enum()</code>","text":"<p>Return enumerator for Arnold output formats.</p> Source code in <code>server/settings/render_settings.py</code> <pre><code>def arnold_image_format_enum():\n    \"\"\"Return enumerator for Arnold output formats.\"\"\"\n    return [\n        {\"label\": \"jpeg\", \"value\": \"jpeg\"},\n        {\"label\": \"png\", \"value\": \"png\"},\n        {\"label\": \"deepexr\", \"value\": \"deep exr\"},\n        {\"label\": \"tif\", \"value\": \"tif\"},\n        {\"label\": \"exr\", \"value\": \"exr\"},\n        {\"label\": \"maya\", \"value\": \"maya\"},\n        {\"label\": \"mtoa_shaders\", \"value\": \"mtoa_shaders\"}\n    ]\n</code></pre>"},{"location":"autoapi/server/settings/render_settings.html#server.settings.render_settings.redshift_aov_list_enum","title":"<code>redshift_aov_list_enum()</code>","text":"<p>Return enumerator for Redshift AOVs.</p> <p>*Tested in Redshift 3.6.03</p> Source code in <code>server/settings/render_settings.py</code> <pre><code>def redshift_aov_list_enum():\n    \"\"\"Return enumerator for Redshift AOVs.\n\n    *Tested in Redshift 3.6.03\n    \"\"\"\n    return [\n        {\"value\": \"Ambient Occlusion\", \"label\": \"Ambient Occlusion\"},\n        {\"value\": \"Background\", \"label\": \"Background\"},\n        {\"value\": \"Beauty\", \"label\": \"Beauty\"},\n        {\"value\": \"Bump Normals\", \"label\": \"Bump Normals\"},\n        {\"value\": \"Caustics\", \"label\": \"Caustics\"},\n        {\"value\": \"Caustics Raw\", \"label\": \"Caustics Raw\"},\n        {\"value\": \"Cryptomatte\", \"label\": \"Cryptomatte\"},\n        {\"value\": \"Custom\", \"label\": \"Custom\"},\n        {\"value\": \"Depth\", \"label\": \"Depth\"},\n        {\"value\": \"Diffuse Filter\", \"label\": \"Diffuse Filter\"},\n        {\"value\": \"Diffuse Lighting\", \"label\": \"Diffuse Lighting\"},\n        {\"value\": \"Diffuse Lighting Raw\", \"label\": \"Diffuse Lighting Raw\"},\n        {\"value\": \"Emission\", \"label\": \"Emission\"},\n        {\"value\": \"Global Illumination\", \"label\": \"Global Illumination\"},\n        {\"value\": \"Global Illumination Raw\",\n         \"label\": \"Global Illumination Raw\"},\n        {\"value\": \"Matte\", \"label\": \"Matte\"},\n        {\"value\": \"Motion Vectors\", \"label\": \"Motion Vectors\"},\n        {\"value\": \"Normals\", \"label\": \"Normals\"},\n        {\"value\": \"ObjectID\", \"label\": \"ObjectID\"},\n        {\"value\": \"Object-Space Bump Normals\",\n         \"label\": \"Object-Space Bump Normals\"},\n        {\"value\": \"Object-Space Positions\",\n         \"label\": \"Object-Space Positions\"},\n        {\"value\": \"Puzzle Matte\", \"label\": \"Puzzle Matte\"},\n        {\"value\": \"Reflections\", \"label\": \"Reflections\"},\n        {\"value\": \"Reflections Filter\", \"label\": \"Reflections Filter\"},\n        {\"value\": \"Reflections Raw\", \"label\": \"Reflections Raw\"},\n        {\"value\": \"Refractions\", \"label\": \"Refractions\"},\n        {\"value\": \"Refractions Filter\", \"label\": \"Refractions Filter\"},\n        {\"value\": \"Refractions Raw\", \"label\": \"Refractions Raw\"},\n        {\"value\": \"Shadows\", \"label\": \"Shadows\"},\n        {\"value\": \"Specular Lighting\", \"label\": \"Specular Lighting\"},\n        {\"value\": \"Sub Surface Scatter\", \"label\": \"Sub Surface Scatter\"},\n        {\"value\": \"Sub Surface Scatter Raw\",\n         \"label\": \"Sub Surface Scatter Raw\"},\n        {\"value\": \"Total Diffuse Lighting Raw\",\n         \"label\": \"Total Diffuse Lighting Raw\"},\n        {\"value\": \"Total Translucency Lighting Raw\",\n         \"label\": \"Total Translucency Lighting Raw\"},\n        {\"value\": \"Translucency Filter\", \"label\": \"Translucency Filter\"},\n        {\"value\": \"Translucency Lighting Raw\",\n         \"label\": \"Translucency Lighting Raw\"},\n        {\"value\": \"Volume Fog Emission\", \"label\": \"Volume Fog Emission\"},\n        {\"value\": \"Volume Fog Tint\", \"label\": \"Volume Fog Tint\"},\n        {\"value\": \"Volume Lighting\", \"label\": \"Volume Lighting\"},\n        {\"value\": \"World Position\", \"label\": \"World Position\"},\n    ]\n</code></pre>"},{"location":"autoapi/server/settings/render_settings.html#server.settings.render_settings.redshift_image_output_enum","title":"<code>redshift_image_output_enum()</code>","text":"<p>Return output format for Redshift enumerator.</p> Source code in <code>server/settings/render_settings.py</code> <pre><code>def redshift_image_output_enum():\n    \"\"\"Return output format for Redshift enumerator.\"\"\"\n    return [\n        {\"value\": \"iff\", \"label\": \"Maya IFF\"},\n        {\"value\": \"exr\", \"label\": \"OpenEXR\"},\n        {\"value\": \"tif\", \"label\": \"TIFF\"},\n        {\"value\": \"png\", \"label\": \"PNG\"},\n        {\"value\": \"tga\", \"label\": \"Targa\"},\n        {\"value\": \"jpg\", \"label\": \"JPEG\"}\n    ]\n</code></pre>"},{"location":"autoapi/server/settings/render_settings.html#server.settings.render_settings.redshift_primary_gi_engine_enum","title":"<code>redshift_primary_gi_engine_enum()</code>","text":"<p>Get Redshift engine type enumerator.</p> Source code in <code>server/settings/render_settings.py</code> <pre><code>def redshift_primary_gi_engine_enum():\n    \"\"\"Get Redshift engine type enumerator.\"\"\"\n    return [\n        {\"value\": \"0\", \"label\": \"None\"},\n        {\"value\": \"3\", \"label\": \"Irradiance Cache\"},\n        {\"value\": \"4\", \"label\": \"Brute Force\"}\n    ]\n</code></pre>"},{"location":"autoapi/server/settings/render_settings.html#server.settings.render_settings.redshift_secondary_gi_engine_enum","title":"<code>redshift_secondary_gi_engine_enum()</code>","text":"<p>Get Redshift engine type enumerator.</p> Source code in <code>server/settings/render_settings.py</code> <pre><code>def redshift_secondary_gi_engine_enum():\n    \"\"\"Get Redshift engine type enumerator.\"\"\"\n    return [\n        {\"value\": \"0\", \"label\": \"None\"},\n        {\"value\": \"2\", \"label\": \"Irradiance Point Cloud\"},\n        {\"value\": \"4\", \"label\": \"Brute Force\"}\n    ]\n</code></pre>"},{"location":"autoapi/server/settings/render_settings.html#server.settings.render_settings.vray_aov_list_enum","title":"<code>vray_aov_list_enum()</code>","text":"<p>Return enumerator for Vray AOVs.</p> Key is value, Value in this case is Label. This <p>was taken from v3 settings.</p> Source code in <code>server/settings/render_settings.py</code> <pre><code>def vray_aov_list_enum():\n    \"\"\"Return enumerator for Vray AOVs.\n\n    Note: Key is value, Value in this case is Label. This\n        was taken from v3 settings.\n    \"\"\"\n\n    return [\n        {\"value\": \"empty\", \"label\": \"&lt; empty &gt;\"},\n        {\"value\": \"atmosphereChannel\", \"label\": \"atmosphere\"},\n        {\"value\": \"backgroundChannel\", \"label\": \"background\"},\n        {\"value\": \"bumpNormalsChannel\", \"label\": \"bumpnormals\"},\n        {\"value\": \"causticsChannel\", \"label\": \"caustics\"},\n        {\"value\": \"coatFilterChannel\", \"label\": \"coat_filter\"},\n        {\"value\": \"coatGlossinessChannel\", \"label\": \"coatGloss\"},\n        {\"value\": \"coatReflectionChannel\", \"label\": \"coat_reflection\"},\n        {\"value\": \"vrayCoatChannel\", \"label\": \"coat_specular\"},\n        {\"value\": \"CoverageChannel\", \"label\": \"coverage\"},\n        {\"value\": \"cryptomatteChannel\", \"label\": \"cryptomatte\"},\n        {\"value\": \"customColor\", \"label\": \"custom_color\"},\n        {\"value\": \"drBucketChannel\", \"label\": \"DR\"},\n        {\"value\": \"denoiserChannel\", \"label\": \"denoiser\"},\n        {\"value\": \"diffuseChannel\", \"label\": \"diffuse\"},\n        {\"value\": \"ExtraTexElement\", \"label\": \"extraTex\"},\n        {\"value\": \"giChannel\", \"label\": \"GI\"},\n        {\"value\": \"LightMixElement\", \"label\": \"None\"},\n        {\"value\": \"lightingChannel\", \"label\": \"lighting\"},\n        {\"value\": \"LightingAnalysisChannel\", \"label\": \"LightingAnalysis\"},\n        {\"value\": \"materialIDChannel\", \"label\": \"materialID\"},\n        {\"value\": \"MaterialSelectElement\", \"label\": \"materialSelect\"},\n        {\"value\": \"matteShadowChannel\", \"label\": \"matteShadow\"},\n        {\"value\": \"MultiMatteElement\", \"label\": \"multimatte\"},\n        {\"value\": \"multimatteIDChannel\", \"label\": \"multimatteID\"},\n        {\"value\": \"normalsChannel\", \"label\": \"normals\"},\n        {\"value\": \"nodeIDChannel\", \"label\": \"objectId\"},\n        {\"value\": \"objectSelectChannel\", \"label\": \"objectSelect\"},\n        {\"value\": \"rawCoatFilterChannel\", \"label\": \"raw_coat_filter\"},\n        {\"value\": \"rawCoatReflectionChannel\", \"label\": \"raw_coat_reflection\"},\n        {\"value\": \"rawDiffuseFilterChannel\", \"label\": \"rawDiffuseFilter\"},\n        {\"value\": \"rawGiChannel\", \"label\": \"rawGI\"},\n        {\"value\": \"rawLightChannel\", \"label\": \"rawLight\"},\n        {\"value\": \"rawReflectionChannel\", \"label\": \"rawReflection\"},\n        {\n            \"value\": \"rawReflectionFilterChannel\",\n            \"label\": \"rawReflectionFilter\"\n        },\n        {\"value\": \"rawRefractionChannel\", \"label\": \"rawRefraction\"},\n        {\n            \"value\": \"rawRefractionFilterChannel\",\n            \"label\": \"rawRefractionFilter\"\n        },\n        {\"value\": \"rawShadowChannel\", \"label\": \"rawShadow\"},\n        {\"value\": \"rawSheenFilterChannel\", \"label\": \"raw_sheen_filter\"},\n        {\n            \"value\": \"rawSheenReflectionChannel\",\n            \"label\": \"raw_sheen_reflection\"\n        },\n        {\"value\": \"rawTotalLightChannel\", \"label\": \"rawTotalLight\"},\n        {\"value\": \"reflectIORChannel\", \"label\": \"reflIOR\"},\n        {\"value\": \"reflectChannel\", \"label\": \"reflect\"},\n        {\"value\": \"reflectionFilterChannel\", \"label\": \"reflectionFilter\"},\n        {\"value\": \"reflectGlossinessChannel\", \"label\": \"reflGloss\"},\n        {\"value\": \"refractChannel\", \"label\": \"refract\"},\n        {\"value\": \"refractionFilterChannel\", \"label\": \"refractionFilter\"},\n        {\"value\": \"refractGlossinessChannel\", \"label\": \"refrGloss\"},\n        {\"value\": \"renderIDChannel\", \"label\": \"renderId\"},\n        {\"value\": \"FastSSS2Channel\", \"label\": \"SSS\"},\n        {\"value\": \"sampleRateChannel\", \"label\": \"sampleRate\"},\n        {\"value\": \"samplerInfo\", \"label\": \"samplerInfo\"},\n        {\"value\": \"selfIllumChannel\", \"label\": \"selfIllum\"},\n        {\"value\": \"shadowChannel\", \"label\": \"shadow\"},\n        {\"value\": \"sheenFilterChannel\", \"label\": \"sheen_filter\"},\n        {\"value\": \"sheenGlossinessChannel\", \"label\": \"sheenGloss\"},\n        {\"value\": \"sheenReflectionChannel\", \"label\": \"sheen_reflection\"},\n        {\"value\": \"vraySheenChannel\", \"label\": \"sheen_specular\"},\n        {\"value\": \"specularChannel\", \"label\": \"specular\"},\n        {\"value\": \"Toon\", \"label\": \"Toon\"},\n        {\"value\": \"toonLightingChannel\", \"label\": \"toonLighting\"},\n        {\"value\": \"toonSpecularChannel\", \"label\": \"toonSpecular\"},\n        {\"value\": \"totalLightChannel\", \"label\": \"totalLight\"},\n        {\"value\": \"unclampedColorChannel\", \"label\": \"unclampedColor\"},\n        {\"value\": \"VRScansPaintMaskChannel\", \"label\": \"VRScansPaintMask\"},\n        {\"value\": \"VRScansZoneMaskChannel\", \"label\": \"VRScansZoneMask\"},\n        {\"value\": \"velocityChannel\", \"label\": \"velocity\"},\n        {\"value\": \"zdepthChannel\", \"label\": \"zDepth\"},\n        {\"value\": \"LightSelectElement\", \"label\": \"lightselect\"},\n    ]\n</code></pre>"},{"location":"autoapi/server/settings/render_settings.html#server.settings.render_settings.vray_image_output_enum","title":"<code>vray_image_output_enum()</code>","text":"<p>Return output format for Vray enumerator.</p> Source code in <code>server/settings/render_settings.py</code> <pre><code>def vray_image_output_enum():\n    \"\"\"Return output format for Vray enumerator.\"\"\"\n    return [\n        {\"label\": \"png\", \"value\": \"png\"},\n        {\"label\": \"jpg\", \"value\": \"jpg\"},\n        {\"label\": \"vrimg\", \"value\": \"vrimg\"},\n        {\"label\": \"hdr\", \"value\": \"hdr\"},\n        {\"label\": \"exr\", \"value\": \"exr\"},\n        {\"label\": \"exr (multichannel)\", \"value\": \"exr (multichannel)\"},\n        {\"label\": \"exr (deep)\", \"value\": \"exr (deep)\"},\n        {\"label\": \"tga\", \"value\": \"tga\"},\n        {\"label\": \"bmp\", \"value\": \"bmp\"},\n        {\"label\": \"sgi\", \"value\": \"sgi\"}\n    ]\n</code></pre>"},{"location":"autoapi/server/settings/scriptsmenu.html","title":"scriptsmenu","text":""},{"location":"autoapi/server/settings/scriptsmenu.html#server.settings.scriptsmenu.ScriptsmenuModel","title":"<code>ScriptsmenuModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Add a custom scripts menu to Maya</p> Source code in <code>server/settings/scriptsmenu.py</code> <pre><code>class ScriptsmenuModel(BaseSettingsModel):\n    \"\"\"Add a custom scripts menu to Maya\"\"\"\n    _isGroup = True\n\n    name: str = SettingsField(title=\"Menu Name\")\n\n    definition_type: str = SettingsField(\n        title=\"Define menu using\",\n        description=\"Choose the way to define the custom scripts menu \"\n                    \"via settings\",\n        enum_resolver=lambda: _definition_mode_type,\n        conditional_enum=True,\n        default=\"definition\"\n    )\n    definition: list[ScriptsmenuSubmodel] = SettingsField(\n        default_factory=list,\n        title=\"Menu Definition\",\n        description=\"Scriptmenu Items Definition\"\n    )\n    definition_json: str = SettingsField(\n        \"[]\", title=\"Menu Definition JSON\", widget=\"textarea\",\n        description=(\n            \"Define the custom tools menu using a JSON list. \"\n            \"For more details on the JSON format, see \"\n            \"[here](https://github.com/Colorbleed/scriptsmenu?tab=readme-ov-file#configuration).\"  # noqa: E501\n        )\n    )\n\n    @validator(\"definition_json\")\n    def validate_json(cls, value):\n        if not value.strip():\n            return \"[]\"\n        try:\n            converted_value = json.loads(value)\n            success = isinstance(converted_value, list)\n        except json.JSONDecodeError:\n            success = False\n\n        if not success:\n            raise BadRequestException(\n                \"The definition can't be parsed as json list object\"\n            )\n        return value\n</code></pre>"},{"location":"autoapi/server/settings/scriptsmenu.html#server.settings.scriptsmenu.ScriptsmenuSubmodel","title":"<code>ScriptsmenuSubmodel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Item Definition</p> Source code in <code>server/settings/scriptsmenu.py</code> <pre><code>class ScriptsmenuSubmodel(BaseSettingsModel):\n    \"\"\"Item Definition\"\"\"\n    _isGroup = True\n    type: str = SettingsField(title=\"Type\")\n    command: str = SettingsField(title=\"Command\")\n    sourcetype: str = SettingsField(title=\"Source Type\")\n    title: str = SettingsField(title=\"Title\")\n    tooltip: str = SettingsField(title=\"Tooltip\")\n    tags: list[str] = SettingsField(\n        default_factory=list, title=\"A list of tags\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/templated_workfile_settings.html","title":"templated_workfile_settings","text":""},{"location":"autoapi/server/settings/workfile_build_settings.html","title":"workfile_build_settings","text":""}]}